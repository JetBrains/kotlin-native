//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/lang/Float.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaLangFloat")
#ifdef RESTRICT_JavaLangFloat
#define INCLUDE_ALL_JavaLangFloat 0
#else
#define INCLUDE_ALL_JavaLangFloat 1
#endif
#undef RESTRICT_JavaLangFloat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaLangFloat_) && (INCLUDE_ALL_JavaLangFloat || defined(INCLUDE_JavaLangFloat))
#define JavaLangFloat_

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class IOSClass;

/*!
 @brief The <code>Float</code> class wraps a value of primitive type 
 <code>float</code> in an object.An object of type 
 <code>Float</code> contains a single field whose type is 
 <code>float</code>.
 <p>In addition, this class provides several methods for converting a 
 <code>float</code> to a <code>String</code> and a 
 <code>String</code> to a <code>float</code>, as well as other
  constants and methods useful when dealing with a 
 <code>float</code>.
 @author Lee Boynton
 @author Arthur van Hoff
 @author Joseph D. Darcy
 @since JDK1.0
 */
@interface JavaLangFloat : NSNumber < JavaLangComparable >
@property (readonly, class) jfloat POSITIVE_INFINITY NS_SWIFT_NAME(POSITIVE_INFINITY);
@property (readonly, class) jfloat NEGATIVE_INFINITY NS_SWIFT_NAME(NEGATIVE_INFINITY);
@property (readonly, class) jfloat NaN NS_SWIFT_NAME(NaN);
@property (readonly, class) jfloat MAX_VALUE NS_SWIFT_NAME(MAX_VALUE);
@property (readonly, class) jfloat MIN_NORMAL NS_SWIFT_NAME(MIN_NORMAL);
@property (readonly, class) jfloat MIN_VALUE NS_SWIFT_NAME(MIN_VALUE);
@property (readonly, class) jint MAX_EXPONENT NS_SWIFT_NAME(MAX_EXPONENT);
@property (readonly, class) jint MIN_EXPONENT NS_SWIFT_NAME(MIN_EXPONENT);
@property (readonly, class) jint SIZE NS_SWIFT_NAME(SIZE);
@property (readonly, class) jint BYTES NS_SWIFT_NAME(BYTES);
@property (readonly, class, strong) IOSClass *TYPE NS_SWIFT_NAME(TYPE);

+ (jfloat)POSITIVE_INFINITY;

+ (jfloat)NEGATIVE_INFINITY;

+ (jfloat)NaN;

+ (jfloat)MAX_VALUE;

+ (jfloat)MIN_NORMAL;

+ (jfloat)MIN_VALUE;

+ (jint)MAX_EXPONENT;

+ (jint)MIN_EXPONENT;

+ (jint)SIZE;

+ (jint)BYTES;

+ (IOSClass *)TYPE;

#pragma mark Public

/*!
 @brief Constructs a newly allocated <code>Float</code> object that
  represents the argument converted to type <code>float</code>.
 @param value the value to be represented by the <code>Float</code> .
 */
- (instancetype __nonnull)initWithDouble:(jdouble)value;

/*!
 @brief Constructs a newly allocated <code>Float</code> object that
  represents the primitive <code>float</code> argument.
 @param value the value to be represented by the <code>Float</code> .
 */
- (instancetype __nonnull)initWithFloat:(jfloat)value;

/*!
 @brief Constructs a newly allocated <code>Float</code> object that
  represents the floating-point value of type <code>float</code>
  represented by the string.The string is converted to a 
 <code>float</code> value as if by the <code>valueOf</code> method.
 @param s a string to be converted to a <code>Float</code> .
 @throw NumberFormatExceptionif the string does not contain a
                parsable number.
 - seealso: java.lang.Float#valueOf(java.lang.String)
 */
- (instancetype __nonnull)initWithNSString:(NSString *)s;

/*!
 @brief Returns the value of this <code>Float</code> as a <code>byte</code> after
  a narrowing primitive conversion.
 @return the <code>float</code> value represented by this object
           converted to type <code>byte</code>
 */
- (jbyte)charValue;

/*!
 @brief Compares the two specified <code>float</code> values.The sign
  of the integer value returned is the same as that of the
  integer that would be returned by the call: 
 @code

     new Float(f1).compareTo(new Float(f2)) 
  
@endcode
 @param f1 the first <code>float</code>  to compare.
 @param f2 the second <code>float</code>  to compare.
 @return the value <code>0</code> if <code>f1</code> is
           numerically equal to <code>f2</code>; a value less than
           <code>0</code> if <code>f1</code> is numerically less than
           <code>f2</code>; and a value greater than <code>0</code>
           if <code>f1</code> is numerically greater than
           <code>f2</code>.
 @since 1.4
 */
+ (jint)compareWithFloat:(jfloat)f1
               withFloat:(jfloat)f2;

/*!
 @brief Compares two <code>Float</code> objects numerically.There are
  two ways in which comparisons performed by this method differ
  from those performed by the Java language numerical comparison
  operators (<code><, <=, ==, >=, ></code>) when
  applied to primitive <code>float</code> values: 
 <ul><li>
           <code>Float.NaN</code> is considered by this method to
           be equal to itself and greater than all other          
 <code>float</code> values
           (including <code>Float.POSITIVE_INFINITY</code>).
 <li>
           <code>0.0f</code> is considered by this method to be greater
           than <code>-0.0f</code>.
  </ul>
  This ensures that the <i>natural ordering</i> of <code>Float</code>
  objects imposed by this method is <i>consistent with equals</i>.
 @param anotherFloat the <code>Float</code>  to be compared.
 @return the value <code>0</code> if <code>anotherFloat</code> is
           numerically equal to this <code>Float</code>; a value
           less than <code>0</code> if this <code>Float</code>
           is numerically less than <code>anotherFloat</code>;
           and a value greater than <code>0</code> if this
           <code>Float</code> is numerically greater than
           <code>anotherFloat</code>.
 @since 1.2
 - seealso: Comparable#compareTo(Object)
 */
- (jint)compareToWithId:(JavaLangFloat *)anotherFloat;

/*!
 @brief Returns the value of this <code>Float</code> as a <code>double</code>
  after a widening primitive conversion.
 @return the <code>float</code> value represented by this
          object converted to type <code>double</code>
 */
- (jdouble)doubleValue;

/*!
 @brief Compares this object against the specified object.The result
  is <code>true</code> if and only if the argument is not 
 <code>null</code> and is a <code>Float</code> object that
  represents a <code>float</code> with the same value as the 
 <code>float</code> represented by this object.
 For this
  purpose, two <code>float</code> values are considered to be the
  same if and only if the method <code>floatToIntBits(float)</code>
  returns the identical <code>int</code> value when applied to
  each. 
 <p>Note that in most cases, for two instances of class 
 <code>Float</code>, <code>f1</code> and <code>f2</code>, the value
  of <code>f1.equals(f2)</code> is <code>true</code> if and only if 
 <blockquote>@code

    f1.floatValue() == f2.floatValue() 
  
@endcode</blockquote>
  
 <p>also has the value <code>true</code>. However, there are two exceptions: 
 <ul>
  <li>If <code>f1</code> and <code>f2</code> both represent
      <code>Float.NaN</code>, then the <code>equals</code> method returns
      <code>true</code>, even though <code>Float.NaN==Float.NaN</code>
      has the value <code>false</code>.
  <li>If <code>f1</code> represents <code>+0.0f</code> while
      <code>f2</code> represents <code>-0.0f</code>, or vice
      versa, the <code>equal</code> test has the value
      <code>false</code>, even though <code>0.0f==-0.0f</code>
      has the value <code>true</code>.
  </ul>
  This definition allows hash tables to operate properly.
 @param obj the object to be compared
 @return <code>true</code> if the objects are the same;
           <code>false</code> otherwise.
 - seealso: java.lang.Float#floatToIntBits(float)
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns a representation of the specified floating-point value
  according to the IEEE 754 floating-point "single format" bit
  layout.
 <p>Bit 31 (the bit that is selected by the mask 
 <code>0x80000000</code>) represents the sign of the floating-point
  number.
  Bits 30-23 (the bits that are selected by the mask 
 <code>0x7f800000</code>) represent the exponent.
  Bits 22-0 (the bits that are selected by the mask 
 <code>0x007fffff</code>) represent the significand (sometimes called
  the mantissa) of the floating-point number. 
 <p>If the argument is positive infinity, the result is 
 <code>0x7f800000</code>.
  
 <p>If the argument is negative infinity, the result is 
 <code>0xff800000</code>.
  
 <p>If the argument is NaN, the result is <code>0x7fc00000</code>.
  
 <p>In all cases, the result is an integer that, when given to the 
 <code>intBitsToFloat(int)</code> method, will produce a floating-point
  value the same as the argument to <code>floatToIntBits</code>
  (except all NaN values are collapsed to a single
  "canonical" NaN value).
 @param value a floating-point number.
 @return the bits that represent the floating-point number.
 */
+ (jint)floatToIntBitsWithFloat:(jfloat)value;

/*!
 @brief Returns a representation of the specified floating-point value
  according to the IEEE 754 floating-point "single format" bit
  layout, preserving Not-a-Number (NaN) values.
 <p>Bit 31 (the bit that is selected by the mask 
 <code>0x80000000</code>) represents the sign of the floating-point
  number.
  Bits 30-23 (the bits that are selected by the mask 
 <code>0x7f800000</code>) represent the exponent.
  Bits 22-0 (the bits that are selected by the mask 
 <code>0x007fffff</code>) represent the significand (sometimes called
  the mantissa) of the floating-point number. 
 <p>If the argument is positive infinity, the result is 
 <code>0x7f800000</code>.
  
 <p>If the argument is negative infinity, the result is 
 <code>0xff800000</code>.
  
 <p>If the argument is NaN, the result is the integer representing
  the actual NaN value.  Unlike the <code>floatToIntBits</code>
  method, <code>floatToRawIntBits</code> does not collapse all the
  bit patterns encoding a NaN to a single "canonical"
  NaN value. 
 <p>In all cases, the result is an integer that, when given to the 
 <code>intBitsToFloat(int)</code> method, will produce a
  floating-point value the same as the argument to 
 <code>floatToRawIntBits</code>.
 @param value a floating-point number.
 @return the bits that represent the floating-point number.
 @since 1.3
 */
+ (jint)floatToRawIntBitsWithFloat:(jfloat)value;

/*!
 @brief Returns the <code>float</code> value of this <code>Float</code> object.
 @return the <code>float</code> value represented by this object
 */
- (jfloat)floatValue;

/*!
 @brief Returns a hash code for this <code>Float</code> object.The
  result is the integer bit representation, exactly as produced
  by the method <code>floatToIntBits(float)</code>, of the primitive 
 <code>float</code> value represented by this <code>Float</code>
  object.
 @return a hash code value for this object.
 */
- (NSUInteger)hash;

/*!
 @brief Returns a hash code for a <code>float</code> value; compatible with 
 <code>Float.hashCode()</code>.
 @param value the value to hash
 @return a hash code value for a <code>float</code> value.
 @since 1.8
 */
+ (jint)hashCodeWithFloat:(jfloat)value;

/*!
 @brief Returns the <code>float</code> value corresponding to a given
  bit representation.
 The argument is considered to be a representation of a
  floating-point value according to the IEEE 754 floating-point
  "single format" bit layout. 
 <p>If the argument is <code>0x7f800000</code>, the result is positive
  infinity. 
 <p>If the argument is <code>0xff800000</code>, the result is negative
  infinity. 
 <p>If the argument is any value in the range 
 <code>0x7f800001</code> through <code>0x7fffffff</code> or in
  the range <code>0xff800001</code> through 
 <code>0xffffffff</code>, the result is a NaN.  No IEEE 754
  floating-point operation provided by Java can distinguish
  between two NaN values of the same type with different bit
  patterns.  Distinct values of NaN are only distinguishable by
  use of the <code>Float.floatToRawIntBits</code> method. 
 <p>In all other cases, let <i>s</i>, <i>e</i>, and <i>m</i> be three
  values that can be computed from the argument: 
 <blockquote>@code
 int s = ((bits >> 31) == 0) ? 1 : -1;
  int e = ((bits >> 23) & 0xff);
  int m = (e == 0) ?
                  (bits & 0x7fffff) << 1 :
                  (bits & 0x7fffff) | 0x800000; 
 
@endcode</blockquote>
  Then the floating-point result equals the value of the mathematical
  expression <i>s</i>&middot;<i>m</i>&middot;2<sup><i>e</i>-150</sup>.
  
 <p>Note that this method may not be able to return a 
 <code>float</code> NaN with exactly same bit pattern as the 
 <code>int</code> argument.  IEEE 754 distinguishes between two
  kinds of NaNs, quiet NaNs and <i>signaling NaNs</i>.  The
  differences between the two kinds of NaN are generally not
  visible in Java.  Arithmetic operations on signaling NaNs turn
  them into quiet NaNs with a different, but often similar, bit
  pattern.  However, on some processors merely copying a
  signaling NaN also performs that conversion.  In particular,
  copying a signaling NaN to return it to the calling method may
  perform this conversion.  So <code>intBitsToFloat</code> may
  not be able to return a <code>float</code> with a signaling NaN
  bit pattern.  Consequently, for some <code>int</code> values, 
 <code>floatToRawIntBits(intBitsToFloat(start))</code> may 
 <i>not</i> equal <code>start</code>.  Moreover, which
  particular bit patterns represent signaling NaNs is platform
  dependent; although all NaN bit patterns, quiet or signaling,
  must be in the NaN range identified above.
 @param bits an integer.
 @return the <code>float</code> floating-point value with the same bit
           pattern.
 */
+ (jfloat)intBitsToFloatWithInt:(jint)bits;

/*!
 @brief Returns the value of this <code>Float</code> as an <code>int</code> after
  a narrowing primitive conversion.
 @return the <code>float</code> value represented by this object
           converted to type <code>int</code>
 */
- (jint)intValue;

/*!
 @brief Returns <code>true</code> if the argument is a finite floating-point
  value; returns <code>false</code> otherwise (for NaN and infinity
  arguments).
 @param f the <code>float</code>  value to be tested
 @return <code>true</code> if the argument is a finite
  floating-point value, <code>false</code> otherwise.
 @since 1.8
 */
+ (jboolean)isFiniteWithFloat:(jfloat)f;

/*!
 @brief Returns <code>true</code> if this <code>Float</code> value is
  infinitely large in magnitude, <code>false</code> otherwise.
 @return <code>true</code> if the value represented by this object is
           positive infinity or negative infinity;          
 <code>false</code> otherwise.
 */
- (jboolean)isInfinite;

/*!
 @brief Returns <code>true</code> if the specified number is infinitely
  large in magnitude, <code>false</code> otherwise.
 @param v the value to be tested.
 @return <code>true</code> if the argument is positive infinity or
           negative infinity; <code>false</code> otherwise.
 */
+ (jboolean)isInfiniteWithFloat:(jfloat)v;

/*!
 @brief Returns <code>true</code> if this <code>Float</code> value is a
  Not-a-Number (NaN), <code>false</code> otherwise.
 @return <code>true</code> if the value represented by this object is
           NaN; <code>false</code> otherwise.
 */
- (jboolean)isNaN;

/*!
 @brief Returns <code>true</code> if the specified number is a
  Not-a-Number (NaN) value, <code>false</code> otherwise.
 @param v the value to be tested.
 @return <code>true</code> if the argument is NaN;
           <code>false</code> otherwise.
 */
+ (jboolean)isNaNWithFloat:(jfloat)v;

/*!
 @brief Returns value of this <code>Float</code> as a <code>long</code> after a
  narrowing primitive conversion.
 @return the <code>float</code> value represented by this object
           converted to type <code>long</code>
 */
- (jlong)longLongValue;

/*!
 @brief Returns the greater of two <code>float</code> values
  as if by calling <code>Math.max</code>.
 @param a the first operand
 @param b the second operand
 @return the greater of <code>a</code> and <code>b</code>
 - seealso: java.util.function.BinaryOperator
 @since 1.8
 */
+ (jfloat)maxWithFloat:(jfloat)a
             withFloat:(jfloat)b;

/*!
 @brief Returns the smaller of two <code>float</code> values
  as if by calling <code>Math.min</code>.
 @param a the first operand
 @param b the second operand
 @return the smaller of <code>a</code> and <code>b</code>
 - seealso: java.util.function.BinaryOperator
 @since 1.8
 */
+ (jfloat)minWithFloat:(jfloat)a
             withFloat:(jfloat)b;

/*!
 @brief Returns a new <code>float</code> initialized to the value
  represented by the specified <code>String</code>, as performed
  by the <code>valueOf</code> method of class <code>Float</code>.
 @param s the string to be parsed.
 @return the <code>float</code> value represented by the string
          argument.
 @throw NullPointerExceptionif the string is null
 @throw NumberFormatExceptionif the string does not contain a
                parsable <code>float</code>.
 - seealso: java.lang.Float#valueOf(String)
 @since 1.2
 */
+ (jfloat)parseFloatWithNSString:(NSString *)s;

/*!
 @brief Returns the value of this <code>Float</code> as a <code>short</code>
  after a narrowing primitive conversion.
 @return the <code>float</code> value represented by this object
           converted to type <code>short</code>
 @since JDK1.1
 */
- (jshort)shortValue;

/*!
 @brief Adds two <code>float</code> values together as per the + operator.
 @param a the first operand
 @param b the second operand
 @return the sum of <code>a</code> and <code>b</code>
 - seealso: java.util.function.BinaryOperator
 @since 1.8
 */
+ (jfloat)sumWithFloat:(jfloat)a
             withFloat:(jfloat)b;

/*!
 @brief Returns a hexadecimal string representation of the 
 <code>float</code> argument.All characters mentioned below are
  ASCII characters.
 <ul>
  <li>If the argument is NaN, the result is the string
      "<code>NaN</code>".
  <li>Otherwise, the result is a string that represents the sign and
  magnitude (absolute value) of the argument. If the sign is negative,
  the first character of the result is '<code>-</code>'
  (<code>'\u002D'</code>); if the sign is positive, no sign character
  appears in the result. As for the magnitude <i>m</i>:
  
 <ul>
  <li>If <i>m</i> is infinity, it is represented by the string 
 <code>"Infinity"</code>; thus, positive infinity produces the
  result <code>"Infinity"</code> and negative infinity produces
  the result <code>"-Infinity"</code>.
  
 <li>If <i>m</i> is zero, it is represented by the string 
 <code>"0x0.0p0"</code>; thus, negative zero produces the result 
 <code>"-0x0.0p0"</code> and positive zero produces the result 
 <code>"0x0.0p0"</code>.
  
 <li>If <i>m</i> is a <code>float</code> value with a
  normalized representation, substrings are used to represent the
  significand and exponent fields.  The significand is
  represented by the characters <code>"0x1."</code>
  followed by a lowercase hexadecimal representation of the rest
  of the significand as a fraction.  Trailing zeros in the
  hexadecimal representation are removed unless all the digits
  are zero, in which case a single zero is used. Next, the
  exponent is represented by <code>"p"</code> followed
  by a decimal string of the unbiased exponent as if produced by
  a call to <code>Integer.toString</code> on the
  exponent value. 
 <li>If <i>m</i> is a <code>float</code> value with a subnormal
  representation, the significand is represented by the
  characters <code>"0x0."</code> followed by a
  hexadecimal representation of the rest of the significand as a
  fraction.  Trailing zeros in the hexadecimal representation are
  removed. Next, the exponent is represented by 
 <code>"p-126"</code>.  Note that there must be at
  least one nonzero digit in a subnormal significand. 
 </ul>
  
 </ul>
  
 <table border>
  <caption>Examples</caption>
  <tr><th>Floating-point Value</th><th>Hexadecimal String</th>
  <tr><td><code>1.0</code></td> <td><code>0x1.0p0</code></td>
  <tr><td><code>-1.0</code></td>        <td><code>-0x1.0p0</code></td>
  <tr><td><code>2.0</code></td> <td><code>0x1.0p1</code></td>
  <tr><td><code>3.0</code></td> <td><code>0x1.8p1</code></td>
  <tr><td><code>0.5</code></td> <td><code>0x1.0p-1</code></td>
  <tr><td><code>0.25</code></td>        <td><code>0x1.0p-2</code></td>
  <tr><td><code>Float.MAX_VALUE</code></td>
      <td><code>0x1.fffffep127</code></td>
  <tr><td><code>Minimum Normal Value</code></td>
      <td><code>0x1.0p-126</code></td>
  <tr><td><code>Maximum Subnormal Value</code></td>
      <td><code>0x0.fffffep-126</code></td>
  <tr><td><code>Float.MIN_VALUE</code></td>
      <td><code>0x0.000002p-126</code></td>
  </table>
 @param f the <code>float</code>  to be converted.
 @return a hex string representation of the argument.
 @since 1.5
 @author Joseph D. Darcy
 */
+ (NSString * __nonnull)toHexStringWithFloat:(jfloat)f;

/*!
 @brief Returns a string representation of this <code>Float</code> object.
 The primitive <code>float</code> value represented by this object
  is converted to a <code>String</code> exactly as if by the method 
 <code>toString</code> of one argument.
 @return a <code>String</code> representation of this object.
 - seealso: java.lang.Float#toString(float)
 */
- (NSString * __nonnull)description;

/*!
 @brief Returns a string representation of the <code>float</code>
  argument.All characters mentioned below are ASCII characters.
 <ul>
  <li>If the argument is NaN, the result is the string
  "<code>NaN</code>".
  <li>Otherwise, the result is a string that represents the sign and
      magnitude (absolute value) of the argument. If the sign is
      negative, the first character of the result is
      '<code>-</code>' (<code>'\u002D'</code>); if the sign is
      positive, no sign character appears in the result. As for
      the magnitude <i>m</i>:
  <ul>
  <li>If <i>m</i> is infinity, it is represented by the characters
      <code>"Infinity"</code>; thus, positive infinity produces
      the result <code>"Infinity"</code> and negative infinity
      produces the result <code>"-Infinity"</code>.
  <li>If <i>m</i> is zero, it is represented by the characters
      <code>"0.0"</code>; thus, negative zero produces the result
      <code>"-0.0"</code> and positive zero produces the result
      <code>"0.0"</code>.
  <li> If <i>m</i> is greater than or equal to 10<sup>-3</sup> but
       less than 10<sup>7</sup>, then it is represented as the
       integer part of <i>m</i>, in decimal form with no leading
       zeroes, followed by '<code>.</code>'
       (<code>'\u002E'</code>), followed by one or more
       decimal digits representing the fractional part of      
 <i>m</i>.
  <li> If <i>m</i> is less than 10<sup>-3</sup> or greater than or
       equal to 10<sup>7</sup>, then it is represented in
       so-called "computerized scientific notation." Let <i>n</i>
       be the unique integer such that 10<sup><i>n</i> </sup>&le;
       <i>m</i> &lt; 10<sup><i>n</i>+1</sup>; then let <i>a</i>
       be the mathematically exact quotient of <i>m</i> and
       10<sup><i>n</i></sup> so that 1 &le; <i>a</i> &lt; 10.
       The magnitude is then represented as the integer part of      
 <i>a</i>, as a single decimal digit, followed by
       '<code>.</code>' (<code>'\u002E'</code>), followed by
       decimal digits representing the fractional part of      
 <i>a</i>, followed by the letter '<code>E</code>'
       (<code>'\u0045'</code>), followed by a representation
       of <i>n</i> as a decimal integer, as produced by the
       method <code>java.lang.Integer.toString(int)</code>.
  
 </ul>
  </ul>
  How many digits must be printed for the fractional part of 
 <i>m</i> or <i>a</i>? There must be at least one digit
  to represent the fractional part, and beyond that as many, but
  only as many, more digits as are needed to uniquely distinguish
  the argument value from adjacent values of type 
 <code>float</code>. That is, suppose that <i>x</i> is the
  exact mathematical value represented by the decimal
  representation produced by this method for a finite nonzero
  argument <i>f</i>. Then <i>f</i> must be the <code>float</code>
  value nearest to <i>x</i>; or, if two <code>float</code> values are
  equally close to <i>x</i>, then <i>f</i> must be one of
  them and the least significant bit of the significand of 
 <i>f</i> must be <code>0</code>.
  
 <p>To create localized string representations of a floating-point
  value, use subclasses of <code>java.text.NumberFormat</code>.
 @param f the float to be converted.
 @return a string representation of the argument.
 */
+ (NSString * __nonnull)toStringWithFloat:(jfloat)f;

/*!
 @brief Returns a <code>Float</code> instance representing the specified 
 <code>float</code> value.
 If a new <code>Float</code> instance is not required, this method
  should generally be used in preference to the constructor 
 <code>Float(float)</code>, as this method is likely to yield
  significantly better space and time performance by caching
  frequently requested values.
 @param f a float value.
 @return a <code>Float</code> instance representing <code>f</code>.
 @since 1.5
 */
+ (JavaLangFloat * __nonnull)valueOfWithFloat:(jfloat)f;

/*!
 @brief Returns a <code>Float</code> object holding the 
 <code>float</code> value represented by the argument string 
 <code>s</code>.
 <p>If <code>s</code> is <code>null</code>, then a 
 <code>NullPointerException</code> is thrown. 
 <p>Leading and trailing whitespace characters in <code>s</code>
  are ignored.  Whitespace is removed as if by the <code>String.trim</code>
  method; that is, both ASCII space and control
  characters are removed. The rest of <code>s</code> should
  constitute a <i>FloatValue</i> as described by the lexical
  syntax rules: 
 <blockquote>
  <dl>
  <dt><i>FloatValue:</i>
  <dd><i>Sign<sub>opt</sub></i> <code>NaN</code>
  <dd><i>Sign<sub>opt</sub></i> <code>Infinity</code>
  <dd><i>Sign<sub>opt</sub> FloatingPointLiteral</i>
  <dd><i>Sign<sub>opt</sub> HexFloatingPointLiteral</i>
  <dd><i>SignedInteger</i>
  </dl>
  
 <dl>
  <dt><i>HexFloatingPointLiteral</i>:
  <dd> <i>HexSignificand BinaryExponent FloatTypeSuffix<sub>opt</sub></i>
  </dl>
  
 <dl>
  <dt><i>HexSignificand:</i>
  <dd><i>HexNumeral</i>
  <dd><i>HexNumeral</i> <code>.</code>
  <dd><code>0x</code> <i>HexDigits<sub>opt</sub>
      </i><code>.</code><i> HexDigits</i>
  <dd><code>0X</code><i> HexDigits<sub>opt</sub>
      </i><code>.</code> <i>HexDigits</i>
  </dl>
  
 <dl>
  <dt><i>BinaryExponent:</i>
  <dd><i>BinaryExponentIndicator SignedInteger</i>
  </dl>
  
 <dl>
  <dt><i>BinaryExponentIndicator:</i>
  <dd><code>p</code>
  <dd><code>P</code>
  </dl>
  
 </blockquote>
  where <i>Sign</i>, <i>FloatingPointLiteral</i>,
  <i>HexNumeral</i>, <i>HexDigits</i>, <i>SignedInteger</i> and 
 <i>FloatTypeSuffix</i> are as defined in the lexical structure
  sections of 
 <cite>The Java&trade; Language Specification</cite>,
  except that underscores are not accepted between digits.
  If <code>s</code> does not have the form of
  a <i>FloatValue</i>, then a <code>NumberFormatException</code>
  is thrown. Otherwise, <code>s</code> is regarded as
  representing an exact decimal value in the usual
  "computerized scientific notation" or as an exact
  hexadecimal value; this exact numerical value is then
  conceptually converted to an "infinitely precise"
  binary value that is then rounded to type <code>float</code>
  by the usual round-to-nearest rule of IEEE 754 floating-point
  arithmetic, which includes preserving the sign of a zero
  value.
  Note that the round-to-nearest rule also implies overflow and
  underflow behaviour; if the exact value of <code>s</code> is large
  enough in magnitude (greater than or equal to (<code>MAX_VALUE</code>
  + <code>ulp(MAX_VALUE)</code>/2),
  rounding to <code>float</code> will result in an infinity and if the
  exact value of <code>s</code> is small enough in magnitude (less
  than or equal to <code>MIN_VALUE</code>/2), rounding to float will
  result in a zero.
  Finally, after rounding a <code>Float</code> object representing
  this <code>float</code> value is returned. 
 <p>To interpret localized string representations of a
  floating-point value, use subclasses of <code>java.text.NumberFormat</code>
 .
  
 <p>Note that trailing format specifiers, specifiers that
  determine the type of a floating-point literal
  (<code>1.0f</code> is a <code>float</code> value; 
 <code>1.0d</code> is a <code>double</code> value), do 
 <em>not</em> influence the results of this method.  In other
  words, the numerical value of the input string is converted
  directly to the target floating-point type.  In general, the
  two-step sequence of conversions, string to <code>double</code>
  followed by <code>double</code> to <code>float</code>, is 
 <em>not</em> equivalent to converting a string directly to 
 <code>float</code>.  For example, if first converted to an
  intermediate <code>double</code> and then to 
 <code>float</code>, the string<br>
  <code>"1.00000017881393421514957253748434595763683319091796875001d"</code><br>
  results in the <code>float</code> value 
 <code>1.0000002f</code>; if the string is converted directly to 
 <code>float</code>, <code>1.000000<b>1</b>f</code> results. 
 <p>To avoid calling this method on an invalid string and having
  a <code>NumberFormatException</code> be thrown, the documentation
  for <code>Double.valueOf</code> lists a regular
  expression which can be used to screen the input.
 @param s the string to be parsed.
 @return a <code>Float</code> object holding the value
           represented by the <code>String</code> argument.
 @throw NumberFormatExceptionif the string does not contain a
           parsable number.
 */
+ (JavaLangFloat * __nonnull)valueOfWithNSString:(NSString *)s;

#pragma mark Package-Private

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaLangFloat)

/*!
 @brief A constant holding the positive infinity of type 
 <code>float</code>.It is equal to the value returned by 
 <code>Float.intBitsToFloat(0x7f800000)</code>.
 */
inline jfloat JavaLangFloat_get_POSITIVE_INFINITY(void);
#define JavaLangFloat_POSITIVE_INFINITY INFINITY
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, POSITIVE_INFINITY, jfloat)

/*!
 @brief A constant holding the negative infinity of type 
 <code>float</code>.It is equal to the value returned by 
 <code>Float.intBitsToFloat(0xff800000)</code>.
 */
inline jfloat JavaLangFloat_get_NEGATIVE_INFINITY(void);
#define JavaLangFloat_NEGATIVE_INFINITY -INFINITY
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, NEGATIVE_INFINITY, jfloat)

/*!
 @brief A constant holding a Not-a-Number (NaN) value of type 
 <code>float</code>.It is equivalent to the value returned by 
 <code>Float.intBitsToFloat(0x7fc00000)</code>.
 */
inline jfloat JavaLangFloat_get_NaN(void);
#define JavaLangFloat_NaN NAN
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, NaN, jfloat)

/*!
 @brief A constant holding the largest positive finite value of type 
 <code>float</code>, (2-2<sup>-23</sup>)&middot;2<sup>127</sup>.
 It is equal to the hexadecimal floating-point literal 
 <code>0x1.fffffeP+127f</code> and also equal to 
 <code>Float.intBitsToFloat(0x7f7fffff)</code>.
 */
inline jfloat JavaLangFloat_get_MAX_VALUE(void);
#define JavaLangFloat_MAX_VALUE __FLT_MAX__
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, MAX_VALUE, jfloat)

/*!
 @brief A constant holding the smallest positive normal value of type 
 <code>float</code>, 2<sup>-126</sup>.It is equal to the
  hexadecimal floating-point literal <code>0x1.0p-126f</code> and also
  equal to <code>Float.intBitsToFloat(0x00800000)</code>.
 @since 1.6
 */
inline jfloat JavaLangFloat_get_MIN_NORMAL(void);
#define JavaLangFloat_MIN_NORMAL __FLT_MIN__
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, MIN_NORMAL, jfloat)

/*!
 @brief A constant holding the smallest positive nonzero value of type 
 <code>float</code>, 2<sup>-149</sup>.It is equal to the
  hexadecimal floating-point literal <code>0x0.000002P-126f</code>
  and also equal to <code>Float.intBitsToFloat(0x1)</code>.
 */
inline jfloat JavaLangFloat_get_MIN_VALUE(void);
#define JavaLangFloat_MIN_VALUE 1.4E-45f
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, MIN_VALUE, jfloat)

/*!
 @brief Maximum exponent a finite <code>float</code> variable may have.It
  is equal to the value returned by <code>Math.getExponent(Float.MAX_VALUE)</code>
 .
 @since 1.6
 */
inline jint JavaLangFloat_get_MAX_EXPONENT(void);
#define JavaLangFloat_MAX_EXPONENT 127
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, MAX_EXPONENT, jint)

/*!
 @brief Minimum exponent a normalized <code>float</code> variable may have.
 It is equal to the value returned by <code>Math.getExponent(Float.MIN_NORMAL)</code>
 .
 @since 1.6
 */
inline jint JavaLangFloat_get_MIN_EXPONENT(void);
#define JavaLangFloat_MIN_EXPONENT -126
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, MIN_EXPONENT, jint)

/*!
 @brief The number of bits used to represent a <code>float</code> value.
 @since 1.5
 */
inline jint JavaLangFloat_get_SIZE(void);
#define JavaLangFloat_SIZE 32
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, SIZE, jint)

/*!
 @brief The number of bytes used to represent a <code>float</code> value.
 @since 1.8
 */
inline jint JavaLangFloat_get_BYTES(void);
#define JavaLangFloat_BYTES 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangFloat, BYTES, jint)

/*!
 @brief The <code>Class</code> instance representing the primitive type 
 <code>float</code>.
 @since JDK1.1
 */
inline IOSClass *JavaLangFloat_get_TYPE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSClass *JavaLangFloat_TYPE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaLangFloat, TYPE, IOSClass *)

FOUNDATION_EXPORT NSString *JavaLangFloat_toStringWithFloat_(jfloat f);

FOUNDATION_EXPORT NSString *JavaLangFloat_toHexStringWithFloat_(jfloat f);

FOUNDATION_EXPORT JavaLangFloat *JavaLangFloat_valueOfWithNSString_(NSString *s);

FOUNDATION_EXPORT JavaLangFloat *JavaLangFloat_valueOfWithFloat_(jfloat f);

FOUNDATION_EXPORT jfloat JavaLangFloat_parseFloatWithNSString_(NSString *s);

FOUNDATION_EXPORT jboolean JavaLangFloat_isNaNWithFloat_(jfloat v);

FOUNDATION_EXPORT jboolean JavaLangFloat_isInfiniteWithFloat_(jfloat v);

FOUNDATION_EXPORT jboolean JavaLangFloat_isFiniteWithFloat_(jfloat f);

FOUNDATION_EXPORT void JavaLangFloat_initWithFloat_(JavaLangFloat *self, jfloat value);

FOUNDATION_EXPORT JavaLangFloat *new_JavaLangFloat_initWithFloat_(jfloat value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaLangFloat *create_JavaLangFloat_initWithFloat_(jfloat value);

FOUNDATION_EXPORT void JavaLangFloat_initWithDouble_(JavaLangFloat *self, jdouble value);

FOUNDATION_EXPORT JavaLangFloat *new_JavaLangFloat_initWithDouble_(jdouble value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaLangFloat *create_JavaLangFloat_initWithDouble_(jdouble value);

FOUNDATION_EXPORT void JavaLangFloat_initWithNSString_(JavaLangFloat *self, NSString *s);

FOUNDATION_EXPORT JavaLangFloat *new_JavaLangFloat_initWithNSString_(NSString *s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaLangFloat *create_JavaLangFloat_initWithNSString_(NSString *s);

FOUNDATION_EXPORT jint JavaLangFloat_hashCodeWithFloat_(jfloat value);

FOUNDATION_EXPORT jint JavaLangFloat_floatToIntBitsWithFloat_(jfloat value);

FOUNDATION_EXPORT jint JavaLangFloat_floatToRawIntBitsWithFloat_(jfloat value);

FOUNDATION_EXPORT jfloat JavaLangFloat_intBitsToFloatWithInt_(jint bits);

FOUNDATION_EXPORT jint JavaLangFloat_compareWithFloat_withFloat_(jfloat f1, jfloat f2);

FOUNDATION_EXPORT jfloat JavaLangFloat_sumWithFloat_withFloat_(jfloat a, jfloat b);

FOUNDATION_EXPORT jfloat JavaLangFloat_maxWithFloat_withFloat_(jfloat a, jfloat b);

FOUNDATION_EXPORT jfloat JavaLangFloat_minWithFloat_withFloat_(jfloat a, jfloat b);

J2OBJC_TYPE_LITERAL_HEADER(JavaLangFloat)

BOXED_INC_AND_DEC(Float, floatValue, JavaLangFloat)
BOXED_COMPOUND_ASSIGN_ARITHMETIC(Float, floatValue, jfloat, JavaLangFloat)
BOXED_COMPOUND_ASSIGN_FPMOD(Float, floatValue, jfloat, JavaLangFloat)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaLangFloat")
