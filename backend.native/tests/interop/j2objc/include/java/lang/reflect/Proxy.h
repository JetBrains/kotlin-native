//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/lang/reflect/Proxy.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaLangReflectProxy")
#ifdef RESTRICT_JavaLangReflectProxy
#define INCLUDE_ALL_JavaLangReflectProxy 0
#else
#define INCLUDE_ALL_JavaLangReflectProxy 1
#endif
#undef RESTRICT_JavaLangReflectProxy

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaLangReflectProxy_) && (INCLUDE_ALL_JavaLangReflectProxy || defined(INCLUDE_JavaLangReflectProxy))
#define JavaLangReflectProxy_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@class IOSObjectArray;
@class JavaLangClassLoader;
@protocol JavaLangReflectInvocationHandler;

/*!
 @brief <code>Proxy</code> provides static methods for creating dynamic proxy
  classes and instances, and it is also the superclass of all
  dynamic proxy classes created by those methods.
 <p>To create a proxy for some interface <code>Foo</code>:
  @code

      InvocationHandler handler = new MyInvocationHandler(...);
      Class proxyClass = Proxy.getProxyClass(
          Foo.class.getClassLoader(), new Class[] { Foo.class });
      Foo f = (Foo) proxyClass.
          getConstructor(new Class[] { InvocationHandler.class }).
          newInstance(new Object[] { handler }); 
  
@endcode
  or more simply: 
 @code

      Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                                           new Class[] { Foo.class },
                                           handler); 
  
@endcode
  
 <p>A <i>dynamic proxy class</i> (simply referred to as a <i>proxy
  class</i> below) is a class that implements a list of interfaces
  specified at runtime when the class is created, with behavior as
  described below.
  A <i>proxy interface</i> is such an interface that is implemented
  by a proxy class.
  A <i>proxy instance</i> is an instance of a proxy class.
  Each proxy instance has an associated <i>invocation handler</i>
  object, which implements the interface <code>InvocationHandler</code>.
  A method invocation on a proxy instance through one of its proxy
  interfaces will be dispatched to the <code>invoke</code>
  method of the instance's invocation handler, passing the proxy
  instance, a <code>java.lang.reflect.Method</code> object identifying
  the method that was invoked, and an array of type <code>Object</code>
  containing the arguments.  The invocation handler processes the
  encoded method invocation as appropriate and the result that it
  returns will be returned as the result of the method invocation on
  the proxy instance. 
 <p>A proxy class has the following properties: 
 <ul>
  <li>Proxy classes are public, final, and not abstract. 
 <li>The unqualified name of a proxy class is unspecified.  The space
  of class names that begin with the string <code>"$Proxy"</code>
  should be, however, reserved for proxy classes. 
 <li>A proxy class extends <code>java.lang.reflect.Proxy</code>.
  
 <li>A proxy class implements exactly the interfaces specified at its
  creation, in the same order. 
 <li>If a proxy class implements a non-public interface, then it will
  be defined in the same package as that interface.  Otherwise, the
  package of a proxy class is also unspecified.  Note that package
  sealing will not prevent a proxy class from being successfully defined
  in a particular package at runtime, and neither will classes already
  defined by the same class loader and the same package with particular
  signers. 
 <li>Since a proxy class implements all of the interfaces specified at
  its creation, invoking <code>getInterfaces</code> on its 
 <code>Class</code> object will return an array containing the same
  list of interfaces (in the order specified at its creation), invoking 
 <code>getMethods</code> on its <code>Class</code> object will return
  an array of <code>Method</code> objects that include all of the
  methods in those interfaces, and invoking <code>getMethod</code> will
  find methods in the proxy interfaces as would be expected. 
 <li>The <code>Proxy.isProxyClass</code> method will
  return true if it is passed a proxy class-- a class returned by 
 <code>Proxy.getProxyClass</code> or the class of an object returned by 
 <code>Proxy.newProxyInstance</code>-- and false otherwise. 
 <li>The <code>java.security.ProtectionDomain</code> of a proxy class
  is the same as that of system classes loaded by the bootstrap class
  loader, such as <code>java.lang.Object</code>, because the code for a
  proxy class is generated by trusted system code.  This protection
  domain will typically be granted 
 <code>java.security.AllPermission</code>.
  
 <li>Each proxy class has one public constructor that takes one argument,
  an implementation of the interface <code>InvocationHandler</code>, to set
  the invocation handler for a proxy instance.  Rather than having to use
  the reflection API to access the public constructor, a proxy instance
  can be also be created by calling the <code>Proxy.newProxyInstance</code>
  method, which combines the actions of calling 
 <code>Proxy.getProxyClass</code> with invoking the
  constructor with an invocation handler. 
 </ul>
  
 <p>A proxy instance has the following properties: 
 <ul>
  <li>Given a proxy instance <code>proxy</code> and one of the
  interfaces implemented by its proxy class <code>Foo</code>, the
  following expression will return true: 
 @code

      proxy instanceof Foo
   
@endcode
  and the following cast operation will succeed (rather than throwing
  a <code>ClassCastException</code>):
  @code

      (Foo) proxy
   
@endcode
  
 <li>Each proxy instance has an associated invocation handler, the one
  that was passed to its constructor.  The static 
 <code>Proxy.getInvocationHandler</code> method
  will return the invocation handler associated with the proxy instance
  passed as its argument. 
 <li>An interface method invocation on a proxy instance will be
  encoded and dispatched to the invocation handler's <code>invoke</code>
  method as described in the
  documentation for that method. 
 <li>An invocation of the <code>hashCode</code>,
  <code>equals</code>, or <code>toString</code> methods declared in 
 <code>java.lang.Object</code> on a proxy instance will be encoded and
  dispatched to the invocation handler's <code>invoke</code> method in
  the same manner as interface method invocations are encoded and
  dispatched, as described above.  The declaring class of the 
 <code>Method</code> object passed to <code>invoke</code> will be 
 <code>java.lang.Object</code>.  Other public methods of a proxy
  instance inherited from <code>java.lang.Object</code> are not
  overridden by a proxy class, so invocations of those methods behave
  like they do for instances of <code>java.lang.Object</code>.
  </ul>
  
 <h3>Methods Duplicated in Multiple Proxy Interfaces</h3>
  
 <p>When two or more interfaces of a proxy class contain a method with
  the same name and parameter signature, the order of the proxy class's
  interfaces becomes significant.  When such a <i>duplicate method</i>
  is invoked on a proxy instance, the <code>Method</code> object passed
  to the invocation handler will not necessarily be the one whose
  declaring class is assignable from the reference type of the interface
  that the proxy's method was invoked through.  This limitation exists
  because the corresponding method implementation in the generated proxy
  class cannot determine which interface it was invoked through.
  Therefore, when a duplicate method is invoked on a proxy instance,
  the <code>Method</code> object for the method in the foremost interface
  that contains the method (either directly or inherited through a
  superinterface) in the proxy class's list of interfaces is passed to
  the invocation handler's <code>invoke</code> method, regardless of the
  reference type through which the method invocation occurred. 
 <p>If a proxy interface contains a method with the same name and
  parameter signature as the <code>hashCode</code>, <code>equals</code>,
  or <code>toString</code> methods of <code>java.lang.Object</code>,
  when such a method is invoked on a proxy instance, the 
 <code>Method</code> object passed to the invocation handler will have 
 <code>java.lang.Object</code> as its declaring class.  In other words,
  the public, non-final methods of <code>java.lang.Object</code>
  logically precede all of the proxy interfaces for the determination of
  which <code>Method</code> object to pass to the invocation handler. 
 <p>Note also that when a duplicate method is dispatched to an
  invocation handler, the <code>invoke</code> method may only throw
  checked exception types that are assignable to one of the exception
  types in the <code>throws</code> clause of the method in <i>all</i> of
  the proxy interfaces that it can be invoked through.  If the 
 <code>invoke</code> method throws a checked exception that is not
  assignable to any of the exception types declared by the method in one
  of the proxy interfaces that it can be invoked through, then an
  unchecked <code>UndeclaredThrowableException</code> will be thrown by
  the invocation on the proxy instance.  This restriction means that not
  all of the exception types returned by invoking 
 <code>getExceptionTypes</code> on the <code>Method</code> object
  passed to the <code>invoke</code> method can necessarily be thrown
  successfully by the <code>invoke</code> method.
 @author Peter Jones
 - seealso: InvocationHandler
 @since 1.3
 */
@interface JavaLangReflectProxy : NSObject < JavaIoSerializable > {
 @public
  /*!
   @brief the invocation handler for this proxy instance.
   */
  id<JavaLangReflectInvocationHandler> h_;
}

#pragma mark Public

- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns the invocation handler for the specified proxy instance.
 @param proxy the proxy instance to return the invocation handler for
 @return the invocation handler for the proxy instance
 @throw IllegalArgumentExceptionif the argument is not a
           proxy instance
 */
+ (id<JavaLangReflectInvocationHandler> __nonnull)getInvocationHandlerWithId:(id)proxy;

/*!
 @brief Returns the <code>java.lang.Class</code> object for a proxy class
  given a class loader and an array of interfaces.The proxy class
  will be defined by the specified class loader and will implement
  all of the supplied interfaces.
 If a proxy class for the same
  permutation of interfaces has already been defined by the class
  loader, then the existing proxy class will be returned; otherwise,
  a proxy class for those interfaces will be generated dynamically
  and defined by the class loader. 
 <p>There are several restrictions on the parameters that may be
  passed to <code>Proxy.getProxyClass</code>:
  
 <ul>
  <li>All of the <code>Class</code> objects in the 
 <code>interfaces</code> array must represent interfaces, not
  classes or primitive types. 
 <li>No two elements in the <code>interfaces</code> array may
  refer to identical <code>Class</code> objects. 
 <li>All of the interface types must be visible by name through the
  specified class loader.  In other words, for class loader 
 <code>cl</code> and every interface <code>i</code>, the following
  expression must be true: 
 @code

      Class.forName(i.getName(), false, cl) == i 
  
@endcode
  
 <li>All non-public interfaces must be in the same package;
  otherwise, it would not be possible for the proxy class to
  implement all of the interfaces, regardless of what package it is
  defined in. 
 <li>For any set of member methods of the specified interfaces
  that have the same signature: 
 <ul>
  <li>If the return type of any of the methods is a primitive
  type or void, then all of the methods must have that same
  return type. 
 <li>Otherwise, one of the methods must have a return type that
  is assignable to all of the return types of the rest of the
  methods. 
 </ul>
  
 <li>The resulting proxy class must not exceed any limits imposed
  on classes by the virtual machine.  For example, the VM may limit
  the number of interfaces that a class may implement to 65535; in
  that case, the size of the <code>interfaces</code> array must not
  exceed 65535. 
 </ul>
  
 <p>If any of these restrictions are violated, 
 <code>Proxy.getProxyClass</code> will throw an 
 <code>IllegalArgumentException</code>.  If the <code>interfaces</code>
  array argument or any of its elements are <code>null</code>, a 
 <code>NullPointerException</code> will be thrown. 
 <p>Note that the order of the specified proxy interfaces is
  significant: two requests for a proxy class with the same combination
  of interfaces but in a different order will result in two distinct
  proxy classes.
 @param loader the class loader to define the proxy class
 @param interfaces the list of interfaces for the proxy class           to implement
 @return a proxy class that is defined in the specified class loader
           and that implements the specified interfaces
 @throw IllegalArgumentExceptionif any of the restrictions on the
           parameters that may be passed to <code>getProxyClass</code>
           are violated
 @throw NullPointerExceptionif the <code>interfaces</code> array
           argument or any of its elements are <code>null</code>
 */
+ (IOSClass * __nonnull)getProxyClassWithJavaLangClassLoader:(JavaLangClassLoader *)loader
                                           withIOSClassArray:(IOSObjectArray *)interfaces;

- (NSUInteger)hash;

/*!
 @brief Returns true if and only if the specified class was dynamically
  generated to be a proxy class using the <code>getProxyClass</code>
  method or the <code>newProxyInstance</code> method.
 <p>The reliability of this method is important for the ability
  to use it to make security decisions, so its implementation should
  not just test if the class in question extends <code>Proxy</code>.
 @param cl the class to test
 @return <code>true</code> if the class is a proxy class and
           <code>false</code> otherwise
 @throw NullPointerExceptionif <code>cl</code> is <code>null</code>
 */
+ (jboolean)isProxyClassWithIOSClass:(IOSClass *)cl;

/*!
 @brief Returns an instance of a proxy class for the specified interfaces
  that dispatches method invocations to the specified invocation
  handler.This method is equivalent to: 
 @code

      Proxy.getProxyClass(loader, interfaces).
 getConstructor(new Class[] { InvocationHandler.class }).
          newInstance(new Object[] { handler }); 
  
@endcode
  
 <p><code>Proxy.newProxyInstance</code> throws 
 <code>IllegalArgumentException</code> for the same reasons that 
 <code>Proxy.getProxyClass</code> does.
 @param loader the class loader to define the proxy class
 @param interfaces the list of interfaces for the proxy class           to implement
 @param h the invocation handler to dispatch method invocations to
 @return a proxy instance with the specified invocation handler of a
           proxy class that is defined by the specified class loader
           and that implements the specified interfaces
 @throw IllegalArgumentExceptionif any of the restrictions on the
           parameters that may be passed to <code>getProxyClass</code>
           are violated
 @throw NullPointerExceptionif the <code>interfaces</code> array
           argument or any of its elements are <code>null</code>, or
           if the invocation handler, <code>h</code>, is
           <code>null</code>
 */
+ (id __nonnull)newProxyInstanceWithJavaLangClassLoader:(JavaLangClassLoader *)loader
                                      withIOSClassArray:(IOSObjectArray *)interfaces
                   withJavaLangReflectInvocationHandler:(id<JavaLangReflectInvocationHandler>)h OBJC_METHOD_FAMILY_NONE;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Constructs a new <code>Proxy</code> instance from a subclass
  (typically, a dynamic proxy class) with the specified value
  for its invocation handler.
 @param h the invocation handler for this proxy instance
 */
- (instancetype __nonnull)initWithJavaLangReflectInvocationHandler:(id<JavaLangReflectInvocationHandler>)h;

#pragma mark Package-Private

- (jboolean)proxy_equalsWithId:(id)obj;

- (jint)proxy_hashCode;

- (NSString *)proxy_toString;

@end

J2OBJC_STATIC_INIT(JavaLangReflectProxy)

J2OBJC_FIELD_SETTER(JavaLangReflectProxy, h_, id<JavaLangReflectInvocationHandler>)

FOUNDATION_EXPORT void JavaLangReflectProxy_initWithJavaLangReflectInvocationHandler_(JavaLangReflectProxy *self, id<JavaLangReflectInvocationHandler> h);

FOUNDATION_EXPORT JavaLangReflectProxy *new_JavaLangReflectProxy_initWithJavaLangReflectInvocationHandler_(id<JavaLangReflectInvocationHandler> h) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaLangReflectProxy *create_JavaLangReflectProxy_initWithJavaLangReflectInvocationHandler_(id<JavaLangReflectInvocationHandler> h);

FOUNDATION_EXPORT IOSClass *JavaLangReflectProxy_getProxyClassWithJavaLangClassLoader_withIOSClassArray_(JavaLangClassLoader *loader, IOSObjectArray *interfaces);

FOUNDATION_EXPORT id JavaLangReflectProxy_newProxyInstanceWithJavaLangClassLoader_withIOSClassArray_withJavaLangReflectInvocationHandler_(JavaLangClassLoader *loader, IOSObjectArray *interfaces, id<JavaLangReflectInvocationHandler> h);

FOUNDATION_EXPORT jboolean JavaLangReflectProxy_isProxyClassWithIOSClass_(IOSClass *cl);

FOUNDATION_EXPORT id<JavaLangReflectInvocationHandler> JavaLangReflectProxy_getInvocationHandlerWithId_(id proxy);

J2OBJC_TYPE_LITERAL_HEADER(JavaLangReflectProxy)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaLangReflectProxy")
