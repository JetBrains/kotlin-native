//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/lang/reflect/Modifier.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaLangReflectModifier")
#ifdef RESTRICT_JavaLangReflectModifier
#define INCLUDE_ALL_JavaLangReflectModifier 0
#else
#define INCLUDE_ALL_JavaLangReflectModifier 1
#endif
#undef RESTRICT_JavaLangReflectModifier

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaLangReflectModifier_) && (INCLUDE_ALL_JavaLangReflectModifier || defined(INCLUDE_JavaLangReflectModifier))
#define JavaLangReflectModifier_

/*!
 @brief The Modifier class provides <code>static</code> methods and
  constants to decode class and member access modifiers.The sets of
  modifiers are represented as integers with distinct bit positions
  representing different modifiers.
 The values for the constants
  representing the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of 
 <cite>The Java&trade; Virtual Machine Specification</cite>.
 - seealso: Class#getModifiers()
 - seealso: Member#getModifiers()
 @author Nakul Saraiya
 @author Kenneth Russell
 */
@interface JavaLangReflectModifier : NSObject
@property (readonly, class) jint PUBLIC NS_SWIFT_NAME(PUBLIC);
@property (readonly, class) jint PRIVATE NS_SWIFT_NAME(PRIVATE);
@property (readonly, class) jint PROTECTED NS_SWIFT_NAME(PROTECTED);
@property (readonly, class) jint STATIC NS_SWIFT_NAME(STATIC);
@property (readonly, class) jint FINAL NS_SWIFT_NAME(FINAL);
@property (readonly, class) jint SYNCHRONIZED NS_SWIFT_NAME(SYNCHRONIZED);
@property (readonly, class) jint VOLATILE NS_SWIFT_NAME(VOLATILE);
@property (readonly, class) jint TRANSIENT NS_SWIFT_NAME(TRANSIENT);
@property (readonly, class) jint NATIVE NS_SWIFT_NAME(NATIVE);
@property (readonly, class) jint INTERFACE NS_SWIFT_NAME(INTERFACE);
@property (readonly, class) jint ABSTRACT NS_SWIFT_NAME(ABSTRACT);
@property (readonly, class) jint STRICT NS_SWIFT_NAME(STRICT);
@property (readonly, class) jint BRIDGE NS_SWIFT_NAME(BRIDGE);
@property (readonly, class) jint VARARGS NS_SWIFT_NAME(VARARGS);
@property (readonly, class) jint SYNTHETIC NS_SWIFT_NAME(SYNTHETIC);
@property (readonly, class) jint ANNOTATION NS_SWIFT_NAME(ANNOTATION);
@property (readonly, class) jint ENUM NS_SWIFT_NAME(ENUM);
@property (readonly, class) jint MANDATED NS_SWIFT_NAME(MANDATED);
@property (readonly, class) jint CONSTRUCTOR NS_SWIFT_NAME(CONSTRUCTOR);
@property (readonly, class) jint DEFAULT NS_SWIFT_NAME(DEFAULT);
@property (readonly, class) jint ACCESS_MODIFIERS NS_SWIFT_NAME(ACCESS_MODIFIERS);

+ (jint)PUBLIC;

+ (jint)PRIVATE;

+ (jint)PROTECTED;

+ (jint)STATIC;

+ (jint)FINAL;

+ (jint)SYNCHRONIZED;

+ (jint)VOLATILE;

+ (jint)TRANSIENT;

+ (jint)NATIVE;

+ (jint)INTERFACE;

+ (jint)ABSTRACT;

+ (jint)STRICT;

+ (jint)BRIDGE;

+ (jint)VARARGS;

+ (jint)SYNTHETIC;

+ (jint)ANNOTATION;

+ (jint)ENUM;

+ (jint)MANDATED;

+ (jint)CONSTRUCTOR;

+ (jint)DEFAULT;

+ (jint)ACCESS_MODIFIERS;

#pragma mark Public

- (instancetype __nonnull)init;

/*!
 @brief Return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a class.
 @return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a class.
 @since 1.7
 */
+ (jint)classModifiers;

/*!
 @brief Return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a constructor.
 @return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a constructor.
 @since 1.7
 */
+ (jint)constructorModifiers;

/*!
 @brief Return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a field.
 @return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a field.
 @since 1.7
 */
+ (jint)fieldModifiers;

/*!
 @brief Return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to an interface.
 @return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to an interface.
 @since 1.7
 */
+ (jint)interfaceModifiers;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>abstract</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>abstract</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isAbstractWithInt:(jint)mod;

/*!
 @brief Returns true if the given modifiers contain <code>Modifier.CONSTRUCTOR</code>.
 */
+ (jboolean)isConstructorWithInt:(jint)modifiers;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>final</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>final</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isFinalWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>interface</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>interface</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isInterfaceWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>native</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>native</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isNativeWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>private</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>private</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isPrivateWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>protected</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>protected</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isProtectedWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>public</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>public</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isPublicWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>static</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>static</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isStaticWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>strictfp</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>strictfp</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isStrictWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>synchronized</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>synchronized</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isSynchronizedWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>transient</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>transient</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isTransientWithInt:(jint)mod;

/*!
 @brief Return <code>true</code> if the integer argument includes the 
 <code>volatile</code> modifier, <code>false</code> otherwise.
 @param mod a set of modifiers
 @return <code>true</code> if <code>mod</code> includes the 
 <code>volatile</code> modifier; <code>false</code> otherwise.
 */
+ (jboolean)isVolatileWithInt:(jint)mod;

/*!
 @brief Return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a method.
 @return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a method.
 @since 1.7
 */
+ (jint)methodModifiers;

/*!
 @brief Return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a parameter.
 @return an <code>int</code> value OR-ing together the source language
  modifiers that can be applied to a parameter.
 @since 1.8
 */
+ (jint)parameterModifiers;

/*!
 @brief Return a string describing the access modifier flags in
  the specified modifier.For example: 
 <blockquote>@code

     public final synchronized strictfp 
  
@endcode</blockquote>
  The modifier names are returned in an order consistent with the
  suggested modifier orderings given in sections 8.1.1, 8.3.1, 8.4.3, 8.8.3, and 9.1.1 of 
 <cite>The Java&trade; Language Specification</cite>.
 The full modifier ordering used by this method is: 
 <blockquote> <code>public protected private abstract static final transient
  volatile synchronized native strictfp
  interface</code>
  </blockquote>
  The <code>interface</code> modifier discussed in this class is
  not a true modifier in the Java language and it appears after
  all other modifiers listed by this method.  This method may
  return a string of modifiers that are not valid modifiers of a
  Java entity; in other words, no checking is done on the
  possible validity of the combination of modifiers represented
  by the input.
  Note that to perform such checking for a known kind of entity,
  such as a constructor or method, first AND the argument of 
 <code>toString</code> with the appropriate mask from a method like 
 <code>constructorModifiers</code> or <code>methodModifiers</code>.
 @param mod a set of modifiers
 @return a string representation of the set of modifiers
  represented by <code>mod</code>
 */
+ (NSString *)toStringWithInt:(jint)mod;

#pragma mark Package-Private

+ (jboolean)isMandatedWithInt:(jint)mod;

+ (jboolean)isSyntheticWithInt:(jint)mod;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaLangReflectModifier)

/*!
 @brief The <code>int</code> value representing the <code>public</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_PUBLIC(void);
#define JavaLangReflectModifier_PUBLIC 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, PUBLIC, jint)

/*!
 @brief The <code>int</code> value representing the <code>private</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_PRIVATE(void);
#define JavaLangReflectModifier_PRIVATE 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, PRIVATE, jint)

/*!
 @brief The <code>int</code> value representing the <code>protected</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_PROTECTED(void);
#define JavaLangReflectModifier_PROTECTED 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, PROTECTED, jint)

/*!
 @brief The <code>int</code> value representing the <code>static</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_STATIC(void);
#define JavaLangReflectModifier_STATIC 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, STATIC, jint)

/*!
 @brief The <code>int</code> value representing the <code>final</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_FINAL(void);
#define JavaLangReflectModifier_FINAL 16
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, FINAL, jint)

/*!
 @brief The <code>int</code> value representing the <code>synchronized</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_SYNCHRONIZED(void);
#define JavaLangReflectModifier_SYNCHRONIZED 32
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, SYNCHRONIZED, jint)

/*!
 @brief The <code>int</code> value representing the <code>volatile</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_VOLATILE(void);
#define JavaLangReflectModifier_VOLATILE 64
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, VOLATILE, jint)

/*!
 @brief The <code>int</code> value representing the <code>transient</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_TRANSIENT(void);
#define JavaLangReflectModifier_TRANSIENT 128
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, TRANSIENT, jint)

/*!
 @brief The <code>int</code> value representing the <code>native</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_NATIVE(void);
#define JavaLangReflectModifier_NATIVE 256
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, NATIVE, jint)

/*!
 @brief The <code>int</code> value representing the <code>interface</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_INTERFACE(void);
#define JavaLangReflectModifier_INTERFACE 512
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, INTERFACE, jint)

/*!
 @brief The <code>int</code> value representing the <code>abstract</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_ABSTRACT(void);
#define JavaLangReflectModifier_ABSTRACT 1024
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, ABSTRACT, jint)

/*!
 @brief The <code>int</code> value representing the <code>strictfp</code>
  modifier.
 */
inline jint JavaLangReflectModifier_get_STRICT(void);
#define JavaLangReflectModifier_STRICT 2048
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, STRICT, jint)

inline jint JavaLangReflectModifier_get_BRIDGE(void);
#define JavaLangReflectModifier_BRIDGE 64
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, BRIDGE, jint)

inline jint JavaLangReflectModifier_get_VARARGS(void);
#define JavaLangReflectModifier_VARARGS 128
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, VARARGS, jint)

/*!
 */
inline jint JavaLangReflectModifier_get_SYNTHETIC(void);
#define JavaLangReflectModifier_SYNTHETIC 4096
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, SYNTHETIC, jint)

inline jint JavaLangReflectModifier_get_ANNOTATION(void);
#define JavaLangReflectModifier_ANNOTATION 8192
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, ANNOTATION, jint)

inline jint JavaLangReflectModifier_get_ENUM(void);
#define JavaLangReflectModifier_ENUM 16384
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, ENUM, jint)

inline jint JavaLangReflectModifier_get_MANDATED(void);
#define JavaLangReflectModifier_MANDATED 32768
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, MANDATED, jint)

/*!
 @brief Dex addition to mark instance constructors and static class
  initializer methods.
 */
inline jint JavaLangReflectModifier_get_CONSTRUCTOR(void);
#define JavaLangReflectModifier_CONSTRUCTOR 65536
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, CONSTRUCTOR, jint)

/*!
 @brief Default methods are marked with a synthetic access flag
  to speed up class loading and invocation target lookup.
 Implies INTERFACE, not-ABSTRACT, and not-STATIC.
 */
inline jint JavaLangReflectModifier_get_DEFAULT(void);
#define JavaLangReflectModifier_DEFAULT 4194304
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, DEFAULT, jint)

/*!
 */
inline jint JavaLangReflectModifier_get_ACCESS_MODIFIERS(void);
#define JavaLangReflectModifier_ACCESS_MODIFIERS 7
J2OBJC_STATIC_FIELD_CONSTANT(JavaLangReflectModifier, ACCESS_MODIFIERS, jint)

FOUNDATION_EXPORT void JavaLangReflectModifier_init(JavaLangReflectModifier *self);

FOUNDATION_EXPORT JavaLangReflectModifier *new_JavaLangReflectModifier_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaLangReflectModifier *create_JavaLangReflectModifier_init(void);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isPublicWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isPrivateWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isProtectedWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isStaticWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isFinalWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isSynchronizedWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isVolatileWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isConstructorWithInt_(jint modifiers);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isTransientWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isNativeWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isInterfaceWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isAbstractWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isStrictWithInt_(jint mod);

FOUNDATION_EXPORT NSString *JavaLangReflectModifier_toStringWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isSyntheticWithInt_(jint mod);

FOUNDATION_EXPORT jboolean JavaLangReflectModifier_isMandatedWithInt_(jint mod);

FOUNDATION_EXPORT jint JavaLangReflectModifier_classModifiers(void);

FOUNDATION_EXPORT jint JavaLangReflectModifier_interfaceModifiers(void);

FOUNDATION_EXPORT jint JavaLangReflectModifier_constructorModifiers(void);

FOUNDATION_EXPORT jint JavaLangReflectModifier_methodModifiers(void);

FOUNDATION_EXPORT jint JavaLangReflectModifier_fieldModifiers(void);

FOUNDATION_EXPORT jint JavaLangReflectModifier_parameterModifiers(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaLangReflectModifier)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaLangReflectModifier")
