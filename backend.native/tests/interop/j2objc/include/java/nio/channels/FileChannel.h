//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/channels/FileChannel.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioChannelsFileChannel")
#ifdef RESTRICT_JavaNioChannelsFileChannel
#define INCLUDE_ALL_JavaNioChannelsFileChannel 0
#else
#define INCLUDE_ALL_JavaNioChannelsFileChannel 1
#endif
#undef RESTRICT_JavaNioChannelsFileChannel

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioChannelsFileChannel_) && (INCLUDE_ALL_JavaNioChannelsFileChannel || defined(INCLUDE_JavaNioChannelsFileChannel))
#define JavaNioChannelsFileChannel_

#define RESTRICT_JavaNioChannelsSpiAbstractInterruptibleChannel 1
#define INCLUDE_JavaNioChannelsSpiAbstractInterruptibleChannel 1
#include "java/nio/channels/spi/AbstractInterruptibleChannel.h"

#define RESTRICT_JavaNioChannelsSeekableByteChannel 1
#define INCLUDE_JavaNioChannelsSeekableByteChannel 1
#include "java/nio/channels/SeekableByteChannel.h"

#define RESTRICT_JavaNioChannelsGatheringByteChannel 1
#define INCLUDE_JavaNioChannelsGatheringByteChannel 1
#include "java/nio/channels/GatheringByteChannel.h"

#define RESTRICT_JavaNioChannelsScatteringByteChannel 1
#define INCLUDE_JavaNioChannelsScatteringByteChannel 1
#include "java/nio/channels/ScatteringByteChannel.h"

@class IOSObjectArray;
@class JavaNioByteBuffer;
@class JavaNioChannelsFileChannel_MapMode;
@class JavaNioChannelsFileLock;
@class JavaNioMappedByteBuffer;
@protocol JavaNioChannelsReadableByteChannel;
@protocol JavaNioChannelsWritableByteChannel;

/*!
 @brief A channel for reading, writing, mapping, and manipulating a file.
 <p> A file channel is a <code>SeekableByteChannel</code> that is connected to
  a file. It has a current <i>position</i> within its file which can
  be both <code><i>queried</i></code> and <code><i>modified</i></code>
 .  The file itself contains a variable-length sequence
  of bytes that can be read and written and whose current <code><i>size</i></code>
  can be queried.  The size of the file increases
  when bytes are written beyond its current size; the size of the file
  decreases when it is <code></code><i>truncated</i><code></code>.  The
  file may also have some associated <i>metadata</i> such as access
  permissions, content type, and last-modification time; this class does not
  define methods for metadata access. 
 <p> In addition to the familiar read, write, and close operations of byte
  channels, this class defines the following file-specific operations: </p>
  
 <ul>
    <li><p> Bytes may be <code>read</code> or
    <code><i>written</i></code> at an absolute
    position in a file in a way that does not affect the channel's current
    position.  </p></li>
    <li><p> A region of a file may be <code><i>mapped</i></code>
    directly into memory; for large files this is often much more efficient
    than invoking the usual <tt>read</tt> or <tt>write</tt> methods.
    </p></li>
    <li><p> Updates made to a file may be <code><i>forced
    out</i></code>
  to the underlying storage device, ensuring that data are not
    lost in the event of a system crash.  </p></li>
    <li><p> Bytes can be transferred from a file <code><i>to
    some other channel</i></code>
 , and <code><i>vice
    versa</i></code>
 , in a way that can be optimized by many operating systems
    into a very fast transfer directly to or from the filesystem cache.   
 </p></li>
    <li><p> A region of a file may be <code><i>locked</i></code>
    against access by other programs.  </p></li>
  
 </ul>
  
 <p> File channels are safe for use by multiple concurrent threads.  The 
 <code>close</code> method may be invoked at any time, as specified
  by the <code>Channel</code> interface.  Only one operation that involves the
  channel's position or can change its file's size may be in progress at any
  given time; attempts to initiate a second such operation while the first is
  still in progress will block until the first operation completes.  Other
  operations, in particular those that take an explicit position, may proceed
  concurrently; whether they in fact do so is dependent upon the underlying
  implementation and is therefore unspecified. 
 <p> The view of a file provided by an instance of this class is guaranteed
  to be consistent with other views of the same file provided by other
  instances in the same program.  The view provided by an instance of this
  class may or may not, however, be consistent with the views seen by other
  concurrently-running programs due to caching performed by the underlying
  operating system and delays induced by network-filesystem protocols.  This
  is true regardless of the language in which these other programs are
  written, and whether they are running on the same machine or on some other
  machine.  The exact nature of any such inconsistencies are system-dependent
  and are therefore unspecified. 
 <p> A file channel can be obtained from an
  existing <code>FileInputStream</code>, <code>FileOutputStream</code>
 , or <code>RandomAccessFile</code>
  object by invoking
  that object's <tt>getChannel</tt> method, which returns a file channel that
  is connected to the same underlying file. Where the file channel is obtained
  from an existing stream or random access file then the state of the file
  channel is intimately connected to that of the object whose <tt>getChannel</tt>
  method returned the channel.  Changing the channel's position, whether
  explicitly or by reading or writing bytes, will change the file position of
  the originating object, and vice versa. Changing the file's length via the
  file channel will change the length seen via the originating object, and vice
  versa.  Changing the file's content by writing bytes will change the content
  seen by the originating object, and vice versa. 
 <a name="open-mode"></a> <p> At various points this class specifies that an
  instance that is "open for reading," "open for writing," or "open for
  reading and writing" is required.  A channel obtained via the <code>getChannel</code>
  method of a <code>java.io.FileInputStream</code>
  instance will be open for reading.  A channel
  obtained via the <code>getChannel</code>
  method of a <code>java.io.FileOutputStream</code> instance will be open for
  writing.  Finally, a channel obtained via the <code>getChannel</code>
  method of a <code>java.io.RandomAccessFile</code>
  instance will be open for reading if the instance
  was created with mode <tt>"r"</tt> and will be open for reading and writing
  if the instance was created with mode <tt>"rw"</tt>.
  
 <a name="append-mode"></a><p> A file channel that is open for writing may be in 
 <i>append mode</i>, for example if it was obtained from a file-output stream
  that was created by invoking the <code>FileOutputStream(File,boolean)</code>
  constructor and passing <tt>true</tt> for
  the second parameter.  In this mode each invocation of a relative write
  operation first advances the position to the end of the file and then writes
  the requested data.  Whether the advancement of the position and the writing
  of the data are done in a single atomic operation is system-dependent and
  therefore unspecified.
 - seealso: java.io.FileInputStream#getChannel()
 - seealso: java.io.FileOutputStream#getChannel()
 - seealso: java.io.RandomAccessFile#getChannel()
 @author Mark Reinhold
 @author Mike McCloskey
 @author JSR-51 Expert Group
 @since 1.4
 */
@interface JavaNioChannelsFileChannel : JavaNioChannelsSpiAbstractInterruptibleChannel < JavaNioChannelsSeekableByteChannel, JavaNioChannelsGatheringByteChannel, JavaNioChannelsScatteringByteChannel >

#pragma mark Public

/*!
 @brief Forces any updates to this channel's file to be written to the storage
  device that contains it.
 <p> If this channel's file resides on a local storage device then when
  this method returns it is guaranteed that all changes made to the file
  since this channel was created, or since this method was last invoked,
  will have been written to that device.  This is useful for ensuring that
  critical information is not lost in the event of a system crash. 
 <p> If the file does not reside on a local device then no such guarantee
  is made. 
 <p> The <tt>metaData</tt> parameter can be used to limit the number of
  I/O operations that this method is required to perform.  Passing 
 <tt>false</tt> for this parameter indicates that only updates to the
  file's content need be written to storage; passing <tt>true</tt>
  indicates that updates to both the file's content and metadata must be
  written, which generally requires at least one more I/O operation.
  Whether this parameter actually has any effect is dependent upon the
  underlying operating system and is therefore unspecified. 
 <p> Invoking this method may cause an I/O operation to occur even if the
  channel was only opened for reading.  Some operating systems, for
  example, maintain a last-access time as part of a file's metadata, and
  this time is updated whenever the file is read.  Whether or not this is
  actually done is system-dependent and is therefore unspecified. 
 <p> This method is only guaranteed to force changes that were made to
  this channel's file via the methods defined in this class.  It may or
  may not force changes that were made by modifying the content of a 
 <code><i>mapped byte buffer</i></code> obtained by
  invoking the <code>map</code> method.  Invoking the <code>force</code>
  method of the mapped byte buffer will
  force changes made to the buffer's content to be written.  </p>
 @param metaData If 
  <tt> true </tt>  then this method is required to force changes           to both the file's content and metadata to be written to
            storage; otherwise, it need only force content changes to be
            written
 @throw ClosedChannelException
 If this channel is closed
 @throw IOException
 If some other I/O error occurs
 */
- (void)forceWithBoolean:(jboolean)metaData;

/*!
 @brief Acquires an exclusive lock on this channel's file.
 <p> An invocation of this method of the form <tt>fc.lock()</tt> behaves
  in exactly the same way as the invocation 
 @code

      fc.<code>lock</code>(0L, Long.MAX_VALUE, false) 
@endcode
 @return A lock object representing the newly-acquired lock
 @throw ClosedChannelException
 If this channel is closed
 @throw AsynchronousCloseException
 If another thread closes this channel while the invoking
           thread is blocked in this method
 @throw FileLockInterruptionException
 If the invoking thread is interrupted while blocked in this
           method
 @throw OverlappingFileLockException
 If a lock that overlaps the requested region is already held by
           this Java virtual machine, or if another thread is already
           blocked in this method and is attempting to lock an overlapping
           region of the same file
 @throw NonWritableChannelException
 If this channel was not opened for writing
 @throw IOException
 If some other I/O error occurs
 - seealso: #lock(long,long,boolean)
 - seealso: #tryLock()
 - seealso: #tryLock(long,long,boolean)
 */
- (JavaNioChannelsFileLock *)lock;

/*!
 @brief Acquires a lock on the given region of this channel's file.
 <p> An invocation of this method will block until the region can be
  locked, this channel is closed, or the invoking thread is interrupted,
  whichever comes first. 
 <p> If this channel is closed by another thread during an invocation of
  this method then an <code>AsynchronousCloseException</code> will be thrown. 
 <p> If the invoking thread is interrupted while waiting to acquire the
  lock then its interrupt status will be set and a <code>FileLockInterruptionException</code>
  will be thrown.  If the invoker's
  interrupt status is set when this method is invoked then that exception
  will be thrown immediately; the thread's interrupt status will not be
  changed. 
 <p> The region specified by the <tt>position</tt> and <tt>size</tt>
  parameters need not be contained within, or even overlap, the actual
  underlying file.  Lock regions are fixed in size; if a locked region
  initially contains the end of the file and the file grows beyond the
  region then the new portion of the file will not be covered by the lock.
  If a file is expected to grow in size and a lock on the entire file is
  required then a region starting at zero, and no smaller than the
  expected maximum size of the file, should be locked.  The zero-argument 
 <code>lock()</code> method simply locks a region of size <code>Long.MAX_VALUE</code>
 .
  
 <p> Some operating systems do not support shared locks, in which case a
  request for a shared lock is automatically converted into a request for
  an exclusive lock.  Whether the newly-acquired lock is shared or
  exclusive may be tested by invoking the resulting lock object's <code>isShared</code>
  method. 
 <p> File locks are held on behalf of the entire Java virtual machine.
  They are not suitable for controlling access to a file by multiple
  threads within the same virtual machine.  </p>
 @param position The position at which the locked region is to start; must be
           non-negative
 @param size The size of the locked region; must be non-negative, and the sum
            <tt> position
  </tt> &nbsp; + &nbsp; <tt> size </tt>  must be non-negative
 @param shared <tt>
  true </tt>  to request a shared lock, in which case this          channel must be open for reading (and possibly writing);
            <tt> false
  </tt>  to request an exclusive lock, in which case this          channel must be open for writing (and possibly reading)
 @return A lock object representing the newly-acquired lock
 @throw IllegalArgumentException
 If the preconditions on the parameters do not hold
 @throw ClosedChannelException
 If this channel is closed
 @throw AsynchronousCloseException
 If another thread closes this channel while the invoking
           thread is blocked in this method
 @throw FileLockInterruptionException
 If the invoking thread is interrupted while blocked in this
           method
 @throw OverlappingFileLockException
 If a lock that overlaps the requested region is already held by
           this Java virtual machine, or if another thread is already
           blocked in this method and is attempting to lock an overlapping
           region
 @throw NonReadableChannelException
 If <tt>shared</tt> is <tt>true</tt> this channel was not
           opened for reading
 @throw NonWritableChannelException
 If <tt>shared</tt> is <tt>false</tt> but this channel was not
           opened for writing
 @throw IOException
 If some other I/O error occurs
 - seealso: #lock()
 - seealso: #tryLock()
 - seealso: #tryLock(long,long,boolean)
 */
- (JavaNioChannelsFileLock *)lockWithLong:(jlong)position
                                 withLong:(jlong)size
                              withBoolean:(jboolean)shared;

/*!
 @brief Maps a region of this channel's file directly into memory.
 <p> A region of a file may be mapped into memory in one of three modes: 
 </p>
  
 <ul type=disc>
    
 <li><p> <i>Read-only:</i> Any attempt to modify the resulting buffer
    will cause a <code>java.nio.ReadOnlyBufferException</code> to be thrown.
    (<code>MapMode.READ_ONLY</code>) </p></li>
    
 <li><p> <i>Read/write:</i> Changes made to the resulting buffer will
    eventually be propagated to the file; they may or may not be made
    visible to other programs that have mapped the same file.  (<code>MapMode.READ_WRITE</code>
 ) </p></li>
    
 <li><p> <i>Private:</i> Changes made to the resulting buffer will not
    be propagated to the file and will not be visible to other programs
    that have mapped the same file; instead, they will cause private
    copies of the modified portions of the buffer to be created.  (<code>MapMode.PRIVATE</code>
 ) </p></li>
  
 </ul>
  
 <p> For a read-only mapping, this channel must have been opened for
  reading; for a read/write or private mapping, this channel must have
  been opened for both reading and writing. 
 <p> The <code><i>mapped byte buffer</i></code>
  returned by this method will have a position of zero and a limit and
  capacity of <tt>size</tt>; its mark will be undefined.  The buffer and
  the mapping that it represents will remain valid until the buffer itself
  is garbage-collected. 
 <p> A mapping, once established, is not dependent upon the file channel
  that was used to create it.  Closing the channel, in particular, has no
  effect upon the validity of the mapping. 
 <p> Many of the details of memory-mapped files are inherently dependent
  upon the underlying operating system and are therefore unspecified.  The
  behavior of this method when the requested region is not completely
  contained within this channel's file is unspecified.  Whether changes
  made to the content or size of the underlying file, by this program or
  another, are propagated to the buffer is unspecified.  The rate at which
  changes to the buffer are propagated to the file is unspecified. 
 <p> For most operating systems, mapping a file into memory is more
  expensive than reading or writing a few tens of kilobytes of data via
  the usual <code>read</code> and <code>write</code> methods.  From the
  standpoint of performance it is generally only worth mapping relatively
  large files into memory.  </p>
 @param mode One of the constants 
 <code>READ_ONLY</code> , <code>READ_WRITE</code>
  , or <code>PRIVATE</code>
   defined in the <code>MapMode</code>  class, according to          whether the file is to be mapped read-only, read/write, or
           privately (copy-on-write), respectively
 @param position The position within the file at which the mapped region
           is to start; must be non-negative
 @param size The size of the region to be mapped; must be non-negative and
           no greater than 
 <code>java.lang.Integer.MAX_VALUE</code>
 @return The mapped byte buffer
 @throw NonReadableChannelException
 If the <tt>mode</tt> is <code>READ_ONLY</code> but
          this channel was not opened for reading
 @throw NonWritableChannelException
 If the <tt>mode</tt> is <code>READ_WRITE</code> or
          <code>PRIVATE</code> but this channel was not opened
          for both reading and writing
 @throw IllegalArgumentException
 If the preconditions on the parameters do not hold
 @throw IOException
 If some other I/O error occurs
 - seealso: java.nio.channels.FileChannel.MapMode
 - seealso: java.nio.MappedByteBuffer
 */
- (JavaNioMappedByteBuffer *)mapWithJavaNioChannelsFileChannel_MapMode:(JavaNioChannelsFileChannel_MapMode *)mode
                                                              withLong:(jlong)position
                                                              withLong:(jlong)size;

/*!
 @brief Returns this channel's file position.
 </p>
 @return This channel's file position,
           a non-negative integer counting the number of bytes
           from the beginning of the file to the current position
 @throw ClosedChannelException
 If this channel is closed
 @throw IOException
 If some other I/O error occurs
 */
- (jlong)position;

/*!
 @brief Sets this channel's file position.
 <p> Setting the position to a value that is greater than the file's
  current size is legal but does not change the size of the file.  A later
  attempt to read bytes at such a position will immediately return an
  end-of-file indication.  A later attempt to write bytes at such a
  position will cause the file to be grown to accommodate the new bytes;
  the values of any bytes between the previous end-of-file and the
  newly-written bytes are unspecified.  </p>
 @param newPosition The new position, a non-negative integer counting
           the number of bytes from the beginning of the file
 @return This file channel
 @throw ClosedChannelException
 If this channel is closed
 @throw IllegalArgumentException
 If the new position is negative
 @throw IOException
 If some other I/O error occurs
 */
- (JavaNioChannelsFileChannel *)positionWithLong:(jlong)newPosition;

/*!
 @brief Reads a sequence of bytes from this channel into the given buffer.
 <p> Bytes are read starting at this channel's current file position, and
  then the file position is updated with the number of bytes actually
  read.  Otherwise this method behaves exactly as specified in the <code>ReadableByteChannel</code>
  interface. </p>
 */
- (jint)readWithJavaNioByteBuffer:(JavaNioByteBuffer *)dst;

/*!
 @brief Reads a sequence of bytes from this channel into the given buffer,
  starting at the given file position.
 <p> This method works in the same manner as the <code>read(ByteBuffer)</code>
  method, except that bytes are read starting at the
  given file position rather than at the channel's current position.  This
  method does not modify this channel's position.  If the given position
  is greater than the file's current size then no bytes are read.  </p>
 @param dst The buffer into which bytes are to be transferred
 @param position The file position at which the transfer is to begin;
           must be non-negative
 @return The number of bytes read, possibly zero, or <tt>-1</tt> if the
           given position is greater than or equal to the file's current
           size
 @throw IllegalArgumentException
 If the position is negative
 @throw NonReadableChannelException
 If this channel was not opened for reading
 @throw ClosedChannelException
 If this channel is closed
 @throw AsynchronousCloseException
 If another thread closes this channel
           while the read operation is in progress
 @throw ClosedByInterruptException
 If another thread interrupts the current thread
           while the read operation is in progress, thereby
           closing the channel and setting the current thread's
           interrupt status
 @throw IOException
 If some other I/O error occurs
 */
- (jint)readWithJavaNioByteBuffer:(JavaNioByteBuffer *)dst
                         withLong:(jlong)position;

/*!
 @brief Reads a sequence of bytes from this channel into the given buffers.
 <p> Bytes are read starting at this channel's current file position, and
  then the file position is updated with the number of bytes actually
  read.  Otherwise this method behaves exactly as specified in the <code>ScatteringByteChannel</code>
  interface.  </p>
 */
- (jlong)readWithJavaNioByteBufferArray:(IOSObjectArray *)dsts;

/*!
 @brief Reads a sequence of bytes from this channel into a subsequence of the
  given buffers.
 <p> Bytes are read starting at this channel's current file position, and
  then the file position is updated with the number of bytes actually
  read.  Otherwise this method behaves exactly as specified in the <code>ScatteringByteChannel</code>
  interface.  </p>
 */
- (jlong)readWithJavaNioByteBufferArray:(IOSObjectArray *)dsts
                                withInt:(jint)offset
                                withInt:(jint)length;

/*!
 @brief Returns the current size of this channel's file.
 </p>
 @return The current size of this channel's file,
           measured in bytes
 @throw ClosedChannelException
 If this channel is closed
 @throw IOException
 If some other I/O error occurs
 */
- (jlong)size;

/*!
 @brief Transfers bytes into this channel's file from the given readable byte
  channel.
 <p> An attempt is made to read up to <tt>count</tt> bytes from the
  source channel and write them to this channel's file starting at the
  given <tt>position</tt>.  An invocation of this method may or may not
  transfer all of the requested bytes; whether or not it does so depends
  upon the natures and states of the channels.  Fewer than the requested
  number of bytes will be transferred if the source channel has fewer than 
 <tt>count</tt> bytes remaining, or if the source channel is non-blocking
  and has fewer than <tt>count</tt> bytes immediately available in its
  input buffer. 
 <p> This method does not modify this channel's position.  If the given
  position is greater than the file's current size then no bytes are
  transferred.  If the source channel has a position then bytes are read
  starting at that position and then the position is incremented by the
  number of bytes read. 
 <p> This method is potentially much more efficient than a simple loop
  that reads from the source channel and writes to this channel.  Many
  operating systems can transfer bytes directly from the source channel
  into the filesystem cache without actually copying them.  </p>
 @param src The source channel
 @param position The position within the file at which the transfer is to begin;
           must be non-negative
 @param count The maximum number of bytes to be transferred; must be
           non-negative
 @return The number of bytes, possibly zero,
           that were actually transferred
 @throw IllegalArgumentException
 If the preconditions on the parameters do not hold
 @throw NonReadableChannelException
 If the source channel was not opened for reading
 @throw NonWritableChannelException
 If this channel was not opened for writing
 @throw ClosedChannelException
 If either this channel or the source channel is closed
 @throw AsynchronousCloseException
 If another thread closes either channel
           while the transfer is in progress
 @throw ClosedByInterruptException
 If another thread interrupts the current thread while the
           transfer is in progress, thereby closing both channels and
           setting the current thread's interrupt status
 @throw IOException
 If some other I/O error occurs
 */
- (jlong)transferFromWithJavaNioChannelsReadableByteChannel:(id<JavaNioChannelsReadableByteChannel>)src
                                                   withLong:(jlong)position
                                                   withLong:(jlong)count;

/*!
 @brief Transfers bytes from this channel's file to the given writable byte
  channel.
 <p> An attempt is made to read up to <tt>count</tt> bytes starting at
  the given <tt>position</tt> in this channel's file and write them to the
  target channel.  An invocation of this method may or may not transfer
  all of the requested bytes; whether or not it does so depends upon the
  natures and states of the channels.  Fewer than the requested number of
  bytes are transferred if this channel's file contains fewer than 
 <tt>count</tt> bytes starting at the given <tt>position</tt>, or if the
  target channel is non-blocking and it has fewer than <tt>count</tt>
  bytes free in its output buffer. 
 <p> This method does not modify this channel's position.  If the given
  position is greater than the file's current size then no bytes are
  transferred.  If the target channel has a position then bytes are
  written starting at that position and then the position is incremented
  by the number of bytes written. 
 <p> This method is potentially much more efficient than a simple loop
  that reads from this channel and writes to the target channel.  Many
  operating systems can transfer bytes directly from the filesystem cache
  to the target channel without actually copying them.  </p>
 @param position The position within the file at which the transfer is to begin;
           must be non-negative
 @param count The maximum number of bytes to be transferred; must be
           non-negative
 @param target The target channel
 @return The number of bytes, possibly zero,
           that were actually transferred
 @throw IllegalArgumentException
 If the preconditions on the parameters do not hold
 @throw NonReadableChannelException
 If this channel was not opened for reading
 @throw NonWritableChannelException
 If the target channel was not opened for writing
 @throw ClosedChannelException
 If either this channel or the target channel is closed
 @throw AsynchronousCloseException
 If another thread closes either channel
           while the transfer is in progress
 @throw ClosedByInterruptException
 If another thread interrupts the current thread while the
           transfer is in progress, thereby closing both channels and
           setting the current thread's interrupt status
 @throw IOException
 If some other I/O error occurs
 */
- (jlong)transferToWithLong:(jlong)position
                   withLong:(jlong)count
withJavaNioChannelsWritableByteChannel:(id<JavaNioChannelsWritableByteChannel>)target;

/*!
 @brief Truncates this channel's file to the given size.
 <p> If the given size is less than the file's current size then the file
  is truncated, discarding any bytes beyond the new end of the file.  If
  the given size is greater than or equal to the file's current size then
  the file is not modified.  In either case, if this channel's file
  position is greater than the given size then it is set to that size. 
 </p>
 @param size The new size, a non-negative byte count
 @return This file channel
 @throw NonWritableChannelException
 If this channel was not opened for writing
 @throw ClosedChannelException
 If this channel is closed
 @throw IllegalArgumentException
 If the new size is negative
 @throw IOException
 If some other I/O error occurs
 */
- (JavaNioChannelsFileChannel *)truncateWithLong:(jlong)size;

/*!
 @brief Attempts to acquire an exclusive lock on this channel's file.
 <p> An invocation of this method of the form <tt>fc.tryLock()</tt>
  behaves in exactly the same way as the invocation 
 @code

      fc.<code>tryLock</code>(0L, Long.MAX_VALUE, false) 
@endcode
 @return A lock object representing the newly-acquired lock,
           or <tt>null</tt> if the lock could not be acquired
           because another program holds an overlapping lock
 @throw ClosedChannelException
 If this channel is closed
 @throw OverlappingFileLockException
 If a lock that overlaps the requested region is already held by
           this Java virtual machine, or if another thread is already
           blocked in this method and is attempting to lock an overlapping
           region
 @throw IOException
 If some other I/O error occurs
 - seealso: #lock()
 - seealso: #lock(long,long,boolean)
 - seealso: #tryLock(long,long,boolean)
 */
- (JavaNioChannelsFileLock *)tryLock;

/*!
 @brief Attempts to acquire a lock on the given region of this channel's file.
 <p> This method does not block.  An invocation always returns
  immediately, either having acquired a lock on the requested region or
  having failed to do so.  If it fails to acquire a lock because an
  overlapping lock is held by another program then it returns 
 <tt>null</tt>.  If it fails to acquire a lock for any other reason then
  an appropriate exception is thrown. 
 <p> The region specified by the <tt>position</tt> and <tt>size</tt>
  parameters need not be contained within, or even overlap, the actual
  underlying file.  Lock regions are fixed in size; if a locked region
  initially contains the end of the file and the file grows beyond the
  region then the new portion of the file will not be covered by the lock.
  If a file is expected to grow in size and a lock on the entire file is
  required then a region starting at zero, and no smaller than the
  expected maximum size of the file, should be locked.  The zero-argument 
 <code>tryLock()</code> method simply locks a region of size <code>Long.MAX_VALUE</code>
 .
  
 <p> Some operating systems do not support shared locks, in which case a
  request for a shared lock is automatically converted into a request for
  an exclusive lock.  Whether the newly-acquired lock is shared or
  exclusive may be tested by invoking the resulting lock object's <code>isShared</code>
  method. 
 <p> File locks are held on behalf of the entire Java virtual machine.
  They are not suitable for controlling access to a file by multiple
  threads within the same virtual machine.  </p>
 @param position The position at which the locked region is to start; must be
           non-negative
 @param size The size of the locked region; must be non-negative, and the sum
            <tt> position
  </tt> &nbsp; + &nbsp; <tt> size </tt>  must be non-negative
 @param shared <tt>
  true </tt>  to request a shared lock,           <tt>
  false </tt>  to request an exclusive lock
 @return A lock object representing the newly-acquired lock,
           or <tt>null</tt> if the lock could not be acquired
           because another program holds an overlapping lock
 @throw IllegalArgumentException
 If the preconditions on the parameters do not hold
 @throw ClosedChannelException
 If this channel is closed
 @throw OverlappingFileLockException
 If a lock that overlaps the requested region is already held by
           this Java virtual machine, or if another thread is already
           blocked in this method and is attempting to lock an overlapping
           region of the same file
 @throw IOException
 If some other I/O error occurs
 - seealso: #lock()
 - seealso: #lock(long,long,boolean)
 - seealso: #tryLock()
 */
- (JavaNioChannelsFileLock *)tryLockWithLong:(jlong)position
                                    withLong:(jlong)size
                                 withBoolean:(jboolean)shared;

/*!
 @brief Writes a sequence of bytes to this channel from the given buffer.
 <p> Bytes are written starting at this channel's current file position
  unless the channel is in append mode, in which case the position is
  first advanced to the end of the file.  The file is grown, if necessary,
  to accommodate the written bytes, and then the file position is updated
  with the number of bytes actually written.  Otherwise this method
  behaves exactly as specified by the <code>WritableByteChannel</code>
  interface. </p>
 */
- (jint)writeWithJavaNioByteBuffer:(JavaNioByteBuffer *)src;

/*!
 @brief Writes a sequence of bytes to this channel from the given buffer,
  starting at the given file position.
 <p> This method works in the same manner as the <code>write(ByteBuffer)</code>
  method, except that bytes are written starting at
  the given file position rather than at the channel's current position.
  This method does not modify this channel's position.  If the given
  position is greater than the file's current size then the file will be
  grown to accommodate the new bytes; the values of any bytes between the
  previous end-of-file and the newly-written bytes are unspecified.  </p>
 @param src The buffer from which bytes are to be transferred
 @param position The file position at which the transfer is to begin;
           must be non-negative
 @return The number of bytes written, possibly zero
 @throw IllegalArgumentException
 If the position is negative
 @throw NonWritableChannelException
 If this channel was not opened for writing
 @throw ClosedChannelException
 If this channel is closed
 @throw AsynchronousCloseException
 If another thread closes this channel
           while the write operation is in progress
 @throw ClosedByInterruptException
 If another thread interrupts the current thread
           while the write operation is in progress, thereby
           closing the channel and setting the current thread's
           interrupt status
 @throw IOException
 If some other I/O error occurs
 */
- (jint)writeWithJavaNioByteBuffer:(JavaNioByteBuffer *)src
                          withLong:(jlong)position;

/*!
 @brief Writes a sequence of bytes to this channel from the given buffers.
 <p> Bytes are written starting at this channel's current file position
  unless the channel is in append mode, in which case the position is
  first advanced to the end of the file.  The file is grown, if necessary,
  to accommodate the written bytes, and then the file position is updated
  with the number of bytes actually written.  Otherwise this method
  behaves exactly as specified in the <code>GatheringByteChannel</code>
  interface.  </p>
 */
- (jlong)writeWithJavaNioByteBufferArray:(IOSObjectArray *)srcs;

/*!
 @brief Writes a sequence of bytes to this channel from a subsequence of the
  given buffers.
 <p> Bytes are written starting at this channel's current file position
  unless the channel is in append mode, in which case the position is
  first advanced to the end of the file.  The file is grown, if necessary,
  to accommodate the written bytes, and then the file position is updated
  with the number of bytes actually written.  Otherwise this method
  behaves exactly as specified in the <code>GatheringByteChannel</code>
  interface.  </p>
 */
- (jlong)writeWithJavaNioByteBufferArray:(IOSObjectArray *)srcs
                                 withInt:(jint)offset
                                 withInt:(jint)length;

#pragma mark Protected

/*!
 @brief Initializes a new instance of this class.
 */
- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioChannelsFileChannel)

FOUNDATION_EXPORT void JavaNioChannelsFileChannel_init(JavaNioChannelsFileChannel *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioChannelsFileChannel)

#endif

#if !defined (JavaNioChannelsFileChannel_MapMode_) && (INCLUDE_ALL_JavaNioChannelsFileChannel || defined(INCLUDE_JavaNioChannelsFileChannel_MapMode))
#define JavaNioChannelsFileChannel_MapMode_

/*!
 @brief A typesafe enumeration for file-mapping modes.
 @since 1.4
 - seealso: java.nio.channels.FileChannel#map
 */
@interface JavaNioChannelsFileChannel_MapMode : NSObject
@property (readonly, class, strong) JavaNioChannelsFileChannel_MapMode *READ_ONLY NS_SWIFT_NAME(READ_ONLY);
@property (readonly, class, strong) JavaNioChannelsFileChannel_MapMode *READ_WRITE NS_SWIFT_NAME(READ_WRITE);
@property (readonly, class, strong) JavaNioChannelsFileChannel_MapMode *PRIVATE NS_SWIFT_NAME(PRIVATE);

+ (JavaNioChannelsFileChannel_MapMode *)READ_ONLY;

+ (JavaNioChannelsFileChannel_MapMode *)READ_WRITE;

+ (JavaNioChannelsFileChannel_MapMode *)PRIVATE;

#pragma mark Public

/*!
 @brief Returns a string describing this file-mapping mode.
 @return A descriptive string
 */
- (NSString *)description;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaNioChannelsFileChannel_MapMode)

/*!
 @brief Mode for a read-only mapping.
 */
inline JavaNioChannelsFileChannel_MapMode *JavaNioChannelsFileChannel_MapMode_get_READ_ONLY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaNioChannelsFileChannel_MapMode *JavaNioChannelsFileChannel_MapMode_READ_ONLY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaNioChannelsFileChannel_MapMode, READ_ONLY, JavaNioChannelsFileChannel_MapMode *)

/*!
 @brief Mode for a read/write mapping.
 */
inline JavaNioChannelsFileChannel_MapMode *JavaNioChannelsFileChannel_MapMode_get_READ_WRITE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaNioChannelsFileChannel_MapMode *JavaNioChannelsFileChannel_MapMode_READ_WRITE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaNioChannelsFileChannel_MapMode, READ_WRITE, JavaNioChannelsFileChannel_MapMode *)

/*!
 @brief Mode for a private (copy-on-write) mapping.
 */
inline JavaNioChannelsFileChannel_MapMode *JavaNioChannelsFileChannel_MapMode_get_PRIVATE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaNioChannelsFileChannel_MapMode *JavaNioChannelsFileChannel_MapMode_PRIVATE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaNioChannelsFileChannel_MapMode, PRIVATE, JavaNioChannelsFileChannel_MapMode *)

J2OBJC_TYPE_LITERAL_HEADER(JavaNioChannelsFileChannel_MapMode)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaNioChannelsFileChannel")
