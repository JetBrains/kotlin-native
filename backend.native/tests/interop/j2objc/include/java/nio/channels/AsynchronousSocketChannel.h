//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/channels/AsynchronousSocketChannel.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioChannelsAsynchronousSocketChannel")
#ifdef RESTRICT_JavaNioChannelsAsynchronousSocketChannel
#define INCLUDE_ALL_JavaNioChannelsAsynchronousSocketChannel 0
#else
#define INCLUDE_ALL_JavaNioChannelsAsynchronousSocketChannel 1
#endif
#undef RESTRICT_JavaNioChannelsAsynchronousSocketChannel

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioChannelsAsynchronousSocketChannel_) && (INCLUDE_ALL_JavaNioChannelsAsynchronousSocketChannel || defined(INCLUDE_JavaNioChannelsAsynchronousSocketChannel))
#define JavaNioChannelsAsynchronousSocketChannel_

#define RESTRICT_JavaNioChannelsAsynchronousByteChannel 1
#define INCLUDE_JavaNioChannelsAsynchronousByteChannel 1
#include "java/nio/channels/AsynchronousByteChannel.h"

#define RESTRICT_JavaNioChannelsNetworkChannel 1
#define INCLUDE_JavaNioChannelsNetworkChannel 1
#include "java/nio/channels/NetworkChannel.h"

@class IOSObjectArray;
@class JavaNetSocketAddress;
@class JavaNioByteBuffer;
@class JavaNioChannelsAsynchronousChannelGroup;
@class JavaNioChannelsSpiAsynchronousChannelProvider;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaNetSocketOption;
@protocol JavaNioChannelsCompletionHandler;
@protocol JavaUtilConcurrentFuture;

/*!
 @brief An asynchronous channel for stream-oriented connecting sockets.
 <p> Asynchronous socket channels are created in one of two ways. A newly-created 
 <code>AsynchronousSocketChannel</code> is created by invoking one of the <code>open</code>
  methods defined by this class. A newly-created channel is open but
  not yet connected. A connected <code>AsynchronousSocketChannel</code> is created
  when a connection is made to the socket of an <code>AsynchronousServerSocketChannel</code>.
  It is not possible to create an asynchronous socket channel for an arbitrary,
  pre-existing <code>socket</code>.
  
 <p> A newly-created channel is connected by invoking its <code>connect</code>
  method; once connected, a channel remains connected until it is closed.  Whether
  or not a socket channel is connected may be determined by invoking its <code>getRemoteAddress</code>
  method. An attempt to invoke an I/O
  operation upon an unconnected channel will cause a <code>NotYetConnectedException</code>
  to be thrown. 
 <p> Channels of this type are safe for use by multiple concurrent threads.
  They support concurrent reading and writing, though at most one read operation
  and one write operation can be outstanding at any time.
  If a thread initiates a read operation before a previous read operation has
  completed then a <code>ReadPendingException</code> will be thrown. Similarly, an
  attempt to initiate a write operation before a previous write has completed
  will throw a <code>WritePendingException</code>.
  
 <p> Socket options are configured using the <code>setOption</code>
  method. Asynchronous socket channels support the following options: 
 <blockquote>
  <table border summary="Socket options">
    <tr>
      <th>Option Name</th>
      <th>Description</th>
    </tr>
    <tr>
      <td> <code>SO_SNDBUF</code> </td>
      <td> The size of the socket send buffer </td>
    </tr>
    <tr>
      <td> <code>SO_RCVBUF</code> </td>
      <td> The size of the socket receive buffer </td>
    </tr>
    <tr>
      <td> <code>SO_KEEPALIVE</code> </td>
      <td> Keep connection alive </td>
    </tr>
    <tr>
      <td> <code>SO_REUSEADDR</code> </td>
      <td> Re-use address </td>
    </tr>
    <tr>
      <td> <code>TCP_NODELAY</code> </td>
      <td> Disable the Nagle algorithm </td>
    </tr>
  </table>
  </blockquote>
  Additional (implementation specific) options may also be supported. 
 <h2>Timeouts</h2>
  
 <p> The <code>read</code>
  and <code>write</code>
  methods defined by this class allow a timeout to be specified when initiating
  a read or write operation. If the timeout elapses before an operation completes
  then the operation completes with the exception <code>InterruptedByTimeoutException</code>
 . A timeout may leave the channel, or the
  underlying connection, in an inconsistent state. Where the implementation
  cannot guarantee that bytes have not been read from the channel then it puts
  the channel into an implementation specific <em>error state</em>. A subsequent
  attempt to initiate a <code>read</code> operation causes an unspecified runtime
  exception to be thrown. Similarly if a <code>write</code> operation times out and
  the implementation cannot guarantee bytes have not been written to the
  channel then further attempts to <code>write</code> to the channel cause an
  unspecified runtime exception to be thrown. When a timeout elapses then the
  state of the <code>ByteBuffer</code>, or the sequence of buffers, for the I/O
  operation is not defined. Buffers should be discarded or at least care must
  be taken to ensure that the buffers are not accessed while the channel remains
  open. All methods that accept timeout parameters treat values less than or
  equal to zero to mean that the I/O operation does not timeout.
 @since 1.7
 */
@interface JavaNioChannelsAsynchronousSocketChannel : NSObject < JavaNioChannelsAsynchronousByteChannel, JavaNioChannelsNetworkChannel >

#pragma mark Public

/*!
 @throw ConnectionPendingException
 If a connection operation is already in progress on this channel
 @throw AlreadyBoundException
 @throw UnsupportedAddressTypeException
 @throw ClosedChannelException
 @throw IOException
 @throw SecurityException
 If a security manager has been installed and its
           <code>checkListen</code> method denies
           the operation
 */
- (JavaNioChannelsAsynchronousSocketChannel *)bindWithJavaNetSocketAddress:(JavaNetSocketAddress *)local;

/*!
 @brief Connects this channel.
 <p> This method initiates an operation to connect this channel. This
  method behaves in exactly the same manner as the <code>connect(SocketAddress, Object, CompletionHandler)</code>
  method except that
  instead of specifying a completion handler, this method returns a <code>Future</code>
  representing the pending result. The <code>Future</code>'s <code>get</code>
  method returns <code>null</code> on successful completion.
 @param remote The remote address to which this channel is to be connected
 @return A <code>Future</code> object representing the pending result
 @throw UnresolvedAddressException
 If the given remote address is not fully resolved
 @throw UnsupportedAddressTypeException
 If the type of the given remote address is not supported
 @throw AlreadyConnectedException
 If this channel is already connected
 @throw ConnectionPendingException
 If a connection operation is already in progress on this channel
 @throw SecurityException
 If a security manager has been installed
           and it does not permit access to the given remote endpoint
 */
- (id<JavaUtilConcurrentFuture>)connectWithJavaNetSocketAddress:(JavaNetSocketAddress *)remote;

/*!
 @brief Connects this channel.
 <p> This method initiates an operation to connect this channel. The 
 <code>handler</code> parameter is a completion handler that is invoked when
  the connection is successfully established or connection cannot be
  established. If the connection cannot be established then the channel is
  closed. 
 <p> This method performs exactly the same security checks as the <code>java.net.Socket</code>
  class.  That is, if a security manager has been
  installed then this method verifies that its <code>checkConnect</code>
  method permits
  connecting to the address and port number of the given remote endpoint.
 @param remote The remote address to which this channel is to be connected
 @param attachment The object to attach to the I/O operation; can be 
 <code>null</code>
 @param handler The handler for consuming the result
 @throw UnresolvedAddressException
 If the given remote address is not fully resolved
 @throw UnsupportedAddressTypeException
 If the type of the given remote address is not supported
 @throw AlreadyConnectedException
 If this channel is already connected
 @throw ConnectionPendingException
 If a connection operation is already in progress on this channel
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 @throw SecurityException
 If a security manager has been installed
           and it does not permit access to the given remote endpoint
 - seealso: #getRemoteAddress
 */
- (void)connectWithJavaNetSocketAddress:(JavaNetSocketAddress *)remote
                                 withId:(id)attachment
   withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

/*!
 @brief <p>
  If there is a security manager set, its <code>checkConnect</code> method is
  called with the local address and <code>-1</code> as its arguments to see
  if the operation is allowed.
 If the operation is not allowed,
  a <code>SocketAddress</code> representing the 
 <code>loopback</code> address and the
  local port of the channel's socket is returned.
 @return The <code>SocketAddress</code> that the socket is bound to, or the
           <code>SocketAddress</code> representing the loopback address if
           denied by the security manager, or <code>null</code> if the
           channel's socket is not bound
 @throw ClosedChannelException
 @throw IOException
 */
- (JavaNetSocketAddress *)getLocalAddress;

/*!
 @brief Returns the remote address to which this channel's socket is connected.
 <p> Where the channel is bound and connected to an Internet Protocol
  socket address then the return value from this method is of type <code>java.net.InetSocketAddress</code>
 .
 @return The remote address; <code>null</code> if the channel's socket is not
           connected
 @throw ClosedChannelException
 If the channel is closed
 @throw IOException
 If an I/O error occurs
 */
- (JavaNetSocketAddress *)getRemoteAddress;

/*!
 @brief Opens an asynchronous socket channel.
 <p> This method returns an asynchronous socket channel that is bound to
  the <em>default group</em>.This method is equivalent to evaluating the
  expression: 
 <blockquote>@code

  open((AsynchronousChannelGroup)null); 
  
@endcode</blockquote>
 @return A new asynchronous socket channel
 @throw IOException
 If an I/O error occurs
 */
+ (JavaNioChannelsAsynchronousSocketChannel *)open;

/*!
 @brief Opens an asynchronous socket channel.
 <p> The new channel is created by invoking the <code>openAsynchronousSocketChannel</code>
  method on the <code>AsynchronousChannelProvider</code>
  that created the group. If the group parameter
  is <code>null</code> then the resulting channel is created by the system-wide
  default provider, and bound to the <em>default group</em>.
 @param group The group to which the newly constructed channel should be bound,
            or <code>null</code>
   for the default group
 @return A new asynchronous socket channel
 @throw ShutdownChannelGroupException
 If the channel group is shutdown
 @throw IOException
 If an I/O error occurs
 */
+ (JavaNioChannelsAsynchronousSocketChannel *)openWithJavaNioChannelsAsynchronousChannelGroup:(JavaNioChannelsAsynchronousChannelGroup *)group;

/*!
 @brief Returns the provider that created this channel.
 @return The provider that created this channel
 */
- (JavaNioChannelsSpiAsynchronousChannelProvider *)provider;

/*!
 @throw IllegalArgumentException
 @throw ReadPendingException
 @throw NotYetConnectedException
 If this channel is not yet connected
 */
- (id<JavaUtilConcurrentFuture>)readWithJavaNioByteBuffer:(JavaNioByteBuffer *)dst;

/*!
 @throw IllegalArgumentException
 @throw ReadPendingException
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 */
- (void)readWithJavaNioByteBuffer:(JavaNioByteBuffer *)dst
                           withId:(id)attachment
withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

/*!
 @brief Reads a sequence of bytes from this channel into the given buffer.
 <p> This method initiates an asynchronous read operation to read a
  sequence of bytes from this channel into the given buffer. The <code>handler</code>
  parameter is a completion handler that is invoked when the read
  operation completes (or fails). The result passed to the completion
  handler is the number of bytes read or <code>-1</code> if no bytes could be
  read because the channel has reached end-of-stream. 
 <p> If a timeout is specified and the timeout elapses before the operation
  completes then the operation completes with the exception <code>InterruptedByTimeoutException</code>
 . Where a timeout occurs, and the
  implementation cannot guarantee that bytes have not been read, or will not
  be read from the channel into the given buffer, then further attempts to
  read from the channel will cause an unspecific runtime exception to be
  thrown. 
 <p> Otherwise this method works in the same manner as the <code>AsynchronousByteChannel.read(ByteBuffer,Object,CompletionHandler)</code>
  method.
 @param dst The buffer into which bytes are to be transferred
 @param timeout The maximum time for the I/O operation to complete
 @param unit The time unit of the 
 <code>timeout</code>  argument
 @param attachment The object to attach to the I/O operation; can be 
 <code>null</code>
 @param handler The handler for consuming the result
 @throw IllegalArgumentException
 If the buffer is read-only
 @throw ReadPendingException
 If a read operation is already in progress on this channel
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 */
- (void)readWithJavaNioByteBuffer:(JavaNioByteBuffer *)dst
                         withLong:(jlong)timeout
   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                           withId:(id)attachment
withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

/*!
 @brief Reads a sequence of bytes from this channel into a subsequence of the
  given buffers.This operation, sometimes called a <em>scattering read</em>,
  is often useful when implementing network protocols that group data into
  segments consisting of one or more fixed-length headers followed by a
  variable-length body.
 The <code>handler</code> parameter is a completion
  handler that is invoked when the read operation completes (or fails). The
  result passed to the completion handler is the number of bytes read or 
 <code>-1</code> if no bytes could be read because the channel has reached
  end-of-stream. 
 <p> This method initiates a read of up to <i>r</i> bytes from this channel,
  where <i>r</i> is the total number of bytes remaining in the specified
  subsequence of the given buffer array, that is, 
 <blockquote>@code

  dsts[offset].remaining()
      + dsts[offset+1].remaining()
      + ... + dsts[offset+length-1].remaining()
@endcode</blockquote>
  at the moment that the read is attempted. 
 <p> Suppose that a byte sequence of length <i>n</i> is read, where 
 <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
  Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence
  are transferred into buffer <tt>dsts[offset]</tt>, up to the next 
 <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer 
 <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence
  is transferred into the given buffers.  As many bytes as possible are
  transferred into each buffer, hence the final position of each updated
  buffer, except the last updated buffer, is guaranteed to be equal to
  that buffer's limit. The underlying operating system may impose a limit
  on the number of buffers that may be used in an I/O operation. Where the
  number of buffers (with bytes remaining), exceeds this limit, then the
  I/O operation is performed with the maximum number of buffers allowed by
  the operating system. 
 <p> If a timeout is specified and the timeout elapses before the operation
  completes then it completes with the exception <code>InterruptedByTimeoutException</code>
 . Where a timeout occurs, and the
  implementation cannot guarantee that bytes have not been read, or will not
  be read from the channel into the given buffers, then further attempts to
  read from the channel will cause an unspecific runtime exception to be
  thrown.
 @param dsts The buffers into which bytes are to be transferred
 @param offset The offset within the buffer array of the first buffer into which
            bytes are to be transferred; must be non-negative and no larger than
            <code>dsts.length</code>
 @param length The maximum number of buffers to be accessed; must be non-negative
            and no larger than 
 <code>dsts.length - offset</code>
 @param timeout The maximum time for the I/O operation to complete
 @param unit The time unit of the 
 <code>timeout</code>  argument
 @param attachment The object to attach to the I/O operation; can be 
 <code>null</code>
 @param handler The handler for consuming the result
 @throw IndexOutOfBoundsException
 If the pre-conditions for the <code>offset</code>  and <code>length</code>
           parameter aren't met
 @throw IllegalArgumentException
 If the buffer is read-only
 @throw ReadPendingException
 If a read operation is already in progress on this channel
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 */
- (void)readWithJavaNioByteBufferArray:(IOSObjectArray *)dsts
                               withInt:(jint)offset
                               withInt:(jint)length
                              withLong:(jlong)timeout
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                withId:(id)attachment
  withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

/*!
 @throw IllegalArgumentException
 @throw ClosedChannelException
 @throw IOException
 */
- (JavaNioChannelsAsynchronousSocketChannel *)setOptionWithJavaNetSocketOption:(id<JavaNetSocketOption>)name
                                                                        withId:(id)value;

/*!
 @brief Shutdown the connection for reading without closing the channel.
 <p> Once shutdown for reading then further reads on the channel will
  return <code>-1</code>, the end-of-stream indication. If the input side of the
  connection is already shutdown then invoking this method has no effect.
  The effect on an outstanding read operation is system dependent and
  therefore not specified. The effect, if any, when there is data in the
  socket receive buffer that has not been read, or data arrives subsequently,
  is also system dependent.
 @return The channel
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ClosedChannelException
 If this channel is closed
 @throw IOException
 If some other I/O error occurs
 */
- (JavaNioChannelsAsynchronousSocketChannel *)shutdownInput;

/*!
 @brief Shutdown the connection for writing without closing the channel.
 <p> Once shutdown for writing then further attempts to write to the
  channel will throw <code>ClosedChannelException</code>. If the output side of
  the connection is already shutdown then invoking this method has no
  effect. The effect on an outstanding write operation is system dependent
  and therefore not specified.
 @return The channel
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ClosedChannelException
 If this channel is closed
 @throw IOException
 If some other I/O error occurs
 */
- (JavaNioChannelsAsynchronousSocketChannel *)shutdownOutput;

/*!
 @throw WritePendingException
 @throw NotYetConnectedException
 If this channel is not yet connected
 */
- (id<JavaUtilConcurrentFuture>)writeWithJavaNioByteBuffer:(JavaNioByteBuffer *)src;

/*!
 @throw WritePendingException
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 */
- (void)writeWithJavaNioByteBuffer:(JavaNioByteBuffer *)src
                            withId:(id)attachment
withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

/*!
 @brief Writes a sequence of bytes to this channel from the given buffer.
 <p> This method initiates an asynchronous write operation to write a
  sequence of bytes to this channel from the given buffer. The <code>handler</code>
  parameter is a completion handler that is invoked when the write
  operation completes (or fails). The result passed to the completion
  handler is the number of bytes written. 
 <p> If a timeout is specified and the timeout elapses before the operation
  completes then it completes with the exception <code>InterruptedByTimeoutException</code>
 . Where a timeout occurs, and the
  implementation cannot guarantee that bytes have not been written, or will
  not be written to the channel from the given buffer, then further attempts
  to write to the channel will cause an unspecific runtime exception to be
  thrown. 
 <p> Otherwise this method works in the same manner as the <code>AsynchronousByteChannel.write(ByteBuffer,Object,CompletionHandler)</code>
  method.
 @param src The buffer from which bytes are to be retrieved
 @param timeout The maximum time for the I/O operation to complete
 @param unit The time unit of the 
 <code>timeout</code>  argument
 @param attachment The object to attach to the I/O operation; can be 
 <code>null</code>
 @param handler The handler for consuming the result
 @throw WritePendingException
 If a write operation is already in progress on this channel
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 */
- (void)writeWithJavaNioByteBuffer:(JavaNioByteBuffer *)src
                          withLong:(jlong)timeout
    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                            withId:(id)attachment
withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

/*!
 @brief Writes a sequence of bytes to this channel from a subsequence of the given
  buffers.This operation, sometimes called a <em>gathering write</em>, is
  often useful when implementing network protocols that group data into
  segments consisting of one or more fixed-length headers followed by a
  variable-length body.
 The <code>handler</code> parameter is a completion
  handler that is invoked when the write operation completes (or fails).
  The result passed to the completion handler is the number of bytes written. 
 <p> This method initiates a write of up to <i>r</i> bytes to this channel,
  where <i>r</i> is the total number of bytes remaining in the specified
  subsequence of the given buffer array, that is, 
 <blockquote>@code

  srcs[offset].remaining()
      + srcs[offset+1].remaining()
      + ... + srcs[offset+length-1].remaining()
@endcode</blockquote>
  at the moment that the write is attempted. 
 <p> Suppose that a byte sequence of length <i>n</i> is written, where 
 <tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
  Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence
  are written from buffer <tt>srcs[offset]</tt>, up to the next 
 <tt>srcs[offset+1].remaining()</tt> bytes are written from buffer 
 <tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is
  written.  As many bytes as possible are written from each buffer, hence
  the final position of each updated buffer, except the last updated
  buffer, is guaranteed to be equal to that buffer's limit. The underlying
  operating system may impose a limit on the number of buffers that may be
  used in an I/O operation. Where the number of buffers (with bytes
  remaining), exceeds this limit, then the I/O operation is performed with
  the maximum number of buffers allowed by the operating system. 
 <p> If a timeout is specified and the timeout elapses before the operation
  completes then it completes with the exception <code>InterruptedByTimeoutException</code>
 . Where a timeout occurs, and the
  implementation cannot guarantee that bytes have not been written, or will
  not be written to the channel from the given buffers, then further attempts
  to write to the channel will cause an unspecific runtime exception to be
  thrown.
 @param srcs The buffers from which bytes are to be retrieved
 @param offset The offset within the buffer array of the first buffer from which
            bytes are to be retrieved; must be non-negative and no larger
            than <code>srcs.length</code>
 @param length The maximum number of buffers to be accessed; must be non-negative
            and no larger than 
 <code>srcs.length - offset</code>
 @param timeout The maximum time for the I/O operation to complete
 @param unit The time unit of the 
 <code>timeout</code>  argument
 @param attachment The object to attach to the I/O operation; can be 
 <code>null</code>
 @param handler The handler for consuming the result
 @throw IndexOutOfBoundsException
 If the pre-conditions for the <code>offset</code>  and <code>length</code>
           parameter aren't met
 @throw WritePendingException
 If a write operation is already in progress on this channel
 @throw NotYetConnectedException
 If this channel is not yet connected
 @throw ShutdownChannelGroupException
 If the channel group has terminated
 */
- (void)writeWithJavaNioByteBufferArray:(IOSObjectArray *)srcs
                                withInt:(jint)offset
                                withInt:(jint)length
                               withLong:(jlong)timeout
         withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                 withId:(id)attachment
   withJavaNioChannelsCompletionHandler:(id<JavaNioChannelsCompletionHandler>)handler;

#pragma mark Protected

/*!
 @brief Initializes a new instance of this class.
 @param provider The provider that created this channel
 */
- (instancetype __nonnull)initWithJavaNioChannelsSpiAsynchronousChannelProvider:(JavaNioChannelsSpiAsynchronousChannelProvider *)provider;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioChannelsAsynchronousSocketChannel)

FOUNDATION_EXPORT void JavaNioChannelsAsynchronousSocketChannel_initWithJavaNioChannelsSpiAsynchronousChannelProvider_(JavaNioChannelsAsynchronousSocketChannel *self, JavaNioChannelsSpiAsynchronousChannelProvider *provider);

FOUNDATION_EXPORT JavaNioChannelsAsynchronousSocketChannel *JavaNioChannelsAsynchronousSocketChannel_openWithJavaNioChannelsAsynchronousChannelGroup_(JavaNioChannelsAsynchronousChannelGroup *group);

FOUNDATION_EXPORT JavaNioChannelsAsynchronousSocketChannel *JavaNioChannelsAsynchronousSocketChannel_open(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioChannelsAsynchronousSocketChannel)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaNioChannelsAsynchronousSocketChannel")
