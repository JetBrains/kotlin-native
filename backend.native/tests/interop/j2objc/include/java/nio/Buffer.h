//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/Buffer.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioBuffer")
#ifdef RESTRICT_JavaNioBuffer
#define INCLUDE_ALL_JavaNioBuffer 0
#else
#define INCLUDE_ALL_JavaNioBuffer 1
#endif
#undef RESTRICT_JavaNioBuffer

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioBuffer_) && (INCLUDE_ALL_JavaNioBuffer || defined(INCLUDE_JavaNioBuffer))
#define JavaNioBuffer_

/*!
 @brief A container for data of a specific primitive type.
 <p> A buffer is a linear, finite sequence of elements of a specific
  primitive type.  Aside from its content, the essential properties of a
  buffer are its capacity, limit, and position: </p>
  
 <blockquote>
    <p> A buffer's <i>capacity</i> is the number of elements it contains.  The
    capacity of a buffer is never negative and never changes.  </p>
    <p> A buffer's <i>limit</i> is the index of the first element that should
    not be read or written.  A buffer's limit is never negative and is never
    greater than its capacity.  </p>
    <p> A buffer's <i>position</i> is the index of the next element to be
    read or written.  A buffer's position is never negative and is never
    greater than its limit.  </p>
  
 </blockquote>
  
 <p> There is one subclass of this class for each non-boolean primitive type. 
 <h2> Transferring data </h2>
  
 <p> Each subclass of this class defines two categories of <i>get</i> and 
 <i>put</i> operations: </p>
  
 <blockquote>
    <p> <i>Relative</i> operations read or write one or more elements starting
    at the current position and then increment the position by the number of
    elements transferred.  If the requested transfer exceeds the limit then a
    relative <i>get</i> operation throws a <code>BufferUnderflowException</code>
    and a relative <i>put</i> operation throws a <code>BufferOverflowException</code>
 ; in either case, no data is transferred.  </p>
    <p> <i>Absolute</i> operations take an explicit element index and do not
    affect the position.  Absolute <i>get</i> and <i>put</i> operations throw
    an <code>IndexOutOfBoundsException</code> if the index argument exceeds the
    limit.  </p>
  
 </blockquote>
  
 <p> Data may also, of course, be transferred in to or out of a buffer by the
  I/O operations of an appropriate channel, which are always relative to the
  current position. 
 <h2> Marking and resetting </h2>
  
 <p> A buffer's <i>mark</i> is the index to which its position will be reset
  when the <code>reset</code> method is invoked.  The mark is not always
  defined, but when it is defined it is never negative and is never greater
  than the position.  If the mark is defined then it is discarded when the
  position or the limit is adjusted to a value smaller than the mark.  If the
  mark is not defined then invoking the <code>reset</code> method causes an 
 <code>InvalidMarkException</code> to be thrown. 
 <h2> Invariants </h2>
  
 <p> The following invariant holds for the mark, position, limit, and
  capacity values: 
 <blockquote>
      <tt>0</tt> <tt>&lt;=</tt>
      <i>mark</i> <tt>&lt;=</tt>
      <i>position</i> <tt>&lt;=</tt>
      <i>limit</i> <tt>&lt;=</tt>
      <i>capacity</i>
  </blockquote>
  
 <p> A newly-created buffer always has a position of zero and a mark that is
  undefined.  The initial limit may be zero, or it may be some other value
  that depends upon the type of the buffer and the manner in which it is
  constructed.  Each element of a newly-allocated buffer is initialized
  to zero. 
 <h2> Clearing, flipping, and rewinding </h2>
  
 <p> In addition to methods for accessing the position, limit, and capacity
  values and for marking and resetting, this class also defines the following
  operations upon buffers: 
 <ul>
    <li><p> <code>clear</code> makes a buffer ready for a new sequence of
    channel-read or relative <i>put</i> operations: It sets the limit to the
    capacity and the position to zero.  </p></li>
    <li><p> <code>flip</code> makes a buffer ready for a new sequence of
    channel-write or relative <i>get</i> operations: It sets the limit to the
    current position and then sets the position to zero.  </p></li>
    <li><p> <code>rewind</code> makes a buffer ready for re-reading the data that
    it already contains: It leaves the limit unchanged and sets the position
    to zero.  </p></li>
  
 </ul>
  
 <h2> Read-only buffers </h2>
  
 <p> Every buffer is readable, but not every buffer is writable.  The
  mutation methods of each buffer class are specified as <i>optional
  operations</i> that will throw a <code>ReadOnlyBufferException</code> when
  invoked upon a read-only buffer.  A read-only buffer does not allow its
  content to be changed, but its mark, position, and limit values are mutable.
  Whether or not a buffer is read-only may be determined by invoking its 
 <code>isReadOnly</code> method. 
 <h2> Thread safety </h2>
  
 <p> Buffers are not safe for use by multiple concurrent threads.  If a
  buffer is to be used by more than one thread then access to the buffer
  should be controlled by appropriate synchronization. 
 <h2> Invocation chaining </h2>
  
 <p> Methods in this class that do not otherwise have a value to return are
  specified to return the buffer upon which they are invoked.  This allows
  method invocations to be chained; for example, the sequence of statements 
 <blockquote>@code

  b.flip();
  b.position(23);
  b.limit(42);
@endcode</blockquote>
  can be replaced by the single, more compact statement 
 <blockquote>@code

  b.flip().position(23).limit(42);
@endcode</blockquote>
 @author Mark Reinhold
 @author JSR-51 Expert Group
 @since 1.4
 */
@interface JavaNioBuffer : NSObject {
 @public
  jint position_;
  jint capacity_;
  jlong address_;
  /*!
   @brief The log base 2 of the element size of this buffer.Each typed subclass
  (ByteBuffer, CharBuffer, etc.) is responsible for initializing this
  value.
   The value is used by JNI code in frameworks/base/ to avoid the
  need for costly 'instanceof' tests.
   */
  jint _elementSizeShift_;
}
@property (readonly, class) jint SPLITERATOR_CHARACTERISTICS NS_SWIFT_NAME(SPLITERATOR_CHARACTERISTICS);

+ (jint)SPLITERATOR_CHARACTERISTICS;

#pragma mark Public

/*!
 @brief Returns the array that backs this
  buffer&nbsp;&nbsp;<i>(optional operation)</i>.
 <p> This method is intended to allow array-backed buffers to be
  passed to native code more efficiently. Concrete subclasses
  provide more strongly-typed return values for this method. 
 <p> Modifications to this buffer's content will cause the returned
  array's content to be modified, and vice versa. 
 <p> Invoke the <code>hasArray</code> method before invoking this
  method in order to ensure that this buffer has an accessible backing
  array.  </p>
 @return The array that backs this buffer
 @throw ReadOnlyBufferException
 If this buffer is backed by an array but is read-only
 @throw UnsupportedOperationException
 If this buffer is not backed by an accessible array
 @since 1.6
 */
- (id)array;

/*!
 @brief Returns the offset within this buffer's backing array of the first
  element of the buffer&nbsp;&nbsp;<i>(optional operation)</i>.
 <p> If this buffer is backed by an array then buffer position <i>p</i>
  corresponds to array index <i>p</i>&nbsp;+&nbsp;<tt>arrayOffset()</tt>.
  
 <p> Invoke the <code>hasArray</code> method before invoking this
  method in order to ensure that this buffer has an accessible backing
  array.  </p>
 @return The offset within this buffer's array
           of the first element of the buffer
 @throw ReadOnlyBufferException
 If this buffer is backed by an array but is read-only
 @throw UnsupportedOperationException
 If this buffer is not backed by an accessible array
 @since 1.6
 */
- (jint)arrayOffset;

/*!
 @brief Returns this buffer's capacity.
 @return The capacity of this buffer
 */
- (jint)capacity;

/*!
 @brief Clears this buffer.The position is set to zero, the limit is set to
  the capacity, and the mark is discarded.
 <p> Invoke this method before using a sequence of channel-read or 
 <i>put</i> operations to fill this buffer.  For example: 
 <blockquote>@code

  buf.clear();     // Prepare buffer for reading
  in.read(buf);    // Read data
@endcode</blockquote>
  
 <p> This method does not actually erase the data in the buffer, but it
  is named as if it did because it will most often be used in situations
  in which that might as well be the case. </p>
 @return This buffer
 */
- (JavaNioBuffer *)clear;

/*!
 @brief Flips this buffer.The limit is set to the current position and then
  the position is set to zero.
 If the mark is defined then it is
  discarded. 
 <p> After a sequence of channel-read or <i>put</i> operations, invoke
  this method to prepare for a sequence of channel-write or relative 
 <i>get</i> operations.  For example: 
 <blockquote>@code

  buf.put(magic);    // Prepend header
  in.read(buf);      // Read data into rest of buffer
  buf.flip();        // Flip buffer
  out.write(buf);    // Write header + data to channel
@endcode</blockquote>
  
 <p> This method is often used in conjunction with the <code>compact</code>
  method when transferring data from
  one place to another.  </p>
 @return This buffer
 */
- (JavaNioBuffer *)flip;

/*!
 @brief For testing only.This field is accessed directly via JNI from frameworks code.
 */
- (jint)getElementSizeShift;

/*!
 @brief Tells whether or not this buffer is backed by an accessible
  array.
 <p> If this method returns <tt>true</tt> then the <code>array</code>
  and <code>arrayOffset</code> methods may safely be invoked. 
 </p>
 @return <tt>true</tt> if, and only if, this buffer
           is backed by an array and is not read-only
 @since 1.6
 */
- (jboolean)hasArray;

/*!
 @brief Tells whether there are any elements between the current position and
  the limit.
 @return <tt>true</tt> if, and only if, there is at least one element
           remaining in this buffer
 */
- (jboolean)hasRemaining;

/*!
 @brief Tells whether or not this buffer is 
 <a href="ByteBuffer.html#direct"><i>direct</i></a>.
 @return <tt>true</tt> if, and only if, this buffer is direct
 @since 1.6
 */
- (jboolean)isDirect;

/*!
 @brief Tells whether or not this buffer is read-only.
 @return <tt>true</tt> if, and only if, this buffer is read-only
 */
- (jboolean)isReadOnly;

/*!
 @brief Returns this buffer's limit.
 @return The limit of this buffer
 */
- (jint)limit;

/*!
 @brief Sets this buffer's limit.If the position is larger than the new limit
  then it is set to the new limit.
 If the mark is defined and larger than
  the new limit then it is discarded.
 @param newLimit The new limit value; must be non-negative
           and no larger than this buffer's capacity
 @return This buffer
 @throw IllegalArgumentException
 If the preconditions on <tt>newLimit</tt> do not hold
 */
- (JavaNioBuffer *)limitWithInt:(jint)newLimit;

/*!
 @brief Sets this buffer's mark at its position.
 @return This buffer
 */
- (JavaNioBuffer *)mark;

/*!
 @brief Returns this buffer's position.
 @return The position of this buffer
 */
- (jint)position;

/*!
 @brief Sets this buffer's position.If the mark is defined and larger than the
  new position then it is discarded.
 @param newPosition The new position value; must be non-negative
           and no larger than the current limit
 @return This buffer
 @throw IllegalArgumentException
 If the preconditions on <tt>newPosition</tt> do not hold
 */
- (JavaNioBuffer *)positionWithInt:(jint)newPosition;

/*!
 @brief Returns the number of elements between the current position and the
  limit.
 @return The number of elements remaining in this buffer
 */
- (jint)remaining;

/*!
 @brief Resets this buffer's position to the previously-marked position.
 <p> Invoking this method neither changes nor discards the mark's
  value. </p>
 @return This buffer
 @throw InvalidMarkException
 If the mark has not been set
 */
- (JavaNioBuffer *)reset;

/*!
 @brief Rewinds this buffer.The position is set to zero and the mark is
  discarded.
 <p> Invoke this method before a sequence of channel-write or <i>get</i>
  operations, assuming that the limit has already been set
  appropriately.  For example: 
 <blockquote>@code

  out.write(buf);    // Write remaining data
  buf.rewind();      // Rewind buffer
  buf.get(array);    // Copy data into array
@endcode</blockquote>
 @return This buffer
 */
- (JavaNioBuffer *)rewind;

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)mark
                              withInt:(jint)pos
                              withInt:(jint)lim
                              withInt:(jint)cap
                              withInt:(jint)elementSizeShift;

+ (void)checkBoundsWithInt:(jint)off
                   withInt:(jint)len
                   withInt:(jint)size;

/*!
 @brief Checks the given index against the limit, throwing an <code>IndexOutOfBoundsException</code>
  if it is not smaller than the limit
  or is smaller than zero.
 */
- (jint)checkIndexWithInt:(jint)i;

- (jint)checkIndexWithInt:(jint)i
                  withInt:(jint)nb;

- (void)discardMark;

- (jint)markValue;

/*!
 @brief Checks the current position against the limit, throwing a <code>BufferUnderflowException</code>
  if it is not smaller than the limit, and then
  increments the position.
 @return The current position value, before it is incremented
 */
- (jint)nextGetIndex;

- (jint)nextGetIndexWithInt:(jint)nb;

/*!
 @brief Checks the current position against the limit, throwing a <code>BufferOverflowException</code>
  if it is not smaller than the limit, and then
  increments the position.
 @return The current position value, before it is incremented
 */
- (jint)nextPutIndex;

- (jint)nextPutIndexWithInt:(jint)nb;

- (void)truncate;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioBuffer)

/*!
 @brief The characteristics of Spliterators that traverse and split elements
  maintained in Buffers.
 */
inline jint JavaNioBuffer_get_SPLITERATOR_CHARACTERISTICS(void);
#define JavaNioBuffer_SPLITERATOR_CHARACTERISTICS 16464
J2OBJC_STATIC_FIELD_CONSTANT(JavaNioBuffer, SPLITERATOR_CHARACTERISTICS, jint)

FOUNDATION_EXPORT void JavaNioBuffer_initWithInt_withInt_withInt_withInt_withInt_(JavaNioBuffer *self, jint mark, jint pos, jint lim, jint cap, jint elementSizeShift);

FOUNDATION_EXPORT void JavaNioBuffer_checkBoundsWithInt_withInt_withInt_(jint off, jint len, jint size);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioBuffer)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaNioBuffer")
