//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/time/temporal/TemporalQuery.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTimeTemporalTemporalQuery")
#ifdef RESTRICT_JavaTimeTemporalTemporalQuery
#define INCLUDE_ALL_JavaTimeTemporalTemporalQuery 0
#else
#define INCLUDE_ALL_JavaTimeTemporalTemporalQuery 1
#endif
#undef RESTRICT_JavaTimeTemporalTemporalQuery

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTimeTemporalTemporalQuery_) && (INCLUDE_ALL_JavaTimeTemporalTemporalQuery || defined(INCLUDE_JavaTimeTemporalTemporalQuery))
#define JavaTimeTemporalTemporalQuery_

@protocol JavaTimeTemporalTemporalAccessor;

/*!
 @brief Strategy for querying a temporal object.
 <p>
  Queries are a key tool for extracting information from temporal objects.
  They exist to externalize the process of querying, permitting different
  approaches, as per the strategy design pattern.
  Examples might be a query that checks if the date is the day before February 29th
  in a leap year, or calculates the number of days to your next birthday. 
 <p>
  The <code>TemporalField</code> interface provides another mechanism for querying
  temporal objects. That interface is limited to returning a <code>long</code>.
  By contrast, queries can return any type. 
 <p>
  There are two equivalent ways of using a <code>TemporalQuery</code>.
  The first is to invoke the method on this interface directly.
  The second is to use <code>TemporalAccessor.query(TemporalQuery)</code>:
  @code

    // these two lines are equivalent, but the second approach is recommended
    temporal = thisQuery.queryFrom(temporal);
    temporal = temporal.query(thisQuery); 
  
@endcode
  It is recommended to use the second approach, <code>query(TemporalQuery)</code>,
  as it is a lot clearer to read in code. 
 <p>
  The most common implementations are method references, such as 
 <code>LocalDate::from</code> and <code>ZoneId::from</code>.
  Additional common queries are provided as static methods in <code>TemporalQueries</code>.
 @since 1.8
 */
@protocol JavaTimeTemporalTemporalQuery < JavaObject >

/*!
 @brief Queries the specified temporal object.
 <p>
  This queries the specified temporal object to return an object using the logic
  encapsulated in the implementing class.
  Examples might be a query that checks if the date is the day before February 29th
  in a leap year, or calculates the number of days to your next birthday. 
 <p>
  There are two equivalent ways of using this method.
  The first is to invoke this method directly.
  The second is to use <code>TemporalAccessor.query(TemporalQuery)</code>:
  @code

    // these two lines are equivalent, but the second approach is recommended
    temporal = thisQuery.queryFrom(temporal);
    temporal = temporal.query(thisQuery); 
  
@endcode
  It is recommended to use the second approach, <code>query(TemporalQuery)</code>,
  as it is a lot clearer to read in code.
 @param temporal the temporal object to query, not null
 @return the queried value, may return null to indicate not found
 @throw DateTimeExceptionif unable to query
 @throw ArithmeticExceptionif numeric overflow occurs
 */
- (id)queryFromWithJavaTimeTemporalTemporalAccessor:(id<JavaTimeTemporalTemporalAccessor>)temporal;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeTemporalTemporalQuery)

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeTemporalTemporalQuery)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTimeTemporalTemporalQuery")
