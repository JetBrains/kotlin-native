//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/time/temporal/TemporalAccessor.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTimeTemporalTemporalAccessor")
#ifdef RESTRICT_JavaTimeTemporalTemporalAccessor
#define INCLUDE_ALL_JavaTimeTemporalTemporalAccessor 0
#else
#define INCLUDE_ALL_JavaTimeTemporalTemporalAccessor 1
#endif
#undef RESTRICT_JavaTimeTemporalTemporalAccessor

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTimeTemporalTemporalAccessor_) && (INCLUDE_ALL_JavaTimeTemporalTemporalAccessor || defined(INCLUDE_JavaTimeTemporalTemporalAccessor))
#define JavaTimeTemporalTemporalAccessor_

@class JavaTimeTemporalValueRange;
@protocol JavaTimeTemporalTemporalField;
@protocol JavaTimeTemporalTemporalQuery;

/*!
 @brief Framework-level interface defining read-only access to a temporal object,
  such as a date, time, offset or some combination of these.
 <p>
  This is the base interface type for date, time and offset objects.
  It is implemented by those classes that can provide information
  as fields or queries.
  <p>
  Most date and time information can be represented as a number.
  These are modeled using <code>TemporalField</code> with the number held using
  a <code>long</code> to handle large values. Year, month and day-of-month are
  simple examples of fields, but they also include instant and offsets.
  See <code>ChronoField</code> for the standard set of fields. 
 <p>
  Two pieces of date/time information cannot be represented by numbers,
  the chronology and the 
 time-zone.
  These can be accessed via queries using
  the static methods defined on <code>TemporalQuery</code>.
  <p>
  A sub-interface, <code>Temporal</code>, extends this definition to one that also
  supports adjustment and manipulation on more complete temporal objects. 
 <p>
  This interface is a framework-level interface that should not be widely
  used in application code. Instead, applications should create and pass
  around instances of concrete types, such as <code>LocalDate</code>.
  There are many reasons for this, part of which is that implementations
  of this interface may be in calendar systems other than ISO.
  See <code>java.time.chrono.ChronoLocalDate</code> for a fuller discussion of the issues.
 @since 1.8
 */
@protocol JavaTimeTemporalTemporalAccessor < JavaObject >

/*!
 @brief Checks if the specified field is supported.
 <p>
  This checks if the date-time can be queried for the specified field.
  If false, then calling the <code>range</code> and <code>get</code>
  methods will throw an exception.
 @param field the field to check, null returns false
 @return true if this date-time can be queried for the field, false if not
 */
- (jboolean)isSupportedWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Gets the range of valid values for the specified field.
 <p>
  All fields can be expressed as a <code>long</code> integer.
  This method returns an object that describes the valid range for that value.
  The value of this temporal object is used to enhance the accuracy of the returned range.
  If the date-time cannot return the range, because the field is unsupported or for
  some other reason, an exception will be thrown. 
 <p>
  Note that the result only describes the minimum and maximum valid values
  and it is important not to read too much into them. For example, there
  could be values within the range that are invalid for the field.
 @param field the field to query the range for, not null
 @return the range of valid values for the field, not null
 @throw DateTimeExceptionif the range for the field cannot be obtained
 @throw UnsupportedTemporalTypeExceptionif the field is not supported
 */
- (JavaTimeTemporalValueRange *)rangeWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Gets the value of the specified field as an <code>int</code>.
 <p>
  This queries the date-time for the value of the specified field.
  The returned value will always be within the valid range of values for the field.
  If the date-time cannot return the value, because the field is unsupported or for
  some other reason, an exception will be thrown.
 @param field the field to get, not null
 @return the value for the field, within the valid range of values
 @throw DateTimeExceptionif a value for the field cannot be obtained or
          the value is outside the range of valid values for the field
 @throw UnsupportedTemporalTypeExceptionif the field is not supported or
          the range of values exceeds an <code>int</code>
 @throw ArithmeticExceptionif numeric overflow occurs
 */
- (jint)getWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Gets the value of the specified field as a <code>long</code>.
 <p>
  This queries the date-time for the value of the specified field.
  The returned value may be outside the valid range of values for the field.
  If the date-time cannot return the value, because the field is unsupported or for
  some other reason, an exception will be thrown.
 @param field the field to get, not null
 @return the value for the field
 @throw DateTimeExceptionif a value for the field cannot be obtained
 @throw UnsupportedTemporalTypeExceptionif the field is not supported
 @throw ArithmeticExceptionif numeric overflow occurs
 */
- (jlong)getLongWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Queries this date-time.
 <p>
  This queries this date-time using the specified query strategy object. 
 <p>
  Queries are a key tool for extracting information from date-times.
  They exists to externalize the process of querying, permitting different
  approaches, as per the strategy design pattern.
  Examples might be a query that checks if the date is the day before February 29th
  in a leap year, or calculates the number of days to your next birthday. 
 <p>
  The most common query implementations are method references, such as 
 <code>LocalDate::from</code> and <code>ZoneId::from</code>.
  Additional implementations are provided as static methods on <code>TemporalQuery</code>.
 @param query the query to invoke, not null
 @return the query result, null may be returned (defined by the query)
 @throw DateTimeExceptionif unable to query
 @throw ArithmeticExceptionif numeric overflow occurs
 */
- (id)queryWithJavaTimeTemporalTemporalQuery:(id<JavaTimeTemporalTemporalQuery>)query;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeTemporalTemporalAccessor)

FOUNDATION_EXPORT JavaTimeTemporalValueRange *JavaTimeTemporalTemporalAccessor_rangeWithJavaTimeTemporalTemporalField_(id<JavaTimeTemporalTemporalAccessor> self, id<JavaTimeTemporalTemporalField> field);

FOUNDATION_EXPORT jint JavaTimeTemporalTemporalAccessor_getWithJavaTimeTemporalTemporalField_(id<JavaTimeTemporalTemporalAccessor> self, id<JavaTimeTemporalTemporalField> field);

FOUNDATION_EXPORT id JavaTimeTemporalTemporalAccessor_queryWithJavaTimeTemporalTemporalQuery_(id<JavaTimeTemporalTemporalAccessor> self, id<JavaTimeTemporalTemporalQuery> query);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeTemporalTemporalAccessor)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTimeTemporalTemporalAccessor")
