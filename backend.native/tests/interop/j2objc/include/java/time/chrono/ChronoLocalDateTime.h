//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/time/chrono/ChronoLocalDateTime.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTimeChronoChronoLocalDateTime")
#ifdef RESTRICT_JavaTimeChronoChronoLocalDateTime
#define INCLUDE_ALL_JavaTimeChronoChronoLocalDateTime 0
#else
#define INCLUDE_ALL_JavaTimeChronoChronoLocalDateTime 1
#endif
#undef RESTRICT_JavaTimeChronoChronoLocalDateTime

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTimeChronoChronoLocalDateTime_) && (INCLUDE_ALL_JavaTimeChronoChronoLocalDateTime || defined(INCLUDE_JavaTimeChronoChronoLocalDateTime))
#define JavaTimeChronoChronoLocalDateTime_

#define RESTRICT_JavaTimeTemporalTemporal 1
#define INCLUDE_JavaTimeTemporalTemporal 1
#include "java/time/temporal/Temporal.h"

#define RESTRICT_JavaTimeTemporalTemporalAdjuster 1
#define INCLUDE_JavaTimeTemporalTemporalAdjuster 1
#include "java/time/temporal/TemporalAdjuster.h"

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class JavaTimeFormatDateTimeFormatter;
@class JavaTimeInstant;
@class JavaTimeLocalTime;
@class JavaTimeZoneId;
@class JavaTimeZoneOffset;
@protocol JavaTimeChronoChronoLocalDate;
@protocol JavaTimeChronoChronoZonedDateTime;
@protocol JavaTimeChronoChronology;
@protocol JavaTimeTemporalTemporalAccessor;
@protocol JavaTimeTemporalTemporalAmount;
@protocol JavaTimeTemporalTemporalField;
@protocol JavaTimeTemporalTemporalQuery;
@protocol JavaTimeTemporalTemporalUnit;
@protocol JavaUtilComparator;

/*!
 @brief A date-time without a time-zone in an arbitrary chronology, intended
  for advanced globalization use cases.
 <p>
  <b>Most applications should declare method signatures, fields and variables
  as <code>LocalDateTime</code>, not this interface.</b>
  <p>
  A <code>ChronoLocalDateTime</code> is the abstract representation of a local date-time
  where the <code>Chronology chronology</code>, or calendar system, is pluggable.
  The date-time is defined in terms of fields expressed by <code>TemporalField</code>,
  where most common implementations are defined in <code>ChronoField</code>.
  The chronology defines how the calendar system operates and the meaning of
  the standard fields. 
 <h3>When to use this interface</h3>
  The design of the API encourages the use of <code>LocalDateTime</code> rather than this
  interface, even in the case where the application needs to deal with multiple
  calendar systems. The rationale for this is explored in detail in <code>ChronoLocalDate</code>.
  <p>
  Ensure that the discussion in <code>ChronoLocalDate</code> has been read and understood
  before using this interface.
 @since 1.8
 */
@protocol JavaTimeChronoChronoLocalDateTime < JavaTimeTemporalTemporal, JavaTimeTemporalTemporalAdjuster, JavaLangComparable, JavaObject >

/*!
 @brief Gets the chronology of this date-time.
 <p>
  The <code>Chronology</code> represents the calendar system in use.
  The era and other fields in <code>ChronoField</code> are defined by the chronology.
 @return the chronology, not null
 */
- (id<JavaTimeChronoChronology>)getChronology;

/*!
 @brief Gets the local date part of this date-time.
 <p>
  This returns a local date with the same year, month and day
  as this date-time.
 @return the date part of this date-time, not null
 */
- (id<JavaTimeChronoChronoLocalDate>)toLocalDate;

/*!
 @brief Gets the local time part of this date-time.
 <p>
  This returns a local time with the same hour, minute, second and
  nanosecond as this date-time.
 @return the time part of this date-time, not null
 */
- (JavaTimeLocalTime *)toLocalTime;

/*!
 @brief Checks if the specified field is supported.
 <p>
  This checks if the specified field can be queried on this date-time.
  If false, then calling the <code>range</code>,
  <code>get</code> and <code>with(TemporalField, long)</code>
  methods will throw an exception. 
 <p>
  The set of supported fields is defined by the chronology and normally includes
  all <code>ChronoField</code> date and time fields. 
 <p>
  If the field is not a <code>ChronoField</code>, then the result of this method
  is obtained by invoking <code>TemporalField.isSupportedBy(TemporalAccessor)</code>
  passing <code>this</code> as the argument.
  Whether the field is supported is determined by the field.
 @param field the field to check, null returns false
 @return true if the field can be queried, false if not
 */
- (jboolean)isSupportedWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Checks if the specified unit is supported.
 <p>
  This checks if the specified unit can be added to or subtracted from this date-time.
  If false, then calling the <code>plus(long, TemporalUnit)</code> and 
 <code>minus</code> methods will throw an exception. 
 <p>
  The set of supported units is defined by the chronology and normally includes
  all <code>ChronoUnit</code> units except <code>FOREVER</code>.
  <p>
  If the unit is not a <code>ChronoUnit</code>, then the result of this method
  is obtained by invoking <code>TemporalUnit.isSupportedBy(Temporal)</code>
  passing <code>this</code> as the argument.
  Whether the unit is supported is determined by the unit.
 @param unit the unit to check, null returns false
 @return true if the unit can be added/subtracted, false if not
 */
- (jboolean)isSupportedWithJavaTimeTemporalTemporalUnit:(id<JavaTimeTemporalTemporalUnit>)unit;

/*!
 @throw DateTimeException
 @throw ArithmeticException
 */
- (id<JavaTimeChronoChronoLocalDateTime>)withWithJavaTimeTemporalTemporalAdjuster:(id<JavaTimeTemporalTemporalAdjuster>)adjuster;

/*!
 @throw DateTimeException
 @throw ArithmeticException
 */
- (id<JavaTimeChronoChronoLocalDateTime>)withWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                      withLong:(jlong)newValue;

/*!
 @throw DateTimeException
 @throw ArithmeticException
 */
- (id<JavaTimeChronoChronoLocalDateTime>)plusWithJavaTimeTemporalTemporalAmount:(id<JavaTimeTemporalTemporalAmount>)amount;

/*!
 @throw DateTimeException
 @throw ArithmeticException
 */
- (id<JavaTimeChronoChronoLocalDateTime>)plusWithLong:(jlong)amountToAdd
                     withJavaTimeTemporalTemporalUnit:(id<JavaTimeTemporalTemporalUnit>)unit;

/*!
 @throw DateTimeException
 @throw ArithmeticException
 */
- (id<JavaTimeChronoChronoLocalDateTime>)minusWithJavaTimeTemporalTemporalAmount:(id<JavaTimeTemporalTemporalAmount>)amount;

/*!
 @throw DateTimeException
 @throw ArithmeticException
 */
- (id<JavaTimeChronoChronoLocalDateTime>)minusWithLong:(jlong)amountToSubtract
                      withJavaTimeTemporalTemporalUnit:(id<JavaTimeTemporalTemporalUnit>)unit;

/*!
 @brief Queries this date-time using the specified query.
 <p>
  This queries this date-time using the specified query strategy object.
  The <code>TemporalQuery</code> object defines the logic to be used to
  obtain the result. Read the documentation of the query to understand
  what the result of this method will be. 
 <p>
  The result of this method is obtained by invoking the 
 <code>TemporalQuery.queryFrom(TemporalAccessor)</code> method on the
  specified query passing <code>this</code> as the argument.
 @param query the query to invoke, not null
 @return the query result, null may be returned (defined by the query)
 @throw DateTimeExceptionif unable to query (defined by the query)
 @throw ArithmeticExceptionif numeric overflow occurs (defined by the query)
 */
- (id)queryWithJavaTimeTemporalTemporalQuery:(id<JavaTimeTemporalTemporalQuery>)query;

/*!
 @brief Adjusts the specified temporal object to have the same date and time as this object.
 <p>
  This returns a temporal object of the same observable type as the input
  with the date and time changed to be the same as this. 
 <p>
  The adjustment is equivalent to using <code>Temporal.with(TemporalField, long)</code>
  twice, passing <code>ChronoField.EPOCH_DAY</code> and 
 <code>ChronoField.NANO_OF_DAY</code> as the fields. 
 <p>
  In most cases, it is clearer to reverse the calling pattern by using 
 <code>Temporal.with(TemporalAdjuster)</code>:
  @code

    // these two lines are equivalent, but the second approach is recommended
    temporal = thisLocalDateTime.adjustInto(temporal);
    temporal = temporal.with(thisLocalDateTime); 
  
@endcode
  <p>
  This instance is immutable and unaffected by this method call.
 @param temporal the target object to be adjusted, not null
 @return the adjusted object, not null
 @throw DateTimeExceptionif unable to make the adjustment
 @throw ArithmeticExceptionif numeric overflow occurs
 */
- (id<JavaTimeTemporalTemporal>)adjustIntoWithJavaTimeTemporalTemporal:(id<JavaTimeTemporalTemporal>)temporal;

/*!
 @brief Formats this date-time using the specified formatter.
 <p>
  This date-time will be passed to the formatter to produce a string. 
 <p>
  The default implementation must behave as follows: 
 @code

   return formatter.format(this); 
  
@endcode
 @param formatter the formatter to use, not null
 @return the formatted date-time string, not null
 @throw DateTimeExceptionif an error occurs during printing
 */
- (NSString *)formatWithJavaTimeFormatDateTimeFormatter:(JavaTimeFormatDateTimeFormatter *)formatter;

/*!
 @brief Combines this time with a time-zone to create a <code>ChronoZonedDateTime</code>.
 <p>
  This returns a <code>ChronoZonedDateTime</code> formed from this date-time at the
  specified time-zone. The result will match this date-time as closely as possible.
  Time-zone rules, such as daylight savings, mean that not every local date-time
  is valid for the specified zone, thus the local date-time may be adjusted. 
 <p>
  The local date-time is resolved to a single instant on the time-line.
  This is achieved by finding a valid offset from UTC/Greenwich for the local
  date-time as defined by the <code>rules</code> of the zone ID.
 <p>
  In most cases, there is only one valid offset for a local date-time.
  In the case of an overlap, where clocks are set back, there are two valid offsets.
  This method uses the earlier offset typically corresponding to "summer". 
 <p>
  In the case of a gap, where clocks jump forward, there is no valid offset.
  Instead, the local date-time is adjusted to be later by the length of the gap.
  For a typical one hour daylight savings change, the local date-time will be
  moved one hour later into the offset typically corresponding to "summer". 
 <p>
  To obtain the later offset during an overlap, call 
 <code>ChronoZonedDateTime.withLaterOffsetAtOverlap()</code> on the result of this method.
 @param zone the time-zone to use, not null
 @return the zoned date-time formed from this date-time, not null
 */
- (id<JavaTimeChronoChronoZonedDateTime>)atZoneWithJavaTimeZoneId:(JavaTimeZoneId *)zone;

/*!
 @brief Converts this date-time to an <code>Instant</code>.
 <p>
  This combines this local date-time and the specified offset to form
  an <code>Instant</code>.
  <p>
  This default implementation calculates from the epoch-day of the date and the
  second-of-day of the time.
 @param offset the offset to use for the conversion, not null
 @return an <code>Instant</code> representing the same instant, not null
 */
- (JavaTimeInstant *)toInstantWithJavaTimeZoneOffset:(JavaTimeZoneOffset *)offset;

/*!
 @brief Converts this date-time to the number of seconds from the epoch
  of 1970-01-01T00:00:00Z.
 <p>
  This combines this local date-time and the specified offset to calculate the
  epoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.
  Instants on the time-line after the epoch are positive, earlier are negative. 
 <p>
  This default implementation calculates from the epoch-day of the date and the
  second-of-day of the time.
 @param offset the offset to use for the conversion, not null
 @return the number of seconds from the epoch of 1970-01-01T00:00:00Z
 */
- (jlong)toEpochSecondWithJavaTimeZoneOffset:(JavaTimeZoneOffset *)offset;

/*!
 @brief Compares this date-time to another date-time, including the chronology.
 <p>
  The comparison is based first on the underlying time-line date-time, then
  on the chronology.
  It is "consistent with equals", as defined by <code>Comparable</code>.
  <p>
  For example, the following is the comparator order: 
 <ol>
  <li><code>2012-12-03T12:00 (ISO)</code></li>
  <li><code>2012-12-04T12:00 (ISO)</code></li>
  <li><code>2555-12-04T12:00 (ThaiBuddhist)</code></li>
  <li><code>2012-12-05T12:00 (ISO)</code></li>
  </ol>
  Values #2 and #3 represent the same date-time on the time-line.
  When two values represent the same date-time, the chronology ID is compared to distinguish them.
  This step is needed to make the ordering "consistent with equals". 
 <p>
  If all the date-time objects being compared are in the same chronology, then the
  additional chronology stage is not required and only the local date-time is used. 
 <p>
  This default implementation performs the comparison defined above.
 @param other the other date-time to compare to, not null
 @return the comparator value, negative if less, positive if greater
 */
- (jint)compareToWithId:(id<JavaTimeChronoChronoLocalDateTime>)other;

/*!
 @brief Checks if this date-time is after the specified date-time ignoring the chronology.
 <p>
  This method differs from the comparison in <code>compareTo</code> in that it
  only compares the underlying date-time and not the chronology.
  This allows dates in different calendar systems to be compared based
  on the time-line position. 
 <p>
  This default implementation performs the comparison based on the epoch-day
  and nano-of-day.
 @param other the other date-time to compare to, not null
 @return true if this is after the specified date-time
 */
- (jboolean)isAfterWithJavaTimeChronoChronoLocalDateTime:(id<JavaTimeChronoChronoLocalDateTime>)other;

/*!
 @brief Checks if this date-time is before the specified date-time ignoring the chronology.
 <p>
  This method differs from the comparison in <code>compareTo</code> in that it
  only compares the underlying date-time and not the chronology.
  This allows dates in different calendar systems to be compared based
  on the time-line position. 
 <p>
  This default implementation performs the comparison based on the epoch-day
  and nano-of-day.
 @param other the other date-time to compare to, not null
 @return true if this is before the specified date-time
 */
- (jboolean)isBeforeWithJavaTimeChronoChronoLocalDateTime:(id<JavaTimeChronoChronoLocalDateTime>)other;

/*!
 @brief Checks if this date-time is equal to the specified date-time ignoring the chronology.
 <p>
  This method differs from the comparison in <code>compareTo</code> in that it
  only compares the underlying date and time and not the chronology.
  This allows date-times in different calendar systems to be compared based
  on the time-line position. 
 <p>
  This default implementation performs the comparison based on the epoch-day
  and nano-of-day.
 @param other the other date-time to compare to, not null
 @return true if the underlying date-time is equal to the specified date-time on the timeline
 */
- (jboolean)isEqualWithJavaTimeChronoChronoLocalDateTime:(id<JavaTimeChronoChronoLocalDateTime>)other;

/*!
 @brief Checks if this date-time is equal to another date-time, including the chronology.
 <p>
  Compares this date-time with another ensuring that the date-time and chronology are the same.
 @param obj the object to check, null returns false
 @return true if this is equal to the other date
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief A hash code for this date-time.
 @return a suitable hash code
 */
- (NSUInteger)hash;

/*!
 @brief Outputs this date-time as a <code>String</code>.
 <p>
  The output will include the full local date-time.
 @return a string representation of this date-time, not null
 */
- (NSString *)description;

@end

@interface JavaTimeChronoChronoLocalDateTime : NSObject

/*!
 @brief Gets a comparator that compares <code>ChronoLocalDateTime</code> in
  time-line order ignoring the chronology.
 <p>
  This comparator differs from the comparison in <code>compareTo</code> in that it
  only compares the underlying date-time and not the chronology.
  This allows dates in different calendar systems to be compared based
  on the position of the date-time on the local time-line.
  The underlying comparison is equivalent to comparing the epoch-day and nano-of-day.
 @return a comparator that compares in time-line order ignoring the chronology
 - seealso: #isAfter
 - seealso: #isBefore
 - seealso: #isEqual
 */
+ (id<JavaUtilComparator>)timeLineOrder;

/*!
 @brief Obtains an instance of <code>ChronoLocalDateTime</code> from a temporal object.
 <p>
  This obtains a local date-time based on the specified temporal.
  A <code>TemporalAccessor</code> represents an arbitrary set of date and time information,
  which this factory converts to an instance of <code>ChronoLocalDateTime</code>.
  <p>
  The conversion extracts and combines the chronology and the date-time
  from the temporal object. The behavior is equivalent to using 
 <code>Chronology.localDateTime(TemporalAccessor)</code> with the extracted chronology.
  Implementations are permitted to perform optimizations such as accessing
  those fields that are equivalent to the relevant objects. 
 <p>
  This method matches the signature of the functional interface <code>TemporalQuery</code>
  allowing it to be used as a query via method reference, <code>ChronoLocalDateTime::from</code>.
 @param temporal the temporal object to convert, not null
 @return the date-time, not null
 @throw DateTimeExceptionif unable to convert to a <code>ChronoLocalDateTime</code>
 - seealso: Chronology#localDateTime(TemporalAccessor)
 */
+ (id<JavaTimeChronoChronoLocalDateTime>)fromWithJavaTimeTemporalTemporalAccessor:(id<JavaTimeTemporalTemporalAccessor>)temporal;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeChronoChronoLocalDateTime)

FOUNDATION_EXPORT id<JavaUtilComparator> JavaTimeChronoChronoLocalDateTime_timeLineOrder(void);

FOUNDATION_EXPORT id<JavaTimeChronoChronoLocalDateTime> JavaTimeChronoChronoLocalDateTime_fromWithJavaTimeTemporalTemporalAccessor_(id<JavaTimeTemporalTemporalAccessor> temporal);

FOUNDATION_EXPORT id<JavaTimeChronoChronology> JavaTimeChronoChronoLocalDateTime_getChronology(id<JavaTimeChronoChronoLocalDateTime> self);

FOUNDATION_EXPORT jboolean JavaTimeChronoChronoLocalDateTime_isSupportedWithJavaTimeTemporalTemporalUnit_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeTemporalTemporalUnit> unit);

FOUNDATION_EXPORT id<JavaTimeChronoChronoLocalDateTime> JavaTimeChronoChronoLocalDateTime_withWithJavaTimeTemporalTemporalAdjuster_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeTemporalTemporalAdjuster> adjuster);

FOUNDATION_EXPORT id<JavaTimeChronoChronoLocalDateTime> JavaTimeChronoChronoLocalDateTime_plusWithJavaTimeTemporalTemporalAmount_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeTemporalTemporalAmount> amount);

FOUNDATION_EXPORT id<JavaTimeChronoChronoLocalDateTime> JavaTimeChronoChronoLocalDateTime_minusWithJavaTimeTemporalTemporalAmount_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeTemporalTemporalAmount> amount);

FOUNDATION_EXPORT id<JavaTimeChronoChronoLocalDateTime> JavaTimeChronoChronoLocalDateTime_minusWithLong_withJavaTimeTemporalTemporalUnit_(id<JavaTimeChronoChronoLocalDateTime> self, jlong amountToSubtract, id<JavaTimeTemporalTemporalUnit> unit);

FOUNDATION_EXPORT id JavaTimeChronoChronoLocalDateTime_queryWithJavaTimeTemporalTemporalQuery_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeTemporalTemporalQuery> query);

FOUNDATION_EXPORT id<JavaTimeTemporalTemporal> JavaTimeChronoChronoLocalDateTime_adjustIntoWithJavaTimeTemporalTemporal_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeTemporalTemporal> temporal);

FOUNDATION_EXPORT NSString *JavaTimeChronoChronoLocalDateTime_formatWithJavaTimeFormatDateTimeFormatter_(id<JavaTimeChronoChronoLocalDateTime> self, JavaTimeFormatDateTimeFormatter *formatter);

FOUNDATION_EXPORT JavaTimeInstant *JavaTimeChronoChronoLocalDateTime_toInstantWithJavaTimeZoneOffset_(id<JavaTimeChronoChronoLocalDateTime> self, JavaTimeZoneOffset *offset);

FOUNDATION_EXPORT jlong JavaTimeChronoChronoLocalDateTime_toEpochSecondWithJavaTimeZoneOffset_(id<JavaTimeChronoChronoLocalDateTime> self, JavaTimeZoneOffset *offset);

FOUNDATION_EXPORT jint JavaTimeChronoChronoLocalDateTime_compareToWithJavaTimeChronoChronoLocalDateTime_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeChronoChronoLocalDateTime> other);

FOUNDATION_EXPORT jboolean JavaTimeChronoChronoLocalDateTime_isAfterWithJavaTimeChronoChronoLocalDateTime_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeChronoChronoLocalDateTime> other);

FOUNDATION_EXPORT jboolean JavaTimeChronoChronoLocalDateTime_isBeforeWithJavaTimeChronoChronoLocalDateTime_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeChronoChronoLocalDateTime> other);

FOUNDATION_EXPORT jboolean JavaTimeChronoChronoLocalDateTime_isEqualWithJavaTimeChronoChronoLocalDateTime_(id<JavaTimeChronoChronoLocalDateTime> self, id<JavaTimeChronoChronoLocalDateTime> other);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeChronoChronoLocalDateTime)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTimeChronoChronoLocalDateTime")
