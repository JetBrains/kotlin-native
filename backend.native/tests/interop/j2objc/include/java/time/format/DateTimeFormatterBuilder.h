//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/time/format/DateTimeFormatterBuilder.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder")
#ifdef RESTRICT_JavaTimeFormatDateTimeFormatterBuilder
#define INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder 0
#else
#define INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder 1
#endif
#undef RESTRICT_JavaTimeFormatDateTimeFormatterBuilder
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_SettingsParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif
#ifdef INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser
#define INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder))
#define JavaTimeFormatDateTimeFormatterBuilder_

@class JavaTimeFormatDateTimeFormatter;
@class JavaTimeFormatFormatStyle;
@class JavaTimeFormatResolverStyle;
@class JavaTimeFormatSignStyle;
@class JavaTimeFormatTextStyle;
@class JavaUtilLocale;
@protocol JavaTimeChronoChronoLocalDate;
@protocol JavaTimeChronoChronology;
@protocol JavaTimeTemporalTemporalField;
@protocol JavaUtilComparator;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/*!
 @brief Builder to create date-time formatters.
 <p>
  This allows a <code>DateTimeFormatter</code> to be created.
  All date-time formatters are created ultimately using this builder. 
 <p>
  The basic elements of date-time can all be added: 
 <ul>
  <li>Value - a numeric value</li>
  <li>Fraction - a fractional value including the decimal place. Always use this when
  outputting fractions to ensure that the fraction is parsed correctly</li>
  <li>Text - the textual equivalent for the value</li>
  <li>OffsetId/Offset - the zone offset</li>
  <li>ZoneId - the time-zone id</li>
  <li>ZoneText - the name of the time-zone</li>
  <li>ChronologyId - the chronology id</li>
  <li>ChronologyText - the name of the chronology</li>
  <li>Literal - a text literal</li>
  <li>Nested and Optional - formats can be nested or made optional</li>
  </ul>
  In addition, any of the elements may be decorated by padding, either with spaces or any other character. 
 <p>
  Finally, a shorthand pattern, mostly compatible with <code>java.text.SimpleDateFormat SimpleDateFormat</code>
  can be used, see <code>appendPattern(String)</code>.
  In practice, this simply parses the pattern and calls other methods on the builder.
 @since 1.8
 */
@interface JavaTimeFormatDateTimeFormatterBuilder : NSObject
@property (readonly, class, strong) id<JavaUtilComparator> LENGTH_SORT NS_SWIFT_NAME(LENGTH_SORT);

+ (id<JavaUtilComparator>)LENGTH_SORT;

#pragma mark Public

/*!
 @brief Constructs a new instance of the builder.
 */
- (instancetype __nonnull)init;

/*!
 @brief Appends all the elements of a formatter to the builder.
 <p>
  This method has the same effect as appending each of the constituent
  parts of the formatter directly to this builder.
 @param formatter the formatter to add, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendWithJavaTimeFormatDateTimeFormatter:(JavaTimeFormatDateTimeFormatter *)formatter;

/*!
 @brief Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.
 <p>
  This appends an instruction to format/parse the chronology ID to the builder. 
 <p>
  During formatting, the chronology is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.chronology()</code>.
  It will be printed using the result of <code>Chronology.getId()</code>.
  If the chronology cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, the chronology is parsed and must match one of the chronologies
  in <code>Chronology.getAvailableChronologies()</code>.
  If the chronology cannot be parsed then an exception is thrown unless the
  section of the formatter is optional.
  The parser uses the case sensitive setting.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendChronologyId;

/*!
 @brief Appends the chronology name to the formatter.
 <p>
  The calendar system name will be output during a format.
  If the chronology cannot be obtained then an exception will be thrown.
 @param textStyle the text style to use, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendChronologyTextWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle;

/*!
 @brief Appends the fractional value of a date-time field to the formatter.
 <p>
  The fractional value of the field will be output including the
  preceding decimal point. The preceding value is not output.
  For example, the second-of-minute value of 15 would be output as <code>.25</code>.
  <p>
  The width of the printed fraction can be controlled. Setting the
  minimum width to zero will cause no output to be generated.
  The printed fraction will have the minimum width necessary between
  the minimum and maximum widths - trailing zeroes are omitted.
  No rounding occurs due to the maximum width - digits are simply dropped. 
 <p>
  When parsing in strict mode, the number of parsed digits must be between
  the minimum and maximum width. When parsing in lenient mode, the minimum
  width is considered to be zero and the maximum is nine. 
 <p>
  If the value cannot be obtained then an exception will be thrown.
  If the value is negative an exception will be thrown.
  If the field does not have a fixed set of valid values then an
  exception will be thrown.
  If the field value in the date-time to be printed is invalid it
  cannot be printed and an exception will be thrown.
 @param field the field to append, not null
 @param minWidth the minimum width of the field excluding the decimal point, from 0 to 9
 @param maxWidth the maximum width of the field excluding the decimal point, from 1 to 9
 @param decimalPoint whether to output the localized decimal point symbol
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif the field has a variable set of valid values or
   either width is invalid
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendFractionWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                                    withInt:(jint)minWidth
                                                                                    withInt:(jint)maxWidth
                                                                                withBoolean:(jboolean)decimalPoint;

/*!
 @brief Appends an instant using ISO-8601 to the formatter, formatting fractional
  digits in groups of three.
 <p>
  Instants have a fixed output format.
  They are converted to a date-time with a zone-offset of UTC and formatted
  using the standard ISO-8601 format.
  With this method, formatting nano-of-second outputs zero, three, six
  or nine digits digits as necessary.
  The localized decimal style is not used. 
 <p>
  The instant is obtained using <code>INSTANT_SECONDS</code>
  and optionally (@@code NANO_OF_SECOND). The value of <code>INSTANT_SECONDS</code>
  may be outside the maximum range of <code>LocalDateTime</code>.
  <p>
  The resolver style has no effect on instant parsing.
  The end-of-day time of '24:00' is handled as midnight at the start of the following day.
  The leap-second time of '23:59:59' is handled to some degree, see 
 <code>DateTimeFormatter.parsedLeapSecond()</code> for full details. 
 <p>
  An alternative to this method is to format/parse the instant as a single
  epoch-seconds value. That is achieved using <code>appendValue(INSTANT_SECONDS)</code>.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendInstant;

/*!
 @brief Appends an instant using ISO-8601 to the formatter with control over
  the number of fractional digits.
 <p>
  Instants have a fixed output format, although this method provides some
  control over the fractional digits. They are converted to a date-time
  with a zone-offset of UTC and printed using the standard ISO-8601 format.
  The localized decimal style is not used. 
 <p>
  The <code>fractionalDigits</code> parameter allows the output of the fractional
  second to be controlled. Specifying zero will cause no fractional digits
  to be output. From 1 to 9 will output an increasing number of digits, using
  zero right-padding if necessary. The special value -1 is used to output as
  many digits as necessary to avoid any trailing zeroes. 
 <p>
  When parsing in strict mode, the number of parsed digits must match the
  fractional digits. When parsing in lenient mode, any number of fractional
  digits from zero to nine are accepted. 
 <p>
  The instant is obtained using <code>INSTANT_SECONDS</code>
  and optionally (@@code NANO_OF_SECOND). The value of <code>INSTANT_SECONDS</code>
  may be outside the maximum range of <code>LocalDateTime</code>.
  <p>
  The resolver style has no effect on instant parsing.
  The end-of-day time of '24:00' is handled as midnight at the start of the following day.
  The leap-second time of '23:59:60' is handled to some degree, see 
 <code>DateTimeFormatter.parsedLeapSecond()</code> for full details. 
 <p>
  An alternative to this method is to format/parse the instant as a single
  epoch-seconds value. That is achieved using <code>appendValue(INSTANT_SECONDS)</code>.
 @param fractionalDigits the number of fractional second digits to format with,   from 0 to 9, or -1 to use as many digits as necessary
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendInstantWithInt:(jint)fractionalDigits;

/*!
 @brief Appends a character literal to the formatter.
 <p>
  This character will be output during a format.
 @param literal the literal to append, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendLiteralWithChar:(jchar)literal;

/*!
 @brief Appends a string literal to the formatter.
 <p>
  This string will be output during a format. 
 <p>
  If the literal is empty, nothing is added to the formatter.
 @param literal the literal to append, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendLiteralWithNSString:(NSString *)literal;

/*!
 @brief Appends a localized date-time pattern to the formatter.
 <p>
  This appends a localized section to the builder, suitable for outputting
  a date, time or date-time combination. The format of the localized
  section is lazily looked up based on four items: 
 <ul>
  <li>the <code>dateStyle</code> specified to this method 
 <li>the <code>timeStyle</code> specified to this method 
 <li>the <code>Locale</code> of the <code>DateTimeFormatter</code>
  <li>the <code>Chronology</code>, selecting the best available 
 </ul>
  During formatting, the chronology is obtained from the temporal object
  being formatted, which may have been overridden by 
 <code>DateTimeFormatter.withChronology(Chronology)</code>.
  <p>
  During parsing, if a chronology has already been parsed, then it is used.
  Otherwise the default from <code>DateTimeFormatter.withChronology(Chronology)</code>
  is used, with <code>IsoChronology</code> as the fallback. 
 <p>
  Note that this method provides similar functionality to methods on 
 <code>DateFormat</code> such as <code>java.text.DateFormat.getDateTimeInstance(int, int)</code>.
 @param dateStyle the date style to use, null means no date required
 @param timeStyle the time style to use, null means no time required
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif both the date and time styles are null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendLocalizedWithJavaTimeFormatFormatStyle:(JavaTimeFormatFormatStyle *)dateStyle
                                                           withJavaTimeFormatFormatStyle:(JavaTimeFormatFormatStyle *)timeStyle;

/*!
 @brief Appends the localized zone offset, such as 'GMT+01:00', to the formatter.
 <p>
  This appends a localized zone offset to the builder, the format of the
  localized offset is controlled by the specified <code>style</code>
  to this method: 
 <ul>
  <li><code>full</code> - formats with localized offset text, such
  as 'GMT, 2-digit hour and minute field, optional second field if non-zero,
  and colon. 
 <li><code>short</code> - formats with localized offset text,
  such as 'GMT, hour without leading zero, optional 2-digit minute and
  second if non-zero, and colon. 
 </ul>
  <p>
  During formatting, the offset is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.offset()</code>.
  If the offset cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, the offset is parsed using the format defined above.
  If the offset cannot be parsed then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
 @param style the format style to use, not null
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif style is neither <code>full</code>
  nor <code>short</code>
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendLocalizedOffsetWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)style;

/*!
 @brief Appends the zone offset, such as '+01:00', to the formatter.
 <p>
  This appends an instruction to format/parse the offset ID to the builder. 
 <p>
  During formatting, the offset is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.offset()</code>.
  It will be printed using the format defined below.
  If the offset cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, the offset is parsed using the format defined below.
  If the offset cannot be parsed then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  The format of the offset is controlled by a pattern which must be one
  of the following: 
 <ul>
  <li><code>+HH</code> - hour only, ignoring minute and second 
 <li><code>+HHmm</code> - hour, with minute if non-zero, ignoring second, no colon 
 <li><code>+HH:mm</code> - hour, with minute if non-zero, ignoring second, with colon 
 <li><code>+HHMM</code> - hour and minute, ignoring second, no colon 
 <li><code>+HH:MM</code> - hour and minute, ignoring second, with colon 
 <li><code>+HHMMss</code> - hour and minute, with second if non-zero, no colon 
 <li><code>+HH:MM:ss</code> - hour and minute, with second if non-zero, with colon 
 <li><code>+HHMMSS</code> - hour, minute and second, no colon 
 <li><code>+HH:MM:SS</code> - hour, minute and second, with colon 
 </ul>
  The "no offset" text controls what text is printed when the total amount of
  the offset fields to be output is zero.
  Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.
  Three formats are accepted for parsing UTC - the "no offset" text, and the
  plus and minus versions of zero defined by the pattern.
 @param pattern the pattern to use, not null
 @param noOffsetText the text to use when the offset is zero, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendOffsetWithNSString:(NSString *)pattern
                                                        withNSString:(NSString *)noOffsetText;

/*!
 @brief Appends the zone offset, such as '+01:00', to the formatter.
 <p>
  This appends an instruction to format/parse the offset ID to the builder.
  This is equivalent to calling <code>appendOffset("+HH:MM:ss", "Z")</code>.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendOffsetId;

/*!
 @brief Appends a formatter to the builder which will optionally format/parse.
 <p>
  This method has the same effect as appending each of the constituent
  parts directly to this builder surrounded by an <code>optionalStart()</code> and 
 <code>optionalEnd()</code>.
  <p>
  The formatter will format if data is available for all the fields contained within it.
  The formatter will parse if the string matches, otherwise no error is returned.
 @param formatter the formatter to add, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendOptionalWithJavaTimeFormatDateTimeFormatter:(JavaTimeFormatDateTimeFormatter *)formatter;

/*!
 @brief Appends the elements defined by the specified pattern to the builder.
 <p>
  All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.
  The characters '#', '{' and '}' are reserved for future use.
  The characters '[' and ']' indicate optional patterns.
  The following pattern letters are defined: 
 @code

   Symbol  Meaning                     Presentation      Examples
   ------  -------                     ------------      -------
    G       era                         text              AD; Anno Domini; A
    u       year                        year              2004; 04
    y       year-of-era                 year              2004; 04
    D       day-of-year                 number            189
    M/L     month-of-year               number/text       7; 07; Jul; July; J
    d       day-of-month                number            10
    Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
    Y       week-based-year             year              1996; 96
    w       week-of-week-based-year     number            27
    W       week-of-month               number            4
    E       day-of-week                 text              Tue; Tuesday; T
    e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
    F       week-of-month               number            3
    a       am-pm-of-day                text              PM
    h       clock-hour-of-am-pm (1-12)  number            12
    K       hour-of-am-pm (0-11)        number            0
    k       clock-hour-of-am-pm (1-24)  number            0
    H       hour-of-day (0-23)          number            0
    m       minute-of-hour              number            30
    s       second-of-minute            number            55
    S       fraction-of-second          fraction          978
    A       milli-of-day                number            1234
    n       nano-of-second              number            987654321
    N       nano-of-day                 number            1234000000
    V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
    z       time-zone name              zone-name         Pacific Standard Time; PST
    O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
    X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
    x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
    Z       zone-offset                 offset-Z          +0000; -0800; -08:00;
    p       pad next                    pad modifier      1
    '       escape for text             delimiter
    ''      single quote                literal           '
    [       optional section start
    ]       optional section end
    #       reserved for future use
    {       reserved for future use
    }       reserved for future use 
  
@endcode
  <p>
  The count of pattern letters determine the format.
  See <a href="DateTimeFormatter.html#patterns">DateTimeFormatter</a> for a user-focused description of the patterns.
  The following tables define how the pattern letters map to the builder. 
 <p>
  <b>Date fields</b>: Pattern letters to output a date. 
 @code

   Pattern  Count  Equivalent builder methods
   -------  -----  --------------------------
     G       1      appendText(ChronoField.ERA, TextStyle.SHORT)
     GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)
     GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)
     GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)
     GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)
     u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL);
     uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000);
     uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL);
     u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD);
     y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL);
     yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000);
     yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL);
     y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD);
     Y       1      append special localized WeekFields element for numeric week-based-year
     YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits;
     YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL);
     Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD);
     Q       1      appendValue(IsoFields.QUARTER_OF_YEAR);
     QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);
     QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)
     QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)
     QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)
     q       1      appendValue(IsoFields.QUARTER_OF_YEAR);
     qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);
     qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)
     qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)
     qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)
     M       1      appendValue(ChronoField.MONTH_OF_YEAR);
     MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);
     MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)
     MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)
     MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)
     L       1      appendValue(ChronoField.MONTH_OF_YEAR);
     LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);
     LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)
     LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)
     LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)
     w       1      append special localized WeekFields element for numeric week-of-year
     ww      2      append special localized WeekFields element for numeric week-of-year, zero-padded
     W       1      append special localized WeekFields element for numeric week-of-month
     d       1      appendValue(ChronoField.DAY_OF_MONTH)
     dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)
     D       1      appendValue(ChronoField.DAY_OF_YEAR)
     DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2)
     DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)
     F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)
     E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
     EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
     e       1      append special localized WeekFields element for numeric day-of-week
     ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded
     eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
     eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
     c       1      append special localized WeekFields element for numeric day-of-week
     ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)
     cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)
     ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE) 
  
@endcode
  <p>
  <b>Time fields</b>: Pattern letters to output a time. 
 @code

   Pattern  Count  Equivalent builder methods
   -------  -----  --------------------------
     a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)
     h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)
     hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)
     H       1      appendValue(ChronoField.HOUR_OF_DAY)
     HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)
     k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)
     kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)
     K       1      appendValue(ChronoField.HOUR_OF_AMPM)
     KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)
     m       1      appendValue(ChronoField.MINUTE_OF_HOUR)
     mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)
     s       1      appendValue(ChronoField.SECOND_OF_MINUTE)
     ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)
     S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)
     A       1      appendValue(ChronoField.MILLI_OF_DAY)
     A..A    2..n   appendValue(ChronoField.MILLI_OF_DAY, n)
     n       1      appendValue(ChronoField.NANO_OF_SECOND)
     n..n    2..n   appendValue(ChronoField.NANO_OF_SECOND, n)
     N       1      appendValue(ChronoField.NANO_OF_DAY)
     N..N    2..n   appendValue(ChronoField.NANO_OF_DAY, n) 
  
@endcode
  <p>
  <b>Zone ID</b>: Pattern letters to output <code>ZoneId</code>.
  @code

   Pattern  Count  Equivalent builder methods
   -------  -----  --------------------------
     VV      2      appendZoneId()
     z       1      appendZoneText(TextStyle.SHORT)
     zz      2      appendZoneText(TextStyle.SHORT)
     zzz     3      appendZoneText(TextStyle.SHORT)
     zzzz    4      appendZoneText(TextStyle.FULL) 
  
@endcode
  <p>
  <b>Zone offset</b>: Pattern letters to output <code>ZoneOffset</code>.
  @code

   Pattern  Count  Equivalent builder methods
   -------  -----  --------------------------
     O       1      appendLocalizedOffsetPrefixed(TextStyle.SHORT);
     OOOO    4      appendLocalizedOffsetPrefixed(TextStyle.FULL);
     X       1      appendOffset("+HHmm","Z")
     XX      2      appendOffset("+HHMM","Z")
     XXX     3      appendOffset("+HH:MM","Z")
     XXXX    4      appendOffset("+HHMMss","Z")
     XXXXX   5      appendOffset("+HH:MM:ss","Z")
     x       1      appendOffset("+HHmm","+00")
     xx      2      appendOffset("+HHMM","+0000")
     xxx     3      appendOffset("+HH:MM","+00:00")
     xxxx    4      appendOffset("+HHMMss","+0000")
     xxxxx   5      appendOffset("+HH:MM:ss","+00:00")
     Z       1      appendOffset("+HHMM","+0000")
     ZZ      2      appendOffset("+HHMM","+0000")
     ZZZ     3      appendOffset("+HHMM","+0000")
     ZZZZ    4      appendLocalizedOffset(TextStyle.FULL);
     ZZZZZ   5      appendOffset("+HH:MM:ss","Z") 
  
@endcode
  <p>
  <b>Modifiers</b>: Pattern letters that modify the rest of the pattern: 
 @code

   Pattern  Count  Equivalent builder methods
   -------  -----  --------------------------
     [       1      optionalStart()
     ]       1      optionalEnd()
     p..p    1..n   padNext(n) 
  
@endcode
  <p>
  Any sequence of letters not specified above, unrecognized letter or
  reserved character will throw an exception.
  Future versions may add to the set of patterns.
  It is recommended to use single quotes around all characters that you want
  to output directly to ensure that future changes do not break your application. 
 <p>
  Note that the pattern string is similar, but not identical, to 
 <code>SimpleDateFormat</code>.
  The pattern string is also similar, but not identical, to that defined by the
  Unicode Common Locale Data Repository (CLDR/LDML).
  Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML.
  By contrast, <code>SimpleDateFormat</code> uses 'u' for the numeric day of week.
  Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently.
  Pattern letters 'n', 'A', 'N', and 'p' are added.
  Number types will reject large numbers.
 @param pattern the pattern to add, not null
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif the pattern is invalid
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendPatternWithNSString:(NSString *)pattern;

/*!
 @brief Appends the text of a date-time field to the formatter using the full
  text style.
 <p>
  The text of the field will be output during a format.
  The value must be within the valid range of the field.
  If the value cannot be obtained then an exception will be thrown.
  If the field has no textual representation, then the numeric value will be used. 
 <p>
  The value will be printed as per the normal format of an integer value.
  Only negative numbers will be signed. No padding will be added.
 @param field the field to append, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendTextWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Appends the text of a date-time field to the formatter using the specified
  map to supply the text.
 <p>
  The standard text outputting methods use the localized text in the JDK.
  This method allows that text to be specified directly.
  The supplied map is not validated by the builder to ensure that formatting or
  parsing is possible, thus an invalid map may throw an error during later use. 
 <p>
  Supplying the map of text provides considerable flexibility in formatting and parsing.
  For example, a legacy application might require or supply the months of the
  year as "JNY", "FBY", "MCH" etc. These do not match the standard set of text
  for localized month names. Using this method, a map can be created which
  defines the connection between each value and the text: 
 @code

  Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();
  map.put(1L, "JNY");
  map.put(2L, "FBY");
  map.put(3L, "MCH");
  ...
  builder.appendText(MONTH_OF_YEAR, map); 
  
@endcode
  <p>
  Other uses might be to output the value with a suffix, such as "1st", "2nd", "3rd",
  or as Roman numerals "I", "II", "III", "IV". 
 <p>
  During formatting, the value is obtained and checked that it is in the valid range.
  If text is not available for the value then it is output as a number.
  During parsing, the parser will match against the map of text and numeric values.
 @param field the field to append, not null
 @param textLookup the map from the value to the text
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendTextWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                        withJavaUtilMap:(id<JavaUtilMap>)textLookup;

/*!
 @brief Appends the text of a date-time field to the formatter.
 <p>
  The text of the field will be output during a format.
  The value must be within the valid range of the field.
  If the value cannot be obtained then an exception will be thrown.
  If the field has no textual representation, then the numeric value will be used. 
 <p>
  The value will be printed as per the normal format of an integer value.
  Only negative numbers will be signed. No padding will be added.
 @param field the field to append, not null
 @param textStyle the text style to use, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendTextWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                            withJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle;

/*!
 @brief Appends the value of a date-time field to the formatter using a normal
  output style.
 <p>
  The value of the field will be output during a format.
  If the value cannot be obtained then an exception will be thrown. 
 <p>
  The value will be printed as per the normal format of an integer value.
  Only negative numbers will be signed. No padding will be added. 
 <p>
  The parser for a variable width value such as this normally behaves greedily,
  requiring one digit, but accepting as many digits as possible.
  This behavior can be affected by 'adjacent value parsing'.
  See <code>appendValue(java.time.temporal.TemporalField, int)</code> for full details.
 @param field the field to append, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendValueWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field;

/*!
 @brief Appends the value of a date-time field to the formatter using a fixed
  width, zero-padded approach.
 <p>
  The value of the field will be output during a format.
  If the value cannot be obtained then an exception will be thrown. 
 <p>
  The value will be zero-padded on the left. If the size of the value
  means that it cannot be printed within the width then an exception is thrown.
  If the value of the field is negative then an exception is thrown during formatting. 
 <p>
  This method supports a special technique of parsing known as 'adjacent value parsing'.
  This technique solves the problem where a value, variable or fixed width, is followed by one or more
  fixed length values. The standard parser is greedy, and thus it would normally
  steal the digits that are needed by the fixed width value parsers that follow the
  variable width one. 
 <p>
  No action is required to initiate 'adjacent value parsing'.
  When a call to <code>appendValue</code> is made, the builder
  enters adjacent value parsing setup mode. If the immediately subsequent method
  call or calls on the same builder are for a fixed width value, then the parser will reserve
  space so that the fixed width values can be parsed. 
 <p>
  For example, consider <code>builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);</code>
  The year is a variable width parse of between 1 and 19 digits.
  The month is a fixed width parse of 2 digits.
  Because these were appended to the same builder immediately after one another,
  the year parser will reserve two digits for the month to parse.
  Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.
  Without adjacent value parsing, the year would greedily parse all six digits and leave
  nothing for the month. 
 <p>
  Adjacent value parsing applies to each set of fixed width not-negative values in the parser
  that immediately follow any kind of value, variable or fixed width.
  Calling any other append method will end the setup of adjacent value parsing.
  Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
  simply add the <code>appendValue</code> to another <code>DateTimeFormatterBuilder</code>
  and add that to this builder. 
 <p>
  If adjacent parsing is active, then parsing must match exactly the specified
  number of digits in both strict and lenient modes.
  In addition, no positive or negative sign is permitted.
 @param field the field to append, not null
 @param width the width of the printed field, from 1 to 19
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif the width is invalid
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendValueWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                                 withInt:(jint)width;

/*!
 @brief Appends the value of a date-time field to the formatter providing full
  control over formatting.
 <p>
  The value of the field will be output during a format.
  If the value cannot be obtained then an exception will be thrown. 
 <p>
  This method provides full control of the numeric formatting, including
  zero-padding and the positive/negative sign. 
 <p>
  The parser for a variable width value such as this normally behaves greedily,
  accepting as many digits as possible.
  This behavior can be affected by 'adjacent value parsing'.
  See <code>appendValue(java.time.temporal.TemporalField, int)</code> for full details. 
 <p>
  In strict parsing mode, the minimum number of parsed digits is <code>minWidth</code>
  and the maximum is <code>maxWidth</code>.
  In lenient parsing mode, the minimum number of parsed digits is one
  and the maximum is 19 (except as limited by adjacent value parsing). 
 <p>
  If this method is invoked with equal minimum and maximum widths and a sign style of 
 <code>NOT_NEGATIVE</code> then it delegates to <code>appendValue(TemporalField,int)</code>.
  In this scenario, the formatting and parsing behavior described there occur.
 @param field the field to append, not null
 @param minWidth the minimum field width of the printed field, from 1 to 19
 @param maxWidth the maximum field width of the printed field, from 1 to 19
 @param signStyle the positive/negative output style, not null
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif the widths are invalid
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendValueWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                                 withInt:(jint)minWidth
                                                                                 withInt:(jint)maxWidth
                                                             withJavaTimeFormatSignStyle:(JavaTimeFormatSignStyle *)signStyle;

/*!
 @brief Appends the reduced value of a date-time field to the formatter.
 <p>
  This is typically used for formatting and parsing a two digit year. 
 <p>
  The base date is used to calculate the full value during parsing.
  For example, if the base date is 1950-01-01 then parsed values for
  a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
  Only the year would be extracted from the date, thus a base date of
  1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
  This behavior is necessary to support fields such as week-based-year
  or other calendar systems where the parsed value does not align with
  standard ISO years. 
 <p>
  The exact behavior is as follows. Parse the full set of fields and
  determine the effective chronology using the last chronology if
  it appears more than once. Then convert the base date to the
  effective chronology. Then extract the specified field from the
  chronology-specific base date and use it to determine the 
 <code>baseValue</code> used below. 
 <p>
  For formatting, the <code>width</code> and <code>maxWidth</code> are used to
  determine the number of characters to format.
  If they are equal then the format is fixed width.
  If the value of the field is within the range of the <code>baseValue</code> using 
 <code>width</code> characters then the reduced value is formatted otherwise the value is
  truncated to fit <code>maxWidth</code>.
  The rightmost characters are output to match the width, left padding with zero. 
 <p>
  For strict parsing, the number of characters allowed by <code>width</code> to <code>maxWidth</code> are parsed.
  For lenient parsing, the number of characters must be at least 1 and less than 10.
  If the number of digits parsed is equal to <code>width</code> and the value is positive,
  the value of the field is computed to be the first number greater than
  or equal to the <code>baseValue</code> with the same least significant characters,
  otherwise the value parsed is the field value.
  This allows a reduced value to be entered for values in range of the baseValue
  and width and absolute values can be entered for values outside the range. 
 <p>
  For example, a base value of <code>1980</code> and a width of <code>2</code> will have
  valid values from <code>1980</code> to <code>2079</code>.
  During parsing, the text <code>"12"</code> will result in the value <code>2012</code> as that
  is the value within the range where the last two characters are "12".
  By contrast, parsing the text <code>"1915"</code> will result in the value <code>1915</code>.
 @param field the field to append, not null
 @param width the field width of the printed and parsed field, from 1 to 10
 @param maxWidth the maximum field width of the printed field, from 1 to 10
 @param baseDate the base date used to calculate the base value for the range   of valid values in the parsed chronology, not null
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif the width or base value is invalid
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendValueReducedWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                                        withInt:(jint)width
                                                                                        withInt:(jint)maxWidth
                                                              withJavaTimeChronoChronoLocalDate:(id<JavaTimeChronoChronoLocalDate>)baseDate;

/*!
 @brief Appends the reduced value of a date-time field to the formatter.
 <p>
  Since fields such as year vary by chronology, it is recommended to use the 
 <code>appendValueReduced(TemporalField, int, int, ChronoLocalDate)</code> date}
  variant of this method in most cases. This variant is suitable for
  simple fields or working with only the ISO chronology. 
 <p>
  For formatting, the <code>width</code> and <code>maxWidth</code> are used to
  determine the number of characters to format.
  If they are equal then the format is fixed width.
  If the value of the field is within the range of the <code>baseValue</code> using 
 <code>width</code> characters then the reduced value is formatted otherwise the value is
  truncated to fit <code>maxWidth</code>.
  The rightmost characters are output to match the width, left padding with zero. 
 <p>
  For strict parsing, the number of characters allowed by <code>width</code> to <code>maxWidth</code> are parsed.
  For lenient parsing, the number of characters must be at least 1 and less than 10.
  If the number of digits parsed is equal to <code>width</code> and the value is positive,
  the value of the field is computed to be the first number greater than
  or equal to the <code>baseValue</code> with the same least significant characters,
  otherwise the value parsed is the field value.
  This allows a reduced value to be entered for values in range of the baseValue
  and width and absolute values can be entered for values outside the range. 
 <p>
  For example, a base value of <code>1980</code> and a width of <code>2</code> will have
  valid values from <code>1980</code> to <code>2079</code>.
  During parsing, the text <code>"12"</code> will result in the value <code>2012</code> as that
  is the value within the range where the last two characters are "12".
  By contrast, parsing the text <code>"1915"</code> will result in the value <code>1915</code>.
 @param field the field to append, not null
 @param width the field width of the printed and parsed field, from 1 to 10
 @param maxWidth the maximum field width of the printed field, from 1 to 10
 @param baseValue the base value of the range of valid values
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif the width or base value is invalid
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendValueReducedWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                                        withInt:(jint)width
                                                                                        withInt:(jint)maxWidth
                                                                                        withInt:(jint)baseValue;

/*!
 @brief Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.
 <p>
  This appends an instruction to format/parse the zone ID to the builder.
  The zone ID is obtained in a strict manner suitable for <code>ZonedDateTime</code>.
  By contrast, <code>OffsetDateTime</code> does not have a zone ID suitable
  for use with this method, see <code>appendZoneOrOffsetId()</code>.
  <p>
  During formatting, the zone is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.zoneId()</code>.
  It will be printed using the result of <code>ZoneId.getId()</code>.
  If the zone cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, the text must match a known zone or offset.
  There are two types of zone ID, offset-based, such as '+01:30' and
  region-based, such as 'Europe/London'. These are parsed differently.
  If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
  expects an offset-based zone and will not match region-based zones.
  The offset ID, such as '+02:30', may be at the start of the parse,
  or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
  equivalent to using <code>appendOffset(String, String)</code> using the
  arguments 'HH:MM:ss' and the no offset string '0'.
  If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
  match a following offset ID, then <code>ZoneOffset.UTC</code> is selected.
  In all other cases, the list of known region-based zones is used to
  find the longest available match. If no match is found, and the parse
  starts with 'Z', then <code>ZoneOffset.UTC</code> is selected.
  The parser uses the case sensitive setting. 
 <p>
  For example, the following will parse: 
 @code

    "Europe/London"           -- ZoneId.of("Europe/London")
    "Z"                       -- ZoneOffset.UTC
    "UT"                      -- ZoneId.of("UT")
    "UTC"                     -- ZoneId.of("UTC")
    "GMT"                     -- ZoneId.of("GMT")
    "+01:30"                  -- ZoneOffset.of("+01:30")
    "UT+01:30"                -- ZoneOffset.of("+01:30")
    "UTC+01:30"               -- ZoneOffset.of("+01:30")
    "GMT+01:30"               -- ZoneOffset.of("+01:30") 
  
@endcode
 @return this, for chaining, not null
 - seealso: #appendZoneRegionId()
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendZoneId;

/*!
 @brief Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to
  the formatter, using the best available zone ID.
 <p>
  This appends an instruction to format/parse the best available
  zone or offset ID to the builder.
  The zone ID is obtained in a lenient manner that first attempts to
  find a true zone ID, such as that on <code>ZonedDateTime</code>, and
  then attempts to find an offset, such as that on <code>OffsetDateTime</code>.
  <p>
  During formatting, the zone is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.zone()</code>.
  It will be printed using the result of <code>ZoneId.getId()</code>.
  If the zone cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, the text must match a known zone or offset.
  There are two types of zone ID, offset-based, such as '+01:30' and
  region-based, such as 'Europe/London'. These are parsed differently.
  If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
  expects an offset-based zone and will not match region-based zones.
  The offset ID, such as '+02:30', may be at the start of the parse,
  or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
  equivalent to using <code>appendOffset(String, String)</code> using the
  arguments 'HH:MM:ss' and the no offset string '0'.
  If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
  match a following offset ID, then <code>ZoneOffset.UTC</code> is selected.
  In all other cases, the list of known region-based zones is used to
  find the longest available match. If no match is found, and the parse
  starts with 'Z', then <code>ZoneOffset.UTC</code> is selected.
  The parser uses the case sensitive setting. 
 <p>
  For example, the following will parse: 
 @code

    "Europe/London"           -- ZoneId.of("Europe/London")
    "Z"                       -- ZoneOffset.UTC
    "UT"                      -- ZoneId.of("UT")
    "UTC"                     -- ZoneId.of("UTC")
    "GMT"                     -- ZoneId.of("GMT")
    "+01:30"                  -- ZoneOffset.of("+01:30")
    "UT+01:30"                -- ZoneOffset.of("UT+01:30")
    "UTC+01:30"               -- ZoneOffset.of("UTC+01:30")
    "GMT+01:30"               -- ZoneOffset.of("GMT+01:30") 
  
@endcode
  <p>
  Note that this method is identical to <code>appendZoneId()</code> except
  in the mechanism used to obtain the zone.
 @return this, for chaining, not null
 - seealso: #appendZoneId()
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendZoneOrOffsetId;

/*!
 @brief Appends the time-zone region ID, such as 'Europe/Paris', to the formatter,
  rejecting the zone ID if it is a <code>ZoneOffset</code>.
 <p>
  This appends an instruction to format/parse the zone ID to the builder
  only if it is a region-based ID. 
 <p>
  During formatting, the zone is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.zoneId()</code>.
  If the zone is a <code>ZoneOffset</code> or it cannot be obtained then
  an exception is thrown unless the section of the formatter is optional.
  If the zone is not an offset, then the zone will be printed using
  the zone ID from <code>ZoneId.getId()</code>.
  <p>
  During parsing, the text must match a known zone or offset.
  There are two types of zone ID, offset-based, such as '+01:30' and
  region-based, such as 'Europe/London'. These are parsed differently.
  If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
  expects an offset-based zone and will not match region-based zones.
  The offset ID, such as '+02:30', may be at the start of the parse,
  or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
  equivalent to using <code>appendOffset(String, String)</code> using the
  arguments 'HH:MM:ss' and the no offset string '0'.
  If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
  match a following offset ID, then <code>ZoneOffset.UTC</code> is selected.
  In all other cases, the list of known region-based zones is used to
  find the longest available match. If no match is found, and the parse
  starts with 'Z', then <code>ZoneOffset.UTC</code> is selected.
  The parser uses the case sensitive setting. 
 <p>
  For example, the following will parse: 
 @code

    "Europe/London"           -- ZoneId.of("Europe/London")
    "Z"                       -- ZoneOffset.UTC
    "UT"                      -- ZoneId.of("UT")
    "UTC"                     -- ZoneId.of("UTC")
    "GMT"                     -- ZoneId.of("GMT")
    "+01:30"                  -- ZoneOffset.of("+01:30")
    "UT+01:30"                -- ZoneOffset.of("+01:30")
    "UTC+01:30"               -- ZoneOffset.of("+01:30")
    "GMT+01:30"               -- ZoneOffset.of("+01:30") 
  
@endcode
  <p>
  Note that this method is identical to <code>appendZoneId()</code> except
  in the mechanism used to obtain the zone.
  Note also that parsing accepts offsets, whereas formatting will never
  produce one.
 @return this, for chaining, not null
 - seealso: #appendZoneId()
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendZoneRegionId;

/*!
 @brief Appends the time-zone name, such as 'British Summer Time', to the formatter.
 <p>
  This appends an instruction to format/parse the textual name of the zone to
  the builder. 
 <p>
  During formatting, the zone is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.zoneId()</code>.
  If the zone is a <code>ZoneOffset</code> it will be printed using the
  result of <code>ZoneOffset.getId()</code>.
  If the zone is not an offset, the textual name will be looked up
  for the locale set in the <code>DateTimeFormatter</code>.
  If the temporal object being printed represents an instant, then the text
  will be the summer or winter time text as appropriate.
  If the lookup for text does not find any suitable result, then the 
 <code>ID</code> will be printed instead.
  If the zone cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, either the textual zone name, the zone ID or the offset
  is accepted. Many textual zone names are not unique, such as CST can be
  for both "Central Standard Time" and "China Standard Time". In this
  situation, the zone id will be determined by the region information from
  formatter's  <code>locale</code> and the standard
  zone id for that area, for example, America/New_York for the America Eastern
  zone. The <code>appendZoneText(TextStyle, Set)</code> may be used
  to specify a set of preferred <code>ZoneId</code> in this situation.
 @param textStyle the text style to use, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendZoneTextWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle;

/*!
 @brief Appends the time-zone name, such as 'British Summer Time', to the formatter.
 <p>
  This appends an instruction to format/parse the textual name of the zone to
  the builder. 
 <p>
  During formatting, the zone is obtained using a mechanism equivalent
  to querying the temporal with <code>TemporalQueries.zoneId()</code>.
  If the zone is a <code>ZoneOffset</code> it will be printed using the
  result of <code>ZoneOffset.getId()</code>.
  If the zone is not an offset, the textual name will be looked up
  for the locale set in the <code>DateTimeFormatter</code>.
  If the temporal object being printed represents an instant, then the text
  will be the summer or winter time text as appropriate.
  If the lookup for text does not find any suitable result, then the 
 <code>ID</code> will be printed instead.
  If the zone cannot be obtained then an exception is thrown unless the
  section of the formatter is optional. 
 <p>
  During parsing, either the textual zone name, the zone ID or the offset
  is accepted. Many textual zone names are not unique, such as CST can be
  for both "Central Standard Time" and "China Standard Time". In this
  situation, the zone id will be determined by the region information from
  formatter's  <code>locale</code> and the standard
  zone id for that area, for example, America/New_York for the America Eastern
  zone. This method also allows a set of preferred <code>ZoneId</code> to be
  specified for parsing. The matched preferred zone id will be used if the
  textural zone name being parsed is not unique. 
 <p>
  If the zone cannot be parsed then an exception is thrown unless the
  section of the formatter is optional.
 @param textStyle the text style to use, not null
 @param preferredZones the set of preferred zone ids, not null
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)appendZoneTextWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle
                                                                      withJavaUtilSet:(id<JavaUtilSet>)preferredZones;

/*!
 @brief Gets the formatting pattern for date and time styles for a locale and chronology.
 The locale and chronology are used to lookup the locale specific format
  for the requested dateStyle and/or timeStyle.
 @param dateStyle the FormatStyle for the date, null for time-only pattern
 @param timeStyle the FormatStyle for the time, null for date-only pattern
 @param chrono the Chronology, non-null
 @param locale the locale, non-null
 @return the locale and Chronology specific formatting pattern
 @throw IllegalArgumentExceptionif both dateStyle and timeStyle are null
 */
+ (NSString *)getLocalizedDateTimePatternWithJavaTimeFormatFormatStyle:(JavaTimeFormatFormatStyle *)dateStyle
                                         withJavaTimeFormatFormatStyle:(JavaTimeFormatFormatStyle *)timeStyle
                                          withJavaTimeChronoChronology:(id<JavaTimeChronoChronology>)chrono
                                                    withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Ends an optional section.
 <p>
  The output of formatting can include optional sections, which may be nested.
  An optional section is started by calling <code>optionalStart()</code> and ended
  using this method (or at the end of the builder). 
 <p>
  Calling this method without having previously called <code>optionalStart</code>
  will throw an exception.
  Calling this method immediately after calling <code>optionalStart</code> has no effect
  on the formatter other than ending the (empty) optional section. 
 <p>
  All elements in the optional section are treated as optional.
  During formatting, the section is only output if data is available in the 
 <code>TemporalAccessor</code> for all the elements in the section.
  During parsing, the whole section may be missing from the parsed string. 
 <p>
  For example, consider a builder setup as 
 <code>builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()</code>.
  During formatting, the minute will only be output if its value can be obtained from the date-time.
  During parsing, the input will be successfully parsed whether the minute is present or not.
 @return this, for chaining, not null
 @throw IllegalStateExceptionif there was no previous call to <code>optionalStart</code>
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)optionalEnd;

/*!
 @brief Mark the start of an optional section.
 <p>
  The output of formatting can include optional sections, which may be nested.
  An optional section is started by calling this method and ended by calling 
 <code>optionalEnd()</code> or by ending the build process. 
 <p>
  All elements in the optional section are treated as optional.
  During formatting, the section is only output if data is available in the 
 <code>TemporalAccessor</code> for all the elements in the section.
  During parsing, the whole section may be missing from the parsed string. 
 <p>
  For example, consider a builder setup as 
 <code>builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)</code>.
  The optional section ends automatically at the end of the builder.
  During formatting, the minute will only be output if its value can be obtained from the date-time.
  During parsing, the input will be successfully parsed whether the minute is present or not.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)optionalStart;

/*!
 @brief Causes the next added printer/parser to pad to a fixed width using a space.
 <p>
  This padding will pad to a fixed width using spaces. 
 <p>
  During formatting, the decorated element will be output and then padded
  to the specified width. An exception will be thrown during formatting if
  the pad width is exceeded. 
 <p>
  During parsing, the padding and decorated element are parsed.
  If parsing is lenient, then the pad width is treated as a maximum.
  The padding is parsed greedily. Thus, if the decorated element starts with
  the pad character, it will not be parsed.
 @param padWidth the pad width, 1 or greater
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif pad width is too small
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)padNextWithInt:(jint)padWidth;

/*!
 @brief Causes the next added printer/parser to pad to a fixed width.
 <p>
  This padding is intended for padding other than zero-padding.
  Zero-padding should be achieved using the appendValue methods. 
 <p>
  During formatting, the decorated element will be output and then padded
  to the specified width. An exception will be thrown during formatting if
  the pad width is exceeded. 
 <p>
  During parsing, the padding and decorated element are parsed.
  If parsing is lenient, then the pad width is treated as a maximum.
  If parsing is case insensitive, then the pad character is matched ignoring case.
  The padding is parsed greedily. Thus, if the decorated element starts with
  the pad character, it will not be parsed.
 @param padWidth the pad width, 1 or greater
 @param padChar the pad character
 @return this, for chaining, not null
 @throw IllegalArgumentExceptionif pad width is too small
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)padNextWithInt:(jint)padWidth
                                                  withChar:(jchar)padChar;

/*!
 @brief Changes the parse style to be case insensitive for the remainder of the formatter.
 <p>
  Parsing can be case sensitive or insensitive - by default it is case sensitive.
  This method allows the case sensitivity setting of parsing to be changed. 
 <p>
  Calling this method changes the state of the builder such that all
  subsequent builder method calls will parse text in case insensitive mode.
  See <code>parseCaseSensitive()</code> for the opposite setting.
  The parse case sensitive/insensitive methods may be called at any point
  in the builder, thus the parser can swap between case parsing modes
  multiple times during the parse.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)parseCaseInsensitive;

/*!
 @brief Changes the parse style to be case sensitive for the remainder of the formatter.
 <p>
  Parsing can be case sensitive or insensitive - by default it is case sensitive.
  This method allows the case sensitivity setting of parsing to be changed. 
 <p>
  Calling this method changes the state of the builder such that all
  subsequent builder method calls will parse text in case sensitive mode.
  See <code>parseCaseInsensitive</code> for the opposite setting.
  The parse case sensitive/insensitive methods may be called at any point
  in the builder, thus the parser can swap between case parsing modes
  multiple times during the parse. 
 <p>
  Since the default is case sensitive, this method should only be used after
  a previous call to <code>#parseCaseInsensitive</code>.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)parseCaseSensitive;

/*!
 @brief Appends a default value for a field to the formatter for use in parsing.
 <p>
  This appends an instruction to the builder to inject a default value
  into the parsed result. This is especially useful in conjunction with
  optional parts of the formatter. 
 <p>
  For example, consider a formatter that parses the year, followed by
  an optional month, with a further optional day-of-month. Using such a
  formatter would require the calling code to check whether a full date,
  year-month or just a year had been parsed. This method can be used to
  default the month and day-of-month to a sensible value, such as the
  first of the month, allowing the calling code to always get a date. 
 <p>
  During formatting, this method has no effect. 
 <p>
  During parsing, the current state of the parse is inspected.
  If the specified field has no associated value, because it has not been
  parsed successfully at that point, then the specified value is injected
  into the parse result. Injection is immediate, thus the field-value pair
  will be visible to any subsequent elements in the formatter.
  As such, this method is normally called at the end of the builder.
 @param field the field to default the value of, not null
 @param value the value to default the field to
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)parseDefaultingWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                                                    withLong:(jlong)value;

/*!
 @brief Changes the parse style to be lenient for the remainder of the formatter.
 Note that case sensitivity is set separately to this method. 
 <p>
  Parsing can be strict or lenient - by default its strict.
  This controls the degree of flexibility in matching the text and sign styles.
  Applications calling this method should typically also call <code>parseCaseInsensitive()</code>.
  <p>
  When used, this method changes the parsing to be lenient from this point onwards.
  The change will remain in force until the end of the formatter that is eventually
  constructed or until <code>parseStrict</code> is called.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)parseLenient;

/*!
 @brief Changes the parse style to be strict for the remainder of the formatter.
 <p>
  Parsing can be strict or lenient - by default its strict.
  This controls the degree of flexibility in matching the text and sign styles. 
 <p>
  When used, this method changes the parsing to be strict from this point onwards.
  As strict is the default, this is normally only needed after calling <code>parseLenient()</code>.
  The change will remain in force until the end of the formatter that is eventually
  constructed or until <code>parseLenient</code> is called.
 @return this, for chaining, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder *)parseStrict;

/*!
 @brief Completes this builder by creating the <code>DateTimeFormatter</code>
  using the default locale.
 <p>
  This will create a formatter with the default FORMAT locale.
  Numbers will be printed and parsed using the standard DecimalStyle.
  The resolver style will be <code>SMART</code>.
  <p>
  Calling this method will end any open optional sections by repeatedly
  calling <code>optionalEnd()</code> before creating the formatter. 
 <p>
  This builder can still be used after creating the formatter if desired,
  although the state may have been changed by calls to <code>optionalEnd</code>.
 @return the created formatter, not null
 */
- (JavaTimeFormatDateTimeFormatter *)toFormatter;

/*!
 @brief Completes this builder by creating the <code>DateTimeFormatter</code>
  using the specified locale.
 <p>
  This will create a formatter with the specified locale.
  Numbers will be printed and parsed using the standard DecimalStyle.
  The resolver style will be <code>SMART</code>.
  <p>
  Calling this method will end any open optional sections by repeatedly
  calling <code>optionalEnd()</code> before creating the formatter. 
 <p>
  This builder can still be used after creating the formatter if desired,
  although the state may have been changed by calls to <code>optionalEnd</code>.
 @param locale the locale to use for formatting, not null
 @return the created formatter, not null
 */
- (JavaTimeFormatDateTimeFormatter *)toFormatterWithJavaUtilLocale:(JavaUtilLocale *)locale;

#pragma mark Package-Private

/*!
 @brief Completes this builder by creating the formatter.
 This uses the default locale.
 @param resolverStyle the resolver style to use, not null
 @return the created formatter, not null
 */
- (JavaTimeFormatDateTimeFormatter *)toFormatterWithJavaTimeFormatResolverStyle:(JavaTimeFormatResolverStyle *)resolverStyle
                                                   withJavaTimeChronoChronology:(id<JavaTimeChronoChronology>)chrono;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder)

/*!
 @brief Length comparator.
 */
inline id<JavaUtilComparator> JavaTimeFormatDateTimeFormatterBuilder_get_LENGTH_SORT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilComparator> JavaTimeFormatDateTimeFormatterBuilder_LENGTH_SORT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTimeFormatDateTimeFormatterBuilder, LENGTH_SORT, id<JavaUtilComparator>)

FOUNDATION_EXPORT NSString *JavaTimeFormatDateTimeFormatterBuilder_getLocalizedDateTimePatternWithJavaTimeFormatFormatStyle_withJavaTimeFormatFormatStyle_withJavaTimeChronoChronology_withJavaUtilLocale_(JavaTimeFormatFormatStyle *dateStyle, JavaTimeFormatFormatStyle *timeStyle, id<JavaTimeChronoChronology> chrono, JavaUtilLocale *locale);

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_init(JavaTimeFormatDateTimeFormatterBuilder *self);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder *new_JavaTimeFormatDateTimeFormatterBuilder_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder *create_JavaTimeFormatDateTimeFormatterBuilder_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

/*!
 @brief Strategy for formatting/parsing date-time information.
 <p>
  The printer may format any part, or the whole, of the input date-time object.
  Typically, a complete format is constructed from a number of smaller
  units, each outputting a single field. 
 <p>
  The parser may parse any piece of text from the input, storing the result
  in the context. Typically, each individual parser will just parse one
  field, such as the day-of-month, storing the value in the context.
  Once the parse is complete, the caller will then resolve the parsed values
  to create the desired object, such as a <code>LocalDate</code>.
  <p>
  The parse position will be updated during the parse. Parsing will start at
  the specified index and the return value specifies the new parse position
  for the next parser. If an error occurs, the returned index will be negative
  and will have the error position encoded using the complement operator.
 */
@protocol JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser < JavaObject >

/*!
 @brief Prints the date-time object to the buffer.
 <p>
  The context holds information to use during the format.
  It also contains the date-time information to be printed. 
 <p>
  The buffer must not be mutated beyond the content controlled by the implementation.
 @param context the context to format using, not null
 @param buf the buffer to append to, not null
 @return false if unable to query the value from the date-time, true otherwise
 @throw DateTimeExceptionif the date-time cannot be printed successfully
 */
- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

/*!
 @brief Parses text into date-time information.
 <p>
  The context holds information to use during the parse.
  It is also used to store the parsed date-time information.
 @param context the context to use and parse into, not null
 @param text the input text to parse, not null
 @param position the position to start parsing at, from 0 to the text length
 @return the new parse position, where negative means an error with the
   error position encoded using the complement ~ operator
 @throw NullPointerExceptionif the context or text is null
 @throw IndexOutOfBoundsExceptionif the position is invalid
 */
- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser)

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_

@class IOSObjectArray;
@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;
@protocol JavaUtilList;

/*!
 @brief Composite printer and parser.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

/*!
 @brief Returns a copy of this printer-parser with the optional flag changed.
 @param optional the optional flag to set in the copy
 @return the new printer-parser, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *)withOptionalWithBoolean:(jboolean)optional;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParserArray:(IOSObjectArray *)printerParsers
                                                                                        withBoolean:(jboolean)optional;

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)printerParsers
                                   withBoolean:(jboolean)optional;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_initWithJavaUtilList_withBoolean_(JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *self, id<JavaUtilList> printerParsers, jboolean optional);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_initWithJavaUtilList_withBoolean_(id<JavaUtilList> printerParsers, jboolean optional) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_initWithJavaUtilList_withBoolean_(id<JavaUtilList> printerParsers, jboolean optional);

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParserArray_withBoolean_(JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *self, IOSObjectArray *printerParsers, jboolean optional);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParserArray_withBoolean_(IOSObjectArray *printerParsers, jboolean optional) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser_initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParserArray_withBoolean_(IOSObjectArray *printerParsers, jboolean optional);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_CompositePrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator))
#define JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;
@protocol JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser;

/*!
 @brief Pads the output to a fixed width.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param printerParser the printer, not null
 @param padWidth the width to pad to, 1 or greater
 @param padChar the pad character
 */
- (instancetype __nonnull)initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser:(id<JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser>)printerParser
                                                                                       withInt:(jint)padWidth
                                                                                      withChar:(jchar)padChar;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator_initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser_withInt_withChar_(JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator *self, id<JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser> printerParser, jint padWidth, jchar padChar);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator *new_JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator_initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser_withInt_withChar_(id<JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser> printerParser, jint padWidth, jchar padChar) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator *create_JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator_initWithJavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser_withInt_withChar_(id<JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser> printerParser, jint padWidth, jchar padChar);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_PadPrinterParserDecorator)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_SettingsParser))
#define JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;
@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

typedef NS_ENUM(NSUInteger, JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_Enum) {
  JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_Enum_SENSITIVE = 0,
  JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_Enum_INSENSITIVE = 1,
  JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_Enum_STRICT = 2,
  JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_Enum_LENIENT = 3,
};

/*!
 @brief Enumeration to apply simple parse settings.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_SettingsParser : JavaLangEnum < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

@property (readonly, class, nonnull) JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *SENSITIVE NS_SWIFT_NAME(SENSITIVE);
@property (readonly, class, nonnull) JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *INSENSITIVE NS_SWIFT_NAME(INSENSITIVE);
@property (readonly, class, nonnull) JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *STRICT NS_SWIFT_NAME(STRICT);
@property (readonly, class, nonnull) JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *LENIENT NS_SWIFT_NAME(LENIENT);
+ (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser * __nonnull)SENSITIVE;

+ (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser * __nonnull)INSENSITIVE;

+ (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser * __nonnull)STRICT;

+ (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser * __nonnull)LENIENT;

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

+ (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_SettingsParser)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_values_[];

inline JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_get_SENSITIVE(void);
J2OBJC_ENUM_CONSTANT(JavaTimeFormatDateTimeFormatterBuilder_SettingsParser, SENSITIVE)

inline JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_get_INSENSITIVE(void);
J2OBJC_ENUM_CONSTANT(JavaTimeFormatDateTimeFormatterBuilder_SettingsParser, INSENSITIVE)

inline JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_get_STRICT(void);
J2OBJC_ENUM_CONSTANT(JavaTimeFormatDateTimeFormatterBuilder_SettingsParser, STRICT)

inline JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_get_LENIENT(void);
J2OBJC_ENUM_CONSTANT(JavaTimeFormatDateTimeFormatterBuilder_SettingsParser, LENIENT)

FOUNDATION_EXPORT IOSObjectArray *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_values(void);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_SettingsParser *JavaTimeFormatDateTimeFormatterBuilder_SettingsParser_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_SettingsParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser))
#define JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;
@protocol JavaTimeTemporalTemporalField;

/*!
 @brief Defaults a value into the parse if not currently present.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                       withLong:(jlong)value;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser_initWithJavaTimeTemporalTemporalField_withLong_(JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser *self, id<JavaTimeTemporalTemporalField> field, jlong value);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser *new_JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser_initWithJavaTimeTemporalTemporalField_withLong_(id<JavaTimeTemporalTemporalField> field, jlong value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser *create_JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser_initWithJavaTimeTemporalTemporalField_withLong_(id<JavaTimeTemporalTemporalField> field, jlong value);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_DefaultValueParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses a character literal.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithChar:(jchar)literal;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser_initWithChar_(JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser *self, jchar literal);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser_initWithChar_(jchar literal) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser_initWithChar_(jchar literal);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_CharLiteralPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses a string literal.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithNSString:(NSString *)literal;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser_initWithNSString_(JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser *self, NSString *literal);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser_initWithNSString_(NSString *literal) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser_initWithNSString_(NSString *literal);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_StringLiteralPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_

@class IOSLongArray;
@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatSignStyle;
@protocol JavaLangCharSequence;
@protocol JavaTimeTemporalTemporalField;

/*!
 @brief Prints and parses a numeric date-time field with optional padding.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser > {
 @public
  id<JavaTimeTemporalTemporalField> field_;
  jint minWidth_;
  jint maxWidth_;
  jint subsequentWidth_;
}
@property (readonly, class, strong) IOSLongArray *EXCEED_POINTS NS_SWIFT_NAME(EXCEED_POINTS);

+ (IOSLongArray *)EXCEED_POINTS;

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Constructor.
 @param field the field to format, not null
 @param minWidth the minimum field width, from 1 to 19
 @param maxWidth the maximum field width, from minWidth to 19
 @param signStyle the positive/negative sign style, not null
 @param subsequentWidth the width of subsequent non-negative numbers, 0 or greater,   -1 if fixed width due to active adjacent parsing
 */
- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                        withInt:(jint)minWidth
                                                        withInt:(jint)maxWidth
                                    withJavaTimeFormatSignStyle:(JavaTimeFormatSignStyle *)signStyle
                                                        withInt:(jint)subsequentWidth;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param field the field to format, not null
 @param minWidth the minimum field width, from 1 to 19
 @param maxWidth the maximum field width, from minWidth to 19
 @param signStyle the positive/negative sign style, not null
 */
- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                        withInt:(jint)minWidth
                                                        withInt:(jint)maxWidth
                                    withJavaTimeFormatSignStyle:(JavaTimeFormatSignStyle *)signStyle;

/*!
 @brief Gets the value to output.
 @param context the context
 @param value the value of the field, not null
 @return the value
 */
- (jlong)getValueWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                                               withLong:(jlong)value;

/*!
 @brief For NumberPrinterParser, the width is fixed depending on the
  minWidth, maxWidth, signStyle and whether subsequent fields are fixed.
 @param context the context
 @return true if the field is fixed width
 - seealso: DateTimeFormatterBuilder#appendValue(java.time.temporal.TemporalField, int)
 */
- (jboolean)isFixedWidthWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context;

/*!
 @brief Stores the value.
 @param context the context to store into, not null
 @param value the value
 @param errorPos the position of the field being parsed
 @param successPos the position after the field being parsed
 @return the new position
 */
- (jint)setValueWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                                              withLong:(jlong)value
                                               withInt:(jint)errorPos
                                               withInt:(jint)successPos;

/*!
 @brief Returns a new instance with fixed width flag set.
 @return a new updated printer-parser, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *)withFixedWidth;

/*!
 @brief Returns a new instance with an updated subsequent width.
 @param subsequentWidth the width of subsequent non-negative numbers, 0 or greater
 @return a new updated printer-parser, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *)withSubsequentWidthWithInt:(jint)subsequentWidth;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser)

J2OBJC_FIELD_SETTER(JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser, field_, id<JavaTimeTemporalTemporalField>)

/*!
 @brief Array of 10 to the power of n.
 */
inline IOSLongArray *JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_get_EXCEED_POINTS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSLongArray *JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_EXCEED_POINTS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser, EXCEED_POINTS, IOSLongArray *)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withJavaTimeFormatSignStyle_(JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *self, id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, JavaTimeFormatSignStyle *signStyle);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withJavaTimeFormatSignStyle_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, JavaTimeFormatSignStyle *signStyle) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withJavaTimeFormatSignStyle_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, JavaTimeFormatSignStyle *signStyle);

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withJavaTimeFormatSignStyle_withInt_(JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *self, id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, JavaTimeFormatSignStyle *signStyle, jint subsequentWidth);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withJavaTimeFormatSignStyle_withInt_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, JavaTimeFormatSignStyle *signStyle, jint subsequentWidth) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withJavaTimeFormatSignStyle_withInt_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, JavaTimeFormatSignStyle *signStyle, jint subsequentWidth);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_

@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatSignStyle;
@class JavaTimeLocalDate;
@protocol JavaTimeChronoChronoLocalDate;
@protocol JavaTimeTemporalTemporalField;

/*!
 @brief Prints and parses a reduced numeric date-time field.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser : JavaTimeFormatDateTimeFormatterBuilder_NumberPrinterParser
@property (readonly, class, strong) JavaTimeLocalDate *BASE_DATE NS_SWIFT_NAME(BASE_DATE);

+ (JavaTimeLocalDate *)BASE_DATE;

#pragma mark Public

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param field the field to format, validated not null
 @param minWidth the minimum field width, from 1 to 10
 @param maxWidth the maximum field width, from 1 to 10
 @param baseValue the base value
 @param baseDate the base date
 */
- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                        withInt:(jint)minWidth
                                                        withInt:(jint)maxWidth
                                                        withInt:(jint)baseValue
                              withJavaTimeChronoChronoLocalDate:(id<JavaTimeChronoChronoLocalDate>)baseDate;

- (jlong)getValueWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                                               withLong:(jlong)value;

/*!
 @brief For a ReducedPrinterParser, fixed width is false if the mode is strict,
  otherwise it is set as for NumberPrinterParser.
 @param context the context
 @return if the field is fixed width
 - seealso: DateTimeFormatterBuilder#appendValueReduced(java.time.temporal.TemporalField, int, int, int)
 */
- (jboolean)isFixedWidthWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context;

- (jint)setValueWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                                              withLong:(jlong)value
                                               withInt:(jint)errorPos
                                               withInt:(jint)successPos;

/*!
 @brief Returns a new instance with fixed width flag set.
 @return a new updated printer-parser, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser *)withFixedWidth;

/*!
 @brief Returns a new instance with an updated subsequent width.
 @param subsequentWidth the width of subsequent non-negative numbers, 0 or greater
 @return a new updated printer-parser, not null
 */
- (JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser *)withSubsequentWidthWithInt:(jint)subsequentWidth;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)arg0
                                                        withInt:(jint)arg1
                                                        withInt:(jint)arg2
                                    withJavaTimeFormatSignStyle:(JavaTimeFormatSignStyle *)arg3 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)arg0
                                                        withInt:(jint)arg1
                                                        withInt:(jint)arg2
                                    withJavaTimeFormatSignStyle:(JavaTimeFormatSignStyle *)arg3
                                                        withInt:(jint)arg4 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser)

/*!
 @brief The base date for reduced value parsing.
 */
inline JavaTimeLocalDate *JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_get_BASE_DATE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTimeLocalDate *JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_BASE_DATE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser, BASE_DATE, JavaTimeLocalDate *)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withInt_withJavaTimeChronoChronoLocalDate_(JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser *self, id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, jint baseValue, id<JavaTimeChronoChronoLocalDate> baseDate);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withInt_withJavaTimeChronoChronoLocalDate_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, jint baseValue, id<JavaTimeChronoChronoLocalDate> baseDate) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withInt_withJavaTimeChronoChronoLocalDate_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, jint baseValue, id<JavaTimeChronoChronoLocalDate> baseDate);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_ReducedPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;
@protocol JavaTimeTemporalTemporalField;

/*!
 @brief Prints and parses a numeric date-time field with optional padding.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param field the field to output, not null
 @param minWidth the minimum width to output, from 0 to 9
 @param maxWidth the maximum width to output, from 0 to 9
 @param decimalPoint whether to output the localized decimal point symbol
 */
- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                                        withInt:(jint)minWidth
                                                        withInt:(jint)maxWidth
                                                    withBoolean:(jboolean)decimalPoint;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withBoolean_(JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser *self, id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, jboolean decimalPoint);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withBoolean_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, jboolean decimalPoint) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser_initWithJavaTimeTemporalTemporalField_withInt_withInt_withBoolean_(id<JavaTimeTemporalTemporalField> field, jint minWidth, jint maxWidth, jboolean decimalPoint);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_FractionPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatDateTimeTextProvider;
@class JavaTimeFormatTextStyle;
@protocol JavaLangCharSequence;
@protocol JavaTimeTemporalTemporalField;

/*!
 @brief Prints or parses field text.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)parseText
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param field the field to output, not null
 @param textStyle the text style, not null
 @param provider the text provider, not null
 */
- (instancetype __nonnull)initWithJavaTimeTemporalTemporalField:(id<JavaTimeTemporalTemporalField>)field
                                    withJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle
                         withJavaTimeFormatDateTimeTextProvider:(JavaTimeFormatDateTimeTextProvider *)provider;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser_initWithJavaTimeTemporalTemporalField_withJavaTimeFormatTextStyle_withJavaTimeFormatDateTimeTextProvider_(JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser *self, id<JavaTimeTemporalTemporalField> field, JavaTimeFormatTextStyle *textStyle, JavaTimeFormatDateTimeTextProvider *provider);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser_initWithJavaTimeTemporalTemporalField_withJavaTimeFormatTextStyle_withJavaTimeFormatDateTimeTextProvider_(id<JavaTimeTemporalTemporalField> field, JavaTimeFormatTextStyle *textStyle, JavaTimeFormatDateTimeTextProvider *provider) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser_initWithJavaTimeTemporalTemporalField_withJavaTimeFormatTextStyle_withJavaTimeFormatDateTimeTextProvider_(id<JavaTimeTemporalTemporalField> field, JavaTimeFormatTextStyle *textStyle, JavaTimeFormatDateTimeTextProvider *provider);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_TextPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses an ISO-8601 instant.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)fractionalDigits;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser_initWithInt_(JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser *self, jint fractionalDigits);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser_initWithInt_(jint fractionalDigits) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser_initWithInt_(jint fractionalDigits);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_InstantPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_

@class IOSObjectArray;
@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses an offset ID.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >
@property (readonly, class, strong) IOSObjectArray *PATTERNS NS_SWIFT_NAME(PATTERNS);
@property (readonly, class, strong) JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *INSTANCE_ID_Z NS_SWIFT_NAME(INSTANCE_ID_Z);
@property (readonly, class, strong) JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *INSTANCE_ID_ZERO NS_SWIFT_NAME(INSTANCE_ID_ZERO);

+ (IOSObjectArray *)PATTERNS;

+ (JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *)INSTANCE_ID_Z;

+ (JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *)INSTANCE_ID_ZERO;

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param pattern the pattern
 @param noOffsetText the text to use for UTC, not null
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                              withNSString:(NSString *)noOffsetText;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser)

inline IOSObjectArray *JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_get_PATTERNS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_PATTERNS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser, PATTERNS, IOSObjectArray *)

inline JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_get_INSTANCE_ID_Z(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_INSTANCE_ID_Z;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser, INSTANCE_ID_Z, JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *)

inline JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_get_INSTANCE_ID_ZERO(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_INSTANCE_ID_ZERO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser, INSTANCE_ID_ZERO, JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_initWithNSString_withNSString_(JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *self, NSString *pattern, NSString *noOffsetText);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_initWithNSString_withNSString_(NSString *pattern, NSString *noOffsetText) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser_initWithNSString_withNSString_(NSString *pattern, NSString *noOffsetText);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_OffsetIdPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatTextStyle;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses an offset ID.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param style the style, not null
 */
- (instancetype __nonnull)initWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)style;

- (jint)getDigitWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                 withInt:(jint)position;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser_initWithJavaTimeFormatTextStyle_(JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser *self, JavaTimeFormatTextStyle *style);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser_initWithJavaTimeFormatTextStyle_(JavaTimeFormatTextStyle *style) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser_initWithJavaTimeFormatTextStyle_(JavaTimeFormatTextStyle *style);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_LocalizedOffsetIdPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeFormatterBuilder_PrefixTree;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;
@protocol JavaTimeTemporalTemporalQuery;

/*!
 @brief Prints or parses a zone ID.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

/*!
 @brief This implementation looks for the longest matching string.
 For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just
  Etc/GMC although both are valid.
 */
- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Protected

- (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)getTreeWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaTimeTemporalTemporalQuery:(id<JavaTimeTemporalTemporalQuery>)query
                                                   withNSString:(NSString *)description_;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser_initWithJavaTimeTemporalTemporalQuery_withNSString_(JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser *self, id<JavaTimeTemporalTemporalQuery> query, NSString *description_);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser_initWithJavaTimeTemporalTemporalQuery_withNSString_(id<JavaTimeTemporalTemporalQuery> query, NSString *description_) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser_initWithJavaTimeTemporalTemporalQuery_withNSString_(id<JavaTimeTemporalTemporalQuery> query, NSString *description_);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeFormatterBuilder_PrefixTree;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatTextStyle;
@protocol JavaTimeTemporalTemporalQuery;
@protocol JavaUtilSet;

/*!
 @brief Prints or parses a zone ID.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser : JavaTimeFormatDateTimeFormatterBuilder_ZoneIdPrinterParser

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

#pragma mark Protected

- (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)getTreeWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle
                                          withJavaUtilSet:(id<JavaUtilSet>)preferredZones;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaTimeTemporalTemporalQuery:(id<JavaTimeTemporalTemporalQuery>)arg0
                                                   withNSString:(NSString *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser_initWithJavaTimeFormatTextStyle_withJavaUtilSet_(JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser *self, JavaTimeFormatTextStyle *textStyle, id<JavaUtilSet> preferredZones);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser_initWithJavaTimeFormatTextStyle_withJavaUtilSet_(JavaTimeFormatTextStyle *textStyle, id<JavaUtilSet> preferredZones) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser_initWithJavaTimeFormatTextStyle_withJavaUtilSet_(JavaTimeFormatTextStyle *textStyle, id<JavaUtilSet> preferredZones);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_ZoneTextPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_PrefixTree))
#define JavaTimeFormatDateTimeFormatterBuilder_PrefixTree_

@class JavaTextParsePosition;
@class JavaTimeFormatDateTimeParseContext;
@protocol JavaLangCharSequence;
@protocol JavaUtilSet;

/*!
 @brief A String based prefix tree for parsing time-zone names.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_PrefixTree : NSObject {
 @public
  NSString *key_;
  NSString *value_;
  jchar c0_;
  JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *child_;
  JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *sibling_;
}

#pragma mark Public

/*!
 @brief Adds a pair of {key, value} into the prefix tree.
 @param k the key, not null
 @param v the value, not null
 @return true if the pair is added successfully
 */
- (jboolean)addWithNSString:(NSString *)k
               withNSString:(NSString *)v;

/*!
 @brief Clone a copy of this tree
 */
- (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)copyTree OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Match text with the prefix tree.
 @param text the input text to parse, not null
 @param off the offset position to start parsing at
 @param end the end position to stop parsing
 @return the resulting string, or null if no match found.
 */
- (NSString *)matchWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                    withInt:(jint)off
                                    withInt:(jint)end;

/*!
 @brief Match text with the prefix tree.
 @param text the input text to parse, not null
 @param pos the position to start parsing at, from 0 to the text   length. Upon return, position will be updated to the new parse
    position, or unchanged, if no match found.
 @return the resulting string, or null if no match found.
 */
- (NSString *)matchWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                  withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Creates a new prefix parsing tree based on parse context.
 @param context the parse context
 @return the tree, not null
 */
+ (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)newTreeWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new prefix parsing tree.
 @param keys a set of strings to build the prefix parsing tree, not null
 @param context the parse context
 @return the tree, not null
 */
+ (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)newTreeWithJavaUtilSet:(id<JavaUtilSet>)keys
                                       withJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context OBJC_METHOD_FAMILY_NONE;

#pragma mark Protected

- (jboolean)isEqualWithChar:(jchar)c1
                   withChar:(jchar)c2;

- (JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)newNodeWithNSString:(NSString *)k
                                                              withNSString:(NSString *)v
                     withJavaTimeFormatDateTimeFormatterBuilder_PrefixTree:(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)child OBJC_METHOD_FAMILY_NONE;

- (jboolean)prefixOfWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                     withInt:(jint)off
                                     withInt:(jint)end;

- (NSString *)toKeyWithNSString:(NSString *)k;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree)

J2OBJC_FIELD_SETTER(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree, key_, NSString *)
J2OBJC_FIELD_SETTER(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree, value_, NSString *)
J2OBJC_FIELD_SETTER(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree, child_, JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)
J2OBJC_FIELD_SETTER(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree, sibling_, JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *)

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *JavaTimeFormatDateTimeFormatterBuilder_PrefixTree_newTreeWithJavaTimeFormatDateTimeParseContext_(JavaTimeFormatDateTimeParseContext *context);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_PrefixTree *JavaTimeFormatDateTimeFormatterBuilder_PrefixTree_newTreeWithJavaUtilSet_withJavaTimeFormatDateTimeParseContext_(id<JavaUtilSet> keys, JavaTimeFormatDateTimeParseContext *context);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_PrefixTree)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatTextStyle;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses a chronology.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaTimeFormatTextStyle:(JavaTimeFormatTextStyle *)textStyle;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser_initWithJavaTimeFormatTextStyle_(JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser *self, JavaTimeFormatTextStyle *textStyle);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser_initWithJavaTimeFormatTextStyle_(JavaTimeFormatTextStyle *textStyle) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser_initWithJavaTimeFormatTextStyle_(JavaTimeFormatTextStyle *textStyle);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_ChronoPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@class JavaTimeFormatFormatStyle;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses a localized pattern.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param dateStyle the date style to use, may be null
 @param timeStyle the time style to use, may be null
 */
- (instancetype __nonnull)initWithJavaTimeFormatFormatStyle:(JavaTimeFormatFormatStyle *)dateStyle
                              withJavaTimeFormatFormatStyle:(JavaTimeFormatFormatStyle *)timeStyle;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser_initWithJavaTimeFormatFormatStyle_withJavaTimeFormatFormatStyle_(JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser *self, JavaTimeFormatFormatStyle *dateStyle, JavaTimeFormatFormatStyle *timeStyle);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser_initWithJavaTimeFormatFormatStyle_withJavaTimeFormatFormatStyle_(JavaTimeFormatFormatStyle *dateStyle, JavaTimeFormatFormatStyle *timeStyle) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser_initWithJavaTimeFormatFormatStyle_withJavaTimeFormatFormatStyle_(JavaTimeFormatFormatStyle *dateStyle, JavaTimeFormatFormatStyle *timeStyle);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_LocalizedPrinterParser)

#endif

#if !defined (JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser_) && (INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder || defined(INCLUDE_JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser))
#define JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser_

@class JavaLangStringBuilder;
@class JavaTimeFormatDateTimeParseContext;
@class JavaTimeFormatDateTimePrintContext;
@protocol JavaLangCharSequence;

/*!
 @brief Prints or parses a localized pattern from a localized field.
 The specific formatter and parameters is not selected until the
  the field is to be printed or parsed.
  The locale is needed to select the proper WeekFields from which
  the field for day-of-week, week-of-month, or week-of-year is selected.
 */
@interface JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser : NSObject < JavaTimeFormatDateTimeFormatterBuilder_DateTimePrinterParser >

#pragma mark Public

- (jboolean)formatWithJavaTimeFormatDateTimePrintContext:(JavaTimeFormatDateTimePrintContext *)context
                               withJavaLangStringBuilder:(JavaLangStringBuilder *)buf;

- (jint)parseWithJavaTimeFormatDateTimeParseContext:(JavaTimeFormatDateTimeParseContext *)context
                           withJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                            withInt:(jint)position;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructor.
 @param chr the pattern format letter that added this PrinterParser.
 @param count the repeat count of the format letter
 */
- (instancetype __nonnull)initWithChar:(jchar)chr
                               withInt:(jint)count;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser)

FOUNDATION_EXPORT void JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser_initWithChar_withInt_(JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser *self, jchar chr, jint count);

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser *new_JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser_initWithChar_withInt_(jchar chr, jint count) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser *create_JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser_initWithChar_withInt_(jchar chr, jint count);

J2OBJC_TYPE_LITERAL_HEADER(JavaTimeFormatDateTimeFormatterBuilder_WeekBasedFieldPrinterParser)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTimeFormatDateTimeFormatterBuilder")
