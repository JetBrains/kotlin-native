//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/net/ServerSocket.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNetServerSocket")
#ifdef RESTRICT_JavaNetServerSocket
#define INCLUDE_ALL_JavaNetServerSocket 0
#else
#define INCLUDE_ALL_JavaNetServerSocket 1
#endif
#undef RESTRICT_JavaNetServerSocket

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNetServerSocket_) && (INCLUDE_ALL_JavaNetServerSocket || defined(INCLUDE_JavaNetServerSocket))
#define JavaNetServerSocket_

#define RESTRICT_JavaIoCloseable 1
#define INCLUDE_JavaIoCloseable 1
#include "java/io/Closeable.h"

@class JavaNetInetAddress;
@class JavaNetSocket;
@class JavaNetSocketAddress;
@class JavaNetSocketImpl;
@class JavaNioChannelsServerSocketChannel;
@protocol JavaNetSocketImplFactory;

/*!
 @brief This class implements server sockets.A server socket waits for
  requests to come in over the network.
 It performs some operation
  based on that request, and then possibly returns a result to the requester. 
 <p>
  The actual work of the server socket is performed by an instance of the 
 <code>SocketImpl</code> class. An application can
  change the socket factory that creates the socket
  implementation to configure itself to create sockets
  appropriate to the local firewall.
 @author unascribed
 - seealso: java.net.SocketImpl
 - seealso: java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 - seealso: java.nio.channels.ServerSocketChannel
 @since JDK1.0
 */
@interface JavaNetServerSocket : NSObject < JavaIoCloseable >

#pragma mark Public

/*!
 @brief Creates an unbound server socket.
 @throw IOExceptionIO error when opening the socket.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a server socket, bound to the specified port.A port number
  of <code>0</code> means that the port number is automatically
  allocated, typically from an ephemeral port range.
 This port
  number can then be retrieved by calling <code>getLocalPort</code>.
  <p>
  The maximum queue length for incoming connection indications (a
  request to connect) is set to <code>50</code>. If a connection
  indication arrives when the queue is full, the connection is refused. 
 <p>
  If the application has specified a server socket factory, that
  factory's <code>createSocketImpl</code> method is called to create
  the actual socket implementation. Otherwise a "plain" socket is created. 
 <p>
  If there is a security manager,
  its <code>checkListen</code> method is called
  with the <code>port</code> argument
  as its argument to ensure the operation is allowed.
  This could result in a SecurityException.
 @param port the port number, or  <code> 0 </code>  to use a port
                     number that is automatically allocated.
 @throw IOExceptionif an I/O error occurs when opening the socket.
 @throw SecurityException
 if a security manager exists and its <code>checkListen</code>
  method doesn't allow the operation.
 @throw IllegalArgumentExceptionif the port parameter is outside
              the specified range of valid port values, which is between
              0 and 65535, inclusive.
 - seealso: java.net.SocketImpl
 - seealso: java.net.SocketImplFactory#createSocketImpl()
 - seealso: java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 - seealso: SecurityManager#checkListen
 */
- (instancetype __nonnull)initWithInt:(jint)port;

/*!
 @brief Creates a server socket and binds it to the specified local port
  number, with the specified backlog.
 A port number of <code>0</code> means that the port number is
  automatically allocated, typically from an ephemeral port range.
  This port number can then be retrieved by calling 
 <code>getLocalPort</code>.
  <p>
  The maximum queue length for incoming connection indications (a
  request to connect) is set to the <code>backlog</code> parameter. If
  a connection indication arrives when the queue is full, the
  connection is refused. 
 <p>
  If the application has specified a server socket factory, that
  factory's <code>createSocketImpl</code> method is called to create
  the actual socket implementation. Otherwise a "plain" socket is created. 
 <p>
  If there is a security manager,
  its <code>checkListen</code> method is called
  with the <code>port</code> argument
  as its argument to ensure the operation is allowed.
  This could result in a SecurityException.
  The <code>backlog</code> argument is the requested maximum number of
  pending connections on the socket. Its exact semantics are implementation
  specific. In particular, an implementation may impose a maximum length
  or may choose to ignore the parameter altogther. The value provided
  should be greater than <code>0</code>. If it is less than or equal to 
 <code>0</code>, then an implementation specific default will be used. 
 <P>
 @param port the port number, or  <code> 0 </code>  to use a port                       number that is automatically allocated.
 @param backlog requested maximum length of the queue of incoming                       connections.
 @throw IOExceptionif an I/O error occurs when opening the socket.
 @throw SecurityException
 if a security manager exists and its <code>checkListen</code>
  method doesn't allow the operation.
 @throw IllegalArgumentExceptionif the port parameter is outside
              the specified range of valid port values, which is between
              0 and 65535, inclusive.
 - seealso: java.net.SocketImpl
 - seealso: java.net.SocketImplFactory#createSocketImpl()
 - seealso: java.net.ServerSocket#setSocketFactory(java.net.SocketImplFactory)
 - seealso: SecurityManager#checkListen
 */
- (instancetype __nonnull)initWithInt:(jint)port
                              withInt:(jint)backlog;

/*!
 @brief Create a server with the specified port, listen backlog, and
  local IP address to bind to.The <i>bindAddr</i> argument
  can be used on a multi-homed host for a ServerSocket that
  will only accept connect requests to one of its addresses.
 If <i>bindAddr</i> is null, it will default accepting
  connections on any/all local addresses.
  The port must be between 0 and 65535, inclusive.
  A port number of <code>0</code> means that the port number is
  automatically allocated, typically from an ephemeral port range.
  This port number can then be retrieved by calling 
 <code>getLocalPort</code>.
  
 <P>If there is a security manager, this method
  calls its <code>checkListen</code> method
  with the <code>port</code> argument
  as its argument to ensure the operation is allowed.
  This could result in a SecurityException.
  The <code>backlog</code> argument is the requested maximum number of
  pending connections on the socket. Its exact semantics are implementation
  specific. In particular, an implementation may impose a maximum length
  or may choose to ignore the parameter altogther. The value provided
  should be greater than <code>0</code>. If it is less than or equal to 
 <code>0</code>, then an implementation specific default will be used. 
 <P>
 @param port the port number, or  <code> 0 </code>  to use a port
                number that is automatically allocated.
 @param backlog requested maximum length of the queue of incoming                 connections.
 @param bindAddr the local InetAddress the server will bind to
 @throw SecurityExceptionif a security manager exists and
  its <code>checkListen</code> method doesn't allow the operation.
 @throw IOExceptionif an I/O error occurs when opening the socket.
 @throw IllegalArgumentExceptionif the port parameter is outside
              the specified range of valid port values, which is between
              0 and 65535, inclusive.
 - seealso: SocketOptions
 - seealso: SocketImpl
 - seealso: SecurityManager#checkListen
 @since JDK1.1
 */
- (instancetype __nonnull)initWithInt:(jint)port
                              withInt:(jint)backlog
               withJavaNetInetAddress:(JavaNetInetAddress *)bindAddr;

/*!
 @brief Listens for a connection to be made to this socket and accepts
  it.The method blocks until a connection is made.
 <p>A new Socket <code>s</code> is created and, if there
  is a security manager,
  the security manager's <code>checkAccept</code> method is called
  with <code>s.getInetAddress().getHostAddress()</code> and 
 <code>s.getPort()</code>
  as its arguments to ensure the operation is allowed.
  This could result in a SecurityException.
 @throw IOExceptionif an I/O error occurs when waiting for a
                connection.
 @throw SecurityExceptionif a security manager exists and its
              <code>checkAccept</code> method doesn't allow the operation.
 @throw SocketTimeoutExceptionif a timeout was previously set with setSoTimeout and
              the timeout has been reached.
 @throw java.nio.channels.IllegalBlockingModeException
 if this socket has an associated channel, the channel is in
              non-blocking mode, and there is no connection ready to be
              accepted
 @return the new Socket
 - seealso: SecurityManager#checkAccept
 */
- (JavaNetSocket *)accept;

/*!
 @brief Binds the <code>ServerSocket</code> to a specific address
  (IP address and port number).
 <p>
  If the address is <code>null</code>, then the system will pick up
  an ephemeral port and a valid local address to bind the socket. 
 <p>
 @param endpoint The IP address  &  port number to bind to.
 @throw IOExceptionif the bind operation fails, or if the socket
                      is already bound.
 @throw SecurityExceptionif a <code>SecurityManager</code> is present and
  its <code>checkListen</code> method doesn't allow the operation.
 @throw IllegalArgumentExceptionif endpoint is a
           SocketAddress subclass not supported by this socket
 @since 1.4
 */
- (void)bindWithJavaNetSocketAddress:(JavaNetSocketAddress *)endpoint;

/*!
 @brief Binds the <code>ServerSocket</code> to a specific address
  (IP address and port number).
 <p>
  If the address is <code>null</code>, then the system will pick up
  an ephemeral port and a valid local address to bind the socket. 
 <P>
  The <code>backlog</code> argument is the requested maximum number of
  pending connections on the socket. Its exact semantics are implementation
  specific. In particular, an implementation may impose a maximum length
  or may choose to ignore the parameter altogther. The value provided
  should be greater than <code>0</code>. If it is less than or equal to 
 <code>0</code>, then an implementation specific default will be used.
 @param endpoint The IP address  &  port number to bind to.
 @param backlog requested maximum length of the queue of                           incoming connections.
 @throw IOExceptionif the bind operation fails, or if the socket
                      is already bound.
 @throw SecurityExceptionif a <code>SecurityManager</code> is present and
  its <code>checkListen</code> method doesn't allow the operation.
 @throw IllegalArgumentExceptionif endpoint is a
           SocketAddress subclass not supported by this socket
 @since 1.4
 */
- (void)bindWithJavaNetSocketAddress:(JavaNetSocketAddress *)endpoint
                             withInt:(jint)backlog;

/*!
 @brief Closes this socket.
 Any thread currently blocked in <code>accept()</code> will throw
  a <code>SocketException</code>.
  
 <p> If this socket has an associated channel then the channel is closed
  as well.
 @throw IOExceptionif an I/O error occurs when closing the socket.
 */
- (void)close;

/*!
 @brief Returns the unique <code>java.nio.channels.ServerSocketChannel</code> object
  associated with this socket, if any.
 <p> A server socket will have a channel if, and only if, the channel
  itself was created via the <code>ServerSocketChannel.open</code>
  method.
 @return the server-socket channel associated with this socket,
           or <tt>null</tt> if this socket was not created
           for a channel
 @since 1.4
 */
- (JavaNioChannelsServerSocketChannel *)getChannel;

/*!
 @brief Get the <code>SocketImpl</code> attached to this socket, creating
  it if necessary.
 @return the <code>SocketImpl</code> attached to that ServerSocket.
 @throw SocketExceptionif creation fails.
 @since 1.4
 */
- (JavaNetSocketImpl *)getImpl;

/*!
 @brief Returns the local address of this server socket.
 <p>
  If the socket was bound prior to being <code>closed</code>,
  then this method will continue to return the local address
  after the socket is closed.
 @return the address to which this socket is bound,
           or <code>null</code> if the socket is unbound.
 */
- (JavaNetInetAddress *)getInetAddress;

/*!
 @brief Returns the port number on which this socket is listening.
 <p>
  If the socket was bound prior to being <code>closed</code>,
  then this method will continue to return the port number
  after the socket is closed.
 @return the port number to which this socket is listening or
           -1 if the socket is not bound yet.
 */
- (jint)getLocalPort;

/*!
 @brief Returns the address of the endpoint this socket is bound to, or 
 <code>null</code> if it is not bound yet.
 <p>
  If the socket was bound prior to being <code>closed</code>,
  then this method will continue to return the address of the endpoint
  after the socket is closed.
 @return a <code>SocketAddress</code> representing the local endpoint of this
          socket, or <code>null</code> if it is not bound yet.
 - seealso: #getInetAddress()
 - seealso: #getLocalPort()
 - seealso: #bind(SocketAddress)
 @since 1.4
 */
- (JavaNetSocketAddress *)getLocalSocketAddress;

/*!
 @brief Gets the value of the SO_RCVBUF option for this <tt>ServerSocket</tt>,
  that is the proposed buffer size that will be used for Sockets accepted
  from this <tt>ServerSocket</tt>.
 <p>Note, the value actually set in the accepted socket is determined by
  calling <code>Socket.getReceiveBufferSize()</code>.
 @return the value of the SO_RCVBUF option for this <tt>Socket</tt>.
 @throw SocketExceptionif there is an error
  in the underlying protocol, such as a TCP error.
 - seealso: #setReceiveBufferSize(int)
 @since 1.4
 */
- (jint)getReceiveBufferSize;

/*!
 @brief Tests if SO_REUSEADDR is enabled.
 @return a <code>boolean</code> indicating whether or not SO_REUSEADDR is enabled.
 @throw SocketExceptionif there is an error
  in the underlying protocol, such as a TCP error.
 @since 1.4
 - seealso: #setReuseAddress(boolean)
 */
- (jboolean)getReuseAddress;

/*!
 @brief Retrieve setting for SO_TIMEOUT.0 returns implies that the
  option is disabled (i.e., timeout of infinity).
 @return the SO_TIMEOUT value
 @throw IOExceptionif an I/O error occurs
 @since JDK1.1
 - seealso: #setSoTimeout(int)
 */
- (jint)getSoTimeout;

/*!
 @brief Returns the binding state of the ServerSocket.
 @return true if the ServerSocket succesfuly bound to an address
 @since 1.4
 */
- (jboolean)isBound;

/*!
 @brief Returns the closed state of the ServerSocket.
 @return true if the socket has been closed
 @since 1.4
 */
- (jboolean)isClosed;

/*!
 @brief Sets performance preferences for this ServerSocket.
 <p> Sockets use the TCP/IP protocol by default.  Some implementations
  may offer alternative protocols which have different performance
  characteristics than TCP/IP.  This method allows the application to
  express its own preferences as to how these tradeoffs should be made
  when the implementation chooses from the available protocols. 
 <p> Performance preferences are described by three integers
  whose values indicate the relative importance of short connection time,
  low latency, and high bandwidth.  The absolute values of the integers
  are irrelevant; in order to choose a protocol the values are simply
  compared, with larger values indicating stronger preferences.  If the
  application prefers short connection time over both low latency and high
  bandwidth, for example, then it could invoke this method with the values 
 <tt>(1, 0, 0)</tt>.  If the application prefers high bandwidth above low
  latency, and low latency above short connection time, then it could
  invoke this method with the values <tt>(0, 1, 2)</tt>.
  
 <p> Invoking this method after this socket has been bound
  will have no effect. This implies that in order to use this capability
  requires the socket to be created with the no-argument constructor.
 @param connectionTime An 
  <tt> int </tt>  expressing the relative importance of a short          connection time
 @param latency An 
  <tt> int </tt>  expressing the relative importance of low          latency
 @param bandwidth An 
  <tt> int </tt>  expressing the relative importance of high          bandwidth
 @since 1.5
 */
- (void)setPerformancePreferencesWithInt:(jint)connectionTime
                                 withInt:(jint)latency
                                 withInt:(jint)bandwidth;

/*!
 @brief Sets a default proposed value for the SO_RCVBUF option for sockets
  accepted from this <tt>ServerSocket</tt>.The value actually set
  in the accepted socket must be determined by calling 
 <code>Socket.getReceiveBufferSize()</code> after the socket
  is returned by <code>accept()</code>.
 <p>
  The value of SO_RCVBUF is used both to set the size of the internal
  socket receive buffer, and to set the size of the TCP receive window
  that is advertized to the remote peer. 
 <p>
  It is possible to change the value subsequently, by calling 
 <code>Socket.setReceiveBufferSize(int)</code>. However, if the application
  wishes to allow a receive window larger than 64K bytes, as defined by RFC1323
  then the proposed value must be set in the ServerSocket <B>before</B>
  it is bound to a local address. This implies, that the ServerSocket must be
  created with the no-argument constructor, then setReceiveBufferSize() must
  be called and lastly the ServerSocket is bound to an address by calling bind(). 
 <p>
  Failure to do this will not cause an error, and the buffer size may be set to the
  requested value but the TCP receive window in sockets accepted from
  this ServerSocket will be no larger than 64K bytes.
 @throw SocketExceptionif there is an error
  in the underlying protocol, such as a TCP error.
 @param size the size to which to set the receive buffer  size. This value must be greater than 0.
 @throw IllegalArgumentExceptionif the
  value is 0 or is negative.
 @since 1.4
 - seealso: #getReceiveBufferSize
 */
- (void)setReceiveBufferSizeWithInt:(jint)size;

/*!
 @brief Enable/disable the SO_REUSEADDR socket option.
 <p>
  When a TCP connection is closed the connection may remain
  in a timeout state for a period of time after the connection
  is closed (typically known as the <tt>TIME_WAIT</tt> state
  or <tt>2MSL</tt> wait state).
  For applications using a well known socket address or port
  it may not be possible to bind a socket to the required 
 <tt>SocketAddress</tt> if there is a connection in the
  timeout state involving the socket address or port. 
 <p>
  Enabling <tt>SO_REUSEADDR</tt> prior to binding the socket
  using <code>bind(SocketAddress)</code> allows the socket to be
  bound even though a previous connection is in a timeout
  state. 
 <p>
  When a <tt>ServerSocket</tt> is created the initial setting
  of <tt>SO_REUSEADDR</tt> is not defined. Applications can
  use <code>getReuseAddress()</code> to determine the initial
  setting of <tt>SO_REUSEADDR</tt>.
  <p>
  The behaviour when <tt>SO_REUSEADDR</tt> is enabled or
  disabled after a socket is bound (See <code>isBound()</code>)
  is not defined.
 @param on whether to enable or disable the socket option
 @throw SocketExceptionif an error occurs enabling or
             disabling the <tt>SO_RESUEADDR</tt> socket option,
             or the socket is closed.
 @since 1.4
 - seealso: #getReuseAddress()
 - seealso: #bind(SocketAddress)
 - seealso: #isBound()
 - seealso: #isClosed()
 */
- (void)setReuseAddressWithBoolean:(jboolean)on;

/*!
 @brief Sets the server socket implementation factory for the
  application.The factory can be specified only once.
 <p>
  When an application creates a new server socket, the socket
  implementation factory's <code>createSocketImpl</code> method is
  called to create the actual socket implementation. 
 <p>
  Passing <code>null</code> to the method is a no-op unless the factory
  was already set. 
 <p>
  If there is a security manager, this method first calls
  the security manager's <code>checkSetFactory</code> method
  to ensure the operation is allowed.
  This could result in a SecurityException.
 @param fac the desired factory.
 @throw IOExceptionif an I/O error occurs when setting the
                socket factory.
 @throw SocketExceptionif the factory has already been defined.
 @throw SecurityExceptionif a security manager exists and its
              <code>checkSetFactory</code> method doesn't allow the operation.
 - seealso: java.net.SocketImplFactory#createSocketImpl()
 - seealso: SecurityManager#checkSetFactory
 */
+ (void)setSocketFactoryWithJavaNetSocketImplFactory:(id<JavaNetSocketImplFactory>)fac;

/*!
 @brief Enable/disable SO_TIMEOUT with the specified timeout, in
  milliseconds.With this option set to a non-zero timeout,
  a call to accept() for this ServerSocket
  will block for only this amount of time.
 If the timeout expires,
  a <B>java.net.SocketTimeoutException</B> is raised, though the
  ServerSocket is still valid.  The option <B>must</B> be enabled
  prior to entering the blocking operation to have effect.  The
  timeout must be > 0.
  A timeout of zero is interpreted as an infinite timeout.
 @param timeout the specified timeout, in milliseconds
 @throw SocketExceptionif there is an error in
  the underlying protocol, such as a TCP error.
 @since JDK1.1
 - seealso: #getSoTimeout()
 */
- (void)setSoTimeoutWithInt:(jint)timeout;

/*!
 @brief Returns the implementation address and implementation port of
  this socket as a <code>String</code>.
 @return a string representation of this socket.
 */
- (NSString *)description;

#pragma mark Protected

/*!
 @brief Subclasses of ServerSocket use this method to override accept()
  to return their own subclass of socket.So a FooServerSocket
  will typically hand this method an <i>empty</i> FooSocket.
 On
  return from implAccept the FooSocket will be connected to a client.
 @param s the Socket
 @throw java.nio.channels.IllegalBlockingModeException
 if this socket has an associated channel,
          and the channel is in non-blocking mode
 @throw IOExceptionif an I/O error occurs when waiting
  for a connection.
 @since JDK1.1
 */
- (void)implAcceptWithJavaNetSocket:(JavaNetSocket *)s;

#pragma mark Package-Private

/*!
 @brief Package-private constructor to create a ServerSocket associated with
  the given SocketImpl.
 */
- (instancetype __nonnull)initWithJavaNetSocketImpl:(JavaNetSocketImpl *)impl;

/*!
 @brief Creates the socket implementation.
 @throw IOExceptionif creation fails
 @since 1.4
 */
- (void)createImpl;

- (void)setBound;

- (void)setCreated;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNetServerSocket)

FOUNDATION_EXPORT void JavaNetServerSocket_initWithJavaNetSocketImpl_(JavaNetServerSocket *self, JavaNetSocketImpl *impl);

FOUNDATION_EXPORT JavaNetServerSocket *new_JavaNetServerSocket_initWithJavaNetSocketImpl_(JavaNetSocketImpl *impl) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaNetServerSocket *create_JavaNetServerSocket_initWithJavaNetSocketImpl_(JavaNetSocketImpl *impl);

FOUNDATION_EXPORT void JavaNetServerSocket_init(JavaNetServerSocket *self);

FOUNDATION_EXPORT JavaNetServerSocket *new_JavaNetServerSocket_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaNetServerSocket *create_JavaNetServerSocket_init(void);

FOUNDATION_EXPORT void JavaNetServerSocket_initWithInt_(JavaNetServerSocket *self, jint port);

FOUNDATION_EXPORT JavaNetServerSocket *new_JavaNetServerSocket_initWithInt_(jint port) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaNetServerSocket *create_JavaNetServerSocket_initWithInt_(jint port);

FOUNDATION_EXPORT void JavaNetServerSocket_initWithInt_withInt_(JavaNetServerSocket *self, jint port, jint backlog);

FOUNDATION_EXPORT JavaNetServerSocket *new_JavaNetServerSocket_initWithInt_withInt_(jint port, jint backlog) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaNetServerSocket *create_JavaNetServerSocket_initWithInt_withInt_(jint port, jint backlog);

FOUNDATION_EXPORT void JavaNetServerSocket_initWithInt_withInt_withJavaNetInetAddress_(JavaNetServerSocket *self, jint port, jint backlog, JavaNetInetAddress *bindAddr);

FOUNDATION_EXPORT JavaNetServerSocket *new_JavaNetServerSocket_initWithInt_withInt_withJavaNetInetAddress_(jint port, jint backlog, JavaNetInetAddress *bindAddr) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaNetServerSocket *create_JavaNetServerSocket_initWithInt_withInt_withJavaNetInetAddress_(jint port, jint backlog, JavaNetInetAddress *bindAddr);

FOUNDATION_EXPORT void JavaNetServerSocket_setSocketFactoryWithJavaNetSocketImplFactory_(id<JavaNetSocketImplFactory> fac);

J2OBJC_TYPE_LITERAL_HEADER(JavaNetServerSocket)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaNetServerSocket")
