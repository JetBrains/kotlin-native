//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/net/SocketOptions.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNetSocketOptions")
#ifdef RESTRICT_JavaNetSocketOptions
#define INCLUDE_ALL_JavaNetSocketOptions 0
#else
#define INCLUDE_ALL_JavaNetSocketOptions 1
#endif
#undef RESTRICT_JavaNetSocketOptions

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNetSocketOptions_) && (INCLUDE_ALL_JavaNetSocketOptions || defined(INCLUDE_JavaNetSocketOptions))
#define JavaNetSocketOptions_

/*!
 @brief Interface of methods to get/set socket options.This interface is
  implemented by: <B>SocketImpl</B> and  <B>DatagramSocketImpl</B>.
 Subclasses of these should override the methods
  of this interface in order to support their own options. 
 <P>
  The methods and constants which specify options in this interface are
  for implementation only.  If you're not subclassing SocketImpl or
  DatagramSocketImpl, <B>you won't use these directly.</B> There are
  type-safe methods to get/set each of these options in Socket, ServerSocket,
  DatagramSocket and MulticastSocket. 
 <P>
 @author David Brown
 */
@protocol JavaNetSocketOptions < JavaObject >

/*!
 @brief Enable/disable the option specified by <I>optID</I>.If the option
  is to be enabled, and it takes an option-specific "value",  this is
  passed in <I>value</I>.
 The actual type of value is option-specific,
  and it is an error to pass something that isn't of the expected type: 
 <BR>@code

  SocketImpl s;
  ...
  s.setOption(SO_LINGER, new Integer(10));
     // OK - set SO_LINGER w/ timeout of 10 sec.
  s.setOption(SO_LINGER, new Double(10));
     // ERROR - expects java.lang.Integer
 
@endcode
  If the requested option is binary, it can be set using this method by
  a java.lang.Boolean: 
 <BR>@code

  s.setOption(TCP_NODELAY, new Boolean(true));
     // OK - enables TCP_NODELAY, a binary option 
  
@endcode
  <BR>
  Any option can be disabled using this method with a Boolean(false): 
 <BR>@code

  s.setOption(TCP_NODELAY, new Boolean(false));
     // OK - disables TCP_NODELAY
  s.setOption(SO_LINGER, new Boolean(false));
     // OK - disables SO_LINGER 
  
@endcode
  <BR>
  For an option that has a notion of on and off, and requires
  a non-boolean parameter, setting its value to anything other than 
 <I>Boolean(false)</I> implicitly enables it. 
 <BR>
  Throws SocketException if the option is unrecognized,
  the socket is closed, or some low-level error occurred 
 <BR>
 @param optID identifies the option
 @param value the parameter of the socket option
 @throw SocketExceptionif the option is unrecognized,
  the socket is closed, or some low-level error occurred
 - seealso: #getOption(int)
 */
- (void)setOptionWithInt:(jint)optID
                  withId:(id)value;

/*!
 @brief Fetch the value of an option.
 Binary options will return java.lang.Boolean(true)
  if enabled, java.lang.Boolean(false) if disabled, e.g.: 
 <BR>@code

  SocketImpl s;
  ...
  Boolean noDelay = (Boolean)(s.getOption(TCP_NODELAY));
  if (noDelay.booleanValue()) {
      // true if TCP_NODELAY is enabled...
  ...
  } 
  
@endcode
  <P>
  For options that take a particular type as a parameter,
  getOption(int) will return the parameter's value, else
  it will return java.lang.Boolean(false): 
 @code

  Object o = s.getOption(SO_LINGER);
  if (o instanceof Integer) {
      System.out.print("Linger time is " + ((Integer)o).intValue());
  } else {
    // the true type of o is java.lang.Boolean(false);
  } 
  
@endcode
 @param optID an  <code> int </code>  identifying the option to fetch
 @return the value of the option
 @throw SocketExceptionif the socket is closed
 @throw SocketExceptionif <I>optID</I> is unknown along the
          protocol stack (including the SocketImpl)
 - seealso: #setOption(int, java.lang.Object)
 */
- (id)getOptionWithInt:(jint)optID;

@end

@interface JavaNetSocketOptions : NSObject
@property (readonly, class) jint TCP_NODELAY_ NS_SWIFT_NAME(TCP_NODELAY_);
@property (readonly, class) jint SO_BINDADDR NS_SWIFT_NAME(SO_BINDADDR);
@property (readonly, class) jint SO_REUSEADDR_ NS_SWIFT_NAME(SO_REUSEADDR_);
@property (readonly, class) jint SO_BROADCAST_ NS_SWIFT_NAME(SO_BROADCAST_);
@property (readonly, class) jint IP_MULTICAST_IF_ NS_SWIFT_NAME(IP_MULTICAST_IF_);
@property (readonly, class) jint IP_MULTICAST_IF2 NS_SWIFT_NAME(IP_MULTICAST_IF2);
@property (readonly, class) jint IP_MULTICAST_LOOP_ NS_SWIFT_NAME(IP_MULTICAST_LOOP_);
@property (readonly, class) jint IP_TOS_ NS_SWIFT_NAME(IP_TOS_);
@property (readonly, class) jint SO_LINGER_ NS_SWIFT_NAME(SO_LINGER_);
@property (readonly, class) jint SO_TIMEOUT NS_SWIFT_NAME(SO_TIMEOUT);
@property (readonly, class) jint SO_SNDBUF_ NS_SWIFT_NAME(SO_SNDBUF_);
@property (readonly, class) jint SO_RCVBUF_ NS_SWIFT_NAME(SO_RCVBUF_);
@property (readonly, class) jint SO_KEEPALIVE_ NS_SWIFT_NAME(SO_KEEPALIVE_);
@property (readonly, class) jint SO_OOBINLINE_ NS_SWIFT_NAME(SO_OOBINLINE_);

+ (jint)TCP_NODELAY_;

+ (jint)SO_BINDADDR;

+ (jint)SO_REUSEADDR_;

+ (jint)SO_BROADCAST_;

+ (jint)IP_MULTICAST_IF_;

+ (jint)IP_MULTICAST_IF2;

+ (jint)IP_MULTICAST_LOOP_;

+ (jint)IP_TOS_;

+ (jint)SO_LINGER_;

+ (jint)SO_TIMEOUT;

+ (jint)SO_SNDBUF_;

+ (jint)SO_RCVBUF_;

+ (jint)SO_KEEPALIVE_;

+ (jint)SO_OOBINLINE_;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNetSocketOptions)

/*!
 @brief Disable Nagle's algorithm for this connection.Written data
  to the network is not buffered pending acknowledgement of
  previously written data.
 <P>
  Valid for TCP only: SocketImpl. 
 <P>
 - seealso: Socket#setTcpNoDelay
 - seealso: Socket#getTcpNoDelay
 */
inline jint JavaNetSocketOptions_get_TCP_NODELAY(void);
#define JavaNetSocketOptions_TCP_NODELAY 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, TCP_NODELAY, jint)

/*!
 @brief Fetch the local address binding of a socket (this option cannot
  be "set" only "gotten", since sockets are bound at creation time,
  and so the locally bound address cannot be changed).The default local
  address of a socket is INADDR_ANY, meaning any local address on a
  multi-homed host.
 A multi-homed host can use this option to accept
  connections to only one of its addresses (in the case of a
  ServerSocket or DatagramSocket), or to specify its return address
  to the peer (for a Socket or DatagramSocket).  The parameter of
  this option is an InetAddress. 
 <P>
  This option <B>must</B> be specified in the constructor. 
 <P>
  Valid for: SocketImpl, DatagramSocketImpl 
 <P>
 - seealso: Socket#getLocalAddress
 - seealso: DatagramSocket#getLocalAddress
 */
inline jint JavaNetSocketOptions_get_SO_BINDADDR(void);
#define JavaNetSocketOptions_SO_BINDADDR 15
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_BINDADDR, jint)

/*!
 @brief Sets SO_REUSEADDR for a socket.This is used only for MulticastSockets
  in java, and it is set by default for MulticastSockets.
 <P>
  Valid for: DatagramSocketImpl
 */
inline jint JavaNetSocketOptions_get_SO_REUSEADDR(void);
#define JavaNetSocketOptions_SO_REUSEADDR 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_REUSEADDR, jint)

/*!
 @brief Sets SO_BROADCAST for a socket.This option enables and disables
  the ability of the process to send broadcast messages.
 It is supported
  for only datagram sockets and only on networks that support
  the concept of a broadcast message (e.g. Ethernet, token ring, etc.),
  and it is set by default for DatagramSockets.
 @since 1.4
 */
inline jint JavaNetSocketOptions_get_SO_BROADCAST(void);
#define JavaNetSocketOptions_SO_BROADCAST 32
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_BROADCAST, jint)

/*!
 @brief Set which outgoing interface on which to send multicast packets.
 Useful on hosts with multiple network interfaces, where applications
  want to use other than the system default.  Takes/returns an InetAddress. 
 <P>
  Valid for Multicast: DatagramSocketImpl 
 <P>
 - seealso: MulticastSocket#setInterface(InetAddress)
 - seealso: MulticastSocket#getInterface()
 */
inline jint JavaNetSocketOptions_get_IP_MULTICAST_IF(void);
#define JavaNetSocketOptions_IP_MULTICAST_IF 16
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, IP_MULTICAST_IF, jint)

/*!
 @brief Same as above.This option is introduced so that the behaviour
   with IP_MULTICAST_IF will be kept the same as before, while
   this new option can support setting outgoing interfaces with either
   IPv4 and IPv6 addresses.
 NOTE: make sure there is no conflict with this
 - seealso: MulticastSocket#setNetworkInterface(NetworkInterface)
 - seealso: MulticastSocket#getNetworkInterface()
 @since 1.4
 */
inline jint JavaNetSocketOptions_get_IP_MULTICAST_IF2(void);
#define JavaNetSocketOptions_IP_MULTICAST_IF2 31
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, IP_MULTICAST_IF2, jint)

/*!
 @brief This option enables or disables local loopback of multicast datagrams.
 This option is enabled by default for Multicast Sockets.
 @since 1.4
 */
inline jint JavaNetSocketOptions_get_IP_MULTICAST_LOOP(void);
#define JavaNetSocketOptions_IP_MULTICAST_LOOP 18
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, IP_MULTICAST_LOOP, jint)

/*!
 @brief This option sets the type-of-service or traffic class field
  in the IP header for a TCP or UDP socket.
 @since 1.4
 */
inline jint JavaNetSocketOptions_get_IP_TOS(void);
#define JavaNetSocketOptions_IP_TOS 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, IP_TOS, jint)

/*!
 @brief Specify a linger-on-close timeout.This option disables/enables
  immediate return from a <B>close()</B> of a TCP Socket.
 Enabling
  this option with a non-zero Integer <I>timeout</I> means that a 
 <B>close()</B> will block pending the transmission and acknowledgement
  of all data written to the peer, at which point the socket is closed 
 <I>gracefully</I>.  Upon reaching the linger timeout, the socket is
  closed <I>forcefully</I>, with a TCP RST. Enabling the option with a
  timeout of zero does a forceful close immediately. If the specified
  timeout value exceeds 65,535 it will be reduced to 65,535. 
 <P>
  Valid only for TCP: SocketImpl
 - seealso: Socket#setSoLinger
 - seealso: Socket#getSoLinger
 */
inline jint JavaNetSocketOptions_get_SO_LINGER(void);
#define JavaNetSocketOptions_SO_LINGER 128
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_LINGER, jint)

/*!
 @brief Set a timeout on blocking Socket operations:
 @code

  ServerSocket.accept();
  SocketInputStream.read();
  DatagramSocket.receive(); 
  
@endcode
  
 <P> The option must be set prior to entering a blocking
  operation to take effect.
 If the timeout expires and the
  operation would continue to block, 
 <B>java.io.InterruptedIOException</B> is raised.  The Socket is
  not closed in this case. 
 <P> Valid for all sockets: SocketImpl, DatagramSocketImpl
 - seealso: Socket#setSoTimeout
 - seealso: ServerSocket#setSoTimeout
 - seealso: DatagramSocket#setSoTimeout
 */
inline jint JavaNetSocketOptions_get_SO_TIMEOUT(void);
#define JavaNetSocketOptions_SO_TIMEOUT 4102
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_TIMEOUT, jint)

/*!
 @brief Set a hint the size of the underlying buffers used by the
  platform for outgoing network I/O.When used in set, this is a
  suggestion to the kernel from the application about the size of
  buffers to use for the data to be sent over the socket.
 When
  used in get, this must return the size of the buffer actually
  used by the platform when sending out data on this socket.
  Valid for all sockets: SocketImpl, DatagramSocketImpl
 - seealso: Socket#setSendBufferSize
 - seealso: Socket#getSendBufferSize
 - seealso: DatagramSocket#setSendBufferSize
 - seealso: DatagramSocket#getSendBufferSize
 */
inline jint JavaNetSocketOptions_get_SO_SNDBUF(void);
#define JavaNetSocketOptions_SO_SNDBUF 4097
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_SNDBUF, jint)

/*!
 @brief Set a hint the size of the underlying buffers used by the
  platform for incoming network I/O.When used in set, this is a
  suggestion to the kernel from the application about the size of
  buffers to use for the data to be received over the
  socket.
 When used in get, this must return the size of the
  buffer actually used by the platform when receiving in data on
  this socket.
  Valid for all sockets: SocketImpl, DatagramSocketImpl
 - seealso: Socket#setReceiveBufferSize
 - seealso: Socket#getReceiveBufferSize
 - seealso: DatagramSocket#setReceiveBufferSize
 - seealso: DatagramSocket#getReceiveBufferSize
 */
inline jint JavaNetSocketOptions_get_SO_RCVBUF(void);
#define JavaNetSocketOptions_SO_RCVBUF 4098
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_RCVBUF, jint)

/*!
 @brief When the keepalive option is set for a TCP socket and no data
  has been exchanged across the socket in either direction for
  2 hours (NOTE: the actual value is implementation dependent),
  TCP automatically sends a keepalive probe to the peer.This probe is a
  TCP segment to which the peer must respond.
 One of three responses is expected:
  1. The peer responds with the expected ACK. The application is not
     notified (since everything is OK). TCP will send another probe
     following another 2 hours of inactivity.
  2. The peer responds with an RST, which tells the local TCP that
     the peer host has crashed and rebooted. The socket is closed.
  3. There is no response from the peer. The socket is closed.
  The purpose of this option is to detect if the peer host crashes.
  Valid only for TCP socket: SocketImpl
 - seealso: Socket#setKeepAlive
 - seealso: Socket#getKeepAlive
 */
inline jint JavaNetSocketOptions_get_SO_KEEPALIVE(void);
#define JavaNetSocketOptions_SO_KEEPALIVE 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_KEEPALIVE, jint)

/*!
 @brief When the OOBINLINE option is set, any TCP urgent data received on
  the socket will be received through the socket input stream.
 When the option is disabled (which is the default) urgent data
  is silently discarded.
 - seealso: Socket#setOOBInline
 - seealso: Socket#getOOBInline
 */
inline jint JavaNetSocketOptions_get_SO_OOBINLINE(void);
#define JavaNetSocketOptions_SO_OOBINLINE 4099
J2OBJC_STATIC_FIELD_CONSTANT(JavaNetSocketOptions, SO_OOBINLINE, jint)

J2OBJC_TYPE_LITERAL_HEADER(JavaNetSocketOptions)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaNetSocketOptions")
