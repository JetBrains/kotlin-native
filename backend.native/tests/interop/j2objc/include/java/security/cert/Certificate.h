//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/security/cert/Certificate.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaSecurityCertCertificate")
#ifdef RESTRICT_JavaSecurityCertCertificate
#define INCLUDE_ALL_JavaSecurityCertCertificate 0
#else
#define INCLUDE_ALL_JavaSecurityCertCertificate 1
#endif
#undef RESTRICT_JavaSecurityCertCertificate

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaSecurityCertCertificate_) && (INCLUDE_ALL_JavaSecurityCertCertificate || defined(INCLUDE_JavaSecurityCertCertificate))
#define JavaSecurityCertCertificate_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSByteArray;
@class JavaSecurityProvider;
@protocol JavaSecurityPublicKey;

/*!
 @brief <p>Abstract class for managing a variety of identity certificates.
 An identity certificate is a binding of a principal to a public key which
  is vouched for by another principal.  (A principal represents
  an entity such as an individual user, a group, or a corporation.)
 <p>
  This class is an abstraction for certificates that have different
  formats but important common uses.  For example, different types of
  certificates, such as X.509 and PGP, share general certificate
  functionality (like encoding and verifying) and
  some types of information (like a public key). 
 <p>
  X.509, PGP, and SDSI certificates can all be implemented by
  subclassing the Certificate class, even though they contain different
  sets of information, and they store and retrieve the information in
  different ways.
 - seealso: X509Certificate
 - seealso: CertificateFactory
 @author Hemma Prafullchandra
 */
@interface JavaSecurityCertCertificate : NSObject < JavaIoSerializable >

#pragma mark Public

/*!
 @brief Compares this certificate for equality with the specified
  object.If the <code>other</code> object is an 
 <code>instanceof</code> <code>Certificate</code>, then
  its encoded form is retrieved and compared with the
  encoded form of this certificate.
 @param other the object to test for equality with this certificate.
 @return true iff the encoded forms of the two certificates
  match, false otherwise.
 */
- (jboolean)isEqual:(id)other;

/*!
 @brief Returns the encoded form of this certificate.It is
  assumed that each certificate type would have only a single
  form of encoding; for example, X.509 certificates would
  be encoded as ASN.1 DER.
 @return the encoded form of this certificate
 @throw CertificateEncodingExceptionif an encoding error occurs.
 */
- (IOSByteArray *)getEncoded;

/*!
 @brief Gets the public key from this certificate.
 @return the public key.
 */
- (id<JavaSecurityPublicKey>)getPublicKey;

/*!
 @brief Returns the type of this certificate.
 @return the type of this certificate.
 */
- (NSString *)getType;

/*!
 @brief Returns a hashcode value for this certificate from its
  encoded form.
 @return the hashcode value.
 */
- (NSUInteger)hash;

/*!
 @brief Returns a string representation of this certificate.
 @return a string representation of this certificate.
 */
- (NSString *)description;

/*!
 @brief Verifies that this certificate was signed using the
  private key that corresponds to the specified public key.
 @param key the PublicKey used to carry out the verification.
 @throw NoSuchAlgorithmExceptionon unsupported signature
  algorithms.
 @throw InvalidKeyExceptionon incorrect key.
 @throw NoSuchProviderExceptionif there's no default provider.
 @throw SignatureExceptionon signature errors.
 @throw CertificateExceptionon encoding errors.
 */
- (void)verifyWithJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)key;

/*!
 @brief Verifies that this certificate was signed using the
  private key that corresponds to the specified public key.
 This method uses the signature verification engine
  supplied by the specified provider. Note that the specified
  Provider object does not have to be registered in the provider list. 
 <p> This method was added to version 1.8 of the Java Platform
  Standard Edition. In order to maintain backwards compatibility with
  existing service providers, this method cannot be <code>abstract</code>
  and by default throws an <code>UnsupportedOperationException</code>.
 @param key the PublicKey used to carry out the verification.
 @param sigProvider the signature provider.
 @throw NoSuchAlgorithmExceptionon unsupported signature
  algorithms.
 @throw InvalidKeyExceptionon incorrect key.
 @throw SignatureExceptionon signature errors.
 @throw CertificateExceptionon encoding errors.
 @throw UnsupportedOperationExceptionif the method is not supported
 @since 1.8
 */
- (void)verifyWithJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)key
               withJavaSecurityProvider:(JavaSecurityProvider *)sigProvider;

/*!
 @brief Verifies that this certificate was signed using the
  private key that corresponds to the specified public key.
 This method uses the signature verification engine
  supplied by the specified provider.
 @param key the PublicKey used to carry out the verification.
 @param sigProvider the name of the signature provider.
 @throw NoSuchAlgorithmExceptionon unsupported signature
  algorithms.
 @throw InvalidKeyExceptionon incorrect key.
 @throw NoSuchProviderExceptionon incorrect provider.
 @throw SignatureExceptionon signature errors.
 @throw CertificateExceptionon encoding errors.
 */
- (void)verifyWithJavaSecurityPublicKey:(id<JavaSecurityPublicKey>)key
                           withNSString:(NSString *)sigProvider;

#pragma mark Protected

/*!
 @brief Creates a certificate of the specified type.
 @param type the standard name of the certificate type.  See the CertificateFactory section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#CertificateFactory">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard certificate types.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)type;

/*!
 @brief Replace the Certificate to be serialized.
 @return the alternate Certificate object to be serialized
 @throw java.io.ObjectStreamExceptionif a new object representing
  this Certificate could not be created
 @since 1.3
 */
- (id)writeReplace;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaSecurityCertCertificate)

FOUNDATION_EXPORT void JavaSecurityCertCertificate_initWithNSString_(JavaSecurityCertCertificate *self, NSString *type);

J2OBJC_TYPE_LITERAL_HEADER(JavaSecurityCertCertificate)

#endif

#if !defined (JavaSecurityCertCertificate_CertificateRep_) && (INCLUDE_ALL_JavaSecurityCertCertificate || defined(INCLUDE_JavaSecurityCertCertificate_CertificateRep))
#define JavaSecurityCertCertificate_CertificateRep_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSByteArray;

/*!
 @brief Alternate Certificate class for serialization.
 @since 1.3
 */
@interface JavaSecurityCertCertificate_CertificateRep : NSObject < JavaIoSerializable >

#pragma mark Protected

/*!
 @brief Construct the alternate Certificate class with the Certificate
  type and Certificate encoding bytes.
 <p>
 @param type the standard name of the Certificate type.  <p>
 @param data the Certificate data.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)type
                             withByteArray:(IOSByteArray *)data;

/*!
 @brief Resolve the Certificate Object.
 <p>
 @return the resolved Certificate Object
 @throw java.io.ObjectStreamExceptionif the Certificate
       could not be resolved
 */
- (id)readResolve;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaSecurityCertCertificate_CertificateRep)

FOUNDATION_EXPORT void JavaSecurityCertCertificate_CertificateRep_initWithNSString_withByteArray_(JavaSecurityCertCertificate_CertificateRep *self, NSString *type, IOSByteArray *data);

FOUNDATION_EXPORT JavaSecurityCertCertificate_CertificateRep *new_JavaSecurityCertCertificate_CertificateRep_initWithNSString_withByteArray_(NSString *type, IOSByteArray *data) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaSecurityCertCertificate_CertificateRep *create_JavaSecurityCertCertificate_CertificateRep_initWithNSString_withByteArray_(NSString *type, IOSByteArray *data);

J2OBJC_TYPE_LITERAL_HEADER(JavaSecurityCertCertificate_CertificateRep)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaSecurityCertCertificate")
