//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: openjdk/src/share/classes/java/math/BigInteger.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaMathBigInteger")
#ifdef RESTRICT_JavaMathBigInteger
#define INCLUDE_ALL_JavaMathBigInteger 0
#else
#define INCLUDE_ALL_JavaMathBigInteger 1
#endif
#undef RESTRICT_JavaMathBigInteger

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaMathBigInteger_) && (INCLUDE_ALL_JavaMathBigInteger || defined(INCLUDE_JavaMathBigInteger))
#define JavaMathBigInteger_

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class IOSByteArray;
@class IOSCharArray;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaUtilRandom;

/*!
 @brief Immutable arbitrary-precision integers.All operations behave as if
  BigIntegers were represented in two's-complement notation (like Java's
  primitive integer types).
 BigInteger provides analogues to all of Java's
  primitive integer operators, and all relevant methods from java.lang.Math.
  Additionally, BigInteger provides operations for modular arithmetic, GCD
  calculation, primality testing, prime generation, bit manipulation,
  and a few other miscellaneous operations. 
 <p>Semantics of arithmetic operations exactly mimic those of Java's integer
  arithmetic operators, as defined in <i>The Java Language Specification</i>.
  For example, division by zero throws an <code>ArithmeticException</code>, and
  division of a negative by a positive yields a negative (or zero) remainder.
  All of the details in the Spec concerning overflow are ignored, as
  BigIntegers are made as large as necessary to accommodate the results of an
  operation. 
 <p>Semantics of shift operations extend those of Java's shift operators
  to allow for negative shift distances.  A right-shift with a negative
  shift distance results in a left shift, and vice-versa.  The unsigned
  right shift operator (<code>>>></code>) is omitted, as this operation makes
  little sense in combination with the "infinite word size" abstraction
  provided by this class. 
 <p>Semantics of bitwise logical operations exactly mimic those of Java's
  bitwise integer operators.  The binary operators (<code>and</code>,
  <code>or</code>, <code>xor</code>) implicitly perform sign extension on the shorter
  of the two operands prior to performing the operation. 
 <p>Comparison operations perform signed integer comparisons, analogous to
  those performed by Java's relational and equality operators. 
 <p>Modular arithmetic operations are provided to compute residues, perform
  exponentiation, and compute multiplicative inverses.  These methods always
  return a non-negative result, between <code>0</code> and <code>(modulus - 1)</code>,
  inclusive. 
 <p>Bit operations operate on a single bit of the two's-complement
  representation of their operand.  If necessary, the operand is sign-
  extended so that it contains the designated bit.  None of the single-bit
  operations can produce a BigInteger with a different sign from the
  BigInteger being operated on, as they affect only a single bit, and the
  "infinite word size" abstraction provided by this class ensures that there
  are infinitely many "virtual sign bits" preceding each BigInteger. 
 <p>For the sake of brevity and clarity, pseudo-code is used throughout the
  descriptions of BigInteger methods.  The pseudo-code expression 
 <code>(i + j)</code> is shorthand for "a BigInteger whose value is
  that of the BigInteger <code>i</code> plus that of the BigInteger <code>j</code>."
  The pseudo-code expression <code>(i == j)</code> is shorthand for
  "<code>true</code> if and only if the BigInteger <code>i</code> represents the same
  value as the BigInteger <code>j</code>."  Other pseudo-code expressions are
  interpreted similarly. 
 <p>All methods and constructors in this class throw 
 <code>NullPointerException</code> when passed
  a null object reference for any input parameter.
  BigInteger must support values in the range
  -2<sup><code>Integer.MAX_VALUE</code></sup> (exclusive) to
  +2<sup><code>Integer.MAX_VALUE</code></sup> (exclusive)
  and may support values outside of that range.
  The range of probable prime values is limited and may be less than
  the full supported positive range of <code>BigInteger</code>.
  The range must be at least 1 to 2<sup>500000000</sup>.
 - seealso: BigDecimal
 @author Josh Bloch
 @author Michael McCloskey
 @author Alan Eliasen
 @author Timothy Buktu
 @since JDK1.1
 */
@interface JavaMathBigInteger : NSNumber < JavaLangComparable > {
 @public
  /*!
   @brief The signum of this BigInteger: -1 for negative, 0 for zero, or
  1 for positive.Note that the BigInteger zero <i>must</i> have
  a signum of 0.
   This is necessary to ensures that there is exactly one
  representation for each BigInteger value.
   */
  jint signum_;
  /*!
   @brief The magnitude of this BigInteger, in <i>big-endian</i> order: the
  zeroth element of this array is the most-significant int of the
  magnitude.The magnitude must be "minimal" in that the most-significant
  int (<code>mag[0]</code>) must be non-zero.
   This is necessary to
  ensure that there is exactly one representation for each BigInteger
  value.  Note that this implies that the BigInteger zero has a
  zero-length mag array.
   */
  IOSIntArray *mag_;
}
@property (readonly, class) jlong LONG_MASK NS_SWIFT_NAME(LONG_MASK);
@property (readonly, class) jint BURNIKEL_ZIEGLER_THRESHOLD NS_SWIFT_NAME(BURNIKEL_ZIEGLER_THRESHOLD);
@property (readonly, class) jint BURNIKEL_ZIEGLER_OFFSET NS_SWIFT_NAME(BURNIKEL_ZIEGLER_OFFSET);
@property (readonly, class, strong) JavaMathBigInteger *ZERO NS_SWIFT_NAME(ZERO);
@property (readonly, class, strong) JavaMathBigInteger *ONE NS_SWIFT_NAME(ONE);
@property (readonly, class, strong) JavaMathBigInteger *TEN NS_SWIFT_NAME(TEN);
@property (class, strong) IOSIntArray *bnExpModThreshTable NS_SWIFT_NAME(bnExpModThreshTable);

+ (jlong)LONG_MASK;

+ (jint)BURNIKEL_ZIEGLER_THRESHOLD;

+ (jint)BURNIKEL_ZIEGLER_OFFSET;

+ (JavaMathBigInteger *)ZERO;

+ (JavaMathBigInteger *)ONE;

+ (JavaMathBigInteger *)TEN;

+ (IOSIntArray *)bnExpModThreshTable;

+ (void)setBnExpModThreshTable:(IOSIntArray *)value;

#pragma mark Public

/*!
 @brief Translates a byte array containing the two's-complement binary
  representation of a BigInteger into a BigInteger.The input array is
  assumed to be in <i>big-endian</i> byte-order: the most significant
  byte is in the zeroth element.
 @param val big-endian two's-complement binary representation of          BigInteger.
 @throw NumberFormatException<code>val</code> is zero bytes long.
 */
- (instancetype __nonnull)initWithByteArray:(IOSByteArray *)val;

/*!
 @brief Translates the sign-magnitude representation of a BigInteger into a
  BigInteger.The sign is represented as an integer signum value: -1 for
  negative, 0 for zero, or 1 for positive.
 The magnitude is a byte array
  in <i>big-endian</i> byte-order: the most significant byte is in the
  zeroth element.  A zero-length magnitude array is permissible, and will
  result in a BigInteger value of 0, whether signum is -1, 0 or 1.
 @param signum signum of the number (-1 for negative, 0 for zero, 1          for positive).
 @param magnitude big-endian binary representation of the magnitude of          the number.
 @throw NumberFormatException<code>signum</code> is not one of the three
          legal values (-1, 0, and 1), or <code>signum</code> is 0 and
          <code>magnitude</code> contains one or more non-zero bytes.
 */
- (instancetype __nonnull)initWithInt:(jint)signum
                        withByteArray:(IOSByteArray *)magnitude;

/*!
 @brief Constructs a randomly generated positive BigInteger that is probably
  prime, with the specified bitLength.
 <p>It is recommended that the <code>probablePrime</code>
  method be used in preference to this constructor unless there
  is a compelling need to specify a certainty.
 @param bitLength bitLength of the returned BigInteger.
 @param certainty a measure of the uncertainty that the caller is          willing to tolerate.  The probability that the new BigInteger
           represents a prime number will exceed
           (1 - 1/2
  <sup><code>certainty</code> </sup> ).  The execution time of          this constructor is proportional to the value of this parameter.
 @param rnd source of random bits used to select candidates to be          tested for primality.
 @throw ArithmeticException<code>bitLength < 2</code> or <code>bitLength</code> is too large.
 - seealso: #bitLength()
 */
- (instancetype __nonnull)initWithInt:(jint)bitLength
                              withInt:(jint)certainty
                   withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Constructs a randomly generated BigInteger, uniformly distributed over
  the range 0 to (2<sup><code>numBits</code></sup> - 1), inclusive.
 The uniformity of the distribution assumes that a fair source of random
  bits is provided in <code>rnd</code>.  Note that this constructor always
  constructs a non-negative BigInteger.
 @param numBits maximum bitLength of the new BigInteger.
 @param rnd source of randomness to be used in computing the new          BigInteger.
 @throw IllegalArgumentException<code>numBits</code> is negative.
 - seealso: #bitLength()
 */
- (instancetype __nonnull)initWithInt:(jint)numBits
                   withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Translates the decimal String representation of a BigInteger into a
  BigInteger.The String representation consists of an optional minus
  sign followed by a sequence of one or more decimal digits.
 The
  character-to-digit mapping is provided by <code>Character.digit</code>.
  The String may not contain any extraneous characters (whitespace, for
  example).
 @param val decimal String representation of BigInteger.
 @throw NumberFormatException<code>val</code> is not a valid representation
          of a BigInteger.
 - seealso: Character#digit
 */
- (instancetype __nonnull)initWithNSString:(NSString *)val;

/*!
 @brief Translates the String representation of a BigInteger in the
  specified radix into a BigInteger.The String representation
  consists of an optional minus or plus sign followed by a
  sequence of one or more digits in the specified radix.
 The
  character-to-digit mapping is provided by <code>Character.digit</code>
 .  The String may not contain any extraneous
  characters (whitespace, for example).
 @param val String representation of BigInteger.
 @param radix radix to be used in interpreting <code>val</code> .
 @throw NumberFormatException<code>val</code> is not a valid representation
          of a BigInteger in the specified radix, or <code>radix</code> is
          outside the range from <code>Character.MIN_RADIX</code> to
          <code>Character.MAX_RADIX</code>, inclusive.
 - seealso: Character#digit
 */
- (instancetype __nonnull)initWithNSString:(NSString *)val
                                   withInt:(jint)radix;

/*!
 @brief Returns a BigInteger whose value is the absolute value of this
  BigInteger.
 @return <code>abs(this)</code>
 */
- (JavaMathBigInteger *)abs;

/*!
 @brief Returns a BigInteger whose value is <code>(this + val)</code>.
 @param val value to be added to this BigInteger.
 @return <code>this + val</code>
 */
- (JavaMathBigInteger *)addWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is <code>(this & val)</code>.
 (This
  method returns a negative BigInteger if and only if this and val are
  both negative.)
 @param val value to be AND'ed with this BigInteger.
 @return <code>this & val</code>
 */
- (JavaMathBigInteger *)and__WithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is <code>(this & ~val)</code>.This
  method, which is equivalent to <code>and(val.not())</code>, is provided as
  a convenience for masking operations.
 (This method returns a negative
  BigInteger if and only if <code>this</code> is negative and <code>val</code> is
  positive.)
 @param val value to be complemented and AND'ed with this BigInteger.
 @return <code>this & ~val</code>
 */
- (JavaMathBigInteger *)andNotWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns the number of bits in the two's complement representation
  of this BigInteger that differ from its sign bit.This method is
  useful when implementing bit-vector style sets atop BigIntegers.
 @return number of bits in the two's complement representation
          of this BigInteger that differ from its sign bit.
 */
- (jint)bitCount;

/*!
 @brief Returns the number of bits in the minimal two's-complement
  representation of this BigInteger, <i>excluding</i> a sign bit.
 For positive BigIntegers, this is equivalent to the number of bits in
  the ordinary binary representation.  (Computes 
 <code>(ceil(log2(this < 0 ? -this : this+1)))</code>.)
 @return number of bits in the minimal two's-complement
          representation of this BigInteger, <i>excluding</i> a sign bit.
 */
- (jint)bitLength;

/*!
 @brief Converts this <code>BigInteger</code> to a <code>byte</code>, checking
  for lost information.If the value of this <code>BigInteger</code>
  is out of the range of the <code>byte</code> type, then an 
 <code>ArithmeticException</code> is thrown.
 @return this <code>BigInteger</code> converted to a <code>byte</code>.
 @throw ArithmeticExceptionif the value of <code>this</code> will
  not exactly fit in a <code>byte</code>.
 - seealso: BigInteger#byteValue
 @since 1.8
 */
- (jbyte)byteValueExact;

/*!
 @brief Returns a BigInteger whose value is equivalent to this BigInteger
  with the designated bit cleared.
 (Computes <code>(this & ~(1<<n))</code>.)
 @param n index of bit to clear.
 @return <code>this & ~(1<<n)</code>
 @throw ArithmeticException<code>n</code> is negative.
 */
- (JavaMathBigInteger *)clearBitWithInt:(jint)n;

/*!
 @brief Compares this BigInteger with the specified BigInteger.This
  method is provided in preference to individual methods for each
  of the six boolean comparison operators (&lt;, ==, 
 &gt;, &gt;=, !
 =, &lt;=).  The suggested
  idiom for performing these comparisons is: <code>(x.compareTo(y)</code>
  &lt;<i>op</i>&gt; <code>0)</code>, where 
 &lt;<i>op</i>&gt; is one of the six comparison operators.
 @param val BigInteger to which this BigInteger is to be compared.
 @return -1, 0 or 1 as this BigInteger is numerically less than, equal
          to, or greater than <code>val</code>.
 */
- (jint)compareToWithId:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is <code>(this / val)</code>.
 @param val value by which this BigInteger is to be divided.
 @return <code>this / val</code>
 @throw ArithmeticExceptionif <code>val</code> is zero.
 */
- (JavaMathBigInteger *)divideWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns an array of two BigIntegers containing <code>(this / val)</code>
  followed by <code>(this % val)</code>.
 @param val value by which this BigInteger is to be divided, and the          remainder computed.
 @return an array of two BigIntegers: the quotient <code>(this / val)</code>
          is the initial element, and the remainder <code>(this % val)</code>
          is the final element.
 @throw ArithmeticExceptionif <code>val</code> is zero.
 */
- (IOSObjectArray *)divideAndRemainderWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Converts this BigInteger to a <code>double</code>.This
  conversion is similar to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>float</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  if this BigInteger has too great a magnitude
  to represent as a <code>double</code>, it will be converted to 
 <code>Double.NEGATIVE_INFINITY</code> or <code>Double.POSITIVE_INFINITY</code>
  as appropriate.
 Note that even when
  the return value is finite, this conversion can lose
  information about the precision of the BigInteger value.
 @return this BigInteger converted to a <code>double</code>.
 */
- (jdouble)doubleValue;

/*!
 @brief Compares this BigInteger with the specified Object for equality.
 @param x Object to which this BigInteger is to be compared.
 @return <code>true</code> if and only if the specified Object is a
          BigInteger whose value is numerically equal to this BigInteger.
 */
- (jboolean)isEqual:(id)x;

/*!
 @brief Returns a BigInteger whose value is equivalent to this BigInteger
  with the designated bit flipped.
 (Computes <code>(this ^ (1<<n))</code>.)
 @param n index of bit to flip.
 @return <code>this ^ (1<<n)</code>
 @throw ArithmeticException<code>n</code> is negative.
 */
- (JavaMathBigInteger *)flipBitWithInt:(jint)n;

/*!
 @brief Converts this BigInteger to a <code>float</code>.This
  conversion is similar to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>float</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  if this BigInteger has too great a magnitude
  to represent as a <code>float</code>, it will be converted to 
 <code>Float.NEGATIVE_INFINITY</code> or <code>Float.POSITIVE_INFINITY</code>
  as appropriate.
 Note that even when
  the return value is finite, this conversion can lose
  information about the precision of the BigInteger value.
 @return this BigInteger converted to a <code>float</code>.
 */
- (jfloat)floatValue;

/*!
 @brief Returns a BigInteger whose value is the greatest common divisor of 
 <code>abs(this)</code> and <code>abs(val)</code>.Returns 0 if 
 <code>this == 0 && val == 0</code>.
 @param val value with which the GCD is to be computed.
 @return <code>GCD(abs(this), abs(val))</code>
 */
- (JavaMathBigInteger *)gcdWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns the index of the rightmost (lowest-order) one bit in this
  BigInteger (the number of zero bits to the right of the rightmost
  one bit).Returns -1 if this BigInteger contains no one bits.
 (Computes <code>(this == 0? -1 : log2(this & -this))</code>.)
 @return index of the rightmost one bit in this BigInteger.
 */
- (jint)getLowestSetBit;

/*!
 @brief Returns the hash code for this BigInteger.
 @return hash code for this BigInteger.
 */
- (NSUInteger)hash;

/*!
 @brief Converts this BigInteger to an <code>int</code>.This
  conversion is analogous to a 
 <i>narrowing primitive conversion</i> from <code>long</code> to 
 <code>int</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  if this BigInteger is too big to fit in an 
 <code>int</code>, only the low-order 32 bits are returned.
 Note that this conversion can lose information about the
  overall magnitude of the BigInteger value as well as return a
  result with the opposite sign.
 @return this BigInteger converted to an <code>int</code>.
 - seealso: #intValueExact()
 */
- (jint)intValue;

/*!
 @brief Converts this <code>BigInteger</code> to an <code>int</code>, checking
  for lost information.If the value of this <code>BigInteger</code>
  is out of the range of the <code>int</code> type, then an 
 <code>ArithmeticException</code> is thrown.
 @return this <code>BigInteger</code> converted to an <code>int</code>.
 @throw ArithmeticExceptionif the value of <code>this</code> will
  not exactly fit in a <code>int</code>.
 - seealso: BigInteger#intValue
 @since 1.8
 */
- (jint)intValueExact;

/*!
 @brief Returns <code>true</code> if this BigInteger is probably prime, 
 <code>false</code> if it's definitely composite.If
  <code>certainty</code> is &le; 0, <code>true</code> is
  returned.
 @param certainty a measure of the uncertainty that the caller is          willing to tolerate: if the call returns 
 <code>true</code>          the probability that this BigInteger is prime exceeds
           (1 - 1/2
  <sup><code>certainty</code> </sup> ).  The execution time of          this method is proportional to the value of this parameter.
 @return <code>true</code> if this BigInteger is probably prime,
          <code>false</code> if it's definitely composite.
 */
- (jboolean)isProbablePrimeWithInt:(jint)certainty;

/*!
 @brief Converts this BigInteger to a <code>long</code>.This
  conversion is analogous to a 
 <i>narrowing primitive conversion</i> from <code>long</code> to 
 <code>int</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  if this BigInteger is too big to fit in a 
 <code>long</code>, only the low-order 64 bits are returned.
 Note that this conversion can lose information about the
  overall magnitude of the BigInteger value as well as return a
  result with the opposite sign.
 @return this BigInteger converted to a <code>long</code>.
 - seealso: #longValueExact()
 */
- (jlong)longLongValue;

/*!
 @brief Converts this <code>BigInteger</code> to a <code>long</code>, checking
  for lost information.If the value of this <code>BigInteger</code>
  is out of the range of the <code>long</code> type, then an 
 <code>ArithmeticException</code> is thrown.
 @return this <code>BigInteger</code> converted to a <code>long</code>.
 @throw ArithmeticExceptionif the value of <code>this</code> will
  not exactly fit in a <code>long</code>.
 - seealso: BigInteger#longValue
 @since 1.8
 */
- (jlong)longValueExact;

/*!
 @brief Returns the maximum of this BigInteger and <code>val</code>.
 @param val value with which the maximum is to be computed.
 @return the BigInteger whose value is the greater of this and
          <code>val</code>.  If they are equal, either may be returned.
 */
- (JavaMathBigInteger *)maxWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns the minimum of this BigInteger and <code>val</code>.
 @param val value with which the minimum is to be computed.
 @return the BigInteger whose value is the lesser of this BigInteger and
          <code>val</code>.  If they are equal, either may be returned.
 */
- (JavaMathBigInteger *)minWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is <code>(this mod m</code>).This method
  differs from <code>remainder</code> in that it always returns a 
 <i>non-negative</i> BigInteger.
 @param m the modulus.
 @return <code>this mod m</code>
 @throw ArithmeticException<code>m</code> &le; 0
 - seealso: #remainder
 */
- (JavaMathBigInteger *)modWithJavaMathBigInteger:(JavaMathBigInteger *)m;

/*!
 @brief Returns a BigInteger whose value is <code>(this</code><sup>-1</sup> <code>mod m)</code>.
 @param m the modulus.
 @return <code>this</code><sup>-1</sup> <code>mod m</code>.
 @throw ArithmeticException<code>m</code> &le; 0, or this BigInteger
          has no multiplicative inverse mod m (that is, this BigInteger
          is not <i>relatively prime</i> to m).
 */
- (JavaMathBigInteger *)modInverseWithJavaMathBigInteger:(JavaMathBigInteger *)m;

/*!
 @brief Returns a BigInteger whose value is 
 <tt>(this<sup>exponent</sup> mod m)</tt>.
 (Unlike <code>pow</code>, this
  method permits negative exponents.)
 @param exponent the exponent.
 @param m the modulus.
 @return <tt>this<sup>exponent</sup> mod m</tt>
 @throw ArithmeticException<code>m</code> &le; 0 or the exponent is
          negative and this BigInteger is not <i>relatively
          prime</i> to <code>m</code>.
 - seealso: #modInverse
 */
- (JavaMathBigInteger *)modPowWithJavaMathBigInteger:(JavaMathBigInteger *)exponent
                              withJavaMathBigInteger:(JavaMathBigInteger *)m;

/*!
 @brief Returns a BigInteger whose value is <code>(this * val)</code>.
 @param val value to be multiplied by this BigInteger.
 @return <code>this * val</code>
 */
- (JavaMathBigInteger *)multiplyWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is <code>(-this)</code>.
 @return <code>-this</code>
 */
- (JavaMathBigInteger *)negate;

/*!
 @brief Returns the first integer greater than this <code>BigInteger</code> that
  is probably prime.The probability that the number returned by this
  method is composite does not exceed 2<sup>-100</sup>.
 This method will
  never skip over a prime when searching: if it returns <code>p</code>, there
  is no prime <code>q</code> such that <code>this < q < p</code>.
 @return the first integer greater than this <code>BigInteger</code> that
          is probably prime.
 @throw ArithmeticException<code>this < 0</code> or <code>this</code> is too large.
 @since 1.5
 */
- (JavaMathBigInteger *)nextProbablePrime;

/*!
 @brief Returns a BigInteger whose value is <code>(~this)</code>.
 (This method
  returns a negative value if and only if this BigInteger is
  non-negative.)
 @return <code>~this</code>
 */
- (JavaMathBigInteger *)not__;

/*!
 @brief Returns a BigInteger whose value is <code>(this | val)</code>.
 (This method
  returns a negative BigInteger if and only if either this or val is
  negative.)
 @param val value to be OR'ed with this BigInteger.
 @return <code>this | val</code>
 */
- (JavaMathBigInteger *)or__WithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is <tt>(this<sup>exponent</sup>)</tt>.
 Note that <code>exponent</code> is an integer rather than a BigInteger.
 @param exponent exponent to which this BigInteger is to be raised.
 @return <tt>this<sup>exponent</sup></tt>
 @throw ArithmeticException<code>exponent</code> is negative.  (This would
          cause the operation to yield a non-integer value.)
 */
- (JavaMathBigInteger *)powWithInt:(jint)exponent;

/*!
 @brief Returns a positive BigInteger that is probably prime, with the
  specified bitLength.The probability that a BigInteger returned
  by this method is composite does not exceed 2<sup>-100</sup>.
 @param bitLength bitLength of the returned BigInteger.
 @param rnd source of random bits used to select candidates to be          tested for primality.
 @return a BigInteger of <code>bitLength</code> bits that is probably prime
 @throw ArithmeticException<code>bitLength < 2</code> or <code>bitLength</code> is too large.
 - seealso: #bitLength()
 @since 1.4
 */
+ (JavaMathBigInteger *)probablePrimeWithInt:(jint)bitLength
                          withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Returns a BigInteger whose value is <code>(this % val)</code>.
 @param val value by which this BigInteger is to be divided, and the          remainder computed.
 @return <code>this % val</code>
 @throw ArithmeticExceptionif <code>val</code> is zero.
 */
- (JavaMathBigInteger *)remainderWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a BigInteger whose value is equivalent to this BigInteger
  with the designated bit set.
 (Computes <code>(this | (1<<n))</code>.)
 @param n index of bit to set.
 @return <code>this | (1<<n)</code>
 @throw ArithmeticException<code>n</code> is negative.
 */
- (JavaMathBigInteger *)setBitWithInt:(jint)n;

/*!
 @brief Returns a BigInteger whose value is <code>(this << n)</code>.
 The shift distance, <code>n</code>, may be negative, in which case
  this method performs a right shift.
  (Computes <tt>floor(this * 2<sup>n</sup>)</tt>.)
 @param n shift distance, in bits.
 @return <code>this << n</code>
 - seealso: #shiftRight
 */
- (JavaMathBigInteger *)shiftLeftWithInt:(jint)n;

/*!
 @brief Returns a BigInteger whose value is <code>(this >> n)</code>.Sign
  extension is performed.
 The shift distance, <code>n</code>, may be
  negative, in which case this method performs a left shift.
  (Computes <tt>floor(this / 2<sup>n</sup>)</tt>.)
 @param n shift distance, in bits.
 @return <code>this >> n</code>
 - seealso: #shiftLeft
 */
- (JavaMathBigInteger *)shiftRightWithInt:(jint)n;

/*!
 @brief Converts this <code>BigInteger</code> to a <code>short</code>, checking
  for lost information.If the value of this <code>BigInteger</code>
  is out of the range of the <code>short</code> type, then an 
 <code>ArithmeticException</code> is thrown.
 @return this <code>BigInteger</code> converted to a <code>short</code>.
 @throw ArithmeticExceptionif the value of <code>this</code> will
  not exactly fit in a <code>short</code>.
 - seealso: BigInteger#shortValue
 @since 1.8
 */
- (jshort)shortValueExact;

/*!
 @brief Returns the signum function of this BigInteger.
 @return -1, 0 or 1 as the value of this BigInteger is negative, zero or
          positive.
 */
- (jint)signum;

/*!
 @brief Returns a BigInteger whose value is <code>(this - val)</code>.
 @param val value to be subtracted from this BigInteger.
 @return <code>this - val</code>
 */
- (JavaMathBigInteger *)subtractWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns <code>true</code> if and only if the designated bit is set.
 (Computes <code>((this & (1<<n)) != 0)</code>.)
 @param n index of bit to test.
 @return <code>true</code> if and only if the designated bit is set.
 @throw ArithmeticException<code>n</code> is negative.
 */
- (jboolean)testBitWithInt:(jint)n;

/*!
 @brief Returns a byte array containing the two's-complement
  representation of this BigInteger.The byte array will be in 
 <i>big-endian</i> byte-order: the most significant byte is in
  the zeroth element.
 The array will contain the minimum number
  of bytes required to represent this BigInteger, including at
  least one sign bit, which is <code>(ceil((this.bitLength() +
  1)/8))</code>
 .  (This representation is compatible with the 
 <code>(byte[])</code> constructor.)
 @return a byte array containing the two's-complement representation of
          this BigInteger.
 - seealso: #BigInteger(byte[])
 */
- (IOSByteArray *)toByteArray;

/*!
 @brief Returns the decimal String representation of this BigInteger.
 The digit-to-character mapping provided by 
 <code>Character.forDigit</code> is used, and a minus sign is
  prepended if appropriate.  (This representation is compatible
  with the <code>(String)</code> constructor, and
  allows for String concatenation with Java's + operator.)
 @return decimal String representation of this BigInteger.
 - seealso: Character#forDigit
 - seealso: #BigInteger(java.lang.String)
 */
- (NSString *)description;

/*!
 @brief Returns the String representation of this BigInteger in the
  given radix.If the radix is outside the range from <code>Character.MIN_RADIX</code>
  to <code>Character.MAX_RADIX</code> inclusive,
  it will default to 10 (as is the case for 
 <code>Integer.toString</code>).
 The digit-to-character mapping
  provided by <code>Character.forDigit</code> is used, and a minus
  sign is prepended if appropriate.  (This representation is
  compatible with the <code>(String,
  int)</code>
  constructor.)
 @param radix radix of the String representation.
 @return String representation of this BigInteger in the given radix.
 - seealso: Integer#toString
 - seealso: Character#forDigit
 - seealso: #BigInteger(java.lang.String, int)
 */
- (NSString *)toStringWithInt:(jint)radix;

/*!
 @brief Returns a BigInteger whose value is equal to that of the
  specified <code>long</code>.This "static factory method" is
  provided in preference to a (<code>long</code>) constructor
  because it allows for reuse of frequently used BigIntegers.
 @param val value of the BigInteger to return.
 @return a BigInteger with the specified value.
 */
+ (JavaMathBigInteger *)valueOfWithLong:(jlong)val;

/*!
 @brief Returns a BigInteger whose value is <code>(this ^ val)</code>.
 (This method
  returns a negative BigInteger if and only if exactly one of this and
  val are negative.)
 @param val value to be XOR'ed with this BigInteger.
 @return <code>this ^ val</code>
 */
- (JavaMathBigInteger *)xor__WithJavaMathBigInteger:(JavaMathBigInteger *)val;

#pragma mark Package-Private

- (instancetype __nonnull)initWithCharArray:(IOSCharArray *)val
                                    withInt:(jint)sign
                                    withInt:(jint)len;

/*!
 @brief This internal constructor differs from its public cousin
  with the arguments reversed in two ways: it assumes that its
  arguments are correct, and it doesn't copy the magnitude array.
 */
- (instancetype __nonnull)initWithIntArray:(IOSIntArray *)magnitude
                                   withInt:(jint)signum;

/*!
 @brief Package private methods used by BigDecimal code to add a BigInteger
  with a long.Assumes val is not equal to INFLATED.
 */
- (JavaMathBigInteger *)addWithLong:(jlong)val;

/*!
 @brief Add one word to the number a mlen words into a.Return the resulting
  carry.
 */
+ (jint)addOneWithIntArray:(IOSIntArray *)a
                   withInt:(jint)offset
                   withInt:(jint)mlen
                   withInt:(jint)carry;

/*!
 @brief Package private method to return bit length for an integer.
 */
+ (jint)bitLengthForIntWithInt:(jint)n;

/*!
 @brief Compares the magnitude array of this BigInteger with the specified
  BigInteger's.This is the version of compareTo ignoring sign.
 @param val BigInteger whose magnitude array to be compared.
 @return -1, 0 or 1 as this magnitude array is less than, equal to or
          greater than the magnitude aray for the specified BigInteger's.
 */
- (jint)compareMagnitudeWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Version of compareMagnitude that compares magnitude with long value.
 val can't be Long.MIN_VALUE.
 */
- (jint)compareMagnitudeWithLong:(jlong)val;

- (IOSIntArray *)javaIncrementWithIntArray:(IOSIntArray *)val;

/*!
 @brief Multiply an array by one word k and add to result, return the carry
 */
+ (jint)mulAddWithIntArray:(IOSIntArray *)outArg
              withIntArray:(IOSIntArray *)inArg
                   withInt:(jint)offset
                   withInt:(jint)len
                   withInt:(jint)k;

/*!
 @brief Package private methods used by BigDecimal code to multiply a BigInteger
  with a long.Assumes v is not equal to INFLATED.
 */
- (JavaMathBigInteger *)multiplyWithLong:(jlong)v;

/*!
 @brief Returns <code>true</code> if this BigInteger is probably prime, 
 <code>false</code> if it's definitely composite.
 This method assumes bitLength > 2.
 @param certainty a measure of the uncertainty that the caller is          willing to tolerate: if the call returns 
 <code>true</code>          the probability that this BigInteger is prime exceeds
           <code>(1 - 1/2<sup>certainty</sup>)</code>
  .  The execution time of          this method is proportional to the value of this parameter.
 @return <code>true</code> if this BigInteger is probably prime,
          <code>false</code> if it's definitely composite.
 */
- (jboolean)primeToCertaintyWithInt:(jint)certainty
                 withJavaUtilRandom:(JavaUtilRandom *)random;

+ (void)primitiveLeftShiftWithIntArray:(IOSIntArray *)a
                               withInt:(jint)len
                               withInt:(jint)n;

+ (void)primitiveRightShiftWithIntArray:(IOSIntArray *)a
                                withInt:(jint)len
                                withInt:(jint)n;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaMathBigInteger)

J2OBJC_FIELD_SETTER(JavaMathBigInteger, mag_, IOSIntArray *)

/*!
 @brief This mask is used to obtain the value of an int as if it were unsigned.
 */
inline jlong JavaMathBigInteger_get_LONG_MASK(void);
#define JavaMathBigInteger_LONG_MASK 4294967295LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigInteger, LONG_MASK, jlong)

/*!
 @brief The threshold value for using Burnikel-Ziegler division.If the number
  of ints in the divisor are larger than this value, Burnikel-Ziegler
  division may be used.
 This value is found experimentally to work well.
 */
inline jint JavaMathBigInteger_get_BURNIKEL_ZIEGLER_THRESHOLD(void);
#define JavaMathBigInteger_BURNIKEL_ZIEGLER_THRESHOLD 80
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigInteger, BURNIKEL_ZIEGLER_THRESHOLD, jint)

/*!
 @brief The offset value for using Burnikel-Ziegler division.If the number
  of ints in the divisor exceeds the Burnikel-Ziegler threshold, and the
  number of ints in the dividend is greater than the number of ints in the
  divisor plus this value, Burnikel-Ziegler division will be used.
 This
  value is found experimentally to work well.
 */
inline jint JavaMathBigInteger_get_BURNIKEL_ZIEGLER_OFFSET(void);
#define JavaMathBigInteger_BURNIKEL_ZIEGLER_OFFSET 40
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigInteger, BURNIKEL_ZIEGLER_OFFSET, jint)

/*!
 @brief The BigInteger constant zero.
 @since 1.2
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_ZERO(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_ZERO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, ZERO, JavaMathBigInteger *)

/*!
 @brief The BigInteger constant one.
 @since 1.2
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_ONE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, ONE, JavaMathBigInteger *)

/*!
 @brief The BigInteger constant ten.
 @since 1.5
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_TEN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_TEN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, TEN, JavaMathBigInteger *)

inline IOSIntArray *JavaMathBigInteger_get_bnExpModThreshTable(void);
inline IOSIntArray *JavaMathBigInteger_set_bnExpModThreshTable(IOSIntArray *value);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *JavaMathBigInteger_bnExpModThreshTable;
J2OBJC_STATIC_FIELD_OBJ(JavaMathBigInteger, bnExpModThreshTable, IOSIntArray *)

FOUNDATION_EXPORT void JavaMathBigInteger_initWithByteArray_(JavaMathBigInteger *self, IOSByteArray *val);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithByteArray_(IOSByteArray *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithByteArray_(IOSByteArray *val);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withByteArray_(JavaMathBigInteger *self, jint signum, IOSByteArray *magnitude);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withByteArray_(jint signum, IOSByteArray *magnitude) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withByteArray_(jint signum, IOSByteArray *magnitude);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithNSString_withInt_(JavaMathBigInteger *self, NSString *val, jint radix);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithNSString_withInt_(NSString *val, jint radix) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithNSString_withInt_(NSString *val, jint radix);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithCharArray_withInt_withInt_(JavaMathBigInteger *self, IOSCharArray *val, jint sign, jint len);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithCharArray_withInt_withInt_(IOSCharArray *val, jint sign, jint len) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithCharArray_withInt_withInt_(IOSCharArray *val, jint sign, jint len);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithNSString_(JavaMathBigInteger *self, NSString *val);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithNSString_(NSString *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithNSString_(NSString *val);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withJavaUtilRandom_(JavaMathBigInteger *self, jint numBits, JavaUtilRandom *rnd);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withJavaUtilRandom_(jint numBits, JavaUtilRandom *rnd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withJavaUtilRandom_(jint numBits, JavaUtilRandom *rnd);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withInt_withJavaUtilRandom_(JavaMathBigInteger *self, jint bitLength, jint certainty, JavaUtilRandom *rnd);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withInt_withJavaUtilRandom_(jint bitLength, jint certainty, JavaUtilRandom *rnd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withInt_withJavaUtilRandom_(jint bitLength, jint certainty, JavaUtilRandom *rnd);

FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_probablePrimeWithInt_withJavaUtilRandom_(jint bitLength, JavaUtilRandom *rnd);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithIntArray_withInt_(JavaMathBigInteger *self, IOSIntArray *magnitude, jint signum);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithIntArray_withInt_(IOSIntArray *magnitude, jint signum) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithIntArray_withInt_(IOSIntArray *magnitude, jint signum);

FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_valueOfWithLong_(jlong val);

FOUNDATION_EXPORT jint JavaMathBigInteger_bitLengthForIntWithInt_(jint n);

FOUNDATION_EXPORT void JavaMathBigInteger_primitiveRightShiftWithIntArray_withInt_withInt_(IOSIntArray *a, jint len, jint n);

FOUNDATION_EXPORT void JavaMathBigInteger_primitiveLeftShiftWithIntArray_withInt_withInt_(IOSIntArray *a, jint len, jint n);

FOUNDATION_EXPORT jint JavaMathBigInteger_mulAddWithIntArray_withIntArray_withInt_withInt_withInt_(IOSIntArray *outArg, IOSIntArray *inArg, jint offset, jint len, jint k);

FOUNDATION_EXPORT jint JavaMathBigInteger_addOneWithIntArray_withInt_withInt_withInt_(IOSIntArray *a, jint offset, jint mlen, jint carry);

J2OBJC_TYPE_LITERAL_HEADER(JavaMathBigInteger)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaMathBigInteger")
