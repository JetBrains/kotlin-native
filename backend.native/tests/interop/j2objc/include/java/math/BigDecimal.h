//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: openjdk/src/share/classes/java/math/BigDecimal.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaMathBigDecimal")
#ifdef RESTRICT_JavaMathBigDecimal
#define INCLUDE_ALL_JavaMathBigDecimal 0
#else
#define INCLUDE_ALL_JavaMathBigDecimal 1
#endif
#undef RESTRICT_JavaMathBigDecimal

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaMathBigDecimal_) && (INCLUDE_ALL_JavaMathBigDecimal || defined(INCLUDE_JavaMathBigDecimal))
#define JavaMathBigDecimal_

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class IOSCharArray;
@class IOSObjectArray;
@class JavaMathBigInteger;
@class JavaMathMathContext;
@class JavaMathRoundingMode;

/*!
 @brief Immutable, arbitrary-precision signed decimal numbers.A
  <code>BigDecimal</code> consists of an arbitrary precision integer 
 <i>unscaled value</i> and a 32-bit integer <i>scale</i>.
 If zero
  or positive, the scale is the number of digits to the right of the
  decimal point.  If negative, the unscaled value of the number is
  multiplied by ten to the power of the negation of the scale.  The
  value of the number represented by the <code>BigDecimal</code> is
  therefore <tt>(unscaledValue &times; 10<sup>-scale</sup>)</tt>.
  
 <p>The <code>BigDecimal</code> class provides operations for
  arithmetic, scale manipulation, rounding, comparison, hashing, and
  format conversion.  The <code>toString</code> method provides a
  canonical representation of a <code>BigDecimal</code>.
  
 <p>The <code>BigDecimal</code> class gives its user complete control
  over rounding behavior.  If no rounding mode is specified and the
  exact result cannot be represented, an exception is thrown;
  otherwise, calculations can be carried out to a chosen precision
  and rounding mode by supplying an appropriate <code>MathContext</code>
  object to the operation.  In either case, eight <em>rounding
  modes</em> are provided for the control of rounding.  Using the
  integer fields in this class (such as <code>ROUND_HALF_UP</code>) to
  represent rounding mode is largely obsolete; the enumeration values
  of the <code>RoundingMode</code> <code>enum</code>, (such as <code>RoundingMode.HALF_UP</code>
 ) should be used instead. 
 <p>When a <code>MathContext</code> object is supplied with a precision
  setting of 0 (for example, <code>MathContext.UNLIMITED</code>),
  arithmetic operations are exact, as are the arithmetic methods
  which take no <code>MathContext</code> object.  (This is the only
  behavior that was supported in releases prior to 5.)  As a
  corollary of computing the exact result, the rounding mode setting
  of a <code>MathContext</code> object with a precision setting of 0 is
  not used and thus irrelevant.  In the case of divide, the exact
  quotient could have an infinitely long decimal expansion; for
  example, 1 divided by 3.  If the quotient has a nonterminating
  decimal expansion and the operation is specified to return an exact
  result, an <code>ArithmeticException</code> is thrown.  Otherwise, the
  exact result of the division is returned, as done for other
  operations. 
 <p>When the precision setting is not 0, the rules of 
 <code>BigDecimal</code> arithmetic are broadly compatible with selected
  modes of operation of the arithmetic defined in ANSI X3.274-1996
  and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those
  standards, <code>BigDecimal</code> includes many rounding modes, which
  were mandatory for division in <code>BigDecimal</code> releases prior
  to 5.  Any conflicts between these ANSI standards and the 
 <code>BigDecimal</code> specification are resolved in favor of 
 <code>BigDecimal</code>.
  
 <p>Since the same numerical value can have different
  representations (with different scales), the rules of arithmetic
  and rounding must specify both the numerical result and the scale
  used in the result's representation. 
 <p>In general the rounding modes and precision setting determine
  how operations return results with a limited number of digits when
  the exact result has more digits (perhaps infinitely many in the
  case of division) than the number of digits returned.
  First, the
  total number of digits to return is specified by the 
 <code>MathContext</code>'s <code>precision</code> setting; this determines
  the result's <i>precision</i>.  The digit count starts from the
  leftmost nonzero digit of the exact result.  The rounding mode
  determines how any discarded trailing digits affect the returned
  result. 
 <p>For all arithmetic operators , the operation is carried out as
  though an exact intermediate result were first calculated and then
  rounded to the number of digits specified by the precision setting
  (if necessary), using the selected rounding mode.  If the exact
  result is not returned, some digit positions of the exact result
  are discarded.  When rounding increases the magnitude of the
  returned result, it is possible for a new digit position to be
  created by a carry propagating to a leading &quot;9&quot; digit.
  For example, rounding the value 999.9 to three digits rounding up
  would be numerically equal to one thousand, represented as
  100&times;10<sup>1</sup>.  In such cases, the new &quot;1&quot; is
  the leading digit position of the returned result. 
 <p>Besides a logical exact result, each arithmetic operation has a
  preferred scale for representing a result.  The preferred
  scale for each operation is listed in the table below. 
 <table border>
  <caption><b>Preferred Scales for Results of Arithmetic Operations 
 </b></caption>
  <tr><th>Operation</th><th>Preferred Scale of Result</th></tr>
  <tr><td>Add</td><td>max(addend.scale(), augend.scale())</td>
  <tr><td>Subtract</td><td>max(minuend.scale(), subtrahend.scale())</td>
  <tr><td>Multiply</td><td>multiplier.scale() + multiplicand.scale()</td>
  <tr><td>Divide</td><td>dividend.scale() - divisor.scale()</td>
  </table>
  These scales are the ones used by the methods which return exact
  arithmetic results; except that an exact divide may have to use a
  larger scale since the exact result may have more digits.  For
  example, <code>1/32</code> is <code>0.03125</code>.
  
 <p>Before rounding, the scale of the logical exact intermediate
  result is the preferred scale for that operation.  If the exact
  numerical result cannot be represented in <code>precision</code>
  digits, rounding selects the set of digits to return and the scale
  of the result is reduced from the scale of the intermediate result
  to the least scale which can represent the <code>precision</code>
  digits actually returned.  If the exact result can be represented
  with at most <code>precision</code> digits, the representation
  of the result with the scale closest to the preferred scale is
  returned.  In particular, an exactly representable quotient may be
  represented in fewer than <code>precision</code> digits by removing
  trailing zeros and decreasing the scale.  For example, rounding to
  three digits using the floor
  rounding mode, <br>
  
 <code>19/100 = 0.19   // integer=19,  scale=2</code> <br>
  but<br>
  
 <code>21/110 = 0.190  // integer=190, scale=3</code> <br>
  
 <p>Note that for add, subtract, and multiply, the reduction in
  scale will equal the number of digit positions of the exact result
  which are discarded. If the rounding causes a carry propagation to
  create a new high-order digit position, an additional digit of the
  result is discarded than when no new digit position is created. 
 <p>Other methods may have slightly different rounding semantics.
  For example, the result of the <code>pow</code> method using the 
 specified algorithm can
  occasionally differ from the rounded mathematical result by more
  than one unit in the last place, one <i>ulp</i>.
  
 <p>Two types of operations are provided for manipulating the scale
  of a <code>BigDecimal</code>: scaling/rounding operations and decimal
  point motion operations.  Scaling/rounding operations (<code>setScale</code>
  and <code>round</code>) return a 
 <code>BigDecimal</code> whose value is approximately (or exactly) equal
  to that of the operand, but whose scale or precision is the
  specified value; that is, they increase or decrease the precision
  of the stored number with minimal effect on its value.  Decimal
  point motion operations (<code>movePointLeft</code> and 
 <code>movePointRight</code>) return a 
 <code>BigDecimal</code> created from the operand by moving the decimal
  point a specified distance in the specified direction. 
 <p>For the sake of brevity and clarity, pseudo-code is used
  throughout the descriptions of <code>BigDecimal</code> methods.  The
  pseudo-code expression <code>(i + j)</code> is shorthand for "a 
 <code>BigDecimal</code> whose value is that of the <code>BigDecimal</code>
  <code>i</code> added to that of the <code>BigDecimal</code>
  <code>j</code>." The pseudo-code expression <code>(i == j)</code> is
  shorthand for "<code>true</code> if and only if the 
 <code>BigDecimal</code> <code>i</code> represents the same value as the 
 <code>BigDecimal</code> <code>j</code>." Other pseudo-code expressions
  are interpreted similarly.  Square brackets are used to represent
  the particular <code>BigInteger</code> and scale pair defining a 
 <code>BigDecimal</code> value; for example [19, 2] is the 
 <code>BigDecimal</code> numerically equal to 0.19 having a scale of 2. 
 <p>Note: care should be exercised if <code>BigDecimal</code> objects
  are used as keys in a <code>SortedMap</code> or
  elements in a <code>SortedSet</code> since 
 <code>BigDecimal</code>'s <i>natural ordering</i> is <i>inconsistent
  with equals</i>.  See <code>Comparable</code>, <code>java.util.SortedMap</code>
  or <code>java.util.SortedSet</code> for more
  information. 
 <p>All methods and constructors for this class throw 
 <code>NullPointerException</code> when passed a <code>null</code> object
  reference for any input parameter.
 - seealso: BigInteger
 - seealso: MathContext
 - seealso: RoundingMode
 - seealso: java.util.SortedMap
 - seealso: java.util.SortedSet
 @author Josh Bloch
 @author Mike Cowlishaw
 @author Joseph D. Darcy
 @author Sergey V. Kuksenko
 */
@interface JavaMathBigDecimal : NSNumber < JavaLangComparable >
@property (readonly, class) jlong INFLATED NS_SWIFT_NAME(INFLATED);
@property (readonly, class, strong) JavaMathBigDecimal *ZERO NS_SWIFT_NAME(ZERO);
@property (readonly, class, strong) JavaMathBigDecimal *ONE NS_SWIFT_NAME(ONE);
@property (readonly, class, strong) JavaMathBigDecimal *TEN NS_SWIFT_NAME(TEN);
@property (readonly, class) jint ROUND_UP NS_SWIFT_NAME(ROUND_UP);
@property (readonly, class) jint ROUND_DOWN NS_SWIFT_NAME(ROUND_DOWN);
@property (readonly, class) jint ROUND_CEILING NS_SWIFT_NAME(ROUND_CEILING);
@property (readonly, class) jint ROUND_FLOOR NS_SWIFT_NAME(ROUND_FLOOR);
@property (readonly, class) jint ROUND_HALF_UP NS_SWIFT_NAME(ROUND_HALF_UP);
@property (readonly, class) jint ROUND_HALF_DOWN NS_SWIFT_NAME(ROUND_HALF_DOWN);
@property (readonly, class) jint ROUND_HALF_EVEN NS_SWIFT_NAME(ROUND_HALF_EVEN);
@property (readonly, class) jint ROUND_UNNECESSARY NS_SWIFT_NAME(ROUND_UNNECESSARY);

+ (jlong)INFLATED;

+ (JavaMathBigDecimal *)ZERO;

+ (JavaMathBigDecimal *)ONE;

+ (JavaMathBigDecimal *)TEN;

+ (jint)ROUND_UP;

+ (jint)ROUND_DOWN;

+ (jint)ROUND_CEILING;

+ (jint)ROUND_FLOOR;

+ (jint)ROUND_HALF_UP;

+ (jint)ROUND_HALF_DOWN;

+ (jint)ROUND_HALF_EVEN;

+ (jint)ROUND_UNNECESSARY;

#pragma mark Public

/*!
 @brief Translates a <code>BigInteger</code> into a <code>BigDecimal</code>.
 The scale of the <code>BigDecimal</code> is zero.
 @param val<code>BigInteger</code>  value to be converted to             
 <code>BigDecimal</code> .
 */
- (instancetype __nonnull)initWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Translates a <code>BigInteger</code> unscaled value and an 
 <code>int</code> scale into a <code>BigDecimal</code>.The value of
  the <code>BigDecimal</code> is 
 <tt>(unscaledVal &times; 10<sup>-scale</sup>)</tt>.
 @param unscaledVal unscaled value of the <code>BigDecimal</code> .
 @param scale_ scale of the <code>BigDecimal</code> .
 */
- (instancetype __nonnull)initWithJavaMathBigInteger:(JavaMathBigInteger *)unscaledVal
                                             withInt:(jint)scale_;

/*!
 @brief Translates a <code>BigInteger</code> unscaled value and an 
 <code>int</code> scale into a <code>BigDecimal</code>, with rounding
  according to the context settings.The value of the 
 <code>BigDecimal</code> is <tt>(unscaledVal &times;
  10<sup>-scale</sup>)</tt>, rounded according to the 
 <code>precision</code> and rounding mode settings.
 @param unscaledVal unscaled value of the <code>BigDecimal</code> .
 @param scale_ scale of the <code>BigDecimal</code> .
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithJavaMathBigInteger:(JavaMathBigInteger *)unscaledVal
                                             withInt:(jint)scale_
                             withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates a <code>BigInteger</code> into a <code>BigDecimal</code>
  rounding according to the context settings.The scale of the 
 <code>BigDecimal</code> is zero.
 @param val<code>BigInteger</code>  value to be converted to             
 <code>BigDecimal</code> .
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithJavaMathBigInteger:(JavaMathBigInteger *)val
                             withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates a character array representation of a 
 <code>BigDecimal</code> into a <code>BigDecimal</code>, accepting the
  same sequence of characters as the <code>BigDecimal(String)</code>
  constructor.
 <p>Note that if the sequence of characters is already available
  as a character array, using this constructor is faster than
  converting the <code>char</code> array to string and using the 
 <code>BigDecimal(String)</code> constructor .
 @param inArg<code>char</code>  array that is the source of characters.
 @throw NumberFormatExceptionif <code>in</code> is not a valid
          representation of a <code>BigDecimal</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithCharArray:(IOSCharArray *)inArg;

/*!
 @brief Translates a character array representation of a 
 <code>BigDecimal</code> into a <code>BigDecimal</code>, accepting the
  same sequence of characters as the <code>BigDecimal(String)</code>
  constructor, while allowing a sub-array to be specified.
 <p>Note that if the sequence of characters is already available
  within a character array, using this constructor is faster than
  converting the <code>char</code> array to string and using the 
 <code>BigDecimal(String)</code> constructor .
 @param inArg<code>char</code>  array that is the source of characters.
 @param offset first character in the array to inspect.
 @param len number of characters to consider.
 @throw NumberFormatExceptionif <code>in</code> is not a valid
          representation of a <code>BigDecimal</code> or the defined subarray
          is not wholly within <code>in</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithCharArray:(IOSCharArray *)inArg
                                    withInt:(jint)offset
                                    withInt:(jint)len;

/*!
 @brief Translates a character array representation of a 
 <code>BigDecimal</code> into a <code>BigDecimal</code>, accepting the
  same sequence of characters as the <code>BigDecimal(String)</code>
  constructor, while allowing a sub-array to be specified and
  with rounding according to the context settings.
 <p>Note that if the sequence of characters is already available
  within a character array, using this constructor is faster than
  converting the <code>char</code> array to string and using the 
 <code>BigDecimal(String)</code> constructor .
 @param inArg<code>char</code>  array that is the source of characters.
 @param offset first character in the array to inspect.
 @param len number of characters to consider..
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @throw NumberFormatExceptionif <code>in</code> is not a valid
          representation of a <code>BigDecimal</code> or the defined subarray
          is not wholly within <code>in</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithCharArray:(IOSCharArray *)inArg
                                    withInt:(jint)offset
                                    withInt:(jint)len
                    withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates a character array representation of a 
 <code>BigDecimal</code> into a <code>BigDecimal</code>, accepting the
  same sequence of characters as the <code>BigDecimal(String)</code>
  constructor and with rounding according to the context
  settings.
 <p>Note that if the sequence of characters is already available
  as a character array, using this constructor is faster than
  converting the <code>char</code> array to string and using the 
 <code>BigDecimal(String)</code> constructor .
 @param inArg<code>char</code>  array that is the source of characters.
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @throw NumberFormatExceptionif <code>in</code> is not a valid
          representation of a <code>BigDecimal</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithCharArray:(IOSCharArray *)inArg
                    withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates a <code>double</code> into a <code>BigDecimal</code> which
  is the exact decimal representation of the <code>double</code>'s
  binary floating-point value.The scale of the returned 
 <code>BigDecimal</code> is the smallest value such that 
 <tt>(10<sup>scale</sup> &times; val)</tt> is an integer.
 <p>
  <b>Notes:</b>
  <ol>
  <li>
  The results of this constructor can be somewhat unpredictable.
  One might assume that writing <code>new BigDecimal(0.1)</code> in
  Java creates a <code>BigDecimal</code> which is exactly equal to
  0.1 (an unscaled value of 1, with a scale of 1), but it is
  actually equal to
  0.1000000000000000055511151231257827021181583404541015625.
  This is because 0.1 cannot be represented exactly as a 
 <code>double</code> (or, for that matter, as a binary fraction of
  any finite length).  Thus, the value that is being passed 
 <i>in</i> to the constructor is not exactly equal to 0.1,
  appearances notwithstanding. 
 <li>
  The <code>String</code> constructor, on the other hand, is
  perfectly predictable: writing <code>new BigDecimal("0.1")</code>
  creates a <code>BigDecimal</code> which is <i>exactly</i> equal to
  0.1, as one would expect.  Therefore, it is generally
  recommended that the <tt>String</tt>constructor
  be used in preference to this one. 
 <li>
  When a <code>double</code> must be used as a source for a 
 <code>BigDecimal</code>, note that this constructor provides an
  exact conversion; it does not give the same result as
  converting the <code>double</code> to a <code>String</code> using the 
 <code>Double.toString(double)</code> method and then using the 
 <code>BigDecimal(String)</code> constructor.  To get that result,
  use the <code>static</code> <code>valueOf(double)</code> method. 
 </ol>
 @param val<code>double</code>  value to be converted to         
 <code>BigDecimal</code> .
 @throw NumberFormatExceptionif <code>val</code> is infinite or NaN.
 */
- (instancetype __nonnull)initWithDouble:(jdouble)val;

/*!
 @brief Translates a <code>double</code> into a <code>BigDecimal</code>, with
  rounding according to the context settings.The scale of the 
 <code>BigDecimal</code> is the smallest value such that 
 <tt>(10<sup>scale</sup> &times; val)</tt> is an integer.
 <p>The results of this constructor can be somewhat unpredictable
  and its use is generally not recommended; see the notes under the 
 <code>BigDecimal(double)</code> constructor.
 @param val<code>double</code>  value to be converted to          
 <code>BigDecimal</code> .
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          RoundingMode is UNNECESSARY.
 @throw NumberFormatExceptionif <code>val</code> is infinite or NaN.
 @since 1.5
 */
- (instancetype __nonnull)initWithDouble:(jdouble)val
                 withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates an <code>int</code> into a <code>BigDecimal</code>.The
  scale of the <code>BigDecimal</code> is zero.
 @param val<code>int</code>  value to be converted to             
 <code>BigDecimal</code> .
 @since 1.5
 */
- (instancetype __nonnull)initWithInt:(jint)val;

/*!
 @brief Translates an <code>int</code> into a <code>BigDecimal</code>, with
  rounding according to the context settings.The scale of the 
 <code>BigDecimal</code>, before any rounding, is zero.
 @param val<code>int</code>  value to be converted to <code>BigDecimal</code> .
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithInt:(jint)val
              withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates a <code>long</code> into a <code>BigDecimal</code>.The
  scale of the <code>BigDecimal</code> is zero.
 @param val<code>long</code>  value to be converted to <code>BigDecimal</code> .
 @since 1.5
 */
- (instancetype __nonnull)initWithLong:(jlong)val;

/*!
 @brief Translates a <code>long</code> into a <code>BigDecimal</code>, with
  rounding according to the context settings.The scale of the 
 <code>BigDecimal</code>, before any rounding, is zero.
 @param val<code>long</code>  value to be converted to <code>BigDecimal</code> .
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (instancetype __nonnull)initWithLong:(jlong)val
               withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Translates the string representation of a <code>BigDecimal</code>
  into a <code>BigDecimal</code>.The string representation consists
  of an optional sign, <code>'+'</code> (<tt> '&#92;u002B'</tt>) or 
 <code>'-'</code> (<tt>'&#92;u002D'</tt>), followed by a sequence of
  zero or more decimal digits ("the integer"), optionally
  followed by a fraction, optionally followed by an exponent.
 <p>The fraction consists of a decimal point followed by zero
  or more decimal digits.  The string must contain at least one
  digit in either the integer or the fraction.  The number formed
  by the sign, the integer and the fraction is referred to as the 
 <i>significand</i>.
  
 <p>The exponent consists of the character <code>'e'</code>
  (<tt>'&#92;u0065'</tt>) or <code>'E'</code> (<tt>'&#92;u0045'</tt>)
  followed by one or more decimal digits.  The value of the
  exponent must lie between -<code>Integer.MAX_VALUE</code> (<code>Integer.MIN_VALUE</code>
 +1) and <code>Integer.MAX_VALUE</code>, inclusive. 
 <p>More formally, the strings this constructor accepts are
  described by the following grammar: 
 <blockquote>
  <dl>
  <dt><i>BigDecimalString:</i>
  <dd><i>Sign<sub>opt</sub> Significand Exponent<sub>opt</sub></i>
  <dt><i>Sign:</i>
  <dd><code>+</code>
  <dd><code>-</code>
  <dt><i>Significand:</i>
  <dd><i>IntegerPart</i> <code>.</code> <i>FractionPart<sub>opt</sub></i>
  <dd><code>.</code> <i>FractionPart</i>
  <dd><i>IntegerPart</i>
  <dt><i>IntegerPart:</i>
  <dd><i>Digits</i>
  <dt><i>FractionPart:</i>
  <dd><i>Digits</i>
  <dt><i>Exponent:</i>
  <dd><i>ExponentIndicator SignedInteger</i>
  <dt><i>ExponentIndicator:</i>
  <dd><code>e</code>
  <dd><code>E</code>
  <dt><i>SignedInteger:</i>
  <dd><i>Sign<sub>opt</sub> Digits</i>
  <dt><i>Digits:</i>
  <dd><i>Digit</i>
  <dd><i>Digits Digit</i>
  <dt><i>Digit:</i>
  <dd>any character for which <code>Character.isDigit</code>
  returns <code>true</code>, including 0, 1, 2 ... 
 </dl>
  </blockquote>
  
 <p>The scale of the returned <code>BigDecimal</code> will be the
  number of digits in the fraction, or zero if the string
  contains no decimal point, subject to adjustment for any
  exponent; if the string contains an exponent, the exponent is
  subtracted from the scale.  The value of the resulting scale
  must lie between <code>Integer.MIN_VALUE</code> and 
 <code>Integer.MAX_VALUE</code>, inclusive. 
 <p>The character-to-digit mapping is provided by <code>java.lang.Character.digit</code>
  set to convert to radix 10.  The
  String may not contain any extraneous characters (whitespace,
  for example). 
 <p><b>Examples:</b><br>
  The value of the returned <code>BigDecimal</code> is equal to 
 <i>significand</i> &times; 10<sup>&nbsp;<i>exponent</i></sup>.
  For each string on the left, the resulting representation
  [<code>BigInteger</code>, <code>scale</code>] is shown on the right. 
 @code

  "0"            [0,0]
  "0.00"         [0,2]
  "123"          [123,0]
  "-123"         [-123,0]
  "1.23E3"       [123,-1]
  "1.23E+3"      [123,-1]
  "12.3E+7"      [123,-6]
  "12.0"         [120,1]
  "12.3"         [123,1]
  "0.00123"      [123,5]
  "-1.23E-12"    [-123,14]
  "1234.5E-4"    [12345,5]
  "0E+7"         [0,-7]
  "-0"           [0,0] 
  
@endcode
  
 <p>Note: For values other than <code>float</code> and 
 <code>double</code> NaN and &plusmn;Infinity, this constructor is
  compatible with the values returned by <code>Float.toString</code>
  and <code>Double.toString</code>.  This is generally the preferred
  way to convert a <code>float</code> or <code>double</code> into a
  BigDecimal, as it doesn't suffer from the unpredictability of the 
 <code>BigDecimal(double)</code> constructor.
 @param val String representation of <code>BigDecimal</code> .
 @throw NumberFormatExceptionif <code>val</code> is not a valid
          representation of a <code>BigDecimal</code>.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)val;

/*!
 @brief Translates the string representation of a <code>BigDecimal</code>
  into a <code>BigDecimal</code>, accepting the same strings as the 
 <code>BigDecimal(String)</code> constructor, with rounding
  according to the context settings.
 @param val string representation of a <code>BigDecimal</code> .
 @param mc the context to use.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @throw NumberFormatExceptionif <code>val</code> is not a valid
          representation of a BigDecimal.
 @since 1.5
 */
- (instancetype __nonnull)initWithNSString:(NSString *)val
                   withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is the absolute value
  of this <code>BigDecimal</code>, and whose scale is 
 <code>this.scale()</code>.
 @return <code>abs(this)</code>
 */
- (JavaMathBigDecimal *)abs;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is the absolute value
  of this <code>BigDecimal</code>, with rounding according to the
  context settings.
 @param mc the context to use.
 @return <code>abs(this)</code>, rounded as necessary.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (JavaMathBigDecimal *)absWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this +
  augend)</code>
 , and whose scale is <code>max(this.scale(),
  augend.scale())</code>
 .
 @param augend value to be added to this <code>BigDecimal</code> .
 @return <code>this + augend</code>
 */
- (JavaMathBigDecimal *)addWithJavaMathBigDecimal:(JavaMathBigDecimal *)augend;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this + augend)</code>,
  with rounding according to the context settings.
 If either number is zero and the precision setting is nonzero then
  the other number, rounded if necessary, is used as the result.
 @param augend value to be added to this <code>BigDecimal</code> .
 @param mc the context to use.
 @return <code>this + augend</code>, rounded as necessary.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (JavaMathBigDecimal *)addWithJavaMathBigDecimal:(JavaMathBigDecimal *)augend
                          withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>byte</code>, checking
  for lost information.If this <code>BigDecimal</code> has a
  nonzero fractional part or is out of the possible range for a 
 <code>byte</code> result then an <code>ArithmeticException</code> is
  thrown.
 @return this <code>BigDecimal</code> converted to a <code>byte</code>.
 @throw ArithmeticExceptionif <code>this</code> has a nonzero
          fractional part, or will not fit in a <code>byte</code>.
 @since 1.5
 */
- (jbyte)byteValueExact;

/*!
 @brief Compares this <code>BigDecimal</code> with the specified 
 <code>BigDecimal</code>.Two <code>BigDecimal</code> objects that are
  equal in value but have a different scale (like 2.0 and 2.00)
  are considered equal by this method.
 This method is provided
  in preference to individual methods for each of the six boolean
  comparison operators (&lt;, ==, 
 &gt;, &gt;=, !=, &lt;=).  The
  suggested idiom for performing these comparisons is: 
 <code>(x.compareTo(y)</code> &lt;<i>op</i>&gt; <code>0)</code>, where 
 &lt;<i>op</i>&gt; is one of the six comparison operators.
 @param val<code>BigDecimal</code>  to which this <code>BigDecimal</code>  is
           to be compared.
 @return -1, 0, or 1 as this <code>BigDecimal</code> is numerically
           less than, equal to, or greater than <code>val</code>.
 */
- (jint)compareToWithId:(JavaMathBigDecimal *)val;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this /
  divisor)</code>
 , and whose preferred scale is <code>(this.scale() -
  divisor.scale())</code>
 ; if the exact quotient cannot be
  represented (because it has a non-terminating decimal
  expansion) an <code>ArithmeticException</code> is thrown.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @throw ArithmeticExceptionif the exact quotient does not have a
          terminating decimal expansion
 @return <code>this / divisor</code>
 @since 1.5
 @author Joseph D. Darcy
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this /
  divisor)</code>
 , and whose scale is <code>this.scale()</code>.If
  rounding must be performed to generate a result with the given
  scale, the specified rounding mode is applied.
 <p>The new <code>divide(BigDecimal, RoundingMode)</code> method
  should be used in preference to this legacy method.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param roundingMode rounding mode to apply.
 @return <code>this / divisor</code>
 @throw ArithmeticExceptionif <code>divisor==0</code>, or
          <code>roundingMode==ROUND_UNNECESSARY</code> and
          <code>this.scale()</code> is insufficient to represent the result
          of the division exactly.
 @throw IllegalArgumentExceptionif <code>roundingMode</code> does not
          represent a valid rounding mode.
 - seealso: #ROUND_UP
 - seealso: #ROUND_DOWN
 - seealso: #ROUND_CEILING
 - seealso: #ROUND_FLOOR
 - seealso: #ROUND_HALF_UP
 - seealso: #ROUND_HALF_DOWN
 - seealso: #ROUND_HALF_EVEN
 - seealso: #ROUND_UNNECESSARY
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                             withInt:(jint)roundingMode;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this /
  divisor)</code>
 , and whose scale is as specified.If rounding must
  be performed to generate a result with the specified scale, the
  specified rounding mode is applied.
 <p>The new <code>divide(BigDecimal, int, RoundingMode)</code> method
  should be used in preference to this legacy method.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param scale_ scale of the <code>BigDecimal</code>  quotient to be returned.
 @param roundingMode rounding mode to apply.
 @return <code>this / divisor</code>
 @throw ArithmeticExceptionif <code>divisor</code> is zero,
          <code>roundingMode==ROUND_UNNECESSARY</code> and
          the specified scale is insufficient to represent the result
          of the division exactly.
 @throw IllegalArgumentExceptionif <code>roundingMode</code> does not
          represent a valid rounding mode.
 - seealso: #ROUND_UP
 - seealso: #ROUND_DOWN
 - seealso: #ROUND_CEILING
 - seealso: #ROUND_FLOOR
 - seealso: #ROUND_HALF_UP
 - seealso: #ROUND_HALF_DOWN
 - seealso: #ROUND_HALF_EVEN
 - seealso: #ROUND_UNNECESSARY
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                             withInt:(jint)scale_
                                             withInt:(jint)roundingMode;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this /
  divisor)</code>
 , and whose scale is as specified.If rounding must
  be performed to generate a result with the specified scale, the
  specified rounding mode is applied.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param scale_ scale of the <code>BigDecimal</code>  quotient to be returned.
 @param roundingMode rounding mode to apply.
 @return <code>this / divisor</code>
 @throw ArithmeticExceptionif <code>divisor</code> is zero,
          <code>roundingMode==RoundingMode.UNNECESSARY</code> and
          the specified scale is insufficient to represent the result
          of the division exactly.
 @since 1.5
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                             withInt:(jint)scale_
                            withJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this /
  divisor)</code>
 , with rounding according to the context settings.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param mc the context to use.
 @return <code>this / divisor</code>, rounded as necessary.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code> or
          <code>mc.precision == 0</code> and the quotient has a
          non-terminating decimal expansion.
 @since 1.5
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                             withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this /
  divisor)</code>
 , and whose scale is <code>this.scale()</code>.If
  rounding must be performed to generate a result with the given
  scale, the specified rounding mode is applied.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param roundingMode rounding mode to apply.
 @return <code>this / divisor</code>
 @throw ArithmeticExceptionif <code>divisor==0</code>, or
          <code>roundingMode==RoundingMode.UNNECESSARY</code> and
          <code>this.scale()</code> is insufficient to represent the result
          of the division exactly.
 @since 1.5
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                            withJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Returns a two-element <code>BigDecimal</code> array containing the
  result of <code>divideToIntegralValue</code> followed by the result of 
 <code>remainder</code> on the two operands.
 <p>Note that if both the integer quotient and remainder are
  needed, this method is faster than using the 
 <code>divideToIntegralValue</code> and <code>remainder</code> methods
  separately because the division need only be carried out once.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided,
           and the remainder computed.
 @return a two element <code>BigDecimal</code> array: the quotient
          (the result of <code>divideToIntegralValue</code>) is the initial element
          and the remainder is the final element.
 @throw ArithmeticExceptionif <code>divisor==0</code>
 - seealso: #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
 - seealso: #remainder(java.math.BigDecimal, java.math.MathContext)
 @since 1.5
 */
- (IOSObjectArray *)divideAndRemainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a two-element <code>BigDecimal</code> array containing the
  result of <code>divideToIntegralValue</code> followed by the result of 
 <code>remainder</code> on the two operands calculated with rounding
  according to the context settings.
 <p>Note that if both the integer quotient and remainder are
  needed, this method is faster than using the 
 <code>divideToIntegralValue</code> and <code>remainder</code> methods
  separately because the division need only be carried out once.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided,
           and the remainder computed.
 @param mc the context to use.
 @return a two element <code>BigDecimal</code> array: the quotient
          (the result of <code>divideToIntegralValue</code>) is the
          initial element and the remainder is the final element.
 @throw ArithmeticExceptionif <code>divisor==0</code>
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>, or <code>mc.precision</code>
          &gt; 0 and the result of <code>this.divideToIntgralValue(divisor)</code> would
          require a precision of more than <code>mc.precision</code> digits.
 - seealso: #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
 - seealso: #remainder(java.math.BigDecimal, java.math.MathContext)
 @since 1.5
 */
- (IOSObjectArray *)divideAndRemainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                     withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is the integer part
  of the quotient <code>(this / divisor)</code> rounded down.The
  preferred scale of the result is <code>(this.scale() -
  divisor.scale())</code>
 .
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @return The integer part of <code>this / divisor</code>.
 @throw ArithmeticExceptionif <code>divisor==0</code>
 @since 1.5
 */
- (JavaMathBigDecimal *)divideToIntegralValueWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is the integer part
  of <code>(this / divisor)</code>.Since the integer part of the
  exact quotient does not depend on the rounding mode, the
  rounding mode does not affect the values returned by this
  method.
 The preferred scale of the result is 
 <code>(this.scale() - divisor.scale())</code>.  An 
 <code>ArithmeticException</code> is thrown if the integer part of
  the exact quotient needs more than <code>mc.precision</code>
  digits.
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param mc the context to use.
 @return The integer part of <code>this / divisor</code>.
 @throw ArithmeticExceptionif <code>divisor==0</code>
 @throw ArithmeticExceptionif <code>mc.precision</code> &gt; 0 and the result
          requires a precision of more than <code>mc.precision</code> digits.
 @since 1.5
 @author Joseph D. Darcy
 */
- (JavaMathBigDecimal *)divideToIntegralValueWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                            withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>double</code>.
 This conversion is similar to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>float</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  if this <code>BigDecimal</code> has too great a
  magnitude represent as a <code>double</code>, it will be
  converted to <code>Double.NEGATIVE_INFINITY</code> or <code>Double.POSITIVE_INFINITY</code>
  as appropriate.  Note that even when
  the return value is finite, this conversion can lose
  information about the precision of the <code>BigDecimal</code>
  value.
 @return this <code>BigDecimal</code> converted to a <code>double</code>.
 */
- (jdouble)doubleValue;

/*!
 @brief Compares this <code>BigDecimal</code> with the specified 
 <code>Object</code> for equality.Unlike <code>compareTo</code>
 , this method considers two 
 <code>BigDecimal</code> objects equal only if they are equal in
  value and scale (thus 2.0 is not equal to 2.00 when compared by
  this method).
 @param x<code>Object</code>  to which this <code>BigDecimal</code>  is
           to be compared.
 @return <code>true</code> if and only if the specified <code>Object</code> is a
          <code>BigDecimal</code> whose value and scale are equal to this
          <code>BigDecimal</code>'s.
 - seealso: #compareTo(java.math.BigDecimal)
 - seealso: #hashCode
 */
- (jboolean)isEqual:(id)x;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>float</code>.
 This conversion is similar to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>float</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  if this <code>BigDecimal</code> has too great a
  magnitude to represent as a <code>float</code>, it will be
  converted to <code>Float.NEGATIVE_INFINITY</code> or <code>Float.POSITIVE_INFINITY</code>
  as appropriate.  Note that even when
  the return value is finite, this conversion can lose
  information about the precision of the <code>BigDecimal</code>
  value.
 @return this <code>BigDecimal</code> converted to a <code>float</code>.
 */
- (jfloat)floatValue;

/*!
 @brief Returns the hash code for this <code>BigDecimal</code>.Note that
  two <code>BigDecimal</code> objects that are numerically equal but
  differ in scale (like 2.0 and 2.00) will generally <i>not</i>
  have the same hash code.
 @return hash code for this <code>BigDecimal</code>.
 - seealso: #equals(Object)
 */
- (NSUInteger)hash;

/*!
 @brief Converts this <code>BigDecimal</code> to an <code>int</code>.
 This conversion is analogous to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>short</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  any fractional part of this 
 <code>BigDecimal</code> will be discarded, and if the resulting
  "<code>BigInteger</code>" is too big to fit in an 
 <code>int</code>, only the low-order 32 bits are returned.
  Note that this conversion can lose information about the
  overall magnitude and precision of this <code>BigDecimal</code>
  value as well as return a result with the opposite sign.
 @return this <code>BigDecimal</code> converted to an <code>int</code>.
 */
- (jint)intValue;

/*!
 @brief Converts this <code>BigDecimal</code> to an <code>int</code>, checking
  for lost information.If this <code>BigDecimal</code> has a
  nonzero fractional part or is out of the possible range for an 
 <code>int</code> result then an <code>ArithmeticException</code> is
  thrown.
 @return this <code>BigDecimal</code> converted to an <code>int</code>.
 @throw ArithmeticExceptionif <code>this</code> has a nonzero
          fractional part, or will not fit in an <code>int</code>.
 @since 1.5
 */
- (jint)intValueExact;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>long</code>.
 This conversion is analogous to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>short</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  any fractional part of this 
 <code>BigDecimal</code> will be discarded, and if the resulting
  "<code>BigInteger</code>" is too big to fit in a 
 <code>long</code>, only the low-order 64 bits are returned.
  Note that this conversion can lose information about the
  overall magnitude and precision of this <code>BigDecimal</code> value as well
  as return a result with the opposite sign.
 @return this <code>BigDecimal</code> converted to a <code>long</code>.
 */
- (jlong)longLongValue;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>long</code>, checking
  for lost information.If this <code>BigDecimal</code> has a
  nonzero fractional part or is out of the possible range for a 
 <code>long</code> result then an <code>ArithmeticException</code> is
  thrown.
 @return this <code>BigDecimal</code> converted to a <code>long</code>.
 @throw ArithmeticExceptionif <code>this</code> has a nonzero
          fractional part, or will not fit in a <code>long</code>.
 @since 1.5
 */
- (jlong)longValueExact;

/*!
 @brief Returns the maximum of this <code>BigDecimal</code> and <code>val</code>.
 @param val value with which the maximum is to be computed.
 @return the <code>BigDecimal</code> whose value is the greater of this
          <code>BigDecimal</code> and <code>val</code>.  If they are equal,
          as defined by the <code>compareTo</code>
          method, <code>this</code> is returned.
 - seealso: #compareTo(java.math.BigDecimal)
 */
- (JavaMathBigDecimal *)maxWithJavaMathBigDecimal:(JavaMathBigDecimal *)val;

/*!
 @brief Returns the minimum of this <code>BigDecimal</code> and 
 <code>val</code>.
 @param val value with which the minimum is to be computed.
 @return the <code>BigDecimal</code> whose value is the lesser of this
          <code>BigDecimal</code> and <code>val</code>.  If they are equal,
          as defined by the <code>compareTo</code>
          method, <code>this</code> is returned.
 - seealso: #compareTo(java.math.BigDecimal)
 */
- (JavaMathBigDecimal *)minWithJavaMathBigDecimal:(JavaMathBigDecimal *)val;

/*!
 @brief Returns a <code>BigDecimal</code> which is equivalent to this one
  with the decimal point moved <code>n</code> places to the left.If
  <code>n</code> is non-negative, the call merely adds <code>n</code> to
  the scale.
 If <code>n</code> is negative, the call is equivalent
  to <code>movePointRight(-n)</code>.  The <code>BigDecimal</code>
  returned by this call has value <tt>(this &times;
  10<sup>-n</sup>)</tt> and scale <code>max(this.scale()+n,
  0)</code>
 .
 @param n number of places to move the decimal point to the left.
 @return a <code>BigDecimal</code> which is equivalent to this one with the
          decimal point moved <code>n</code> places to the left.
 @throw ArithmeticExceptionif scale overflows.
 */
- (JavaMathBigDecimal *)movePointLeftWithInt:(jint)n;

/*!
 @brief Returns a <code>BigDecimal</code> which is equivalent to this one
  with the decimal point moved <code>n</code> places to the right.
 If <code>n</code> is non-negative, the call merely subtracts 
 <code>n</code> from the scale.  If <code>n</code> is negative, the call
  is equivalent to <code>movePointLeft(-n)</code>.  The 
 <code>BigDecimal</code> returned by this call has value <tt>(this
  &times; 10<sup>n</sup>)</tt> and scale <code>max(this.scale()-n,
  0)</code>
 .
 @param n number of places to move the decimal point to the right.
 @return a <code>BigDecimal</code> which is equivalent to this one
          with the decimal point moved <code>n</code> places to the right.
 @throw ArithmeticExceptionif scale overflows.
 */
- (JavaMathBigDecimal *)movePointRightWithInt:(jint)n;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <tt>(this &times;
  multiplicand)</tt>, and whose scale is <code>(this.scale() +
  multiplicand.scale())</code>
 .
 @param multiplicand value to be multiplied by this <code>BigDecimal</code> .
 @return <code>this * multiplicand</code>
 */
- (JavaMathBigDecimal *)multiplyWithJavaMathBigDecimal:(JavaMathBigDecimal *)multiplicand;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <tt>(this &times;
  multiplicand)</tt>, with rounding according to the context settings.
 @param multiplicand value to be multiplied by this <code>BigDecimal</code> .
 @param mc the context to use.
 @return <code>this * multiplicand</code>, rounded as necessary.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (JavaMathBigDecimal *)multiplyWithJavaMathBigDecimal:(JavaMathBigDecimal *)multiplicand
                               withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(-this)</code>,
  and whose scale is <code>this.scale()</code>.
 @return <code>-this</code>.
 */
- (JavaMathBigDecimal *)negate;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(-this)</code>,
  with rounding according to the context settings.
 @param mc the context to use.
 @return <code>-this</code>, rounded as necessary.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (JavaMathBigDecimal *)negateWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(+this)</code>, and whose
  scale is <code>this.scale()</code>.
 <p>This method, which simply returns this <code>BigDecimal</code>
  is included for symmetry with the unary minus method <code>negate()</code>
 .
 @return <code>this</code>.
 - seealso: #negate()
 @since 1.5
 */
- (JavaMathBigDecimal *)plus;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(+this)</code>,
  with rounding according to the context settings.
 <p>The effect of this method is identical to that of the <code>round(MathContext)</code>
  method.
 @param mc the context to use.
 @return <code>this</code>, rounded as necessary.  A zero result will
          have a scale of 0.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 - seealso: #round(MathContext)
 @since 1.5
 */
- (JavaMathBigDecimal *)plusWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is 
 <tt>(this<sup>n</sup>)</tt>, The power is computed exactly, to
  unlimited precision.
 <p>The parameter <code>n</code> must be in the range 0 through
  999999999, inclusive.  <code>ZERO.pow(0)</code> returns <code>ONE</code>
 .
  Note that future releases may expand the allowable exponent
  range of this method.
 @param n power to raise this <code>BigDecimal</code>  to.
 @return <tt>this<sup>n</sup></tt>
 @throw ArithmeticExceptionif <code>n</code> is out of range.
 @since 1.5
 */
- (JavaMathBigDecimal *)powWithInt:(jint)n;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is 
 <tt>(this<sup>n</sup>)</tt>.The current implementation uses
  the core algorithm defined in ANSI standard X3.274-1996 with
  rounding according to the context settings.
 In general, the
  returned numerical value is within two ulps of the exact
  numerical value for the chosen precision.  Note that future
  releases may use a different algorithm with a decreased
  allowable error bound and increased allowable exponent range. 
 <p>The X3.274-1996 algorithm is: 
 <ul>
  <li> An <code>ArithmeticException</code> exception is thrown if
   <ul>
     <li><code>abs(n) > 999999999</code>
     <li><code>mc.precision == 0</code> and <code>n < 0</code>
     <li><code>mc.precision > 0</code> and <code>n</code> has more than
     <code>mc.precision</code> decimal digits
   </ul>
  
 <li> if <code>n</code> is zero, <code>ONE</code> is returned even if 
 <code>this</code> is zero, otherwise 
 <ul>
    <li> if <code>n</code> is positive, the result is calculated via
    the repeated squaring technique into a single accumulator.
    The individual multiplications with the accumulator use the
    same math context settings as in <code>mc</code> except for a
    precision increased to <code>mc.precision + elength + 1</code>
    where <code>elength</code> is the number of decimal digits in
    <code>n</code>.
    
 <li> if <code>n</code> is negative, the result is calculated as if
    <code>n</code> were positive; this value is then divided into one
    using the working precision specified above.   
 <li> The final value from either the positive or negative case
    is then rounded to the destination precision.   
 </ul>
  </ul>
 @param n power to raise this <code>BigDecimal</code>  to.
 @param mc the context to use.
 @return <tt>this<sup>n</sup></tt> using the ANSI standard X3.274-1996
          algorithm
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>, or <code>n</code> is out
          of range.
 @since 1.5
 */
- (JavaMathBigDecimal *)powWithInt:(jint)n
           withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns the <i>precision</i> of this <code>BigDecimal</code>.
 (The
  precision is the number of digits in the unscaled value.) 
 <p>The precision of a zero value is 1.
 @return the precision of this <code>BigDecimal</code>.
 @since 1.5
 */
- (jint)precision;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this % divisor)</code>.
 <p>The remainder is given by 
 <code>this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))</code>.
  Note that this is not the modulo operation (the result can be
  negative).
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @return <code>this % divisor</code>.
 @throw ArithmeticExceptionif <code>divisor==0</code>
 @since 1.5
 */
- (JavaMathBigDecimal *)remainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this %
  divisor)</code>
 , with rounding according to the context settings.
 The <code>MathContext</code> settings affect the implicit divide
  used to compute the remainder.  The remainder computation
  itself is by definition exact.  Therefore, the remainder may
  contain more than <code>mc.getPrecision()</code> digits. 
 <p>The remainder is given by 
 <code>this.subtract(this.divideToIntegralValue(divisor,
  mc).multiply(divisor))</code>
 .  Note that this is not the modulo
  operation (the result can be negative).
 @param divisor value by which this <code>BigDecimal</code>  is to be divided.
 @param mc the context to use.
 @return <code>this % divisor</code>, rounded as necessary.
 @throw ArithmeticExceptionif <code>divisor==0</code>
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>, or <code>mc.precision</code>
          &gt; 0 and the result of <code>this.divideToIntgralValue(divisor)</code> would
          require a precision of more than <code>mc.precision</code> digits.
 - seealso: #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
 @since 1.5
 */
- (JavaMathBigDecimal *)remainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a <code>BigDecimal</code> rounded according to the 
 <code>MathContext</code> settings.If the precision setting is 0 then
  no rounding takes place.
 <p>The effect of this method is identical to that of the 
 <code>plus(MathContext)</code> method.
 @param mc the context to use.
 @return a <code>BigDecimal</code> rounded according to the
          <code>MathContext</code> settings.
 @throw ArithmeticExceptionif the rounding mode is
          <code>UNNECESSARY</code> and the
          <code>BigDecimal</code>  operation would require rounding.
 - seealso: #plus(MathContext)
 @since 1.5
 */
- (JavaMathBigDecimal *)roundWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns the <i>scale</i> of this <code>BigDecimal</code>.If zero
  or positive, the scale is the number of digits to the right of
  the decimal point.
 If negative, the unscaled value of the
  number is multiplied by ten to the power of the negation of the
  scale.  For example, a scale of <code>-3</code> means the unscaled
  value is multiplied by 1000.
 @return the scale of this <code>BigDecimal</code>.
 */
- (jint)scale__;

/*!
 @brief Returns a BigDecimal whose numerical value is equal to
  (<code>this</code> * 10<sup>n</sup>).The scale of
  the result is <code>(this.scale() - n)</code>.
 @param n the exponent power of ten to scale by
 @return a BigDecimal whose numerical value is equal to
  (<code>this</code> * 10<sup>n</sup>)
 @throw ArithmeticExceptionif the scale would be
          outside the range of a 32-bit integer.
 @since 1.5
 */
- (JavaMathBigDecimal *)scaleByPowerOfTenWithInt:(jint)n;

/*!
 @brief Returns a <code>BigDecimal</code> whose scale is the specified
  value, and whose value is numerically equal to this 
 <code>BigDecimal</code>'s.Throws an <code>ArithmeticException</code>
  if this is not possible.
 <p>This call is typically used to increase the scale, in which
  case it is guaranteed that there exists a <code>BigDecimal</code>
  of the specified scale and the correct value.  The call can
  also be used to reduce the scale if the caller knows that the 
 <code>BigDecimal</code> has sufficiently many zeros at the end of
  its fractional part (i.e., factors of ten in its integer value)
  to allow for the rescaling without changing its value. 
 <p>This method returns the same result as the two-argument
  versions of <code>setScale</code>, but saves the caller the trouble
  of specifying a rounding mode in cases where it is irrelevant. 
 <p>Note that since <code>BigDecimal</code> objects are immutable,
  calls of this method do <i>not</i> result in the original
  object being modified, contrary to the usual convention of
  having methods named <tt>set<i>X</i></tt> mutate field 
 <i><code>X</code></i>.  Instead, <code>setScale</code> returns an
  object with the proper scale; the returned object may or may
  not be newly allocated.
 @param newScale scale of the <code>BigDecimal</code>  value to be returned.
 @return a <code>BigDecimal</code> whose scale is the specified value, and
          whose unscaled value is determined by multiplying or dividing
          this <code>BigDecimal</code>'s unscaled value by the appropriate
          power of ten to maintain its overall value.
 @throw ArithmeticExceptionif the specified scaling operation would
          require rounding.
 - seealso: #setScale(int, int)
 - seealso: #setScale(int, RoundingMode)
 */
- (JavaMathBigDecimal *)setScaleWithInt:(jint)newScale;

/*!
 @brief Returns a <code>BigDecimal</code> whose scale is the specified
  value, and whose unscaled value is determined by multiplying or
  dividing this <code>BigDecimal</code>'s unscaled value by the
  appropriate power of ten to maintain its overall value.If the
  scale is reduced by the operation, the unscaled value must be
  divided (rather than multiplied), and the value may be changed;
  in this case, the specified rounding mode is applied to the
  division.
 <p>Note that since BigDecimal objects are immutable, calls of
  this method do <i>not</i> result in the original object being
  modified, contrary to the usual convention of having methods
  named <tt>set<i>X</i></tt> mutate field <i><code>X</code></i>.
  Instead, <code>setScale</code> returns an object with the proper
  scale; the returned object may or may not be newly allocated. 
 <p>The new <code>setScale(int, RoundingMode)</code> method should
  be used in preference to this legacy method.
 @param newScale scale of the <code>BigDecimal</code>  value to be returned.
 @param roundingMode The rounding mode to apply.
 @return a <code>BigDecimal</code> whose scale is the specified value,
          and whose unscaled value is determined by multiplying or
          dividing this <code>BigDecimal</code>'s unscaled value by the
          appropriate power of ten to maintain its overall value.
 @throw ArithmeticExceptionif <code>roundingMode==ROUND_UNNECESSARY</code>
          and the specified scaling operation would require
          rounding.
 @throw IllegalArgumentExceptionif <code>roundingMode</code> does not
          represent a valid rounding mode.
 - seealso: #ROUND_UP
 - seealso: #ROUND_DOWN
 - seealso: #ROUND_CEILING
 - seealso: #ROUND_FLOOR
 - seealso: #ROUND_HALF_UP
 - seealso: #ROUND_HALF_DOWN
 - seealso: #ROUND_HALF_EVEN
 - seealso: #ROUND_UNNECESSARY
 */
- (JavaMathBigDecimal *)setScaleWithInt:(jint)newScale
                                withInt:(jint)roundingMode;

/*!
 @brief Returns a <code>BigDecimal</code> whose scale is the specified
  value, and whose unscaled value is determined by multiplying or
  dividing this <code>BigDecimal</code>'s unscaled value by the
  appropriate power of ten to maintain its overall value.If the
  scale is reduced by the operation, the unscaled value must be
  divided (rather than multiplied), and the value may be changed;
  in this case, the specified rounding mode is applied to the
  division.
 <p>Note that since BigDecimal objects are immutable, calls of
  this method do <i>not</i> result in the original object being
  modified, contrary to the usual convention of having methods
  named <tt>set<i>X</i></tt> mutate field <i><code>X</code></i>.
  Instead, <code>setScale</code> returns an object with the proper
  scale; the returned object may or may not be newly allocated.
 @param newScale scale of the <code>BigDecimal</code>  value to be returned.
 @param roundingMode The rounding mode to apply.
 @return a <code>BigDecimal</code> whose scale is the specified value,
          and whose unscaled value is determined by multiplying or
          dividing this <code>BigDecimal</code>'s unscaled value by the
          appropriate power of ten to maintain its overall value.
 @throw ArithmeticExceptionif <code>roundingMode==UNNECESSARY</code>
          and the specified scaling operation would require
          rounding.
 - seealso: RoundingMode
 @since 1.5
 */
- (JavaMathBigDecimal *)setScaleWithInt:(jint)newScale
               withJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>short</code>, checking
  for lost information.If this <code>BigDecimal</code> has a
  nonzero fractional part or is out of the possible range for a 
 <code>short</code> result then an <code>ArithmeticException</code> is
  thrown.
 @return this <code>BigDecimal</code> converted to a <code>short</code>.
 @throw ArithmeticExceptionif <code>this</code> has a nonzero
          fractional part, or will not fit in a <code>short</code>.
 @since 1.5
 */
- (jshort)shortValueExact;

/*!
 @brief Returns the signum function of this <code>BigDecimal</code>.
 @return -1, 0, or 1 as the value of this <code>BigDecimal</code>
          is negative, zero, or positive.
 */
- (jint)signum;

/*!
 @brief Returns a <code>BigDecimal</code> which is numerically equal to
  this one but with any trailing zeros removed from the
  representation.For example, stripping the trailing zeros from the 
 <code>BigDecimal</code> value <code>600.0</code>, which has
  [<code>BigInteger</code>, <code>scale</code>] components equals to
  [6000, 1], yields <code>6E2</code> with [<code>BigInteger</code>,
  <code>scale</code>] components equals to [6, -2].
 If
  this BigDecimal is numerically equal to zero, then 
 <code>BigDecimal.ZERO</code> is returned.
 @return a numerically equal <code>BigDecimal</code> with any
  trailing zeros removed.
 @since 1.5
 */
- (JavaMathBigDecimal *)stripTrailingZeros;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this -
  subtrahend)</code>
 , and whose scale is <code>max(this.scale(),
  subtrahend.scale())</code>
 .
 @param subtrahend value to be subtracted from this <code>BigDecimal</code> .
 @return <code>this - subtrahend</code>
 */
- (JavaMathBigDecimal *)subtractWithJavaMathBigDecimal:(JavaMathBigDecimal *)subtrahend;

/*!
 @brief Returns a <code>BigDecimal</code> whose value is <code>(this - subtrahend)</code>,
  with rounding according to the context settings.
 If <code>subtrahend</code> is zero then this, rounded if necessary, is used as the
  result.  If this is zero then the result is <code>subtrahend.negate(mc)</code>.
 @param subtrahend value to be subtracted from this <code>BigDecimal</code> .
 @param mc the context to use.
 @return <code>this - subtrahend</code>, rounded as necessary.
 @throw ArithmeticExceptionif the result is inexact but the
          rounding mode is <code>UNNECESSARY</code>.
 @since 1.5
 */
- (JavaMathBigDecimal *)subtractWithJavaMathBigDecimal:(JavaMathBigDecimal *)subtrahend
                               withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>BigInteger</code>.
 This conversion is analogous to the 
 <i>narrowing primitive conversion</i> from <code>double</code> to 
 <code>long</code> as defined in section 5.1.3 of 
 <cite>The Java&trade; Language Specification</cite>:
  any fractional part of this 
 <code>BigDecimal</code> will be discarded.  Note that this
  conversion can lose information about the precision of the 
 <code>BigDecimal</code> value. 
 <p>
  To have an exception thrown if the conversion is inexact (in
  other words if a nonzero fractional part is discarded), use the 
 <code>toBigIntegerExact()</code> method.
 @return this <code>BigDecimal</code> converted to a <code>BigInteger</code>.
 */
- (JavaMathBigInteger *)toBigInteger;

/*!
 @brief Converts this <code>BigDecimal</code> to a <code>BigInteger</code>,
  checking for lost information.An exception is thrown if this 
 <code>BigDecimal</code> has a nonzero fractional part.
 @return this <code>BigDecimal</code> converted to a <code>BigInteger</code>.
 @throw ArithmeticExceptionif <code>this</code> has a nonzero
          fractional part.
 @since 1.5
 */
- (JavaMathBigInteger *)toBigIntegerExact;

/*!
 @brief Returns a string representation of this <code>BigDecimal</code>,
  using engineering notation if an exponent is needed.
 <p>Returns a string that represents the <code>BigDecimal</code> as
  described in the <code>toString()</code> method, except that if
  exponential notation is used, the power of ten is adjusted to
  be a multiple of three (engineering notation) such that the
  integer part of nonzero values will be in the range 1 through
  999.  If exponential notation is used for zero values, a
  decimal point and one or two fractional zero digits are used so
  that the scale of the zero value is preserved.  Note that
  unlike the output of <code>toString()</code>, the output of this
  method is <em>not</em> guaranteed to recover the same [integer,
  scale] pair of this <code>BigDecimal</code> if the output string is
  converting back to a <code>BigDecimal</code> using the string constructor
 .  The result of this method meets
  the weaker constraint of always producing a numerically equal
  result from applying the string constructor to the method's output.
 @return string representation of this <code>BigDecimal</code>, using
          engineering notation if an exponent is needed.
 @since 1.5
 */
- (NSString *)toEngineeringString;

/*!
 @brief Returns a string representation of this <code>BigDecimal</code>
  without an exponent field.For values with a positive scale,
  the number of digits to the right of the decimal point is used
  to indicate scale.
 For values with a zero or negative scale,
  the resulting string is generated as if the value were
  converted to a numerically equal value with zero scale and as
  if all the trailing zeros of the zero scale value were present
  in the result.
  The entire string is prefixed by a minus sign character '-'
  (<tt>'&#92;u002D'</tt>) if the unscaled value is less than
  zero. No sign character is prefixed if the unscaled value is
  zero or positive.
  Note that if the result of this method is passed to the 
 string constructor, only the
  numerical value of this <code>BigDecimal</code> will necessarily be
  recovered; the representation of the new <code>BigDecimal</code>
  may have a different scale.  In particular, if this 
 <code>BigDecimal</code> has a negative scale, the string resulting
  from this method will have a scale of zero when processed by
  the string constructor.
  (This method behaves analogously to the <code>toString</code>
  method in 1.4 and earlier releases.)
 @return a string representation of this <code>BigDecimal</code>
  without an exponent field.
 @since 1.5
 - seealso: #toString()
 - seealso: #toEngineeringString()
 */
- (NSString *)toPlainString;

/*!
 @brief Returns the string representation of this <code>BigDecimal</code>,
  using scientific notation if an exponent is needed.
 <p>A standard canonical string form of the <code>BigDecimal</code>
  is created as though by the following steps: first, the
  absolute value of the unscaled value of the <code>BigDecimal</code>
  is converted to a string in base ten using the characters 
 <code>'0'</code> through <code>'9'</code> with no leading zeros (except
  if its value is zero, in which case a single <code>'0'</code>
  character is used). 
 <p>Next, an <i>adjusted exponent</i> is calculated; this is the
  negated scale, plus the number of characters in the converted
  unscaled value, less one.  That is, 
 <code>-scale+(ulength-1)</code>, where <code>ulength</code> is the
  length of the absolute value of the unscaled value in decimal
  digits (its <i>precision</i>).
  
 <p>If the scale is greater than or equal to zero and the
  adjusted exponent is greater than or equal to <code>-6</code>, the
  number will be converted to a character form without using
  exponential notation.  In this case, if the scale is zero then
  no decimal point is added and if the scale is positive a
  decimal point will be inserted with the scale specifying the
  number of characters to the right of the decimal point. 
 <code>'0'</code> characters are added to the left of the converted
  unscaled value as necessary.  If no character precedes the
  decimal point after this insertion then a conventional 
 <code>'0'</code> character is prefixed. 
 <p>Otherwise (that is, if the scale is negative, or the
  adjusted exponent is less than <code>-6</code>), the number will be
  converted to a character form using exponential notation.  In
  this case, if the converted <code>BigInteger</code> has more than
  one digit a decimal point is inserted after the first digit.
  An exponent in character form is then suffixed to the converted
  unscaled value (perhaps with inserted decimal point); this
  comprises the letter <code>'E'</code> followed immediately by the
  adjusted exponent converted to a character form.  The latter is
  in base ten, using the characters <code>'0'</code> through 
 <code>'9'</code> with no leading zeros, and is always prefixed by a
  sign character <code>'-'</code> (<tt>'&#92;u002D'</tt>) if the
  adjusted exponent is negative, <code>'+'</code>
  (<tt>'&#92;u002B'</tt>) otherwise). 
 <p>Finally, the entire string is prefixed by a minus sign
  character <code>'-'</code> (<tt>'&#92;u002D'</tt>) if the unscaled
  value is less than zero.  No sign character is prefixed if the
  unscaled value is zero or positive. 
 <p><b>Examples:</b>
  <p>For each representation [<i>unscaled value</i>, <i>scale</i>]
  on the left, the resulting string is shown on the right. 
 @code

  [123,0]      "123"
  [-123,0]     "-123"
  [123,-1]     "1.23E+3"
  [123,-3]     "1.23E+5"
  [123,1]      "12.3"
  [123,5]      "0.00123"
  [123,10]     "1.23E-8"
  [-123,12]    "-1.23E-10" 
  
@endcode
  
 <b>Notes:</b>
  <ol>
  
 <li>There is a one-to-one mapping between the distinguishable 
 <code>BigDecimal</code> values and the result of this conversion.
  That is, every distinguishable <code>BigDecimal</code> value
  (unscaled value and scale) has a unique string representation
  as a result of using <code>toString</code>.  If that string
  representation is converted back to a <code>BigDecimal</code> using
  the <code>BigDecimal(String)</code> constructor, then the original
  value will be recovered. 
 <li>The string produced for a given number is always the same;
  it is not affected by locale.  This means that it can be used
  as a canonical string representation for exchanging decimal
  data, or as a key for a Hashtable, etc.  Locale-sensitive
  number formatting and parsing is handled by the <code>java.text.NumberFormat</code>
  class and its subclasses. 
 <li>The <code>toEngineeringString</code> method may be used for
  presenting numbers with exponents in engineering notation, and the 
 <code>setScale</code> method may be used for
  rounding a <code>BigDecimal</code> so it has a known number of digits after
  the decimal point. 
 <li>The digit-to-character mapping provided by 
 <code>Character.forDigit</code> is used. 
 </ol>
 @return string representation of this <code>BigDecimal</code>.
 - seealso: Character#forDigit
 - seealso: #BigDecimal(java.lang.String)
 */
- (NSString *)description;

/*!
 @brief Returns the size of an ulp, a unit in the last place, of this 
 <code>BigDecimal</code>.An ulp of a nonzero <code>BigDecimal</code>
  value is the positive distance between this value and the 
 <code>BigDecimal</code> value next larger in magnitude with the
  same number of digits.
 An ulp of a zero value is numerically
  equal to 1 with the scale of <code>this</code>.  The result is
  stored with the same scale as <code>this</code> so the result
  for zero and nonzero values is equal to <code>[1,
  this.scale()]</code>
 .
 @return the size of an ulp of <code>this</code>
 @since 1.5
 */
- (JavaMathBigDecimal *)ulp;

/*!
 @brief Returns a <code>BigInteger</code> whose value is the <i>unscaled
  value</i> of this <code>BigDecimal</code>.
 (Computes <tt>(this *
  10<sup>this.scale()</sup>)</tt>.)
 @return the unscaled value of this <code>BigDecimal</code>.
 @since 1.2
 */
- (JavaMathBigInteger *)unscaledValue;

/*!
 @brief Translates a <code>double</code> into a <code>BigDecimal</code>, using
  the <code>double</code>'s canonical string representation provided
  by the <code>Double.toString(double)</code> method.
 <p><b>Note:</b> This is generally the preferred way to convert
  a <code>double</code> (or <code>float</code>) into a 
 <code>BigDecimal</code>, as the value returned is equal to that
  resulting from constructing a <code>BigDecimal</code> from the
  result of using <code>Double.toString(double)</code>.
 @param val<code>double</code>  to convert to a <code>BigDecimal</code> .
 @return a <code>BigDecimal</code> whose value is equal to or approximately
          equal to the value of <code>val</code>.
 @throw NumberFormatExceptionif <code>val</code> is infinite or NaN.
 @since 1.5
 */
+ (JavaMathBigDecimal *)valueOfWithDouble:(jdouble)val;

/*!
 @brief Translates a <code>long</code> value into a <code>BigDecimal</code>
  with a scale of zero.This &quot;static factory method&quot;
  is provided in preference to a (<code>long</code>) constructor
  because it allows for reuse of frequently used 
 <code>BigDecimal</code> values.
 @param val value of the <code>BigDecimal</code> .
 @return a <code>BigDecimal</code> whose value is <code>val</code>.
 */
+ (JavaMathBigDecimal *)valueOfWithLong:(jlong)val;

/*!
 @brief Translates a <code>long</code> unscaled value and an 
 <code>int</code> scale into a <code>BigDecimal</code>.This
  &quot;static factory method&quot; is provided in preference to
  a (<code>long</code>, <code>int</code>) constructor because it
  allows for reuse of frequently used <code>BigDecimal</code> values..
 @param unscaledVal unscaled value of the <code>BigDecimal</code> .
 @param scale_ scale of the <code>BigDecimal</code> .
 @return a <code>BigDecimal</code> whose value is
          <tt>(unscaledVal &times; 10<sup>-scale</sup>)</tt>.
 */
+ (JavaMathBigDecimal *)valueOfWithLong:(jlong)unscaledVal
                                withInt:(jint)scale_;

#pragma mark Package-Private

/*!
 @brief Trusted package private constructor.
 Trusted simply means if val is INFLATED, intVal could not be null and
  if intVal is null, val could not be INFLATED.
 */
- (instancetype __nonnull)initWithJavaMathBigInteger:(JavaMathBigInteger *)intVal
                                            withLong:(jlong)val
                                             withInt:(jint)scale_
                                             withInt:(jint)prec;

/*!
 @brief Returns the length of the absolute value of a <code>long</code>, in decimal
  digits.
 @param x the <code>long</code>
 @return the length of the unscaled value, in deciaml digits.
 */
+ (jint)longDigitLengthWithLong:(jlong)x;

+ (JavaMathBigDecimal *)scaledTenPowWithInt:(jint)n
                                    withInt:(jint)sign
                                    withInt:(jint)scale_;

+ (JavaMathBigDecimal *)valueOfWithJavaMathBigInteger:(JavaMathBigInteger *)intVal
                                              withInt:(jint)scale_
                                              withInt:(jint)prec;

+ (JavaMathBigDecimal *)valueOfWithLong:(jlong)unscaledVal
                                withInt:(jint)scale_
                                withInt:(jint)prec;

+ (JavaMathBigDecimal *)zeroValueOfWithInt:(jint)scale_;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaMathBigDecimal)

/*!
 @brief Sentinel value for <code>intCompact</code> indicating the
  significand information is only available from <code>intVal</code>.
 */
inline jlong JavaMathBigDecimal_get_INFLATED(void);
#define JavaMathBigDecimal_INFLATED ((jlong) 0x8000000000000000LL)
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, INFLATED, jlong)

/*!
 @brief The value 0, with a scale of 0.
 @since 1.5
 */
inline JavaMathBigDecimal *JavaMathBigDecimal_get_ZERO(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_ZERO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal, ZERO, JavaMathBigDecimal *)

/*!
 @brief The value 1, with a scale of 0.
 @since 1.5
 */
inline JavaMathBigDecimal *JavaMathBigDecimal_get_ONE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal, ONE, JavaMathBigDecimal *)

/*!
 @brief The value 10, with a scale of 0.
 @since 1.5
 */
inline JavaMathBigDecimal *JavaMathBigDecimal_get_TEN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_TEN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal, TEN, JavaMathBigDecimal *)

/*!
 @brief Rounding mode to round away from zero.Always increments the
  digit prior to a nonzero discarded fraction.
 Note that this rounding
  mode never decreases the magnitude of the calculated value.
 */
inline jint JavaMathBigDecimal_get_ROUND_UP(void);
#define JavaMathBigDecimal_ROUND_UP 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_UP, jint)

/*!
 @brief Rounding mode to round towards zero.Never increments the digit
  prior to a discarded fraction (i.e., truncates).
 Note that this
  rounding mode never increases the magnitude of the calculated value.
 */
inline jint JavaMathBigDecimal_get_ROUND_DOWN(void);
#define JavaMathBigDecimal_ROUND_DOWN 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_DOWN, jint)

/*!
 @brief Rounding mode to round towards positive infinity.If the 
 <code>BigDecimal</code> is positive, behaves as for 
 <code>ROUND_UP</code>; if negative, behaves as for 
 <code>ROUND_DOWN</code>.
 Note that this rounding mode never
  decreases the calculated value.
 */
inline jint JavaMathBigDecimal_get_ROUND_CEILING(void);
#define JavaMathBigDecimal_ROUND_CEILING 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_CEILING, jint)

/*!
 @brief Rounding mode to round towards negative infinity.If the 
 <code>BigDecimal</code> is positive, behave as for 
 <code>ROUND_DOWN</code>; if negative, behave as for 
 <code>ROUND_UP</code>.
 Note that this rounding mode never
  increases the calculated value.
 */
inline jint JavaMathBigDecimal_get_ROUND_FLOOR(void);
#define JavaMathBigDecimal_ROUND_FLOOR 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_FLOOR, jint)

/*!
 @brief Rounding mode to round towards &quot;nearest neighbor&quot;
  unless both neighbors are equidistant, in which case round up.
 Behaves as for <code>ROUND_UP</code> if the discarded fraction is 
 &ge; 0.5; otherwise, behaves as for <code>ROUND_DOWN</code>.  Note
  that this is the rounding mode that most of us were taught in
  grade school.
 */
inline jint JavaMathBigDecimal_get_ROUND_HALF_UP(void);
#define JavaMathBigDecimal_ROUND_HALF_UP 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_HALF_UP, jint)

/*!
 @brief Rounding mode to round towards &quot;nearest neighbor&quot;
  unless both neighbors are equidistant, in which case round
  down.Behaves as for <code>ROUND_UP</code> if the discarded
  fraction is &gt; 0.5; otherwise, behaves as for 
 <code>ROUND_DOWN</code>.
 */
inline jint JavaMathBigDecimal_get_ROUND_HALF_DOWN(void);
#define JavaMathBigDecimal_ROUND_HALF_DOWN 5
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_HALF_DOWN, jint)

/*!
 @brief Rounding mode to round towards the &quot;nearest neighbor&quot;
  unless both neighbors are equidistant, in which case, round
  towards the even neighbor.Behaves as for 
 <code>ROUND_HALF_UP</code> if the digit to the left of the
  discarded fraction is odd; behaves as for 
 <code>ROUND_HALF_DOWN</code> if it's even.
 Note that this is the
  rounding mode that minimizes cumulative error when applied
  repeatedly over a sequence of calculations.
 */
inline jint JavaMathBigDecimal_get_ROUND_HALF_EVEN(void);
#define JavaMathBigDecimal_ROUND_HALF_EVEN 6
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_HALF_EVEN, jint)

/*!
 @brief Rounding mode to assert that the requested operation has an exact
  result, hence no rounding is necessary.If this rounding mode is
  specified on an operation that yields an inexact result, an 
 <code>ArithmeticException</code> is thrown.
 */
inline jint JavaMathBigDecimal_get_ROUND_UNNECESSARY(void);
#define JavaMathBigDecimal_ROUND_UNNECESSARY 7
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_UNNECESSARY, jint)

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withLong_withInt_withInt_(JavaMathBigDecimal *self, JavaMathBigInteger *intVal, jlong val, jint scale_, jint prec);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withLong_withInt_withInt_(JavaMathBigInteger *intVal, jlong val, jint scale_, jint prec) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithJavaMathBigInteger_withLong_withInt_withInt_(JavaMathBigInteger *intVal, jlong val, jint scale_, jint prec);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_withInt_withInt_(JavaMathBigDecimal *self, IOSCharArray *inArg, jint offset, jint len);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_withInt_withInt_(IOSCharArray *inArg, jint offset, jint len) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithCharArray_withInt_withInt_(IOSCharArray *inArg, jint offset, jint len);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_withInt_withInt_withJavaMathMathContext_(JavaMathBigDecimal *self, IOSCharArray *inArg, jint offset, jint len, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_withInt_withInt_withJavaMathMathContext_(IOSCharArray *inArg, jint offset, jint len, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithCharArray_withInt_withInt_withJavaMathMathContext_(IOSCharArray *inArg, jint offset, jint len, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_(JavaMathBigDecimal *self, IOSCharArray *inArg);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_(IOSCharArray *inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithCharArray_(IOSCharArray *inArg);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_withJavaMathMathContext_(JavaMathBigDecimal *self, IOSCharArray *inArg, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_withJavaMathMathContext_(IOSCharArray *inArg, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithCharArray_withJavaMathMathContext_(IOSCharArray *inArg, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithNSString_(JavaMathBigDecimal *self, NSString *val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithNSString_(NSString *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithNSString_(NSString *val);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithNSString_withJavaMathMathContext_(JavaMathBigDecimal *self, NSString *val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithNSString_withJavaMathMathContext_(NSString *val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithNSString_withJavaMathMathContext_(NSString *val, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithDouble_(JavaMathBigDecimal *self, jdouble val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithDouble_(jdouble val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithDouble_(jdouble val);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithDouble_withJavaMathMathContext_(JavaMathBigDecimal *self, jdouble val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithDouble_withJavaMathMathContext_(jdouble val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithDouble_withJavaMathMathContext_(jdouble val, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_(JavaMathBigDecimal *self, JavaMathBigInteger *val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_(JavaMathBigInteger *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithJavaMathBigInteger_(JavaMathBigInteger *val);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withJavaMathMathContext_(JavaMathBigDecimal *self, JavaMathBigInteger *val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withJavaMathMathContext_(JavaMathBigInteger *val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithJavaMathBigInteger_withJavaMathMathContext_(JavaMathBigInteger *val, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_(JavaMathBigDecimal *self, JavaMathBigInteger *unscaledVal, jint scale_);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_(JavaMathBigInteger *unscaledVal, jint scale_) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_(JavaMathBigInteger *unscaledVal, jint scale_);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_withJavaMathMathContext_(JavaMathBigDecimal *self, JavaMathBigInteger *unscaledVal, jint scale_, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_withJavaMathMathContext_(JavaMathBigInteger *unscaledVal, jint scale_, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_withJavaMathMathContext_(JavaMathBigInteger *unscaledVal, jint scale_, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithInt_(JavaMathBigDecimal *self, jint val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithInt_(jint val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithInt_(jint val);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithInt_withJavaMathMathContext_(JavaMathBigDecimal *self, jint val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithInt_withJavaMathMathContext_(jint val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithInt_withJavaMathMathContext_(jint val, JavaMathMathContext *mc);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithLong_(JavaMathBigDecimal *self, jlong val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithLong_(jlong val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithLong_(jlong val);

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithLong_withJavaMathMathContext_(JavaMathBigDecimal *self, jlong val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithLong_withJavaMathMathContext_(jlong val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *create_JavaMathBigDecimal_initWithLong_withJavaMathMathContext_(jlong val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithLong_withInt_(jlong unscaledVal, jint scale_);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithLong_(jlong val);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithLong_withInt_withInt_(jlong unscaledVal, jint scale_, jint prec);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithJavaMathBigInteger_withInt_withInt_(JavaMathBigInteger *intVal, jint scale_, jint prec);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_zeroValueOfWithInt_(jint scale_);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithDouble_(jdouble val);

FOUNDATION_EXPORT jint JavaMathBigDecimal_longDigitLengthWithLong_(jlong x);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_scaledTenPowWithInt_withInt_withInt_(jint n, jint sign, jint scale_);

J2OBJC_TYPE_LITERAL_HEADER(JavaMathBigDecimal)

#endif

#if !defined (JavaMathBigDecimal_StringBuilderHelper_) && (INCLUDE_ALL_JavaMathBigDecimal || defined(INCLUDE_JavaMathBigDecimal_StringBuilderHelper))
#define JavaMathBigDecimal_StringBuilderHelper_

@class IOSCharArray;
@class JavaLangStringBuilder;

@interface JavaMathBigDecimal_StringBuilderHelper : NSObject {
 @public
  JavaLangStringBuilder *sb_;
  IOSCharArray *cmpCharArray_;
}
@property (readonly, class, strong) IOSCharArray *DIGIT_TENS NS_SWIFT_NAME(DIGIT_TENS);
@property (readonly, class, strong) IOSCharArray *DIGIT_ONES NS_SWIFT_NAME(DIGIT_ONES);

+ (IOSCharArray *)DIGIT_TENS;

+ (IOSCharArray *)DIGIT_ONES;

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (IOSCharArray *)getCompactCharArray;

- (JavaLangStringBuilder *)getStringBuilder;

/*!
 @brief Places characters representing the intCompact in <code>long</code> into
  cmpCharArray and returns the offset to the array where the
  representation starts.
 @param intCompact the number to put into the cmpCharArray.
 @return offset to the array where the representation starts.
  Note: intCompact must be greater or equal to zero.
 */
- (jint)putIntCompactWithLong:(jlong)intCompact;

@end

J2OBJC_STATIC_INIT(JavaMathBigDecimal_StringBuilderHelper)

J2OBJC_FIELD_SETTER(JavaMathBigDecimal_StringBuilderHelper, sb_, JavaLangStringBuilder *)
J2OBJC_FIELD_SETTER(JavaMathBigDecimal_StringBuilderHelper, cmpCharArray_, IOSCharArray *)

inline IOSCharArray *JavaMathBigDecimal_StringBuilderHelper_get_DIGIT_TENS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSCharArray *JavaMathBigDecimal_StringBuilderHelper_DIGIT_TENS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal_StringBuilderHelper, DIGIT_TENS, IOSCharArray *)

inline IOSCharArray *JavaMathBigDecimal_StringBuilderHelper_get_DIGIT_ONES(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSCharArray *JavaMathBigDecimal_StringBuilderHelper_DIGIT_ONES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal_StringBuilderHelper, DIGIT_ONES, IOSCharArray *)

FOUNDATION_EXPORT void JavaMathBigDecimal_StringBuilderHelper_init(JavaMathBigDecimal_StringBuilderHelper *self);

FOUNDATION_EXPORT JavaMathBigDecimal_StringBuilderHelper *new_JavaMathBigDecimal_StringBuilderHelper_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal_StringBuilderHelper *create_JavaMathBigDecimal_StringBuilderHelper_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaMathBigDecimal_StringBuilderHelper)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaMathBigDecimal")
