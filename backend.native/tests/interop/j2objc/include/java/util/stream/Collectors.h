//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/stream/Collectors.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilStreamCollectors")
#ifdef RESTRICT_JavaUtilStreamCollectors
#define INCLUDE_ALL_JavaUtilStreamCollectors 0
#else
#define INCLUDE_ALL_JavaUtilStreamCollectors 1
#endif
#undef RESTRICT_JavaUtilStreamCollectors

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilStreamCollectors_) && (INCLUDE_ALL_JavaUtilStreamCollectors || defined(INCLUDE_JavaUtilStreamCollectors))
#define JavaUtilStreamCollectors_

@class IOSDoubleArray;
@protocol JavaLangCharSequence;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionBinaryOperator;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilFunctionSupplier;
@protocol JavaUtilFunctionToDoubleFunction;
@protocol JavaUtilFunctionToIntFunction;
@protocol JavaUtilFunctionToLongFunction;
@protocol JavaUtilSet;
@protocol JavaUtilStreamCollector;

/*!
 @brief Implementations of <code>Collector</code> that implement various useful reduction
  operations, such as accumulating elements into collections, summarizing
  elements according to various criteria, etc.
 <p>The following are examples of using the predefined collectors to perform
  common mutable reduction tasks: 
 @code
    // Accumulate names into a List
      List<String> list = people.stream().map(Person::getName).collect(Collectors.toList());
      // Accumulate names into a TreeSet
      Set<String> set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));
      // Convert elements to strings and concatenate them, separated by commas
      String joined = things.stream()
                            .map(Object::toString)
                            .collect(Collectors.joining(", "));
      // Compute sum of salaries of employee
      int total = employees.stream()
                           .collect(Collectors.summingInt(Employee::getSalary)));
      // Group employees by department
      Map<Department, List<Employee>> byDept
          = employees.stream()
                     .collect(Collectors.groupingBy(Employee::getDepartment));
      // Compute sum of salaries by department
      Map<Department, Integer> totalByDept
          = employees.stream()
                     .collect(Collectors.groupingBy(Employee::getDepartment,
                                                    Collectors.summingInt(Employee::getSalary)));
      // Partition students into passing and failing
      Map<Boolean, List<Student>> passingFailing =
          students.stream()
                  .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD)); 
 
@endcode
 @since 1.8
 */
@interface JavaUtilStreamCollectors : NSObject
@property (readonly, class, strong) id<JavaUtilSet> CH_CONCURRENT_ID NS_SWIFT_NAME(CH_CONCURRENT_ID);
@property (readonly, class, strong) id<JavaUtilSet> CH_CONCURRENT_NOID NS_SWIFT_NAME(CH_CONCURRENT_NOID);
@property (readonly, class, strong) id<JavaUtilSet> CH_ID NS_SWIFT_NAME(CH_ID);
@property (readonly, class, strong) id<JavaUtilSet> CH_UNORDERED_ID NS_SWIFT_NAME(CH_UNORDERED_ID);
@property (readonly, class, strong) id<JavaUtilSet> CH_NOID NS_SWIFT_NAME(CH_NOID);

+ (id<JavaUtilSet>)CH_CONCURRENT_ID;

+ (id<JavaUtilSet>)CH_CONCURRENT_NOID;

+ (id<JavaUtilSet>)CH_ID;

+ (id<JavaUtilSet>)CH_UNORDERED_ID;

+ (id<JavaUtilSet>)CH_NOID;

#pragma mark Public

/*!
 @brief Returns a <code>Collector</code> that produces the arithmetic mean of a double-valued
  function applied to the input elements.If no elements are present,
  the result is 0.
 <p>The average returned can vary depending upon the order in which
  values are recorded, due to accumulated rounding error in
  addition of values of differing magnitudes. Values sorted by increasing
  absolute magnitude tend to yield more accurate results.  If any recorded
  value is a <code>NaN</code> or the sum is at any point a <code>NaN</code> then the
  average will be <code>NaN</code>.
 @param mapper a function extracting the property to be summed
 @return a <code>Collector</code> that produces the sum of a derived property
 */
+ (id<JavaUtilStreamCollector>)averagingDoubleWithJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> that produces the arithmetic mean of an integer-valued
  function applied to the input elements.If no elements are present,
  the result is 0.
 @param mapper a function extracting the property to be summed
 @return a <code>Collector</code> that produces the sum of a derived property
 */
+ (id<JavaUtilStreamCollector>)averagingIntWithJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> that produces the arithmetic mean of a long-valued
  function applied to the input elements.If no elements are present,
  the result is 0.
 @param mapper a function extracting the property to be summed
 @return a <code>Collector</code> that produces the sum of a derived property
 */
+ (id<JavaUtilStreamCollector>)averagingLongWithJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)mapper;

/*!
 @brief Adapts a <code>Collector</code> to perform an additional finishing
  transformation.For example, one could adapt the <code>toList()</code>
  collector to always produce an immutable list with: 
 @code
    List<String> people
          = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); 
 
@endcode
 @param downstream a collector
 @param finisher a function to be applied to the final result of the downstream collector
 @return a collector which performs the action of the downstream collector,
  followed by an additional finishing step
 */
+ (id<JavaUtilStreamCollector>)collectingAndThenWithJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream
                                               withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)finisher;

/*!
 @brief Returns a <code>Collector</code> accepting elements of type <code>T</code> that
  counts the number of input elements.If no elements are present, the
  result is 0.
 @return a <code>Collector</code> that counts the input elements
 */
+ (id<JavaUtilStreamCollector>)counting;

/*!
 @brief Returns a <code>Collector</code> implementing a "group by" operation on
  input elements of type <code>T</code>, grouping elements according to a
  classification function, and returning the results in a <code>Map</code>.
 <p>The classification function maps elements to some key type <code>K</code>.
  The collector produces a <code>Map<K, List<T>></code> whose keys are the
  values resulting from applying the classification function to the input
  elements, and whose corresponding values are <code>List</code>s containing the
  input elements which map to the associated key under the classification
  function. 
 <p>There are no guarantees on the type, mutability, serializability, or
  thread-safety of the <code>Map</code> or <code>List</code> objects returned.
 @param classifier the classifier function mapping input elements to keys
 @return a <code>Collector</code> implementing the group-by operation
 - seealso: #groupingBy(Function, Collector)
 - seealso: #groupingBy(Function, Supplier, Collector)
 - seealso: #groupingByConcurrent(Function)
 */
+ (id<JavaUtilStreamCollector>)groupingByWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)classifier;

/*!
 @brief Returns a <code>Collector</code> implementing a cascaded "group by" operation
  on input elements of type <code>T</code>, grouping elements according to a
  classification function, and then performing a reduction operation on
  the values associated with a given key using the specified downstream 
 <code>Collector</code>.
 <p>The classification function maps elements to some key type <code>K</code>.
  The downstream collector operates on elements of type <code>T</code> and
  produces a result of type <code>D</code>. The resulting collector produces a 
 <code>Map<K, D></code>.
  
 <p>There are no guarantees on the type, mutability,
  serializability, or thread-safety of the <code>Map</code> returned. 
 <p>For example, to compute the set of last names of people in each city: 
 @code
    Map<City, Set<String>> namesByCity
          = people.stream().collect(groupingBy(Person::getCity,
                                               mapping(Person::getLastName, toSet()))); 
 
@endcode
 @param classifier a classifier function mapping input elements to keys
 @param downstream a <code>Collector</code>  implementing the downstream reduction
 @return a <code>Collector</code> implementing the cascaded group-by operation
 - seealso: #groupingBy(Function)
 - seealso: #groupingBy(Function, Supplier, Collector)
 - seealso: #groupingByConcurrent(Function, Collector)
 */
+ (id<JavaUtilStreamCollector>)groupingByWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)classifier
                                          withJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream;

/*!
 @brief Returns a <code>Collector</code> implementing a cascaded "group by" operation
  on input elements of type <code>T</code>, grouping elements according to a
  classification function, and then performing a reduction operation on
  the values associated with a given key using the specified downstream 
 <code>Collector</code>.The <code>Map</code> produced by the Collector is created
  with the supplied factory function.
 <p>The classification function maps elements to some key type <code>K</code>.
  The downstream collector operates on elements of type <code>T</code> and
  produces a result of type <code>D</code>. The resulting collector produces a 
 <code>Map<K, D></code>.
  
 <p>For example, to compute the set of last names of people in each city,
  where the city names are sorted: 
 @code
    Map<City, Set<String>> namesByCity
          = people.stream().collect(groupingBy(Person::getCity, TreeMap::new,
                                               mapping(Person::getLastName, toSet()))); 
 
@endcode
 @param classifier a classifier function mapping input elements to keys
 @param downstream a <code>Collector</code>  implementing the downstream reduction
 @param mapFactory a function which, when called, produces a new empty                    
 <code>Map</code>  of the desired type
 @return a <code>Collector</code> implementing the cascaded group-by operation
 - seealso: #groupingBy(Function, Collector)
 - seealso: #groupingBy(Function)
 - seealso: #groupingByConcurrent(Function, Supplier, Collector)
 */
+ (id<JavaUtilStreamCollector>)groupingByWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)classifier
                                         withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)mapFactory
                                          withJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream;

/*!
 @brief Returns a concurrent <code>Collector</code> implementing a "group by"
  operation on input elements of type <code>T</code>, grouping elements
  according to a classification function.
 <p>This is a <code>concurrent</code> and 
 <code>unordered</code> Collector. 
 <p>The classification function maps elements to some key type <code>K</code>.
  The collector produces a <code>ConcurrentMap<K, List<T>></code> whose keys are the
  values resulting from applying the classification function to the input
  elements, and whose corresponding values are <code>List</code>s containing the
  input elements which map to the associated key under the classification
  function. 
 <p>There are no guarantees on the type, mutability, or serializability
  of the <code>Map</code> or <code>List</code> objects returned, or of the
  thread-safety of the <code>List</code> objects returned.
 @param classifier a classifier function mapping input elements to keys
 @return a concurrent, unordered <code>Collector</code> implementing the group-by operation
 - seealso: #groupingBy(Function)
 - seealso: #groupingByConcurrent(Function, Collector)
 - seealso: #groupingByConcurrent(Function, Supplier, Collector)
 */
+ (id<JavaUtilStreamCollector>)groupingByConcurrentWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)classifier;

/*!
 @brief Returns a concurrent <code>Collector</code> implementing a cascaded "group by"
  operation on input elements of type <code>T</code>, grouping elements
  according to a classification function, and then performing a reduction
  operation on the values associated with a given key using the specified
  downstream <code>Collector</code>.
 <p>This is a <code>concurrent</code> and 
 <code>unordered</code> Collector. 
 <p>The classification function maps elements to some key type <code>K</code>.
  The downstream collector operates on elements of type <code>T</code> and
  produces a result of type <code>D</code>. The resulting collector produces a 
 <code>Map<K, D></code>.
  
 <p>For example, to compute the set of last names of people in each city,
  where the city names are sorted: 
 @code
    ConcurrentMap<City, Set<String>> namesByCity
          = people.stream().collect(groupingByConcurrent(Person::getCity,
                                                         mapping(Person::getLastName, toSet()))); 
 
@endcode
 @param classifier a classifier function mapping input elements to keys
 @param downstream a <code>Collector</code>  implementing the downstream reduction
 @return a concurrent, unordered <code>Collector</code> implementing the cascaded group-by operation
 - seealso: #groupingBy(Function, Collector)
 - seealso: #groupingByConcurrent(Function)
 - seealso: #groupingByConcurrent(Function, Supplier, Collector)
 */
+ (id<JavaUtilStreamCollector>)groupingByConcurrentWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)classifier
                                                    withJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream;

/*!
 @brief Returns a concurrent <code>Collector</code> implementing a cascaded "group by"
  operation on input elements of type <code>T</code>, grouping elements
  according to a classification function, and then performing a reduction
  operation on the values associated with a given key using the specified
  downstream <code>Collector</code>.The <code>ConcurrentMap</code> produced by the
  Collector is created with the supplied factory function.
 <p>This is a <code>concurrent</code> and 
 <code>unordered</code> Collector. 
 <p>The classification function maps elements to some key type <code>K</code>.
  The downstream collector operates on elements of type <code>T</code> and
  produces a result of type <code>D</code>. The resulting collector produces a 
 <code>Map<K, D></code>.
  
 <p>For example, to compute the set of last names of people in each city,
  where the city names are sorted: 
 @code
    ConcurrentMap<City, Set<String>> namesByCity
          = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new,
                                               mapping(Person::getLastName, toSet()))); 
 
@endcode
 @param classifier a classifier function mapping input elements to keys
 @param downstream a <code>Collector</code>  implementing the downstream reduction
 @param mapFactory a function which, when called, produces a new empty                    
 <code>ConcurrentMap</code>  of the desired type
 @return a concurrent, unordered <code>Collector</code> implementing the cascaded group-by operation
 - seealso: #groupingByConcurrent(Function)
 - seealso: #groupingByConcurrent(Function, Collector)
 - seealso: #groupingBy(Function, Supplier, Collector)
 */
+ (id<JavaUtilStreamCollector>)groupingByConcurrentWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)classifier
                                                   withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)mapFactory
                                                    withJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream;

/*!
 @brief Returns a <code>Collector</code> that concatenates the input elements into a 
 <code>String</code>, in encounter order.
 @return a <code>Collector</code> that concatenates the input elements into a 
 <code>String</code>, in encounter order
 */
+ (id<JavaUtilStreamCollector>)joining;

/*!
 @brief Returns a <code>Collector</code> that concatenates the input elements,
  separated by the specified delimiter, in encounter order.
 @param delimiter the delimiter to be used between each element
 @return A <code>Collector</code> which concatenates CharSequence elements,
  separated by the specified delimiter, in encounter order
 */
+ (id<JavaUtilStreamCollector>)joiningWithJavaLangCharSequence:(id<JavaLangCharSequence>)delimiter;

/*!
 @brief Returns a <code>Collector</code> that concatenates the input elements,
  separated by the specified delimiter, with the specified prefix and
  suffix, in encounter order.
 @param delimiter the delimiter to be used between each element
 @param prefix the sequence of characters to be used at the beginning                 of the joined result
 @param suffix the sequence of characters to be used at the end                 of the joined result
 @return A <code>Collector</code> which concatenates CharSequence elements,
  separated by the specified delimiter, in encounter order
 */
+ (id<JavaUtilStreamCollector>)joiningWithJavaLangCharSequence:(id<JavaLangCharSequence>)delimiter
                                      withJavaLangCharSequence:(id<JavaLangCharSequence>)prefix
                                      withJavaLangCharSequence:(id<JavaLangCharSequence>)suffix;

/*!
 @brief Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one
  accepting elements of type <code>T</code> by applying a mapping function to
  each input element before accumulation.
 @param mapper a function to be applied to the input elements
 @param downstream a collector which will accept mapped values
 @return a collector which applies the mapping function to the input
  elements and provides the mapped results to the downstream collector
 */
+ (id<JavaUtilStreamCollector>)mappingWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mapper
                                       withJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream;

/*!
 @brief Returns a <code>Collector</code> that produces the maximal element according
  to a given <code>Comparator</code>, described as an <code>Optional<T></code>.
 @param comparator a <code>Comparator</code>  for comparing elements
 @return a <code>Collector</code> that produces the maximal value
 */
+ (id<JavaUtilStreamCollector>)maxByWithJavaUtilComparator:(id<JavaUtilComparator>)comparator;

/*!
 @brief Returns a <code>Collector</code> that produces the minimal element according
  to a given <code>Comparator</code>, described as an <code>Optional<T></code>.
 @param comparator a <code>Comparator</code>  for comparing elements
 @return a <code>Collector</code> that produces the minimal value
 */
+ (id<JavaUtilStreamCollector>)minByWithJavaUtilComparator:(id<JavaUtilComparator>)comparator;

/*!
 @brief Returns a <code>Collector</code> which partitions the input elements according
  to a <code>Predicate</code>, and organizes them into a 
 <code>Map<Boolean, List<T>></code>.
 There are no guarantees on the type, mutability,
  serializability, or thread-safety of the <code>Map</code> returned.
 @param predicate a predicate used for classifying input elements
 @return a <code>Collector</code> implementing the partitioning operation
 - seealso: #partitioningBy(Predicate, Collector)
 */
+ (id<JavaUtilStreamCollector>)partitioningByWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)predicate;

/*!
 @brief Returns a <code>Collector</code> which partitions the input elements according
  to a <code>Predicate</code>, reduces the values in each partition according to
  another <code>Collector</code>, and organizes them into a 
 <code>Map<Boolean, D></code> whose values are the result of the downstream
  reduction.
 <p>There are no guarantees on the type, mutability,
  serializability, or thread-safety of the <code>Map</code> returned.
 @param predicate a predicate used for classifying input elements
 @param downstream a <code>Collector</code>  implementing the downstream
                     reduction
 @return a <code>Collector</code> implementing the cascaded partitioning
          operation
 - seealso: #partitioningBy(Predicate)
 */
+ (id<JavaUtilStreamCollector>)partitioningByWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)predicate
                                               withJavaUtilStreamCollector:(id<JavaUtilStreamCollector>)downstream;

/*!
 @brief Returns a <code>Collector</code> which performs a reduction of its
  input elements under a specified <code>BinaryOperator</code>.The result
  is described as an <code>Optional<T></code>.
 @param op a <code>BinaryOperator<T></code>  used to reduce the input elements
 @return a <code>Collector</code> which implements the reduction operation
 - seealso: #reducing(Object, BinaryOperator)
 - seealso: #reducing(Object, Function, BinaryOperator)
 */
+ (id<JavaUtilStreamCollector>)reducingWithJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)op;

/*!
 @brief Returns a <code>Collector</code> which performs a reduction of its
  input elements under a specified <code>BinaryOperator</code> using the
  provided identity.
 @param identity the identity value for the reduction (also, the value                  that is returned when there are no input elements)
 @param op a <code>BinaryOperator<T></code>  used to reduce the input elements
 @return a <code>Collector</code> which implements the reduction operation
 - seealso: #reducing(BinaryOperator)
 - seealso: #reducing(Object, Function, BinaryOperator)
 */
+ (id<JavaUtilStreamCollector>)reducingWithId:(id)identity
           withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)op;

/*!
 @brief Returns a <code>Collector</code> which performs a reduction of its
  input elements under a specified mapping function and 
 <code>BinaryOperator</code>.This is a generalization of 
 <code>reducing(Object, BinaryOperator)</code> which allows a transformation
  of the elements before reduction.
 @param identity the identity value for the reduction (also, the value                  that is returned when there are no input elements)
 @param mapper a mapping function to apply to each input value
 @param op a <code>BinaryOperator<U></code>  used to reduce the mapped values
 @return a <code>Collector</code> implementing the map-reduce operation
 - seealso: #reducing(Object, BinaryOperator)
 - seealso: #reducing(BinaryOperator)
 */
+ (id<JavaUtilStreamCollector>)reducingWithId:(id)identity
                 withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mapper
           withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)op;

/*!
 @brief Returns a <code>Collector</code> which applies an <code>double</code>-producing
  mapping function to each input element, and returns summary statistics
  for the resulting values.
 @param mapper a mapping function to apply to each element
 @return a <code>Collector</code> implementing the summary-statistics reduction
 - seealso: #summarizingLong(ToLongFunction)
 - seealso: #summarizingInt(ToIntFunction)
 */
+ (id<JavaUtilStreamCollector>)summarizingDoubleWithJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> which applies an <code>int</code>-producing
  mapping function to each input element, and returns summary statistics
  for the resulting values.
 @param mapper a mapping function to apply to each element
 @return a <code>Collector</code> implementing the summary-statistics reduction
 - seealso: #summarizingDouble(ToDoubleFunction)
 - seealso: #summarizingLong(ToLongFunction)
 */
+ (id<JavaUtilStreamCollector>)summarizingIntWithJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> which applies an <code>long</code>-producing
  mapping function to each input element, and returns summary statistics
  for the resulting values.
 @param mapper the mapping function to apply to each element
 @return a <code>Collector</code> implementing the summary-statistics reduction
 - seealso: #summarizingDouble(ToDoubleFunction)
 - seealso: #summarizingInt(ToIntFunction)
 */
+ (id<JavaUtilStreamCollector>)summarizingLongWithJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> that produces the sum of a double-valued
  function applied to the input elements.If no elements are present,
  the result is 0.
 <p>The sum returned can vary depending upon the order in which
  values are recorded, due to accumulated rounding error in
  addition of values of differing magnitudes. Values sorted by increasing
  absolute magnitude tend to yield more accurate results.  If any recorded
  value is a <code>NaN</code> or the sum is at any point a <code>NaN</code> then the
  sum will be <code>NaN</code>.
 @param mapper a function extracting the property to be summed
 @return a <code>Collector</code> that produces the sum of a derived property
 */
+ (id<JavaUtilStreamCollector>)summingDoubleWithJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> that produces the sum of a integer-valued
  function applied to the input elements.If no elements are present,
  the result is 0.
 @param mapper a function extracting the property to be summed
 @return a <code>Collector</code> that produces the sum of a derived property
 */
+ (id<JavaUtilStreamCollector>)summingIntWithJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> that produces the sum of a long-valued
  function applied to the input elements.If no elements are present,
  the result is 0.
 @param mapper a function extracting the property to be summed
 @return a <code>Collector</code> that produces the sum of a derived property
 */
+ (id<JavaUtilStreamCollector>)summingLongWithJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)mapper;

/*!
 @brief Returns a <code>Collector</code> that accumulates the input elements into a
  new <code>Collection</code>, in encounter order.The <code>Collection</code> is
  created by the provided factory.
 @param collectionFactory a <code>Supplier</code>  which returns a new, empty
   <code>Collection</code>  of the appropriate type
 @return a <code>Collector</code> which collects all the input elements into a 
 <code>Collection</code>, in encounter order
 */
+ (id<JavaUtilStreamCollector>)toCollectionWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)collectionFactory;

/*!
 @brief Returns a concurrent <code>Collector</code> that accumulates elements into a 
 <code>ConcurrentMap</code> whose keys and values are the result of applying
  the provided mapping functions to the input elements.
 <p>If the mapped keys contains duplicates (according to 
 <code>Object.equals(Object)</code>), an <code>IllegalStateException</code> is
  thrown when the collection operation is performed.  If the mapped keys
  may have duplicates, use 
 <code>toConcurrentMap(Function, Function, BinaryOperator)</code> instead.
 @param keyMapper the mapping function to produce keys
 @param valueMapper the mapping function to produce values
 @return a concurrent, unordered <code>Collector</code> which collects elements into a 
 <code>ConcurrentMap</code> whose keys are the result of applying a key mapping
  function to the input elements, and whose values are the result of
  applying a value mapping function to the input elements
 - seealso: #toMap(Function, Function)
 - seealso: #toConcurrentMap(Function, Function, BinaryOperator)
 - seealso: #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
 */
+ (id<JavaUtilStreamCollector>)toConcurrentMapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyMapper
                                              withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueMapper;

/*!
 @brief Returns a concurrent <code>Collector</code> that accumulates elements into a 
 <code>ConcurrentMap</code> whose keys and values are the result of applying
  the provided mapping functions to the input elements.
 <p>If the mapped keys contains duplicates (according to <code>Object.equals(Object)</code>),
  the value mapping function is applied to each equal element, and the
  results are merged using the provided merging function.
 @param keyMapper a mapping function to produce keys
 @param valueMapper a mapping function to produce values
 @param mergeFunction a merge function, used to resolve collisions between                       values associated with the same key, as supplied
                        to 
 <code>Map.merge(Object, Object, BiFunction)</code>
 @return a concurrent, unordered <code>Collector</code> which collects elements into a 
 <code>ConcurrentMap</code> whose keys are the result of applying a key mapping
  function to the input elements, and whose values are the result of
  applying a value mapping function to all input elements equal to the key
  and combining them using the merge function
 - seealso: #toConcurrentMap(Function, Function)
 - seealso: #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
 - seealso: #toMap(Function, Function, BinaryOperator)
 */
+ (id<JavaUtilStreamCollector>)toConcurrentMapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyMapper
                                              withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueMapper
                                        withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)mergeFunction;

/*!
 @brief Returns a concurrent <code>Collector</code> that accumulates elements into a 
 <code>ConcurrentMap</code> whose keys and values are the result of applying
  the provided mapping functions to the input elements.
 <p>If the mapped keys contains duplicates (according to <code>Object.equals(Object)</code>),
  the value mapping function is applied to each equal element, and the
  results are merged using the provided merging function.  The 
 <code>ConcurrentMap</code> is created by a provided supplier function. 
 <p>This is a <code>concurrent</code> and 
 <code>unordered</code> Collector.
 @param keyMapper a mapping function to produce keys
 @param valueMapper a mapping function to produce values
 @param mergeFunction a merge function, used to resolve collisions between                       values associated with the same key, as supplied
                        to 
 <code>Map.merge(Object, Object, BiFunction)</code>
 @param mapSupplier a function which returns a new, empty <code>Map</code>  into
                      which the results will be inserted
 @return a concurrent, unordered <code>Collector</code> which collects elements into a 
 <code>ConcurrentMap</code> whose keys are the result of applying a key mapping
  function to the input elements, and whose values are the result of
  applying a value mapping function to all input elements equal to the key
  and combining them using the merge function
 - seealso: #toConcurrentMap(Function, Function)
 - seealso: #toConcurrentMap(Function, Function, BinaryOperator)
 - seealso: #toMap(Function, Function, BinaryOperator, Supplier)
 */
+ (id<JavaUtilStreamCollector>)toConcurrentMapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyMapper
                                              withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueMapper
                                        withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)mergeFunction
                                              withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)mapSupplier;

/*!
 @brief Returns a <code>Collector</code> that accumulates the input elements into a
  new <code>List</code>.There are no guarantees on the type, mutability,
  serializability, or thread-safety of the <code>List</code> returned; if more
  control over the returned <code>List</code> is required, use <code>toCollection(Supplier)</code>.
 @return a <code>Collector</code> which collects all the input elements into a 
 <code>List</code>, in encounter order
 */
+ (id<JavaUtilStreamCollector>)toList;

/*!
 @brief Returns a <code>Collector</code> that accumulates elements into a 
 <code>Map</code> whose keys and values are the result of applying the provided
  mapping functions to the input elements.
 <p>If the mapped keys contains duplicates (according to 
 <code>Object.equals(Object)</code>), an <code>IllegalStateException</code> is
  thrown when the collection operation is performed.  If the mapped keys
  may have duplicates, use <code>toMap(Function, Function, BinaryOperator)</code>
  instead.
 @param keyMapper a mapping function to produce keys
 @param valueMapper a mapping function to produce values
 @return a <code>Collector</code> which collects elements into a <code>Map</code>
  whose keys and values are the result of applying mapping functions to
  the input elements
 - seealso: #toMap(Function, Function, BinaryOperator)
 - seealso: #toMap(Function, Function, BinaryOperator, Supplier)
 - seealso: #toConcurrentMap(Function, Function)
 */
+ (id<JavaUtilStreamCollector>)toMapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyMapper
                                    withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueMapper;

/*!
 @brief Returns a <code>Collector</code> that accumulates elements into a 
 <code>Map</code> whose keys and values are the result of applying the provided
  mapping functions to the input elements.
 <p>If the mapped
  keys contains duplicates (according to <code>Object.equals(Object)</code>),
  the value mapping function is applied to each equal element, and the
  results are merged using the provided merging function.
 @param keyMapper a mapping function to produce keys
 @param valueMapper a mapping function to produce values
 @param mergeFunction a merge function, used to resolve collisions between                       values associated with the same key, as supplied
                        to 
 <code>Map.merge(Object, Object, BiFunction)</code>
 @return a <code>Collector</code> which collects elements into a <code>Map</code>
  whose keys are the result of applying a key mapping function to the input
  elements, and whose values are the result of applying a value mapping
  function to all input elements equal to the key and combining them
  using the merge function
 - seealso: #toMap(Function, Function)
 - seealso: #toMap(Function, Function, BinaryOperator, Supplier)
 - seealso: #toConcurrentMap(Function, Function, BinaryOperator)
 */
+ (id<JavaUtilStreamCollector>)toMapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyMapper
                                    withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueMapper
                              withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)mergeFunction;

/*!
 @brief Returns a <code>Collector</code> that accumulates elements into a 
 <code>Map</code> whose keys and values are the result of applying the provided
  mapping functions to the input elements.
 <p>If the mapped
  keys contains duplicates (according to <code>Object.equals(Object)</code>),
  the value mapping function is applied to each equal element, and the
  results are merged using the provided merging function.  The <code>Map</code>
  is created by a provided supplier function.
 @param keyMapper a mapping function to produce keys
 @param valueMapper a mapping function to produce values
 @param mergeFunction a merge function, used to resolve collisions between                       values associated with the same key, as supplied
                        to 
 <code>Map.merge(Object, Object, BiFunction)</code>
 @param mapSupplier a function which returns a new, empty <code>Map</code>  into
                      which the results will be inserted
 @return a <code>Collector</code> which collects elements into a <code>Map</code>
  whose keys are the result of applying a key mapping function to the input
  elements, and whose values are the result of applying a value mapping
  function to all input elements equal to the key and combining them
  using the merge function
 - seealso: #toMap(Function, Function)
 - seealso: #toMap(Function, Function, BinaryOperator)
 - seealso: #toConcurrentMap(Function, Function, BinaryOperator, Supplier)
 */
+ (id<JavaUtilStreamCollector>)toMapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyMapper
                                    withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueMapper
                              withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)mergeFunction
                                    withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)mapSupplier;

/*!
 @brief Returns a <code>Collector</code> that accumulates the input elements into a
  new <code>Set</code>.There are no guarantees on the type, mutability,
  serializability, or thread-safety of the <code>Set</code> returned; if more
  control over the returned <code>Set</code> is required, use 
 <code>toCollection(Supplier)</code>.
 <p>This is an <code>unordered</code>
  Collector.
 @return a <code>Collector</code> which collects all the input elements into a 
 <code>Set</code>
 */
+ (id<JavaUtilStreamCollector>)toSet;

#pragma mark Package-Private

/*!
 @brief If the compensated sum is spuriously NaN from accumulating one
  or more same-signed infinite values, return the
  correctly-signed infinity stored in the simple sum.
 */
+ (jdouble)computeFinalSumWithDoubleArray:(IOSDoubleArray *)summands;

/*!
 @brief Incorporate a new double value using Kahan summation /
  compensation summation.
 High-order bits of the sum are in intermediateSum[0], low-order
  bits of the sum are in intermediateSum[1], any additional
  elements are application-specific.
 @param intermediateSum the high-order and low-order words of the intermediate sum
 @param value the name value to be included in the running sum
 */
+ (IOSDoubleArray *)sumWithCompensationWithDoubleArray:(IOSDoubleArray *)intermediateSum
                                            withDouble:(jdouble)value;

@end

J2OBJC_STATIC_INIT(JavaUtilStreamCollectors)

inline id<JavaUtilSet> JavaUtilStreamCollectors_get_CH_CONCURRENT_ID(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilStreamCollectors_CH_CONCURRENT_ID;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilStreamCollectors, CH_CONCURRENT_ID, id<JavaUtilSet>)

inline id<JavaUtilSet> JavaUtilStreamCollectors_get_CH_CONCURRENT_NOID(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilStreamCollectors_CH_CONCURRENT_NOID;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilStreamCollectors, CH_CONCURRENT_NOID, id<JavaUtilSet>)

inline id<JavaUtilSet> JavaUtilStreamCollectors_get_CH_ID(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilStreamCollectors_CH_ID;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilStreamCollectors, CH_ID, id<JavaUtilSet>)

inline id<JavaUtilSet> JavaUtilStreamCollectors_get_CH_UNORDERED_ID(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilStreamCollectors_CH_UNORDERED_ID;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilStreamCollectors, CH_UNORDERED_ID, id<JavaUtilSet>)

inline id<JavaUtilSet> JavaUtilStreamCollectors_get_CH_NOID(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilStreamCollectors_CH_NOID;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilStreamCollectors, CH_NOID, id<JavaUtilSet>)

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toCollectionWithJavaUtilFunctionSupplier_(id<JavaUtilFunctionSupplier> collectionFactory);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toList(void);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toSet(void);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_joining(void);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_joiningWithJavaLangCharSequence_(id<JavaLangCharSequence> delimiter);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_joiningWithJavaLangCharSequence_withJavaLangCharSequence_withJavaLangCharSequence_(id<JavaLangCharSequence> delimiter, id<JavaLangCharSequence> prefix, id<JavaLangCharSequence> suffix);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_mappingWithJavaUtilFunctionFunction_withJavaUtilStreamCollector_(id<JavaUtilFunctionFunction> mapper, id<JavaUtilStreamCollector> downstream);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_collectingAndThenWithJavaUtilStreamCollector_withJavaUtilFunctionFunction_(id<JavaUtilStreamCollector> downstream, id<JavaUtilFunctionFunction> finisher);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_counting(void);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_minByWithJavaUtilComparator_(id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_maxByWithJavaUtilComparator_(id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_summingIntWithJavaUtilFunctionToIntFunction_(id<JavaUtilFunctionToIntFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_summingLongWithJavaUtilFunctionToLongFunction_(id<JavaUtilFunctionToLongFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_summingDoubleWithJavaUtilFunctionToDoubleFunction_(id<JavaUtilFunctionToDoubleFunction> mapper);

FOUNDATION_EXPORT IOSDoubleArray *JavaUtilStreamCollectors_sumWithCompensationWithDoubleArray_withDouble_(IOSDoubleArray *intermediateSum, jdouble value);

FOUNDATION_EXPORT jdouble JavaUtilStreamCollectors_computeFinalSumWithDoubleArray_(IOSDoubleArray *summands);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_averagingIntWithJavaUtilFunctionToIntFunction_(id<JavaUtilFunctionToIntFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_averagingLongWithJavaUtilFunctionToLongFunction_(id<JavaUtilFunctionToLongFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_averagingDoubleWithJavaUtilFunctionToDoubleFunction_(id<JavaUtilFunctionToDoubleFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_reducingWithId_withJavaUtilFunctionBinaryOperator_(id identity, id<JavaUtilFunctionBinaryOperator> op);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_reducingWithJavaUtilFunctionBinaryOperator_(id<JavaUtilFunctionBinaryOperator> op);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_reducingWithId_withJavaUtilFunctionFunction_withJavaUtilFunctionBinaryOperator_(id identity, id<JavaUtilFunctionFunction> mapper, id<JavaUtilFunctionBinaryOperator> op);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_groupingByWithJavaUtilFunctionFunction_(id<JavaUtilFunctionFunction> classifier);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_groupingByWithJavaUtilFunctionFunction_withJavaUtilStreamCollector_(id<JavaUtilFunctionFunction> classifier, id<JavaUtilStreamCollector> downstream);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_groupingByWithJavaUtilFunctionFunction_withJavaUtilFunctionSupplier_withJavaUtilStreamCollector_(id<JavaUtilFunctionFunction> classifier, id<JavaUtilFunctionSupplier> mapFactory, id<JavaUtilStreamCollector> downstream);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_groupingByConcurrentWithJavaUtilFunctionFunction_(id<JavaUtilFunctionFunction> classifier);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_groupingByConcurrentWithJavaUtilFunctionFunction_withJavaUtilStreamCollector_(id<JavaUtilFunctionFunction> classifier, id<JavaUtilStreamCollector> downstream);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_groupingByConcurrentWithJavaUtilFunctionFunction_withJavaUtilFunctionSupplier_withJavaUtilStreamCollector_(id<JavaUtilFunctionFunction> classifier, id<JavaUtilFunctionSupplier> mapFactory, id<JavaUtilStreamCollector> downstream);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_partitioningByWithJavaUtilFunctionPredicate_(id<JavaUtilFunctionPredicate> predicate);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_partitioningByWithJavaUtilFunctionPredicate_withJavaUtilStreamCollector_(id<JavaUtilFunctionPredicate> predicate, id<JavaUtilStreamCollector> downstream);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toMapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_(id<JavaUtilFunctionFunction> keyMapper, id<JavaUtilFunctionFunction> valueMapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toMapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_withJavaUtilFunctionBinaryOperator_(id<JavaUtilFunctionFunction> keyMapper, id<JavaUtilFunctionFunction> valueMapper, id<JavaUtilFunctionBinaryOperator> mergeFunction);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toMapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_withJavaUtilFunctionBinaryOperator_withJavaUtilFunctionSupplier_(id<JavaUtilFunctionFunction> keyMapper, id<JavaUtilFunctionFunction> valueMapper, id<JavaUtilFunctionBinaryOperator> mergeFunction, id<JavaUtilFunctionSupplier> mapSupplier);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toConcurrentMapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_(id<JavaUtilFunctionFunction> keyMapper, id<JavaUtilFunctionFunction> valueMapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toConcurrentMapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_withJavaUtilFunctionBinaryOperator_(id<JavaUtilFunctionFunction> keyMapper, id<JavaUtilFunctionFunction> valueMapper, id<JavaUtilFunctionBinaryOperator> mergeFunction);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_toConcurrentMapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_withJavaUtilFunctionBinaryOperator_withJavaUtilFunctionSupplier_(id<JavaUtilFunctionFunction> keyMapper, id<JavaUtilFunctionFunction> valueMapper, id<JavaUtilFunctionBinaryOperator> mergeFunction, id<JavaUtilFunctionSupplier> mapSupplier);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_summarizingIntWithJavaUtilFunctionToIntFunction_(id<JavaUtilFunctionToIntFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_summarizingLongWithJavaUtilFunctionToLongFunction_(id<JavaUtilFunctionToLongFunction> mapper);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> JavaUtilStreamCollectors_summarizingDoubleWithJavaUtilFunctionToDoubleFunction_(id<JavaUtilFunctionToDoubleFunction> mapper);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilStreamCollectors)

#endif

#if !defined (JavaUtilStreamCollectors_CollectorImpl_) && (INCLUDE_ALL_JavaUtilStreamCollectors || defined(INCLUDE_JavaUtilStreamCollectors_CollectorImpl))
#define JavaUtilStreamCollectors_CollectorImpl_

#define RESTRICT_JavaUtilStreamCollector 1
#define INCLUDE_JavaUtilStreamCollector 1
#include "java/util/stream/Collector.h"

@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBinaryOperator;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionSupplier;
@protocol JavaUtilSet;

/*!
 @brief Simple implementation class for <code>Collector</code>.
 */
@interface JavaUtilStreamCollectors_CollectorImpl : NSObject < JavaUtilStreamCollector >

#pragma mark Public

- (id<JavaUtilFunctionBiConsumer>)accumulator;

- (id<JavaUtilSet>)characteristics;

- (id<JavaUtilFunctionBinaryOperator>)combiner;

- (id<JavaUtilFunctionFunction>)finisher;

- (id<JavaUtilFunctionSupplier>)supplier;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier
                            withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)accumulator
                        withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)combiner
                              withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)finisher
                                           withJavaUtilSet:(id<JavaUtilSet>)characteristics;

- (instancetype __nonnull)initWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier
                            withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)accumulator
                        withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)combiner
                                           withJavaUtilSet:(id<JavaUtilSet>)characteristics;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilStreamCollectors_CollectorImpl)

FOUNDATION_EXPORT void JavaUtilStreamCollectors_CollectorImpl_initWithJavaUtilFunctionSupplier_withJavaUtilFunctionBiConsumer_withJavaUtilFunctionBinaryOperator_withJavaUtilFunctionFunction_withJavaUtilSet_(JavaUtilStreamCollectors_CollectorImpl *self, id<JavaUtilFunctionSupplier> supplier, id<JavaUtilFunctionBiConsumer> accumulator, id<JavaUtilFunctionBinaryOperator> combiner, id<JavaUtilFunctionFunction> finisher, id<JavaUtilSet> characteristics);

FOUNDATION_EXPORT JavaUtilStreamCollectors_CollectorImpl *new_JavaUtilStreamCollectors_CollectorImpl_initWithJavaUtilFunctionSupplier_withJavaUtilFunctionBiConsumer_withJavaUtilFunctionBinaryOperator_withJavaUtilFunctionFunction_withJavaUtilSet_(id<JavaUtilFunctionSupplier> supplier, id<JavaUtilFunctionBiConsumer> accumulator, id<JavaUtilFunctionBinaryOperator> combiner, id<JavaUtilFunctionFunction> finisher, id<JavaUtilSet> characteristics) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilStreamCollectors_CollectorImpl *create_JavaUtilStreamCollectors_CollectorImpl_initWithJavaUtilFunctionSupplier_withJavaUtilFunctionBiConsumer_withJavaUtilFunctionBinaryOperator_withJavaUtilFunctionFunction_withJavaUtilSet_(id<JavaUtilFunctionSupplier> supplier, id<JavaUtilFunctionBiConsumer> accumulator, id<JavaUtilFunctionBinaryOperator> combiner, id<JavaUtilFunctionFunction> finisher, id<JavaUtilSet> characteristics);

FOUNDATION_EXPORT void JavaUtilStreamCollectors_CollectorImpl_initWithJavaUtilFunctionSupplier_withJavaUtilFunctionBiConsumer_withJavaUtilFunctionBinaryOperator_withJavaUtilSet_(JavaUtilStreamCollectors_CollectorImpl *self, id<JavaUtilFunctionSupplier> supplier, id<JavaUtilFunctionBiConsumer> accumulator, id<JavaUtilFunctionBinaryOperator> combiner, id<JavaUtilSet> characteristics);

FOUNDATION_EXPORT JavaUtilStreamCollectors_CollectorImpl *new_JavaUtilStreamCollectors_CollectorImpl_initWithJavaUtilFunctionSupplier_withJavaUtilFunctionBiConsumer_withJavaUtilFunctionBinaryOperator_withJavaUtilSet_(id<JavaUtilFunctionSupplier> supplier, id<JavaUtilFunctionBiConsumer> accumulator, id<JavaUtilFunctionBinaryOperator> combiner, id<JavaUtilSet> characteristics) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilStreamCollectors_CollectorImpl *create_JavaUtilStreamCollectors_CollectorImpl_initWithJavaUtilFunctionSupplier_withJavaUtilFunctionBiConsumer_withJavaUtilFunctionBinaryOperator_withJavaUtilSet_(id<JavaUtilFunctionSupplier> supplier, id<JavaUtilFunctionBiConsumer> accumulator, id<JavaUtilFunctionBinaryOperator> combiner, id<JavaUtilSet> characteristics);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilStreamCollectors_CollectorImpl)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilStreamCollectors")
