//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/Arrays.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilArrays")
#ifdef RESTRICT_JavaUtilArrays
#define INCLUDE_ALL_JavaUtilArrays 0
#else
#define INCLUDE_ALL_JavaUtilArrays 1
#endif
#undef RESTRICT_JavaUtilArrays

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilArrays_) && (INCLUDE_ALL_JavaUtilArrays || defined(INCLUDE_JavaUtilArrays))
#define JavaUtilArrays_

@class IOSBooleanArray;
@class IOSByteArray;
@class IOSCharArray;
@class IOSClass;
@class IOSDoubleArray;
@class IOSFloatArray;
@class IOSIntArray;
@class IOSLongArray;
@class IOSObjectArray;
@class IOSShortArray;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionBinaryOperator;
@protocol JavaUtilFunctionDoubleBinaryOperator;
@protocol JavaUtilFunctionIntBinaryOperator;
@protocol JavaUtilFunctionIntFunction;
@protocol JavaUtilFunctionIntToDoubleFunction;
@protocol JavaUtilFunctionIntToLongFunction;
@protocol JavaUtilFunctionIntUnaryOperator;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilList;
@protocol JavaUtilSpliterator;
@protocol JavaUtilSpliterator_OfDouble;
@protocol JavaUtilSpliterator_OfInt;
@protocol JavaUtilSpliterator_OfLong;
@protocol JavaUtilStreamDoubleStream;
@protocol JavaUtilStreamIntStream;
@protocol JavaUtilStreamLongStream;
@protocol JavaUtilStreamStream;

/*!
 @brief This class contains various methods for manipulating arrays (such as
  sorting and searching).This class also contains a static factory
  that allows arrays to be viewed as lists.
 <p>The methods in this class all throw a <code>NullPointerException</code>,
  if the specified array reference is null, except where noted. 
 <p>The documentation for the methods contained in this class includes
  briefs description of the <i>implementations</i>. Such descriptions should
  be regarded as <i>implementation notes</i>, rather than parts of the 
 <i>specification</i>. Implementors should feel free to substitute other
  algorithms, so long as the specification itself is adhered to. (For
  example, the algorithm used by <code>sort(Object[])</code> does not have to be
  a MergeSort, but it does have to be <i>stable</i>.)
  
 <p>This class is a member of the 
 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html">
  Java Collections Framework</a>.
 @author Josh Bloch
 @author Neal Gafter
 @author John Rose
 @since 1.2
 */
@interface JavaUtilArrays : NSObject
@property (readonly, class) jint MIN_ARRAY_SORT_GRAN NS_SWIFT_NAME(MIN_ARRAY_SORT_GRAN);

+ (jint)MIN_ARRAY_SORT_GRAN;

#pragma mark Public

/*!
 @brief Returns a fixed-size list backed by the specified array.
 (Changes to
  the returned list "write through" to the array.)  This method acts
  as bridge between array-based and collection-based APIs, in
  combination with <code>Collection.toArray</code>.  The returned list is
  serializable and implements <code>RandomAccess</code>.
  
 <p>This method also provides a convenient way to create a fixed-size
  list initialized to contain several elements: 
 @code

      List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly"); 
  
@endcode
 @param a the array by which the list will be backed
 @return a list view of the specified array
 */
+ (id<JavaUtilList> __nonnull)asListWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Searches the specified array of bytes for the specified value using the
  binary search algorithm.The array must be sorted (as
  by the <code>sort(byte[])</code> method) prior to making this call.
 If it
  is not sorted, the results are undefined.  If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithByteArray:(IOSByteArray *)a
                         withByte:(jbyte)key;

/*!
 @brief Searches a range of
  the specified array of bytes for the specified value using the
  binary search algorithm.
 The range must be sorted (as
  by the <code>sort(byte[], int, int)</code> method)
  prior to making this call.  If it
  is not sorted, the results are undefined.  If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithByteArray:(IOSByteArray *)a
                          withInt:(jint)fromIndex
                          withInt:(jint)toIndex
                         withByte:(jbyte)key;

/*!
 @brief Searches the specified array of chars for the specified value using the
  binary search algorithm.The array must be sorted (as
  by the <code>sort(char[])</code> method) prior to making this call.
 If it
  is not sorted, the results are undefined.  If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithCharArray:(IOSCharArray *)a
                         withChar:(jchar)key;

/*!
 @brief Searches a range of
  the specified array of chars for the specified value using the
  binary search algorithm.
 The range must be sorted (as
  by the <code>sort(char[], int, int)</code> method)
  prior to making this call.  If it
  is not sorted, the results are undefined.  If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithCharArray:(IOSCharArray *)a
                          withInt:(jint)fromIndex
                          withInt:(jint)toIndex
                         withChar:(jchar)key;

/*!
 @brief Searches the specified array of doubles for the specified value using
  the binary search algorithm.The array must be sorted
  (as by the <code>sort(double[])</code> method) prior to making this call.
 If it is not sorted, the results are undefined.  If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.  This method considers all NaN values to be
  equivalent and equal.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithDoubleArray:(IOSDoubleArray *)a
                         withDouble:(jdouble)key;

/*!
 @brief Searches a range of
  the specified array of doubles for the specified value using
  the binary search algorithm.
 The range must be sorted
  (as by the <code>sort(double[], int, int)</code> method)
  prior to making this call.
  If it is not sorted, the results are undefined.  If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.  This method considers all NaN values to be
  equivalent and equal.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithDoubleArray:(IOSDoubleArray *)a
                            withInt:(jint)fromIndex
                            withInt:(jint)toIndex
                         withDouble:(jdouble)key;

/*!
 @brief Searches the specified array of floats for the specified value using
  the binary search algorithm.The array must be sorted
  (as by the <code>sort(float[])</code> method) prior to making this call.
 If
  it is not sorted, the results are undefined. If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found. This method considers all NaN values to be
  equivalent and equal.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>. The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key. Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithFloatArray:(IOSFloatArray *)a
                         withFloat:(jfloat)key;

/*!
 @brief Searches a range of
  the specified array of floats for the specified value using
  the binary search algorithm.
 The range must be sorted
  (as by the <code>sort(float[], int, int)</code> method)
  prior to making this call. If
  it is not sorted, the results are undefined. If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found. This method considers all NaN values to be
  equivalent and equal.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>. The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key. Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithFloatArray:(IOSFloatArray *)a
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex
                         withFloat:(jfloat)key;

/*!
 @brief Searches the specified array of ints for the specified value using the
  binary search algorithm.The array must be sorted (as
  by the <code>sort(int[])</code> method) prior to making this call.
 If it
  is not sorted, the results are undefined.  If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithIntArray:(IOSIntArray *)a
                         withInt:(jint)key;

/*!
 @brief Searches a range of
  the specified array of ints for the specified value using the
  binary search algorithm.
 The range must be sorted (as
  by the <code>sort(int[], int, int)</code> method)
  prior to making this call.  If it
  is not sorted, the results are undefined.  If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithIntArray:(IOSIntArray *)a
                         withInt:(jint)fromIndex
                         withInt:(jint)toIndex
                         withInt:(jint)key;

/*!
 @brief Searches a range of
  the specified array of longs for the specified value using the
  binary search algorithm.
 The range must be sorted (as
  by the <code>sort(long[], int, int)</code> method)
  prior to making this call.  If it
  is not sorted, the results are undefined.  If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithLongArray:(IOSLongArray *)a
                          withInt:(jint)fromIndex
                          withInt:(jint)toIndex
                         withLong:(jlong)key;

/*!
 @brief Searches the specified array of longs for the specified value using the
  binary search algorithm.The array must be sorted (as
  by the <code>sort(long[])</code> method) prior to making this call.
 If it
  is not sorted, the results are undefined.  If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithLongArray:(IOSLongArray *)a
                         withLong:(jlong)key;

/*!
 @brief Searches a range of
  the specified array for the specified object using the binary
  search algorithm.
 The range must be sorted into ascending order
  according to the 
 natural ordering
  of its elements (as by the 
 <code>sort(Object[], int, int)</code> method) prior to making this
  call.  If it is not sorted, the results are undefined.
  (If the range contains elements that are not mutually comparable (for
  example, strings and integers), it <i>cannot</i> be sorted according
  to the natural ordering of its elements, hence results are undefined.)
  If the range contains multiple
  elements equal to the specified object, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw ClassCastExceptionif the search key is not comparable to the
          elements of the array within the specified range.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithNSObjectArray:(IOSObjectArray *)a
                              withInt:(jint)fromIndex
                              withInt:(jint)toIndex
                               withId:(id)key;

/*!
 @brief Searches the specified array for the specified object using the binary
  search algorithm.The array must be sorted into ascending order
  according to the 
 natural ordering
  of its elements (as by the 
 <code>sort(Object[])</code> method) prior to making this call.
 If it is not sorted, the results are undefined.
  (If the array contains elements that are not mutually comparable (for
  example, strings and integers), it <i>cannot</i> be sorted according
  to the natural ordering of its elements, hence results are undefined.)
  If the array contains multiple
  elements equal to the specified object, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw ClassCastExceptionif the search key is not comparable to the
          elements of the array.
 */
+ (jint)binarySearchWithNSObjectArray:(IOSObjectArray *)a
                               withId:(id)key;

/*!
 @brief Searches a range of
  the specified array of shorts for the specified value using
  the binary search algorithm.
 The range must be sorted
  (as by the <code>sort(short[], int, int)</code> method)
  prior to making this call.  If
  it is not sorted, the results are undefined.  If the range contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithShortArray:(IOSShortArray *)a
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex
                         withShort:(jshort)key;

/*!
 @brief Searches the specified array of shorts for the specified value using
  the binary search algorithm.The array must be sorted
  (as by the <code>sort(short[])</code> method) prior to making this call.
 If
  it is not sorted, the results are undefined.  If the array contains
  multiple elements with the specified value, there is no guarantee which
  one will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 */
+ (jint)binarySearchWithShortArray:(IOSShortArray *)a
                         withShort:(jshort)key;

/*!
 @brief Searches a range of
  the specified array for the specified object using the binary
  search algorithm.
 The range must be sorted into ascending order
  according to the specified comparator (as by the 
 <code>sort(T[], int, int, Comparator)</code>
  method) prior to making this call.
  If it is not sorted, the results are undefined.
  If the range contains multiple elements equal to the specified object,
  there is no guarantee which one will be found.
 @param a the array to be searched
 @param fromIndex the index of the first element (inclusive) to be           searched
 @param toIndex the index of the last element (exclusive) to be searched
 @param key the value to be searched for
 @param c the comparator by which the array is ordered.  A         
  <tt> null </tt>  value indicates that the elements'         
 natural ordering  should be used.
 @return index of the search key, if it is contained in the array
          within the specified range;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element in the range greater than the key,
          or <tt>toIndex</tt> if all
          elements in the range are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw ClassCastExceptionif the range contains elements that are not
          <i>mutually comparable</i> using the specified comparator,
          or the search key is not comparable to the
          elements in the range using this comparator.
 @throw IllegalArgumentException
 if <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0 or toIndex > a.length</code>
 @since 1.6
 */
+ (jint)binarySearchWithNSObjectArray:(IOSObjectArray *)a
                              withInt:(jint)fromIndex
                              withInt:(jint)toIndex
                               withId:(id)key
               withJavaUtilComparator:(id<JavaUtilComparator>)c;

/*!
 @brief Searches the specified array for the specified object using the binary
  search algorithm.The array must be sorted into ascending order
  according to the specified comparator (as by the 
 <code>sort(T[], Comparator)</code>
  method) prior to making this call.
 If it is
  not sorted, the results are undefined.
  If the array contains multiple
  elements equal to the specified object, there is no guarantee which one
  will be found.
 @param a the array to be searched
 @param key the value to be searched for
 @param c the comparator by which the array is ordered.  A         
  <tt> null </tt>  value indicates that the elements'         
 natural ordering  should be used.
 @return index of the search key, if it is contained in the array;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the array: the index of the first
          element greater than the key, or <tt>a.length</tt> if all
          elements in the array are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw ClassCastExceptionif the array contains elements that are not
          <i>mutually comparable</i> using the specified comparator,
          or the search key is not comparable to the
          elements of the array using this comparator.
 */
+ (jint)binarySearchWithNSObjectArray:(IOSObjectArray *)a
                               withId:(id)key
               withJavaUtilComparator:(id<JavaUtilComparator>)c;

/*!
 @brief Checks that the range described by <code>offset</code> and <code>count</code> doesn't exceed 
 <code>arrayLength</code>.
 Android-changed.
 */
+ (void)checkOffsetAndCountWithInt:(jint)arrayLength
                           withInt:(jint)offset
                           withInt:(jint)count;

/*!
 @brief Copies the specified array, truncating or padding with <tt>false</tt> (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>false</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with false elements
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSBooleanArray * __nonnull)copyOfWithBooleanArray:(IOSBooleanArray *)original
                                              withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with zeros (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>(byte)0</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with zeros
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSByteArray * __nonnull)copyOfWithByteArray:(IOSByteArray *)original
                                        withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with null characters (if necessary)
  so the copy has the specified length.For all indices that are valid
  in both the original array and the copy, the two arrays will contain
  identical values.
 For any indices that are valid in the copy but not
  the original, the copy will contain <tt>'\\u000'</tt>.  Such indices
  will exist if and only if the specified length is greater than that of
  the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with null characters
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSCharArray * __nonnull)copyOfWithCharArray:(IOSCharArray *)original
                                        withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with zeros (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>0d</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with zeros
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSDoubleArray * __nonnull)copyOfWithDoubleArray:(IOSDoubleArray *)original
                                            withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with zeros (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>0f</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with zeros
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSFloatArray * __nonnull)copyOfWithFloatArray:(IOSFloatArray *)original
                                          withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with zeros (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>0</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with zeros
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSIntArray * __nonnull)copyOfWithIntArray:(IOSIntArray *)original
                                      withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with zeros (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>0L</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with zeros
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSLongArray * __nonnull)copyOfWithLongArray:(IOSLongArray *)original
                                        withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with zeros (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>(short)0</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with zeros
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSShortArray * __nonnull)copyOfWithShortArray:(IOSShortArray *)original
                                          withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with nulls (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>null</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
  The resulting array is of exactly the same class as the original array.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @return a copy of the original array, truncated or padded with nulls
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSObjectArray * __nonnull)copyOfWithNSObjectArray:(IOSObjectArray *)original
                                              withInt:(jint)newLength OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified array, truncating or padding with nulls (if necessary)
  so the copy has the specified length.For all indices that are
  valid in both the original array and the copy, the two arrays will
  contain identical values.
 For any indices that are valid in the
  copy but not the original, the copy will contain <tt>null</tt>.
  Such indices will exist if and only if the specified length
  is greater than that of the original array.
  The resulting array is of the class <tt>newType</tt>.
 @param original the array to be copied
 @param newLength the length of the copy to be returned
 @param newType the class of the copy to be returned
 @return a copy of the original array, truncated or padded with nulls
      to obtain the specified length
 @throw NegativeArraySizeExceptionif <tt>newLength</tt> is negative
 @throw NullPointerExceptionif <tt>original</tt> is null
 @throw ArrayStoreExceptionif an element copied from
      <tt>original</tt> is not of a runtime type that can be stored in
      an array of class <tt>newType</tt>
 @since 1.6
 */
+ (IOSObjectArray * __nonnull)copyOfWithNSObjectArray:(IOSObjectArray *)original
                                              withInt:(jint)newLength
                                         withIOSClass:(IOSClass *)newType OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>false</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with false elements to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSBooleanArray * __nonnull)copyOfRangeWithBooleanArray:(IOSBooleanArray *)original
                                                   withInt:(jint)from
                                                   withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>(byte)0</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with zeros to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSByteArray * __nonnull)copyOfRangeWithByteArray:(IOSByteArray *)original
                                             withInt:(jint)from
                                             withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>'\\u000'</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with null characters to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSCharArray * __nonnull)copyOfRangeWithCharArray:(IOSCharArray *)original
                                             withInt:(jint)from
                                             withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>0d</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with zeros to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSDoubleArray * __nonnull)copyOfRangeWithDoubleArray:(IOSDoubleArray *)original
                                                 withInt:(jint)from
                                                 withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>0f</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with zeros to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSFloatArray * __nonnull)copyOfRangeWithFloatArray:(IOSFloatArray *)original
                                               withInt:(jint)from
                                               withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>0</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with zeros to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSIntArray * __nonnull)copyOfRangeWithIntArray:(IOSIntArray *)original
                                           withInt:(jint)from
                                           withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>0L</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with zeros to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSLongArray * __nonnull)copyOfRangeWithLongArray:(IOSLongArray *)original
                                             withInt:(jint)from
                                             withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>(short)0</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with zeros to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSShortArray * __nonnull)copyOfRangeWithShortArray:(IOSShortArray *)original
                                               withInt:(jint)from
                                               withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>null</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
  <p>
  The resulting array is of exactly the same class as the original array.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @return a new array containing the specified range from the original array,
      truncated or padded with nulls to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @since 1.6
 */
+ (IOSObjectArray * __nonnull)copyOfRangeWithNSObjectArray:(IOSObjectArray *)original
                                                   withInt:(jint)from
                                                   withInt:(jint)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies the specified range of the specified array into a new array.
 The initial index of the range (<tt>from</tt>) must lie between zero
  and <tt>original.length</tt>, inclusive.  The value at 
 <tt>original[from]</tt> is placed into the initial element of the copy
  (unless <tt>from == original.length</tt> or <tt>from == to</tt>).
  Values from subsequent elements in the original array are placed into
  subsequent elements in the copy.  The final index of the range
  (<tt>to</tt>), which must be greater than or equal to <tt>from</tt>,
  may be greater than <tt>original.length</tt>, in which case 
 <tt>null</tt> is placed in all elements of the copy whose index is
  greater than or equal to <tt>original.length - from</tt>.  The length
  of the returned array will be <tt>to - from</tt>.
  The resulting array is of the class <tt>newType</tt>.
 @param original the array from which a range is to be copied
 @param from the initial index of the range to be copied, inclusive
 @param to the final index of the range to be copied, exclusive.      (This index may lie outside the array.)
 @param newType the class of the copy to be returned
 @return a new array containing the specified range from the original array,
      truncated or padded with nulls to obtain the required length
 @throw ArrayIndexOutOfBoundsExceptionif <code>from < 0</code>
      or <code>from > original.length</code>
 @throw IllegalArgumentExceptionif <tt>from &gt; to</tt>
 @throw NullPointerExceptionif <tt>original</tt> is null
 @throw ArrayStoreExceptionif an element copied from
      <tt>original</tt> is not of a runtime type that can be stored in
      an array of class <tt>newType</tt>.
 @since 1.6
 */
+ (IOSObjectArray * __nonnull)copyOfRangeWithNSObjectArray:(IOSObjectArray *)original
                                                   withInt:(jint)from
                                                   withInt:(jint)to
                                              withIOSClass:(IOSClass *)newType OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays are <i>deeply
  equal</i> to one another.Unlike the <code>equals(Object[],Object[])</code>
  method, this method is appropriate for use with nested arrays of
  arbitrary depth.
 <p>Two array references are considered deeply equal if both are 
 <tt>null</tt>, or if they refer to arrays that contain the same
  number of elements and all corresponding pairs of elements in the two
  arrays are deeply equal. 
 <p>Two possibly <tt>null</tt> elements <tt>e1</tt> and <tt>e2</tt> are
  deeply equal if any of the following conditions hold: 
 <ul>
     <li> <tt>e1</tt> and <tt>e2</tt> are both arrays of object reference
          types, and <tt>Arrays.deepEquals(e1, e2) would return true</tt>
     <li> <tt>e1</tt> and <tt>e2</tt> are arrays of the same primitive
          type, and the appropriate overloading of         
 <tt>Arrays.equals(e1, e2)</tt> would return true.
     <li> <tt>e1 == e2</tt>
     <li> <tt>e1.equals(e2)</tt> would return true. 
 </ul>
  Note that this definition permits <tt>null</tt> elements at any depth. 
 <p>If either of the specified arrays contain themselves as elements
  either directly or indirectly through one or more levels of arrays,
  the behavior of this method is undefined.
 @param a1 one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 - seealso: #equals(Object[],Object[])
 - seealso: Objects#deepEquals(Object, Object)
 @since 1.5
 */
+ (jboolean)deepEqualsWithNSObjectArray:(IOSObjectArray *)a1
                      withNSObjectArray:(IOSObjectArray *)a2;

/*!
 @brief Returns a hash code based on the "deep contents" of the specified
  array.If the array contains other arrays as elements, the
  hash code is based on their contents and so on, ad infinitum.
 It is therefore unacceptable to invoke this method on an array that
  contains itself as an element, either directly or indirectly through
  one or more levels of arrays.  The behavior of such an invocation is
  undefined. 
 <p>For any two arrays <tt>a</tt> and <tt>b</tt> such that 
 <tt>Arrays.deepEquals(a, b)</tt>, it is also the case that 
 <tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt>.
  
 <p>The computation of the value returned by this method is similar to
  that of the value returned by <code>List.hashCode()</code> on a list
  containing the same elements as <tt>a</tt> in the same order, with one
  difference: If an element <tt>e</tt> of <tt>a</tt> is itself an array,
  its hash code is computed not by calling <tt>e.hashCode()</tt>, but as
  by calling the appropriate overloading of <tt>Arrays.hashCode(e)</tt>
  if <tt>e</tt> is an array of a primitive type, or as by calling 
 <tt>Arrays.deepHashCode(e)</tt> recursively if <tt>e</tt> is an array
  of a reference type.  If <tt>a</tt> is <tt>null</tt>, this method
  returns 0.
 @param a the array whose deep-content-based hash code to compute
 @return a deep-content-based hash code for <tt>a</tt>
 - seealso: #hashCode(Object[])
 @since 1.5
 */
+ (jint)deepHashCodeWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Returns a string representation of the "deep contents" of the specified
  array.If the array contains other arrays as elements, the string
  representation contains their contents and so on.
 This method is
  designed for converting multidimensional arrays to strings. 
 <p>The string representation consists of a list of the array's
  elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent
  elements are separated by the characters <tt>", "</tt> (a comma
  followed by a space).  Elements are converted to strings as by 
 <tt>String.valueOf(Object)</tt>, unless they are themselves
  arrays. 
 <p>If an element <tt>e</tt> is an array of a primitive type, it is
  converted to a string as by invoking the appropriate overloading of 
 <tt>Arrays.toString(e)</tt>.  If an element <tt>e</tt> is an array of a
  reference type, it is converted to a string as by invoking
  this method recursively. 
 <p>To avoid infinite recursion, if the specified array contains itself
  as an element, or contains an indirect reference to itself through one
  or more levels of arrays, the self-reference is converted to the string 
 <tt>"[...]"</tt>.  For example, an array containing only a reference
  to itself would be rendered as <tt>"[[...]]"</tt>.
  
 <p>This method returns <tt>"null"</tt> if the specified array
  is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 - seealso: #toString(Object[])
 @since 1.5
 */
+ (NSString * __nonnull)deepToStringWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of booleans are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithBooleanArray:(IOSBooleanArray *)a
                  withBooleanArray:(IOSBooleanArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of bytes are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithByteArray:(IOSByteArray *)a
                  withByteArray:(IOSByteArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of chars are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithCharArray:(IOSCharArray *)a
                  withCharArray:(IOSCharArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of doubles are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
  Two doubles <tt>d1</tt> and <tt>d2</tt> are considered equal if: 
 @code
    <tt>new Double(d1).equals(new Double(d2))</tt>
@endcode
  (Unlike the <tt>==</tt> operator, this method considers 
 <tt>NaN</tt> equals to itself, and 0.0d unequal to -0.0d.)
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 - seealso: Double#equals(Object)
 */
+ (jboolean)equalsWithDoubleArray:(IOSDoubleArray *)a
                  withDoubleArray:(IOSDoubleArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of floats are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
  Two floats <tt>f1</tt> and <tt>f2</tt> are considered equal if: 
 @code
    <tt>new Float(f1).equals(new Float(f2))</tt>
@endcode
  (Unlike the <tt>==</tt> operator, this method considers 
 <tt>NaN</tt> equals to itself, and 0.0f unequal to -0.0f.)
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 - seealso: Float#equals(Object)
 */
+ (jboolean)equalsWithFloatArray:(IOSFloatArray *)a
                  withFloatArray:(IOSFloatArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of ints are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithIntArray:(IOSIntArray *)a
                  withIntArray:(IOSIntArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of longs are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithLongArray:(IOSLongArray *)a
                  withLongArray:(IOSLongArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of Objects are 
 <i>equal</i> to one another.The two arrays are considered equal if
  both arrays contain the same number of elements, and all corresponding
  pairs of elements in the two arrays are equal.
 Two objects <tt>e1</tt>
  and <tt>e2</tt> are considered <i>equal</i> if <tt>(e1==null ? e2==null
  : e1.equals(e2))</tt>.  In other words, the two arrays are equal if
  they contain the same elements in the same order.  Also, two array
  references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithNSObjectArray:(IOSObjectArray *)a
                  withNSObjectArray:(IOSObjectArray *)a2;

/*!
 @brief Returns <tt>true</tt> if the two specified arrays of shorts are 
 <i>equal</i> to one another.Two arrays are considered equal if both
  arrays contain the same number of elements, and all corresponding pairs
  of elements in the two arrays are equal.
 In other words, two arrays
  are equal if they contain the same elements in the same order.  Also,
  two array references are considered equal if both are <tt>null</tt>.<p>
 @param a one array to be tested for equality
 @param a2 the other array to be tested for equality
 @return <tt>true</tt> if the two arrays are equal
 */
+ (jboolean)equalsWithShortArray:(IOSShortArray *)a
                  withShortArray:(IOSShortArray *)a2;

/*!
 @brief Assigns the specified boolean value to each element of the specified
  array of booleans.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithBooleanArray:(IOSBooleanArray *)a
                 withBoolean:(jboolean)val;

/*!
 @brief Assigns the specified boolean value to each element of the specified
  range of the specified array of booleans.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithBooleanArray:(IOSBooleanArray *)a
                     withInt:(jint)fromIndex
                     withInt:(jint)toIndex
                 withBoolean:(jboolean)val;

/*!
 @brief Assigns the specified byte value to each element of the specified array
  of bytes.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithByteArray:(IOSByteArray *)a
                 withByte:(jbyte)val;

/*!
 @brief Assigns the specified byte value to each element of the specified
  range of the specified array of bytes.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithByteArray:(IOSByteArray *)a
                  withInt:(jint)fromIndex
                  withInt:(jint)toIndex
                 withByte:(jbyte)val;

/*!
 @brief Assigns the specified char value to each element of the specified array
  of chars.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithCharArray:(IOSCharArray *)a
                 withChar:(jchar)val;

/*!
 @brief Assigns the specified char value to each element of the specified
  range of the specified array of chars.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithCharArray:(IOSCharArray *)a
                  withInt:(jint)fromIndex
                  withInt:(jint)toIndex
                 withChar:(jchar)val;

/*!
 @brief Assigns the specified double value to each element of the specified
  array of doubles.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithDoubleArray:(IOSDoubleArray *)a
                 withDouble:(jdouble)val;

/*!
 @brief Assigns the specified double value to each element of the specified
  range of the specified array of doubles.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithDoubleArray:(IOSDoubleArray *)a
                    withInt:(jint)fromIndex
                    withInt:(jint)toIndex
                 withDouble:(jdouble)val;

/*!
 @brief Assigns the specified float value to each element of the specified array
  of floats.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithFloatArray:(IOSFloatArray *)a
                 withFloat:(jfloat)val;

/*!
 @brief Assigns the specified float value to each element of the specified
  range of the specified array of floats.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithFloatArray:(IOSFloatArray *)a
                   withInt:(jint)fromIndex
                   withInt:(jint)toIndex
                 withFloat:(jfloat)val;

/*!
 @brief Assigns the specified int value to each element of the specified array
  of ints.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithIntArray:(IOSIntArray *)a
                 withInt:(jint)val;

/*!
 @brief Assigns the specified int value to each element of the specified
  range of the specified array of ints.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithIntArray:(IOSIntArray *)a
                 withInt:(jint)fromIndex
                 withInt:(jint)toIndex
                 withInt:(jint)val;

/*!
 @brief Assigns the specified long value to each element of the specified
  range of the specified array of longs.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithLongArray:(IOSLongArray *)a
                  withInt:(jint)fromIndex
                  withInt:(jint)toIndex
                 withLong:(jlong)val;

/*!
 @brief Assigns the specified long value to each element of the specified array
  of longs.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithLongArray:(IOSLongArray *)a
                 withLong:(jlong)val;

/*!
 @brief Assigns the specified Object reference to each element of the specified
  range of the specified array of Objects.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 @throw ArrayStoreExceptionif the specified value is not of a
          runtime type that can be stored in the specified array
 */
+ (void)fillWithNSObjectArray:(IOSObjectArray *)a
                      withInt:(jint)fromIndex
                      withInt:(jint)toIndex
                       withId:(id)val;

/*!
 @brief Assigns the specified Object reference to each element of the specified
  array of Objects.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 @throw ArrayStoreExceptionif the specified value is not of a
          runtime type that can be stored in the specified array
 */
+ (void)fillWithNSObjectArray:(IOSObjectArray *)a
                       withId:(id)val;

/*!
 @brief Assigns the specified short value to each element of the specified
  range of the specified array of shorts.The range to be filled
  extends from index <tt>fromIndex</tt>, inclusive, to index 
 <tt>toIndex</tt>, exclusive.
 (If <tt>fromIndex==toIndex</tt>, the
  range to be filled is empty.)
 @param a the array to be filled
 @param fromIndex the index of the first element (inclusive) to be         filled with the specified value
 @param toIndex the index of the last element (exclusive) to be         filled with the specified value
 @param val the value to be stored in all elements of the array
 @throw IllegalArgumentExceptionif <tt>fromIndex &gt; toIndex</tt>
 @throw ArrayIndexOutOfBoundsExceptionif <tt>fromIndex &lt; 0</tt> or
          <tt>toIndex &gt; a.length</tt>
 */
+ (void)fillWithShortArray:(IOSShortArray *)a
                   withInt:(jint)fromIndex
                   withInt:(jint)toIndex
                 withShort:(jshort)val;

/*!
 @brief Assigns the specified short value to each element of the specified array
  of shorts.
 @param a the array to be filled
 @param val the value to be stored in all elements of the array
 */
+ (void)fillWithShortArray:(IOSShortArray *)a
                 withShort:(jshort)val;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>boolean</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Boolean</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithBooleanArray:(IOSBooleanArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>byte</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Byte</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithByteArray:(IOSByteArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>char</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Character</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithCharArray:(IOSCharArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>double</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Double</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithDoubleArray:(IOSDoubleArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>float</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Float</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithFloatArray:(IOSFloatArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two non-null <tt>int</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Integer</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithIntArray:(IOSIntArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>long</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Long</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithLongArray:(IOSLongArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.If
  the array contains other arrays as elements, the hash code is based on
  their identities rather than their contents.
 It is therefore
  acceptable to invoke this method on an array that contains itself as an
  element,  either directly or indirectly through one or more levels of
  arrays. 
 <p>For any two arrays <tt>a</tt> and <tt>b</tt> such that 
 <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is equal to the value that would
  be returned by <tt>Arrays.asList(a).hashCode()</tt>, unless <tt>a</tt>
  is <tt>null</tt>, in which case <tt>0</tt> is returned.
 @param a the array whose content-based hash code to compute
 @return a content-based hash code for <tt>a</tt>
 - seealso: #deepHashCode(Object[])
 @since 1.5
 */
+ (jint)hashCodeWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Returns a hash code based on the contents of the specified array.
 For any two <tt>short</tt> arrays <tt>a</tt> and <tt>b</tt>
  such that <tt>Arrays.equals(a, b)</tt>, it is also the case that 
 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
  
 <p>The value returned by this method is the same value that would be
  obtained by invoking the <code><tt>hashCode</tt></code>
  method on a <code>List</code> containing a sequence of <code>Short</code>
  instances representing the elements of <tt>a</tt> in the same order.
  If <tt>a</tt> is <tt>null</tt>, this method returns 0.
 @param a the array whose hash value to compute
 @return a content-based hash code for <tt>a</tt>
 @since 1.5
 */
+ (jint)hashCodeWithShortArray:(IOSShortArray *)a;

/*!
 @brief Cumulates, in parallel, each element of the given array in place,
  using the supplied function.For example if the array initially
  holds <code>[2.0, 1.0, 0.0, 3.0]</code> and the operation performs addition,
  then upon return the array holds <code>[2.0, 3.0, 3.0, 6.0]</code>.
 Parallel prefix computation is usually more efficient than
  sequential loops for large arrays. 
 <p> Because floating-point operations may not be strictly associative,
  the returned result may not be identical to the value that would be
  obtained if the operation was performed sequentially.
 @param array the array, which is modified in-place by this method
 @param op a side-effect-free function to perform the cumulation
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithDoubleArray:(IOSDoubleArray *)array
withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)op;

/*!
 @brief Performs <code>parallelPrefix(double[], DoubleBinaryOperator)</code>
  for the given subrange of the array.
 @param array the array
 @param fromIndex the index of the first element, inclusive
 @param toIndex the index of the last element, exclusive
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > array.length</code>
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithDoubleArray:(IOSDoubleArray *)array
                              withInt:(jint)fromIndex
                              withInt:(jint)toIndex
withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)op;

/*!
 @brief Performs <code>parallelPrefix(int[], IntBinaryOperator)</code>
  for the given subrange of the array.
 @param array the array
 @param fromIndex the index of the first element, inclusive
 @param toIndex the index of the last element, exclusive
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > array.length</code>
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithIntArray:(IOSIntArray *)array
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex
withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)op;

/*!
 @brief Cumulates, in parallel, each element of the given array in place,
  using the supplied function.For example if the array initially
  holds <code>[2, 1, 0, 3]</code> and the operation performs addition,
  then upon return the array holds <code>[2, 3, 3, 6]</code>.
 Parallel prefix computation is usually more efficient than
  sequential loops for large arrays.
 @param array the array, which is modified in-place by this method
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithIntArray:(IOSIntArray *)array
withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)op;

/*!
 @brief Performs <code>parallelPrefix(long[], LongBinaryOperator)</code>
  for the given subrange of the array.
 @param array the array
 @param fromIndex the index of the first element, inclusive
 @param toIndex the index of the last element, exclusive
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > array.length</code>
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithLongArray:(IOSLongArray *)array
                            withInt:(jint)fromIndex
                            withInt:(jint)toIndex
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)op;

/*!
 @brief Cumulates, in parallel, each element of the given array in place,
  using the supplied function.For example if the array initially
  holds <code>[2, 1, 0, 3]</code> and the operation performs addition,
  then upon return the array holds <code>[2, 3, 3, 6]</code>.
 Parallel prefix computation is usually more efficient than
  sequential loops for large arrays.
 @param array the array, which is modified in-place by this method
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithLongArray:(IOSLongArray *)array
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)op;

/*!
 @brief Cumulates, in parallel, each element of the given array in place,
  using the supplied function.For example if the array initially
  holds <code>[2, 1, 0, 3]</code> and the operation performs addition,
  then upon return the array holds <code>[2, 3, 3, 6]</code>.
 Parallel prefix computation is usually more efficient than
  sequential loops for large arrays.
 @param array the array, which is modified in-place by this method
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithNSObjectArray:(IOSObjectArray *)array
     withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)op;

/*!
 @brief Performs <code>parallelPrefix(Object[], BinaryOperator)</code>
  for the given subrange of the array.
 @param array the array
 @param fromIndex the index of the first element, inclusive
 @param toIndex the index of the last element, exclusive
 @param op a side-effect-free, associative function to perform the  cumulation
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > array.length</code>
 @throw NullPointerExceptionif the specified array or function is null
 @since 1.8
 */
+ (void)parallelPrefixWithNSObjectArray:(IOSObjectArray *)array
                                withInt:(jint)fromIndex
                                withInt:(jint)toIndex
     withJavaUtilFunctionBinaryOperator:(id<JavaUtilFunctionBinaryOperator>)op;

/*!
 @brief Set all elements of the specified array, in parallel, using the
  provided generator function to compute each element.
 <p>If the generator function throws an exception, an unchecked exception
  is thrown from <code>parallelSetAll</code> and the array is left in an
  indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)parallelSetAllWithDoubleArray:(IOSDoubleArray *)array
withJavaUtilFunctionIntToDoubleFunction:(id<JavaUtilFunctionIntToDoubleFunction>)generator;

/*!
 @brief Set all elements of the specified array, in parallel, using the
  provided generator function to compute each element.
 <p>If the generator function throws an exception, an unchecked exception
  is thrown from <code>parallelSetAll</code> and the array is left in an
  indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired  value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)parallelSetAllWithIntArray:(IOSIntArray *)array
withJavaUtilFunctionIntUnaryOperator:(id<JavaUtilFunctionIntUnaryOperator>)generator;

/*!
 @brief Set all elements of the specified array, in parallel, using the
  provided generator function to compute each element.
 <p>If the generator function throws an exception, an unchecked exception
  is thrown from <code>parallelSetAll</code> and the array is left in an
  indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)parallelSetAllWithLongArray:(IOSLongArray *)array
withJavaUtilFunctionIntToLongFunction:(id<JavaUtilFunctionIntToLongFunction>)generator;

/*!
 @brief Set all elements of the specified array, in parallel, using the
  provided generator function to compute each element.
 <p>If the generator function throws an exception, an unchecked exception
  is thrown from <code>parallelSetAll</code> and the array is left in an
  indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)parallelSetAllWithNSObjectArray:(IOSObjectArray *)array
        withJavaUtilFunctionIntFunction:(id<JavaUtilFunctionIntFunction>)generator;

/*!
 @brief Sorts the specified array into ascending numerical order.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithByteArray:(IOSByteArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithByteArray:(IOSByteArray *)a
                          withInt:(jint)fromIndex
                          withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithCharArray:(IOSCharArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithCharArray:(IOSCharArray *)a
                          withInt:(jint)fromIndex
                          withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>The <code><</code> relation does not provide a total order on all double
  values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Double.compareTo</code>: <code>-0.0d</code> is treated as less than value 
 <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any
  other value and all <code>Double.NaN</code> values are considered equal.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithDoubleArray:(IOSDoubleArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty. 
 <p>The <code><</code> relation does not provide a total order on all double
  values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Double.compareTo</code>: <code>-0.0d</code> is treated as less than value 
 <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any
  other value and all <code>Double.NaN</code> values are considered equal.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithDoubleArray:(IOSDoubleArray *)a
                            withInt:(jint)fromIndex
                            withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>The <code><</code> relation does not provide a total order on all float
  values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Float.compareTo</code>: <code>-0.0f</code> is treated as less than value 
 <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any
  other value and all <code>Float.NaN</code> values are considered equal.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithFloatArray:(IOSFloatArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty. 
 <p>The <code><</code> relation does not provide a total order on all float
  values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Float.compareTo</code>: <code>-0.0f</code> is treated as less than value 
 <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any
  other value and all <code>Float.NaN</code> values are considered equal.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithFloatArray:(IOSFloatArray *)a
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithIntArray:(IOSIntArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithIntArray:(IOSIntArray *)a
                         withInt:(jint)fromIndex
                         withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithLongArray:(IOSLongArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithLongArray:(IOSLongArray *)a
                          withInt:(jint)fromIndex
                          withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 @param a the array to be sorted
 @since 1.8
 */
+ (void)parallelSortWithShortArray:(IOSShortArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending numerical order.
 The range to be sorted extends from the index <code>fromIndex</code>,
  inclusive, to the index <code>toIndex</code>, exclusive. If 
 <code>fromIndex == toIndex</code>, the range to be sorted is empty.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 @since 1.8
 */
+ (void)parallelSortWithShortArray:(IOSShortArray *)a
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array of objects into ascending order, according
  to the natural ordering of its elements.
 All elements in the array must implement the <code>Comparable</code>
  interface.  Furthermore, all elements in the array must be 
 <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code> must
  not throw a <code>ClassCastException</code> for any elements <code>e1</code>
  and <code>e2</code> in the array). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort.
 @param a the array to be sorted
 @throw ClassCastExceptionif the array contains elements that are not
          <i>mutually comparable</i> (for example, strings and integers)
 @throw IllegalArgumentException(optional) if the natural
          ordering of the array elements is found to violate the         
 <code>Comparable</code> contract
 @since 1.8
 */
+ (void)parallelSortWithJavaLangComparableArray:(IOSObjectArray *)a;

/*!
 @brief Sorts the specified array of objects according to the order induced by
  the specified comparator.All elements in the array must be 
 <i>mutually comparable</i> by the specified comparator (that is, 
 <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code>
  for any elements <code>e1</code> and <code>e2</code> in the array).
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort.
 @param a the array to be sorted
 @param cmp the comparator to determine the order of the array.  A         
 <code>null</code>  value indicates that the elements'         
 natural ordering  should be used.
 @throw ClassCastExceptionif the array contains elements that are
          not <i>mutually comparable</i> using the specified comparator
 @throw IllegalArgumentException(optional) if the comparator is
          found to violate the <code>java.util.Comparator</code> contract
 @since 1.8
 */
+ (void)parallelSortWithNSObjectArray:(IOSObjectArray *)a
               withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Sorts the specified range of the specified array of objects into
  ascending order, according to the 
 natural ordering of its
  elements.The range to be sorted extends from index 
 <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive.
 (If <code>fromIndex==toIndex</code>, the range to be sorted is empty.)  All
  elements in this range must implement the <code>Comparable</code>
  interface.  Furthermore, all elements in this range must be <i>mutually
  comparable</i> (that is, <code>e1.compareTo(e2)</code> must not throw a 
 <code>ClassCastException</code> for any elements <code>e1</code> and 
 <code>e2</code> in the array). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort.
 @param a the array to be sorted
 @param fromIndex the index of the first element (inclusive) to be         sorted
 @param toIndex the index of the last element (exclusive) to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code> or
          (optional) if the natural ordering of the array elements is
          found to violate the <code>Comparable</code> contract
 @throw ArrayIndexOutOfBoundsExceptionif <code>fromIndex < 0</code> or
          <code>toIndex > a.length</code>
 @throw ClassCastExceptionif the array contains elements that are
          not <i>mutually comparable</i> (for example, strings and
          integers).
 @since 1.8
 */
+ (void)parallelSortWithJavaLangComparableArray:(IOSObjectArray *)a
                                        withInt:(jint)fromIndex
                                        withInt:(jint)toIndex;

/*!
 @brief Sorts the specified range of the specified array of objects according
  to the order induced by the specified comparator.The range to be
  sorted extends from index <code>fromIndex</code>, inclusive, to index 
 <code>toIndex</code>, exclusive.
 (If <code>fromIndex==toIndex</code>, the
  range to be sorted is empty.)  All elements in the range must be 
 <i>mutually comparable</i> by the specified comparator (that is, 
 <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code>
  for any elements <code>e1</code> and <code>e2</code> in the range). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort.
 @param a the array to be sorted
 @param fromIndex the index of the first element (inclusive) to be         sorted
 @param toIndex the index of the last element (exclusive) to be sorted
 @param cmp the comparator to determine the order of the array.  A         
 <code>null</code>  value indicates that the elements'         
 natural ordering  should be used.
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code> or
          (optional) if the natural ordering of the array elements is
          found to violate the <code>Comparable</code> contract
 @throw ArrayIndexOutOfBoundsExceptionif <code>fromIndex < 0</code> or
          <code>toIndex > a.length</code>
 @throw ClassCastExceptionif the array contains elements that are
          not <i>mutually comparable</i> (for example, strings and
          integers).
 @since 1.8
 */
+ (void)parallelSortWithNSObjectArray:(IOSObjectArray *)a
                              withInt:(jint)fromIndex
                              withInt:(jint)toIndex
               withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Set all elements of the specified array, using the provided
  generator function to compute each element.
 <p>If the generator function throws an exception, it is relayed to
  the caller and the array is left in an indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)setAllWithDoubleArray:(IOSDoubleArray *)array
withJavaUtilFunctionIntToDoubleFunction:(id<JavaUtilFunctionIntToDoubleFunction>)generator;

/*!
 @brief Set all elements of the specified array, using the provided
  generator function to compute each element.
 <p>If the generator function throws an exception, it is relayed to
  the caller and the array is left in an indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)setAllWithIntArray:(IOSIntArray *)array
withJavaUtilFunctionIntUnaryOperator:(id<JavaUtilFunctionIntUnaryOperator>)generator;

/*!
 @brief Set all elements of the specified array, using the provided
  generator function to compute each element.
 <p>If the generator function throws an exception, it is relayed to
  the caller and the array is left in an indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)setAllWithLongArray:(IOSLongArray *)array
withJavaUtilFunctionIntToLongFunction:(id<JavaUtilFunctionIntToLongFunction>)generator;

/*!
 @brief Set all elements of the specified array, using the provided
  generator function to compute each element.
 <p>If the generator function throws an exception, it is relayed to
  the caller and the array is left in an indeterminate state.
 @param array array to be initialized
 @param generator a function accepting an index and producing the desired         value for that position
 @throw NullPointerExceptionif the generator is null
 @since 1.8
 */
+ (void)setAllWithNSObjectArray:(IOSObjectArray *)array
withJavaUtilFunctionIntFunction:(id<JavaUtilFunctionIntFunction>)generator;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithByteArray:(IOSByteArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithByteArray:(IOSByteArray *)a
                  withInt:(jint)fromIndex
                  withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithCharArray:(IOSCharArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithCharArray:(IOSCharArray *)a
                  withInt:(jint)fromIndex
                  withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>The <code><</code> relation does not provide a total order on all double
  values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Double.compareTo</code>: <code>-0.0d</code> is treated as less than value 
 <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any
  other value and all <code>Double.NaN</code> values are considered equal. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithDoubleArray:(IOSDoubleArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>The <code><</code> relation does not provide a total order on all double
  values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Double.compareTo</code>: <code>-0.0d</code> is treated as less than value 
 <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any
  other value and all <code>Double.NaN</code> values are considered equal. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithDoubleArray:(IOSDoubleArray *)a
                    withInt:(jint)fromIndex
                    withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>The <code><</code> relation does not provide a total order on all float
  values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Float.compareTo</code>: <code>-0.0f</code> is treated as less than value 
 <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any
  other value and all <code>Float.NaN</code> values are considered equal. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithFloatArray:(IOSFloatArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>The <code><</code> relation does not provide a total order on all float
  values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code>
  value compares neither less than, greater than, nor equal to any value,
  even itself. This method uses the total order imposed by the method 
 <code>Float.compareTo</code>: <code>-0.0f</code> is treated as less than value 
 <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any
  other value and all <code>Float.NaN</code> values are considered equal. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithFloatArray:(IOSFloatArray *)a
                   withInt:(jint)fromIndex
                   withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithIntArray:(IOSIntArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithIntArray:(IOSIntArray *)a
                 withInt:(jint)fromIndex
                 withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithLongArray:(IOSLongArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithLongArray:(IOSLongArray *)a
                  withInt:(jint)fromIndex
                  withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array of objects into ascending order, according
  to the natural ordering of its elements.
 All elements in the array must implement the <code>Comparable</code>
  interface.  Furthermore, all elements in the array must be 
 <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code> must
  not throw a <code>ClassCastException</code> for any elements <code>e1</code>
  and <code>e2</code> in the array). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort. 
 <p>Implementation note: This implementation is a stable, adaptive,
  iterative mergesort that requires far fewer than n lg(n) comparisons
  when the input array is partially sorted, while offering the
  performance of a traditional mergesort when the input array is
  randomly ordered.  If the input array is nearly sorted, the
  implementation requires approximately n comparisons.  Temporary
  storage requirements vary from a small constant for nearly sorted
  input arrays to n/2 object references for randomly ordered input
  arrays. 
 <p>The implementation takes equal advantage of ascending and
  descending order in its input array, and can take advantage of
  ascending and descending order in different parts of the the same
  input array.  It is well-suited to merging two or more sorted arrays:
  simply concatenate the arrays and sort the resulting array. 
 <p>The implementation was adapted from Tim Peters's list sort for Python
  (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">
  TimSort</a>).  It uses techniques from Peter McIlroy's "Optimistic
  Sorting and Information Theoretic Complexity", in Proceedings of the
  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
  January 1993.
 @param a the array to be sorted
 @throw ClassCastExceptionif the array contains elements that are not
          <i>mutually comparable</i> (for example, strings and integers)
 @throw IllegalArgumentException(optional) if the natural
          ordering of the array elements is found to violate the         
 <code>Comparable</code> contract
 */
+ (void)sortWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Sorts the specified range of the specified array of objects into
  ascending order, according to the 
 natural ordering of its
  elements.The range to be sorted extends from index 
 <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive.
 (If <code>fromIndex==toIndex</code>, the range to be sorted is empty.)  All
  elements in this range must implement the <code>Comparable</code>
  interface.  Furthermore, all elements in this range must be <i>mutually
  comparable</i> (that is, <code>e1.compareTo(e2)</code> must not throw a 
 <code>ClassCastException</code> for any elements <code>e1</code> and 
 <code>e2</code> in the array). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort. 
 <p>Implementation note: This implementation is a stable, adaptive,
  iterative mergesort that requires far fewer than n lg(n) comparisons
  when the input array is partially sorted, while offering the
  performance of a traditional mergesort when the input array is
  randomly ordered.  If the input array is nearly sorted, the
  implementation requires approximately n comparisons.  Temporary
  storage requirements vary from a small constant for nearly sorted
  input arrays to n/2 object references for randomly ordered input
  arrays. 
 <p>The implementation takes equal advantage of ascending and
  descending order in its input array, and can take advantage of
  ascending and descending order in different parts of the the same
  input array.  It is well-suited to merging two or more sorted arrays:
  simply concatenate the arrays and sort the resulting array. 
 <p>The implementation was adapted from Tim Peters's list sort for Python
  (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">
  TimSort</a>).  It uses techniques from Peter McIlroy's "Optimistic
  Sorting and Information Theoretic Complexity", in Proceedings of the
  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
  January 1993.
 @param a the array to be sorted
 @param fromIndex the index of the first element (inclusive) to be         sorted
 @param toIndex the index of the last element (exclusive) to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code> or
          (optional) if the natural ordering of the array elements is
          found to violate the <code>Comparable</code> contract
 @throw ArrayIndexOutOfBoundsExceptionif <code>fromIndex < 0</code> or
          <code>toIndex > a.length</code>
 @throw ClassCastExceptionif the array contains elements that are
          not <i>mutually comparable</i> (for example, strings and
          integers).
 */
+ (void)sortWithNSObjectArray:(IOSObjectArray *)a
                      withInt:(jint)fromIndex
                      withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array into ascending numerical order.
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 */
+ (void)sortWithShortArray:(IOSShortArray *)a;

/*!
 @brief Sorts the specified range of the array into ascending order.The range
  to be sorted extends from the index <code>fromIndex</code>, inclusive, to
  the index <code>toIndex</code>, exclusive.
 If <code>fromIndex == toIndex</code>,
  the range to be sorted is empty. 
 <p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
  by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
  offers O(n log(n)) performance on many data sets that cause other
  quicksorts to degrade to quadratic performance, and is typically
  faster than traditional (one-pivot) Quicksort implementations.
 @param a the array to be sorted
 @param fromIndex the index of the first element, inclusive, to be sorted
 @param toIndex the index of the last element, exclusive, to be sorted
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code>
 @throw ArrayIndexOutOfBoundsException
 if <code>fromIndex < 0</code> or <code>toIndex > a.length</code>
 */
+ (void)sortWithShortArray:(IOSShortArray *)a
                   withInt:(jint)fromIndex
                   withInt:(jint)toIndex;

/*!
 @brief Sorts the specified array of objects according to the order induced by
  the specified comparator.All elements in the array must be 
 <i>mutually comparable</i> by the specified comparator (that is, 
 <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code>
  for any elements <code>e1</code> and <code>e2</code> in the array).
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort. 
 <p>Implementation note: This implementation is a stable, adaptive,
  iterative mergesort that requires far fewer than n lg(n) comparisons
  when the input array is partially sorted, while offering the
  performance of a traditional mergesort when the input array is
  randomly ordered.  If the input array is nearly sorted, the
  implementation requires approximately n comparisons.  Temporary
  storage requirements vary from a small constant for nearly sorted
  input arrays to n/2 object references for randomly ordered input
  arrays. 
 <p>The implementation takes equal advantage of ascending and
  descending order in its input array, and can take advantage of
  ascending and descending order in different parts of the the same
  input array.  It is well-suited to merging two or more sorted arrays:
  simply concatenate the arrays and sort the resulting array. 
 <p>The implementation was adapted from Tim Peters's list sort for Python
  (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">
  TimSort</a>).  It uses techniques from Peter McIlroy's "Optimistic
  Sorting and Information Theoretic Complexity", in Proceedings of the
  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
  January 1993.
 @param a the array to be sorted
 @param c the comparator to determine the order of the array.  A         
 <code>null</code>  value indicates that the elements'         
 natural ordering  should be used.
 @throw ClassCastExceptionif the array contains elements that are
          not <i>mutually comparable</i> using the specified comparator
 @throw IllegalArgumentException(optional) if the comparator is
          found to violate the <code>Comparator</code> contract
 */
+ (void)sortWithNSObjectArray:(IOSObjectArray *)a
       withJavaUtilComparator:(id<JavaUtilComparator>)c;

/*!
 @brief Sorts the specified range of the specified array of objects according
  to the order induced by the specified comparator.The range to be
  sorted extends from index <code>fromIndex</code>, inclusive, to index 
 <code>toIndex</code>, exclusive.
 (If <code>fromIndex==toIndex</code>, the
  range to be sorted is empty.)  All elements in the range must be 
 <i>mutually comparable</i> by the specified comparator (that is, 
 <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code>
  for any elements <code>e1</code> and <code>e2</code> in the range). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort. 
 <p>Implementation note: This implementation is a stable, adaptive,
  iterative mergesort that requires far fewer than n lg(n) comparisons
  when the input array is partially sorted, while offering the
  performance of a traditional mergesort when the input array is
  randomly ordered.  If the input array is nearly sorted, the
  implementation requires approximately n comparisons.  Temporary
  storage requirements vary from a small constant for nearly sorted
  input arrays to n/2 object references for randomly ordered input
  arrays. 
 <p>The implementation takes equal advantage of ascending and
  descending order in its input array, and can take advantage of
  ascending and descending order in different parts of the the same
  input array.  It is well-suited to merging two or more sorted arrays:
  simply concatenate the arrays and sort the resulting array. 
 <p>The implementation was adapted from Tim Peters's list sort for Python
  (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">
  TimSort</a>).  It uses techniques from Peter McIlroy's "Optimistic
  Sorting and Information Theoretic Complexity", in Proceedings of the
  Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474,
  January 1993.
 @param a the array to be sorted
 @param fromIndex the index of the first element (inclusive) to be         sorted
 @param toIndex the index of the last element (exclusive) to be sorted
 @param c the comparator to determine the order of the array.  A         
 <code>null</code>  value indicates that the elements'         
 natural ordering  should be used.
 @throw ClassCastExceptionif the array contains elements that are not
          <i>mutually comparable</i> using the specified comparator.
 @throw IllegalArgumentExceptionif <code>fromIndex > toIndex</code> or
          (optional) if the comparator is found to violate the         
 <code>Comparator</code> contract
 @throw ArrayIndexOutOfBoundsExceptionif <code>fromIndex < 0</code> or
          <code>toIndex > a.length</code>
 */
+ (void)sortWithNSObjectArray:(IOSObjectArray *)a
                      withInt:(jint)fromIndex
                      withInt:(jint)toIndex
       withJavaUtilComparator:(id<JavaUtilComparator>)c;

/*!
 @brief Returns a <code>Spliterator.OfDouble</code> covering all of the specified
  array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @return a spliterator for the array elements
 @since 1.8
 */
+ (id<JavaUtilSpliterator_OfDouble> __nonnull)spliteratorWithDoubleArray:(IOSDoubleArray *)array;

/*!
 @brief Returns a <code>Spliterator.OfDouble</code> covering the specified range of
  the specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a spliterator for the array elements
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilSpliterator_OfDouble> __nonnull)spliteratorWithDoubleArray:(IOSDoubleArray *)array
                                                                 withInt:(jint)startInclusive
                                                                 withInt:(jint)endExclusive;

/*!
 @brief Returns a <code>Spliterator.OfInt</code> covering all of the specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @return a spliterator for the array elements
 @since 1.8
 */
+ (id<JavaUtilSpliterator_OfInt> __nonnull)spliteratorWithIntArray:(IOSIntArray *)array;

/*!
 @brief Returns a <code>Spliterator.OfInt</code> covering the specified range of the
  specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a spliterator for the array elements
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilSpliterator_OfInt> __nonnull)spliteratorWithIntArray:(IOSIntArray *)array
                                                           withInt:(jint)startInclusive
                                                           withInt:(jint)endExclusive;

/*!
 @brief Returns a <code>Spliterator.OfLong</code> covering all of the specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @return the spliterator for the array elements
 @since 1.8
 */
+ (id<JavaUtilSpliterator_OfLong> __nonnull)spliteratorWithLongArray:(IOSLongArray *)array;

/*!
 @brief Returns a <code>Spliterator.OfLong</code> covering the specified range of the
  specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a spliterator for the array elements
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilSpliterator_OfLong> __nonnull)spliteratorWithLongArray:(IOSLongArray *)array
                                                             withInt:(jint)startInclusive
                                                             withInt:(jint)endExclusive;

/*!
 @brief Returns a <code>Spliterator</code> covering all of the specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @return a spliterator for the array elements
 @since 1.8
 */
+ (id<JavaUtilSpliterator> __nonnull)spliteratorWithNSObjectArray:(IOSObjectArray *)array;

/*!
 @brief Returns a <code>Spliterator</code> covering the specified range of the
  specified array.
 <p>The spliterator reports <code>Spliterator.SIZED</code>,
  <code>Spliterator.SUBSIZED</code>, <code>Spliterator.ORDERED</code>, and 
 <code>Spliterator.IMMUTABLE</code>.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a spliterator for the array elements
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilSpliterator> __nonnull)spliteratorWithNSObjectArray:(IOSObjectArray *)array
                                                          withInt:(jint)startInclusive
                                                          withInt:(jint)endExclusive;

/*!
 @brief Returns a sequential <code>DoubleStream</code> with the specified array as its
  source.
 @param array the array, assumed to be unmodified during use
 @return a <code>DoubleStream</code> for the array
 @since 1.8
 */
+ (id<JavaUtilStreamDoubleStream> __nonnull)streamWithDoubleArray:(IOSDoubleArray *)array;

/*!
 @brief Returns a sequential <code>DoubleStream</code> with the specified range of the
  specified array as its source.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a <code>DoubleStream</code> for the array range
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilStreamDoubleStream> __nonnull)streamWithDoubleArray:(IOSDoubleArray *)array
                                                          withInt:(jint)startInclusive
                                                          withInt:(jint)endExclusive;

/*!
 @brief Returns a sequential <code>IntStream</code> with the specified array as its
  source.
 @param array the array, assumed to be unmodified during use
 @return an <code>IntStream</code> for the array
 @since 1.8
 */
+ (id<JavaUtilStreamIntStream> __nonnull)streamWithIntArray:(IOSIntArray *)array;

/*!
 @brief Returns a sequential <code>IntStream</code> with the specified range of the
  specified array as its source.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return an <code>IntStream</code> for the array range
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilStreamIntStream> __nonnull)streamWithIntArray:(IOSIntArray *)array
                                                    withInt:(jint)startInclusive
                                                    withInt:(jint)endExclusive;

/*!
 @brief Returns a sequential <code>LongStream</code> with the specified array as its
  source.
 @param array the array, assumed to be unmodified during use
 @return a <code>LongStream</code> for the array
 @since 1.8
 */
+ (id<JavaUtilStreamLongStream> __nonnull)streamWithLongArray:(IOSLongArray *)array;

/*!
 @brief Returns a sequential <code>LongStream</code> with the specified range of the
  specified array as its source.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a <code>LongStream</code> for the array range
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilStreamLongStream> __nonnull)streamWithLongArray:(IOSLongArray *)array
                                                      withInt:(jint)startInclusive
                                                      withInt:(jint)endExclusive;

/*!
 @brief Returns a sequential <code>Stream</code> with the specified array as its
  source.
 @param array The array, assumed to be unmodified during use
 @return a <code>Stream</code> for the array
 @since 1.8
 */
+ (id<JavaUtilStreamStream> __nonnull)streamWithNSObjectArray:(IOSObjectArray *)array;

/*!
 @brief Returns a sequential <code>Stream</code> with the specified range of the
  specified array as its source.
 @param array the array, assumed to be unmodified during use
 @param startInclusive the first index to cover, inclusive
 @param endExclusive index immediately past the last index to cover
 @return a <code>Stream</code> for the array range
 @throw ArrayIndexOutOfBoundsExceptionif <code>startInclusive</code> is
          negative, <code>endExclusive</code> is less than
          <code>startInclusive</code>, or <code>endExclusive</code> is greater than
          the array size
 @since 1.8
 */
+ (id<JavaUtilStreamStream> __nonnull)streamWithNSObjectArray:(IOSObjectArray *)array
                                                      withInt:(jint)startInclusive
                                                      withInt:(jint)endExclusive;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(boolean)</tt>.  Returns <tt>"null"</tt> if 
 <tt>a</tt> is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithBooleanArray:(IOSBooleanArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements
  are separated by the characters <tt>", "</tt> (a comma followed
  by a space).  Elements are converted to strings as by 
 <tt>String.valueOf(byte)</tt>.  Returns <tt>"null"</tt> if 
 <tt>a</tt> is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithByteArray:(IOSByteArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(char)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt>
  is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithCharArray:(IOSCharArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(double)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt>
  is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithDoubleArray:(IOSDoubleArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(float)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt>
  is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithFloatArray:(IOSFloatArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(int)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt> is 
 <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithIntArray:(IOSIntArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(long)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt>
  is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithLongArray:(IOSLongArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 If the array contains other arrays as elements, they are converted to
  strings by the <code>Object.toString</code> method inherited from 
 <tt>Object</tt>, which describes their <i>identities</i> rather than
  their contents. 
 <p>The value returned by this method is equal to the value that would
  be returned by <tt>Arrays.asList(a).toString()</tt>, unless <tt>a</tt>
  is <tt>null</tt>, in which case <tt>"null"</tt> is returned.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 - seealso: #deepToString(Object[])
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Returns a string representation of the contents of the specified array.
 The string representation consists of a list of the array's elements,
  enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
  separated by the characters <tt>", "</tt> (a comma followed by a
  space).  Elements are converted to strings as by 
 <tt>String.valueOf(short)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt>
  is <tt>null</tt>.
 @param a the array whose string representation to return
 @return a string representation of <tt>a</tt>
 @since 1.5
 */
+ (NSString * __nonnull)toStringWithShortArray:(IOSShortArray *)a;

#pragma mark Package-Private

+ (jboolean)deepEquals0WithId:(id)e1
                       withId:(id)e2;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilArrays)

/*!
 @brief The minimum array length below which a parallel sorting
  algorithm will not further partition the sorting task.Using
  smaller sizes typically results in memory contention across
  tasks that makes parallel speedups unlikely.
 */
inline jint JavaUtilArrays_get_MIN_ARRAY_SORT_GRAN(void);
#define JavaUtilArrays_MIN_ARRAY_SORT_GRAN 8192
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilArrays, MIN_ARRAY_SORT_GRAN, jint)

FOUNDATION_EXPORT void JavaUtilArrays_checkOffsetAndCountWithInt_withInt_withInt_(jint arrayLength, jint offset, jint count);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithIntArray_(IOSIntArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithIntArray_withInt_withInt_(IOSIntArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithLongArray_(IOSLongArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithLongArray_withInt_withInt_(IOSLongArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithShortArray_(IOSShortArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithShortArray_withInt_withInt_(IOSShortArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithCharArray_(IOSCharArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithCharArray_withInt_withInt_(IOSCharArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithByteArray_(IOSByteArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithByteArray_withInt_withInt_(IOSByteArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithFloatArray_(IOSFloatArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithFloatArray_withInt_withInt_(IOSFloatArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithDoubleArray_(IOSDoubleArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithDoubleArray_withInt_withInt_(IOSDoubleArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithByteArray_(IOSByteArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithByteArray_withInt_withInt_(IOSByteArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithCharArray_(IOSCharArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithCharArray_withInt_withInt_(IOSCharArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithShortArray_(IOSShortArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithShortArray_withInt_withInt_(IOSShortArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithIntArray_(IOSIntArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithIntArray_withInt_withInt_(IOSIntArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithLongArray_(IOSLongArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithLongArray_withInt_withInt_(IOSLongArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithFloatArray_(IOSFloatArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithFloatArray_withInt_withInt_(IOSFloatArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithDoubleArray_(IOSDoubleArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithDoubleArray_withInt_withInt_(IOSDoubleArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithJavaLangComparableArray_(IOSObjectArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithJavaLangComparableArray_withInt_withInt_(IOSObjectArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithNSObjectArray_withJavaUtilComparator_(IOSObjectArray *a, id<JavaUtilComparator> cmp);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSortWithNSObjectArray_withInt_withInt_withJavaUtilComparator_(IOSObjectArray *a, jint fromIndex, jint toIndex, id<JavaUtilComparator> cmp);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithNSObjectArray_(IOSObjectArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithNSObjectArray_withInt_withInt_(IOSObjectArray *a, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithNSObjectArray_withJavaUtilComparator_(IOSObjectArray *a, id<JavaUtilComparator> c);

FOUNDATION_EXPORT void JavaUtilArrays_sortWithNSObjectArray_withInt_withInt_withJavaUtilComparator_(IOSObjectArray *a, jint fromIndex, jint toIndex, id<JavaUtilComparator> c);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithNSObjectArray_withJavaUtilFunctionBinaryOperator_(IOSObjectArray *array, id<JavaUtilFunctionBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithNSObjectArray_withInt_withInt_withJavaUtilFunctionBinaryOperator_(IOSObjectArray *array, jint fromIndex, jint toIndex, id<JavaUtilFunctionBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithLongArray_withJavaUtilFunctionLongBinaryOperator_(IOSLongArray *array, id<JavaUtilFunctionLongBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithLongArray_withInt_withInt_withJavaUtilFunctionLongBinaryOperator_(IOSLongArray *array, jint fromIndex, jint toIndex, id<JavaUtilFunctionLongBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithDoubleArray_withJavaUtilFunctionDoubleBinaryOperator_(IOSDoubleArray *array, id<JavaUtilFunctionDoubleBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithDoubleArray_withInt_withInt_withJavaUtilFunctionDoubleBinaryOperator_(IOSDoubleArray *array, jint fromIndex, jint toIndex, id<JavaUtilFunctionDoubleBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithIntArray_withJavaUtilFunctionIntBinaryOperator_(IOSIntArray *array, id<JavaUtilFunctionIntBinaryOperator> op);

FOUNDATION_EXPORT void JavaUtilArrays_parallelPrefixWithIntArray_withInt_withInt_withJavaUtilFunctionIntBinaryOperator_(IOSIntArray *array, jint fromIndex, jint toIndex, id<JavaUtilFunctionIntBinaryOperator> op);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithLongArray_withLong_(IOSLongArray *a, jlong key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithLongArray_withInt_withInt_withLong_(IOSLongArray *a, jint fromIndex, jint toIndex, jlong key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithIntArray_withInt_(IOSIntArray *a, jint key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithIntArray_withInt_withInt_withInt_(IOSIntArray *a, jint fromIndex, jint toIndex, jint key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithShortArray_withShort_(IOSShortArray *a, jshort key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithShortArray_withInt_withInt_withShort_(IOSShortArray *a, jint fromIndex, jint toIndex, jshort key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithCharArray_withChar_(IOSCharArray *a, jchar key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithCharArray_withInt_withInt_withChar_(IOSCharArray *a, jint fromIndex, jint toIndex, jchar key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithByteArray_withByte_(IOSByteArray *a, jbyte key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithByteArray_withInt_withInt_withByte_(IOSByteArray *a, jint fromIndex, jint toIndex, jbyte key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithDoubleArray_withDouble_(IOSDoubleArray *a, jdouble key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithDoubleArray_withInt_withInt_withDouble_(IOSDoubleArray *a, jint fromIndex, jint toIndex, jdouble key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithFloatArray_withFloat_(IOSFloatArray *a, jfloat key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithFloatArray_withInt_withInt_withFloat_(IOSFloatArray *a, jint fromIndex, jint toIndex, jfloat key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithNSObjectArray_withId_(IOSObjectArray *a, id key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithNSObjectArray_withInt_withInt_withId_(IOSObjectArray *a, jint fromIndex, jint toIndex, id key);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithNSObjectArray_withId_withJavaUtilComparator_(IOSObjectArray *a, id key, id<JavaUtilComparator> c);

FOUNDATION_EXPORT jint JavaUtilArrays_binarySearchWithNSObjectArray_withInt_withInt_withId_withJavaUtilComparator_(IOSObjectArray *a, jint fromIndex, jint toIndex, id key, id<JavaUtilComparator> c);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithLongArray_withLongArray_(IOSLongArray *a, IOSLongArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithIntArray_withIntArray_(IOSIntArray *a, IOSIntArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithShortArray_withShortArray_(IOSShortArray *a, IOSShortArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithCharArray_withCharArray_(IOSCharArray *a, IOSCharArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithByteArray_withByteArray_(IOSByteArray *a, IOSByteArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithBooleanArray_withBooleanArray_(IOSBooleanArray *a, IOSBooleanArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithDoubleArray_withDoubleArray_(IOSDoubleArray *a, IOSDoubleArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithFloatArray_withFloatArray_(IOSFloatArray *a, IOSFloatArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_equalsWithNSObjectArray_withNSObjectArray_(IOSObjectArray *a, IOSObjectArray *a2);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithLongArray_withLong_(IOSLongArray *a, jlong val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithLongArray_withInt_withInt_withLong_(IOSLongArray *a, jint fromIndex, jint toIndex, jlong val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithIntArray_withInt_(IOSIntArray *a, jint val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithIntArray_withInt_withInt_withInt_(IOSIntArray *a, jint fromIndex, jint toIndex, jint val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithShortArray_withShort_(IOSShortArray *a, jshort val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithShortArray_withInt_withInt_withShort_(IOSShortArray *a, jint fromIndex, jint toIndex, jshort val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithCharArray_withChar_(IOSCharArray *a, jchar val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithCharArray_withInt_withInt_withChar_(IOSCharArray *a, jint fromIndex, jint toIndex, jchar val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithByteArray_withByte_(IOSByteArray *a, jbyte val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithByteArray_withInt_withInt_withByte_(IOSByteArray *a, jint fromIndex, jint toIndex, jbyte val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithBooleanArray_withBoolean_(IOSBooleanArray *a, jboolean val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithBooleanArray_withInt_withInt_withBoolean_(IOSBooleanArray *a, jint fromIndex, jint toIndex, jboolean val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithDoubleArray_withDouble_(IOSDoubleArray *a, jdouble val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithDoubleArray_withInt_withInt_withDouble_(IOSDoubleArray *a, jint fromIndex, jint toIndex, jdouble val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithFloatArray_withFloat_(IOSFloatArray *a, jfloat val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithFloatArray_withInt_withInt_withFloat_(IOSFloatArray *a, jint fromIndex, jint toIndex, jfloat val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithNSObjectArray_withId_(IOSObjectArray *a, id val);

FOUNDATION_EXPORT void JavaUtilArrays_fillWithNSObjectArray_withInt_withInt_withId_(IOSObjectArray *a, jint fromIndex, jint toIndex, id val);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilArrays_copyOfWithNSObjectArray_withInt_(IOSObjectArray *original, jint newLength);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilArrays_copyOfWithNSObjectArray_withInt_withIOSClass_(IOSObjectArray *original, jint newLength, IOSClass *newType);

FOUNDATION_EXPORT IOSByteArray *JavaUtilArrays_copyOfWithByteArray_withInt_(IOSByteArray *original, jint newLength);

FOUNDATION_EXPORT IOSShortArray *JavaUtilArrays_copyOfWithShortArray_withInt_(IOSShortArray *original, jint newLength);

FOUNDATION_EXPORT IOSIntArray *JavaUtilArrays_copyOfWithIntArray_withInt_(IOSIntArray *original, jint newLength);

FOUNDATION_EXPORT IOSLongArray *JavaUtilArrays_copyOfWithLongArray_withInt_(IOSLongArray *original, jint newLength);

FOUNDATION_EXPORT IOSCharArray *JavaUtilArrays_copyOfWithCharArray_withInt_(IOSCharArray *original, jint newLength);

FOUNDATION_EXPORT IOSFloatArray *JavaUtilArrays_copyOfWithFloatArray_withInt_(IOSFloatArray *original, jint newLength);

FOUNDATION_EXPORT IOSDoubleArray *JavaUtilArrays_copyOfWithDoubleArray_withInt_(IOSDoubleArray *original, jint newLength);

FOUNDATION_EXPORT IOSBooleanArray *JavaUtilArrays_copyOfWithBooleanArray_withInt_(IOSBooleanArray *original, jint newLength);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilArrays_copyOfRangeWithNSObjectArray_withInt_withInt_(IOSObjectArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilArrays_copyOfRangeWithNSObjectArray_withInt_withInt_withIOSClass_(IOSObjectArray *original, jint from, jint to, IOSClass *newType);

FOUNDATION_EXPORT IOSByteArray *JavaUtilArrays_copyOfRangeWithByteArray_withInt_withInt_(IOSByteArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSShortArray *JavaUtilArrays_copyOfRangeWithShortArray_withInt_withInt_(IOSShortArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSIntArray *JavaUtilArrays_copyOfRangeWithIntArray_withInt_withInt_(IOSIntArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSLongArray *JavaUtilArrays_copyOfRangeWithLongArray_withInt_withInt_(IOSLongArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSCharArray *JavaUtilArrays_copyOfRangeWithCharArray_withInt_withInt_(IOSCharArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSFloatArray *JavaUtilArrays_copyOfRangeWithFloatArray_withInt_withInt_(IOSFloatArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSDoubleArray *JavaUtilArrays_copyOfRangeWithDoubleArray_withInt_withInt_(IOSDoubleArray *original, jint from, jint to);

FOUNDATION_EXPORT IOSBooleanArray *JavaUtilArrays_copyOfRangeWithBooleanArray_withInt_withInt_(IOSBooleanArray *original, jint from, jint to);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilArrays_asListWithNSObjectArray_(IOSObjectArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithLongArray_(IOSLongArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithIntArray_(IOSIntArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithShortArray_(IOSShortArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithCharArray_(IOSCharArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithByteArray_(IOSByteArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithBooleanArray_(IOSBooleanArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithFloatArray_(IOSFloatArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithDoubleArray_(IOSDoubleArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_hashCodeWithNSObjectArray_(IOSObjectArray *a);

FOUNDATION_EXPORT jint JavaUtilArrays_deepHashCodeWithNSObjectArray_(IOSObjectArray *a);

FOUNDATION_EXPORT jboolean JavaUtilArrays_deepEqualsWithNSObjectArray_withNSObjectArray_(IOSObjectArray *a1, IOSObjectArray *a2);

FOUNDATION_EXPORT jboolean JavaUtilArrays_deepEquals0WithId_withId_(id e1, id e2);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithLongArray_(IOSLongArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithIntArray_(IOSIntArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithShortArray_(IOSShortArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithCharArray_(IOSCharArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithByteArray_(IOSByteArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithBooleanArray_(IOSBooleanArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithFloatArray_(IOSFloatArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithDoubleArray_(IOSDoubleArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_toStringWithNSObjectArray_(IOSObjectArray *a);

FOUNDATION_EXPORT NSString *JavaUtilArrays_deepToStringWithNSObjectArray_(IOSObjectArray *a);

FOUNDATION_EXPORT void JavaUtilArrays_setAllWithNSObjectArray_withJavaUtilFunctionIntFunction_(IOSObjectArray *array, id<JavaUtilFunctionIntFunction> generator);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSetAllWithNSObjectArray_withJavaUtilFunctionIntFunction_(IOSObjectArray *array, id<JavaUtilFunctionIntFunction> generator);

FOUNDATION_EXPORT void JavaUtilArrays_setAllWithIntArray_withJavaUtilFunctionIntUnaryOperator_(IOSIntArray *array, id<JavaUtilFunctionIntUnaryOperator> generator);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSetAllWithIntArray_withJavaUtilFunctionIntUnaryOperator_(IOSIntArray *array, id<JavaUtilFunctionIntUnaryOperator> generator);

FOUNDATION_EXPORT void JavaUtilArrays_setAllWithLongArray_withJavaUtilFunctionIntToLongFunction_(IOSLongArray *array, id<JavaUtilFunctionIntToLongFunction> generator);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSetAllWithLongArray_withJavaUtilFunctionIntToLongFunction_(IOSLongArray *array, id<JavaUtilFunctionIntToLongFunction> generator);

FOUNDATION_EXPORT void JavaUtilArrays_setAllWithDoubleArray_withJavaUtilFunctionIntToDoubleFunction_(IOSDoubleArray *array, id<JavaUtilFunctionIntToDoubleFunction> generator);

FOUNDATION_EXPORT void JavaUtilArrays_parallelSetAllWithDoubleArray_withJavaUtilFunctionIntToDoubleFunction_(IOSDoubleArray *array, id<JavaUtilFunctionIntToDoubleFunction> generator);

FOUNDATION_EXPORT id<JavaUtilSpliterator> JavaUtilArrays_spliteratorWithNSObjectArray_(IOSObjectArray *array);

FOUNDATION_EXPORT id<JavaUtilSpliterator> JavaUtilArrays_spliteratorWithNSObjectArray_withInt_withInt_(IOSObjectArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilSpliterator_OfInt> JavaUtilArrays_spliteratorWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT id<JavaUtilSpliterator_OfInt> JavaUtilArrays_spliteratorWithIntArray_withInt_withInt_(IOSIntArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilSpliterator_OfLong> JavaUtilArrays_spliteratorWithLongArray_(IOSLongArray *array);

FOUNDATION_EXPORT id<JavaUtilSpliterator_OfLong> JavaUtilArrays_spliteratorWithLongArray_withInt_withInt_(IOSLongArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilSpliterator_OfDouble> JavaUtilArrays_spliteratorWithDoubleArray_(IOSDoubleArray *array);

FOUNDATION_EXPORT id<JavaUtilSpliterator_OfDouble> JavaUtilArrays_spliteratorWithDoubleArray_withInt_withInt_(IOSDoubleArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaUtilArrays_streamWithNSObjectArray_(IOSObjectArray *array);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaUtilArrays_streamWithNSObjectArray_withInt_withInt_(IOSObjectArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilStreamIntStream> JavaUtilArrays_streamWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT id<JavaUtilStreamIntStream> JavaUtilArrays_streamWithIntArray_withInt_withInt_(IOSIntArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilStreamLongStream> JavaUtilArrays_streamWithLongArray_(IOSLongArray *array);

FOUNDATION_EXPORT id<JavaUtilStreamLongStream> JavaUtilArrays_streamWithLongArray_withInt_withInt_(IOSLongArray *array, jint startInclusive, jint endExclusive);

FOUNDATION_EXPORT id<JavaUtilStreamDoubleStream> JavaUtilArrays_streamWithDoubleArray_(IOSDoubleArray *array);

FOUNDATION_EXPORT id<JavaUtilStreamDoubleStream> JavaUtilArrays_streamWithDoubleArray_withInt_withInt_(IOSDoubleArray *array, jint startInclusive, jint endExclusive);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilArrays)

#endif

#if !defined (JavaUtilArrays_NaturalOrder_) && (INCLUDE_ALL_JavaUtilArrays || defined(INCLUDE_JavaUtilArrays_NaturalOrder))
#define JavaUtilArrays_NaturalOrder_

#define RESTRICT_JavaUtilComparator 1
#define INCLUDE_JavaUtilComparator 1
#include "java/util/Comparator.h"

@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionToDoubleFunction;
@protocol JavaUtilFunctionToIntFunction;
@protocol JavaUtilFunctionToLongFunction;

/*!
 @brief A comparator that implements the natural ordering of a group of
  mutually comparable elements.May be used when a supplied
  comparator is null.
 To simplify code-sharing within underlying
  implementations, the compare method only declares type Object
  for its second argument.
  Arrays class implementor's note: It is an empirical matter
  whether ComparableTimSort offers any performance benefit over
  TimSort used with this comparator.  If not, you are better off
  deleting or bypassing ComparableTimSort.  There is currently no
  empirical case for separating them for parallel sorting, so all
  public Object parallelSort methods use the same comparator
  based implementation.
 */
@interface JavaUtilArrays_NaturalOrder : NSObject < JavaUtilComparator >
@property (readonly, class, strong) JavaUtilArrays_NaturalOrder *INSTANCE NS_SWIFT_NAME(INSTANCE);

+ (JavaUtilArrays_NaturalOrder *)INSTANCE;

#pragma mark Public

- (jint)compareWithId:(id)first
               withId:(id)second;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_STATIC_INIT(JavaUtilArrays_NaturalOrder)

inline JavaUtilArrays_NaturalOrder *JavaUtilArrays_NaturalOrder_get_INSTANCE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilArrays_NaturalOrder *JavaUtilArrays_NaturalOrder_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilArrays_NaturalOrder, INSTANCE, JavaUtilArrays_NaturalOrder *)

FOUNDATION_EXPORT void JavaUtilArrays_NaturalOrder_init(JavaUtilArrays_NaturalOrder *self);

FOUNDATION_EXPORT JavaUtilArrays_NaturalOrder *new_JavaUtilArrays_NaturalOrder_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilArrays_NaturalOrder *create_JavaUtilArrays_NaturalOrder_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilArrays_NaturalOrder)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilArrays")
