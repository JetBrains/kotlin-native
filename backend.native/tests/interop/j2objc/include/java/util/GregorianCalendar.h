//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/GregorianCalendar.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilGregorianCalendar")
#ifdef RESTRICT_JavaUtilGregorianCalendar
#define INCLUDE_ALL_JavaUtilGregorianCalendar 0
#else
#define INCLUDE_ALL_JavaUtilGregorianCalendar 1
#endif
#undef RESTRICT_JavaUtilGregorianCalendar

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilGregorianCalendar_) && (INCLUDE_ALL_JavaUtilGregorianCalendar || defined(INCLUDE_JavaUtilGregorianCalendar))
#define JavaUtilGregorianCalendar_

#define RESTRICT_JavaUtilCalendar 1
#define INCLUDE_JavaUtilCalendar 1
#include "java/util/Calendar.h"

@class IOSIntArray;
@class JavaUtilDate;
@class JavaUtilLocale;
@class JavaUtilTimeZone;

/*!
 @brief <code>GregorianCalendar</code> is a concrete subclass of 
 <code>Calendar</code> and provides the standard calendar system
  used by most of the world.
 <p> <code>GregorianCalendar</code> is a hybrid calendar that
  supports both the Julian and Gregorian calendar systems with the
  support of a single discontinuity, which corresponds by default to
  the Gregorian date when the Gregorian calendar was instituted
  (October 15, 1582 in some countries, later in others).  The cutover
  date may be changed by the caller by calling <code>setGregorianChange()</code>
 .
  
 <p>
  Historically, in those countries which adopted the Gregorian calendar first,
  October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models
  this correctly.  Before the Gregorian cutover, <code>GregorianCalendar</code>
  implements the Julian calendar.  The only difference between the Gregorian
  and the Julian calendar is the leap year rule. The Julian calendar specifies
  leap years every four years, whereas the Gregorian calendar omits century
  years which are not divisible by 400. 
 <p>
  <code>GregorianCalendar</code> implements <em>proleptic</em> Gregorian and
  Julian calendars. That is, dates are computed by extrapolating the current
  rules indefinitely far backward and forward in time. As a result, 
 <code>GregorianCalendar</code> may be used for all years to generate
  meaningful and consistent results. However, dates obtained using 
 <code>GregorianCalendar</code> are historically accurate only from March 1, 4
  AD onward, when modern Julian calendar rules were adopted.  Before this date,
  leap year rules were applied irregularly, and before 45 BC the Julian
  calendar did not even exist. 
 <p>
  Prior to the institution of the Gregorian calendar, New Year's Day was
  March 25. To avoid confusion, this calendar always uses January 1. A manual
  adjustment may be made if desired for dates that are prior to the Gregorian
  changeover and which fall between January 1 and March 24. 
 <h3><a name="week_and_year">Week Of Year and Week Year</a></h3>
  
 <p>Values calculated for the <code>WEEK_OF_YEAR</code>
  field range from 1 to 53. The first week of a
  calendar year is the earliest seven day period starting on <code>getFirstDayOfWeek()</code>
  that contains at
  least <code>getMinimalDaysInFirstWeek()</code>
  days from that year. It thus depends
  on the values of <code>getMinimalDaysInFirstWeek()</code>, <code>getFirstDayOfWeek()</code>
 , and the day of the week of January 1. Weeks
  between week 1 of one year and week 1 of the following year
  (exclusive) are numbered sequentially from 2 to 52 or 53 (except
  for year(s) involved in the Julian-Gregorian transition). 
 <p>The <code>getFirstDayOfWeek()</code> and <code>getMinimalDaysInFirstWeek()</code>
  values are initialized using
  locale-dependent resources when constructing a <code>GregorianCalendar</code>
 . <a name="iso8601_compatible_setting">The week
  determination is compatible</a> with the ISO 8601 standard when <code>getFirstDayOfWeek()</code>
  is <code>MONDAY</code> and <code>getMinimalDaysInFirstWeek()</code>
  is 4, which values are used in locales
  where the standard is preferred. These values can explicitly be set by
  calling <code>setFirstDayOfWeek()</code> and 
 <code>setMinimalDaysInFirstWeek()</code>
 .
  
 <p>A <a name="week_year"><em>week year</em></a> is in sync with a 
 <code>WEEK_OF_YEAR</code> cycle. All weeks between the first and last
  weeks (inclusive) have the same <em>week year</em> value.
  Therefore, the first and last days of a week year may have
  different calendar year values. 
 <p>For example, January 1, 1998 is a Thursday. If <code>getFirstDayOfWeek()</code>
  is <code>MONDAY</code> and <code>getMinimalDaysInFirstWeek()</code>
  is 4 (ISO 8601 standard compatible
  setting), then week 1 of 1998 starts on December 29, 1997, and ends
  on January 4, 1998. The week year is 1998 for the last three days
  of calendar year 1997. If, however, <code>getFirstDayOfWeek()</code> is 
 <code>SUNDAY</code>, then week 1 of 1998 starts on January 4, 1998, and
  ends on January 10, 1998; the first three days of 1998 then are
  part of week 53 of 1997 and their week year is 1997. 
 <h4>Week Of Month</h4>
  
 <p>Values calculated for the <code>WEEK_OF_MONTH</code> field range from 0
  to 6.  Week 1 of a month (the days with <code>WEEK_OF_MONTH =
  1</code>) is the earliest set of at least 
 <code>getMinimalDaysInFirstWeek()</code> contiguous days in that month,
  ending on the day before <code>getFirstDayOfWeek()</code>.  Unlike
  week 1 of a year, week 1 of a month may be shorter than 7 days, need
  not start on <code>getFirstDayOfWeek()</code>, and will not include days of
  the previous month.  Days of a month before week 1 have a 
 <code>WEEK_OF_MONTH</code> of 0. 
 <p>For example, if <code>getFirstDayOfWeek()</code> is <code>SUNDAY</code>
  and <code>getMinimalDaysInFirstWeek()</code> is 4, then the first week of
  January 1998 is Sunday, January 4 through Saturday, January 10.  These days
  have a <code>WEEK_OF_MONTH</code> of 1.  Thursday, January 1 through
  Saturday, January 3 have a <code>WEEK_OF_MONTH</code> of 0.  If 
 <code>getMinimalDaysInFirstWeek()</code> is changed to 3, then January 1
  through January 3 have a <code>WEEK_OF_MONTH</code> of 1. 
 <h4>Default Fields Values</h4>
  
 <p>The <code>clear</code> method sets calendar field(s)
  undefined. <code>GregorianCalendar</code> uses the following
  default value for each calendar field if its value is undefined. 
 <table cellpadding="0" cellspacing="3" border="0" summary="GregorianCalendar default field values" style="text-align: left; width: 66%;">
    <tbody>
      <tr>
        <th style="vertical-align: top; background-color: rgb(204, 204, 255);
           text-align: center;">
 Field<br>
        </th>
        <th style="vertical-align: top; background-color: rgb(204, 204, 255);
           text-align: center;">
 Default Value<br>
        </th>
      </tr>
      <tr>
        <td style="vertical-align: middle;">
               <code>ERA<br></code>
        </td>
        <td style="vertical-align: middle;">
               <code>AD<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: middle; background-color: rgb(238, 238, 255);">
               <code>YEAR<br></code>
        </td>
        <td style="vertical-align: middle; background-color: rgb(238, 238, 255);">
               <code>1970<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: middle;">
               <code>MONTH<br></code>
        </td>
        <td style="vertical-align: middle;">
               <code>JANUARY<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top; background-color: rgb(238, 238, 255);">
               <code>DAY_OF_MONTH<br></code>
        </td>
        <td style="vertical-align: top; background-color: rgb(238, 238, 255);">
               <code>1<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: middle;">
               <code>DAY_OF_WEEK<br></code>
        </td>
        <td style="vertical-align: middle;">
               <code>the first day of week<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top; background-color: rgb(238, 238, 255);">
               <code>WEEK_OF_MONTH<br></code>
        </td>
        <td style="vertical-align: top; background-color: rgb(238, 238, 255);">
               <code>0<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">
               <code>DAY_OF_WEEK_IN_MONTH<br></code>
        </td>
        <td style="vertical-align: top;">
               <code>1<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: middle; background-color: rgb(238, 238, 255);">
               <code>AM_PM<br></code>
        </td>
        <td style="vertical-align: middle; background-color: rgb(238, 238, 255);">
               <code>AM<br></code>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: middle;">
               <code>HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND<br></code>
        </td>
        <td style="vertical-align: middle;">
               <code>0<br></code>
        </td>
      </tr>
    </tbody>
  </table>
  <br>Default values are not applicable for the fields not listed above. 
 <p>
  <strong>Example:</strong>
  <blockquote>
  @code

  // get the supported ids for GMT-08:00 (Pacific Standard Time)
  String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
  // if no ids were returned, something is wrong. get out.
  if (ids.length == 0)
      System.exit(0);
   // begin output
  System.out.println("Current Time");
  // create a Pacific Standard Time time zone
  SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
  // set up rules for Daylight Saving Time
  pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
  pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
  // create a GregorianCalendar with the Pacific Daylight time zone
  // and the current date and time
  Calendar calendar = new GregorianCalendar(pdt);
  Date trialTime = new Date();
  calendar.setTime(trialTime);
  // print out a bunch of interesting things
  System.out.println("ERA: " + calendar.get(Calendar.ERA));
  System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
  System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
  System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
  System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
  System.out.println("DATE: " + calendar.get(Calendar.DATE));
  System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
  System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
  System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
  System.out.println("DAY_OF_WEEK_IN_MONTH: "
                     + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
  System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
  System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
  System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
  System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
  System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
  System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
  System.out.println("ZONE_OFFSET: "
                     + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
  System.out.println("DST_OFFSET: "
                     + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
  System.out.println("Current Time, with hour reset to 3");
  calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
  calendar.set(Calendar.HOUR, 3);
  System.out.println("ERA: " + calendar.get(Calendar.ERA));
  System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
  System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
  System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
  System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
  System.out.println("DATE: " + calendar.get(Calendar.DATE));
  System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
  System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
  System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
  System.out.println("DAY_OF_WEEK_IN_MONTH: "
                     + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
  System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
  System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
  System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
  System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
  System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
  System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
  System.out.println("ZONE_OFFSET: "
         + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
  System.out.println("DST_OFFSET: "
         + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours 
  
@endcode
  </blockquote>
 - seealso: TimeZone
 @author David Goldsmith, Mark Davis, Chen-Lieh Huang, Alan Liu
 @since JDK1.1
 */
@interface JavaUtilGregorianCalendar : JavaUtilCalendar
@property (readonly, class) jint BC NS_SWIFT_NAME(BC);
@property (readonly, class) jint BCE NS_SWIFT_NAME(BCE);
@property (readonly, class) jint AD NS_SWIFT_NAME(AD);
@property (readonly, class) jint CE NS_SWIFT_NAME(CE);
@property (readonly, class, strong) IOSIntArray *MONTH_LENGTH NS_SWIFT_NAME(MONTH_LENGTH);
@property (readonly, class, strong) IOSIntArray *LEAP_MONTH_LENGTH NS_SWIFT_NAME(LEAP_MONTH_LENGTH);
@property (readonly, class, strong) IOSIntArray *MIN_VALUES NS_SWIFT_NAME(MIN_VALUES);
@property (readonly, class, strong) IOSIntArray *LEAST_MAX_VALUES NS_SWIFT_NAME(LEAST_MAX_VALUES);
@property (readonly, class, strong) IOSIntArray *MAX_VALUES NS_SWIFT_NAME(MAX_VALUES);
@property (readonly, class) jlong serialVersionUID NS_SWIFT_NAME(serialVersionUID);
@property (readonly, class) jlong DEFAULT_GREGORIAN_CUTOVER NS_SWIFT_NAME(DEFAULT_GREGORIAN_CUTOVER);

+ (jint)BC;

+ (jint)BCE;

+ (jint)AD;

+ (jint)CE;

+ (IOSIntArray *)MONTH_LENGTH;

+ (IOSIntArray *)LEAP_MONTH_LENGTH;

+ (IOSIntArray *)MIN_VALUES;

+ (IOSIntArray *)LEAST_MAX_VALUES;

+ (IOSIntArray *)MAX_VALUES;

+ (jlong)serialVersionUID;

+ (jlong)DEFAULT_GREGORIAN_CUTOVER;

#pragma mark Public

/*!
 @brief Constructs a default <code>GregorianCalendar</code> using the current time
  in the default time zone with the default 
 <code>FORMAT</code> locale.
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs a <code>GregorianCalendar</code> with the given date set
  in the default time zone with the default locale.
 @param year the value used to set the  <code> YEAR </code>  calendar field in the calendar.
 @param month the value used to set the  <code> MONTH </code>  calendar field in the calendar.
   Month value is 0-based. e.g., 0 for January.
 @param dayOfMonth the value used to set the  <code> DAY_OF_MONTH </code>  calendar field in the calendar.
 */
- (instancetype __nonnull)initWithInt:(jint)year
                              withInt:(jint)month
                              withInt:(jint)dayOfMonth;

/*!
 @brief Constructs a <code>GregorianCalendar</code> with the given date
  and time set for the default time zone with the default locale.
 @param year the value used to set the  <code> YEAR </code>  calendar field in the calendar.
 @param month the value used to set the  <code> MONTH </code>  calendar field in the calendar.
   Month value is 0-based. e.g., 0 for January.
 @param dayOfMonth the value used to set the  <code> DAY_OF_MONTH </code>  calendar field in the calendar.
 @param hourOfDay the value used to set the  <code> HOUR_OF_DAY </code>  calendar field
   in the calendar.
 @param minute the value used to set the  <code> MINUTE </code>  calendar field
   in the calendar.
 */
- (instancetype __nonnull)initWithInt:(jint)year
                              withInt:(jint)month
                              withInt:(jint)dayOfMonth
                              withInt:(jint)hourOfDay
                              withInt:(jint)minute;

/*!
 @brief Constructs a GregorianCalendar with the given date
  and time set for the default time zone with the default locale.
 @param year the value used to set the  <code> YEAR </code>  calendar field in the calendar.
 @param month the value used to set the  <code> MONTH </code>  calendar field in the calendar.
   Month value is 0-based. e.g., 0 for January.
 @param dayOfMonth the value used to set the  <code> DAY_OF_MONTH </code>  calendar field in the calendar.
 @param hourOfDay the value used to set the  <code> HOUR_OF_DAY </code>  calendar field
   in the calendar.
 @param minute the value used to set the  <code> MINUTE </code>  calendar field
   in the calendar.
 @param second the value used to set the  <code> SECOND </code>  calendar field
   in the calendar.
 */
- (instancetype __nonnull)initWithInt:(jint)year
                              withInt:(jint)month
                              withInt:(jint)dayOfMonth
                              withInt:(jint)hourOfDay
                              withInt:(jint)minute
                              withInt:(jint)second;

/*!
 @brief Constructs a <code>GregorianCalendar</code> based on the current time
  in the default time zone with the given locale.
 @param aLocale the given locale.
 */
- (instancetype __nonnull)initWithJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Constructs a <code>GregorianCalendar</code> based on the current time
  in the given time zone with the default 
 <code>FORMAT</code> locale.
 @param zone the given time zone.
 */
- (instancetype __nonnull)initWithJavaUtilTimeZone:(JavaUtilTimeZone *)zone;

/*!
 @brief Constructs a <code>GregorianCalendar</code> based on the current time
  in the given time zone with the given locale.
 @param zone the given time zone.
 @param aLocale the given locale.
 */
- (instancetype __nonnull)initWithJavaUtilTimeZone:(JavaUtilTimeZone *)zone
                                withJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Adds the specified (signed) amount of time to the given calendar field,
  based on the calendar's rules.
 <p><em>Add rule 1</em>. The value of <code>field</code>
  after the call minus the value of <code>field</code> before the
  call is <code>amount</code>, modulo any overflow that has occurred in 
 <code>field</code>. Overflow occurs when a field value exceeds its
  range and, as a result, the next larger field is incremented or
  decremented and the field value is adjusted back into its range.</p>
  
 <p><em>Add rule 2</em>. If a smaller field is expected to be
  invariant, but it is impossible for it to be equal to its
  prior value because of changes in its minimum or maximum after 
 <code>field</code> is changed, then its value is adjusted to be as close
  as possible to its expected value. A smaller field represents a
  smaller unit of time. <code>HOUR</code> is a smaller field than 
 <code>DAY_OF_MONTH</code>. No adjustment is made to smaller fields
  that are not expected to be invariant. The calendar system
  determines what fields are expected to be invariant.</p>
 @param field the calendar field.
 @param amount the amount of date or time to be added to the field.
 @throw IllegalArgumentExceptionif <code>field</code> is 
 <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code>, or unknown,
  or if any calendar fields have out-of-range values in
  non-lenient mode.
 */
- (void)addWithInt:(jint)field
           withInt:(jint)amount;

- (id)java_clone;

/*!
 @brief Compares this <code>GregorianCalendar</code> to the specified 
 <code>Object</code>.The result is <code>true</code> if and
  only if the argument is a <code>GregorianCalendar</code> object
  that represents the same time value (millisecond offset from the 
 <a href="Calendar.html#Epoch">Epoch</a>) under the same 
 <code>Calendar</code> parameters and Gregorian change date as
  this object.
 @param obj the object to compare with.
 @return <code>true</code> if this object is equal to <code>obj</code>;
  <code>false</code> otherwise.
 - seealso: Calendar#compareTo(Calendar)
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns the maximum value that this calendar field could have,
  taking into consideration the given time value and the current
  values of the 
 <code>getFirstDayOfWeek</code>,
  <code>getMinimalDaysInFirstWeek</code>,
  <code>getGregorianChange</code> and 
 <code>getTimeZone</code> methods.
 For example, if the date of this instance is February 1, 2004,
  the actual maximum value of the <code>DAY_OF_MONTH</code> field
  is 29 because 2004 is a leap year, and if the date of this
  instance is February 1, 2005, it's 28. 
 <p>This method calculates the maximum value of <code>WEEK_OF_YEAR</code>
  based on the <code>YEAR</code>
  (calendar year) value, not the <a href="#week_year">
 week year</a>. Call <code>getWeeksInWeekYear()</code>
  to get the maximum value of <code>WEEK_OF_YEAR</code>
  in the week year of this <code>GregorianCalendar</code>.
 @param field the calendar field
 @return the maximum of the given field for the time value of
  this <code>GregorianCalendar</code>
 - seealso: #getMinimum(int)
 - seealso: #getMaximum(int)
 - seealso: #getGreatestMinimum(int)
 - seealso: #getLeastMaximum(int)
 - seealso: #getActualMinimum(int)
 @since 1.2
 */
- (jint)getActualMaximumWithInt:(jint)field;

/*!
 @brief Returns the minimum value that this calendar field could have,
  taking into consideration the given time value and the current
  values of the 
 <code>getFirstDayOfWeek</code>,
  <code>getMinimalDaysInFirstWeek</code>,
  <code>getGregorianChange</code> and 
 <code>getTimeZone</code> methods.
 <p>For example, if the Gregorian change date is January 10,
  1970 and the date of this <code>GregorianCalendar</code> is
  January 20, 1970, the actual minimum value of the 
 <code>DAY_OF_MONTH</code> field is 10 because the previous date
  of January 10, 1970 is December 27, 1996 (in the Julian
  calendar). Therefore, December 28, 1969 to January 9, 1970
  don't exist.
 @param field the calendar field
 @return the minimum of the given field for the time value of
  this <code>GregorianCalendar</code>
 - seealso: #getMinimum(int)
 - seealso: #getMaximum(int)
 - seealso: #getGreatestMinimum(int)
 - seealso: #getLeastMaximum(int)
 - seealso: #getActualMaximum(int)
 @since 1.2
 */
- (jint)getActualMinimumWithInt:(jint)field;

/*!
 @brief Returns <code>"gregory"</code> as the calendar type.
 @return <code>"gregory"</code>
 @since 1.8
 */
- (NSString *)getCalendarType;

/*!
 @brief Returns the highest minimum value for the given calendar field
  of this <code>GregorianCalendar</code> instance.The highest
  minimum value is defined as the largest value returned by 
 <code>getActualMinimum(int)</code> for any possible time value,
  taking into consideration the current values of the 
 <code>getFirstDayOfWeek</code>,
  <code>getMinimalDaysInFirstWeek</code>,
  <code>getGregorianChange</code> and 
 <code>getTimeZone</code> methods.
 @param field the calendar field.
 @return the highest minimum value for the given calendar field.
 - seealso: #getMinimum(int)
 - seealso: #getMaximum(int)
 - seealso: #getLeastMaximum(int)
 - seealso: #getActualMinimum(int)
 - seealso: #getActualMaximum(int)
 */
- (jint)getGreatestMinimumWithInt:(jint)field;

/*!
 @brief Gets the Gregorian Calendar change date.This is the point when the
  switch from Julian dates to Gregorian dates occurred.
 Default is
  October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian
  calendar.
 @return the Gregorian cutover date for this <code>GregorianCalendar</code> object.
 */
- (JavaUtilDate *)getGregorianChange;

/*!
 @brief Returns the lowest maximum value for the given calendar field
  of this <code>GregorianCalendar</code> instance.The lowest
  maximum value is defined as the smallest value returned by 
 <code>getActualMaximum(int)</code> for any possible time value,
  taking into consideration the current values of the 
 <code>getFirstDayOfWeek</code>,
  <code>getMinimalDaysInFirstWeek</code>,
  <code>getGregorianChange</code> and 
 <code>getTimeZone</code> methods.
 @param field the calendar field
 @return the lowest maximum value for the given calendar field.
 - seealso: #getMinimum(int)
 - seealso: #getMaximum(int)
 - seealso: #getGreatestMinimum(int)
 - seealso: #getActualMinimum(int)
 - seealso: #getActualMaximum(int)
 */
- (jint)getLeastMaximumWithInt:(jint)field;

/*!
 @brief Returns the maximum value for the given calendar field of this 
 <code>GregorianCalendar</code> instance.The maximum value is
  defined as the largest value returned by the <code>get</code>
  method for any possible time value,
  taking into consideration the current values of the 
 <code>getFirstDayOfWeek</code>,
  <code>getMinimalDaysInFirstWeek</code>,
  <code>getGregorianChange</code> and 
 <code>getTimeZone</code> methods.
 @param field the calendar field.
 @return the maximum value for the given calendar field.
 - seealso: #getMinimum(int)
 - seealso: #getGreatestMinimum(int)
 - seealso: #getLeastMaximum(int)
 - seealso: #getActualMinimum(int)
 - seealso: #getActualMaximum(int)
 */
- (jint)getMaximumWithInt:(jint)field;

/*!
 @brief Returns the minimum value for the given calendar field of this 
 <code>GregorianCalendar</code> instance.The minimum value is
  defined as the smallest value returned by the <code>get</code>
  method for any possible time value,
  taking into consideration the current values of the 
 <code>getFirstDayOfWeek</code>,
  <code>getMinimalDaysInFirstWeek</code>,
  <code>getGregorianChange</code> and 
 <code>getTimeZone</code> methods.
 @param field the calendar field.
 @return the minimum value for the given calendar field.
 - seealso: #getMaximum(int)
 - seealso: #getGreatestMinimum(int)
 - seealso: #getLeastMaximum(int)
 - seealso: #getActualMinimum(int)
 - seealso: #getActualMaximum(int)
 */
- (jint)getMinimumWithInt:(jint)field;

- (JavaUtilTimeZone *)getTimeZone;

/*!
 @brief Returns the number of weeks in the <a href="#week_year">week year</a>
  represented by this <code>GregorianCalendar</code>.
 <p>For example, if this <code>GregorianCalendar</code>'s date is
  December 31, 2008 with <a href="#iso8601_compatible_setting">the ISO
  8601 compatible setting</a>, this method will return 53 for the
  period: December 29, 2008 to January 3, 2010 while <code>getActualMaximum(WEEK_OF_YEAR)</code>
  will return
  52 for the period: December 31, 2007 to December 28, 2008.
 @return the number of weeks in the week year.
 - seealso: Calendar#WEEK_OF_YEAR
 - seealso: #getWeekYear()
 - seealso: #getActualMaximum(int)
 @since 1.7
 */
- (jint)getWeeksInWeekYear;

/*!
 @brief Returns the <a href="#week_year">week year</a> represented by this 
 <code>GregorianCalendar</code>.The dates in the weeks between 1 and the
  maximum week number of the week year have the same week year value
  that may be one year before or after the <code>YEAR</code>
  (calendar year) value.
 <p>This method calls <code>Calendar.complete()</code> before
  calculating the week year.
 @return the week year represented by this <code>GregorianCalendar</code>.
          If the <code>ERA</code> value is <code>BC</code>, the year is
          represented by 0 or a negative number: BC 1 is 0, BC 2
          is -1, BC 3 is -2, and so on.
 @throw IllegalArgumentException
 if any of the calendar fields is invalid in non-lenient mode.
 - seealso: #isWeekDateSupported()
 - seealso: #getWeeksInWeekYear()
 - seealso: Calendar#getFirstDayOfWeek()
 - seealso: Calendar#getMinimalDaysInFirstWeek()
 @since 1.7
 */
- (jint)getWeekYear;

/*!
 @brief Generates the hash code for this <code>GregorianCalendar</code> object.
 */
- (NSUInteger)hash;

/*!
 @brief Determines if the given year is a leap year.Returns <code>true</code> if
  the given year is a leap year.
 To specify BC year numbers, 
 <code>1 - year number</code> must be given. For example, year BC 4 is
  specified as -3.
 @param year the given year.
 @return <code>true</code> if the given year is a leap year; <code>false</code> otherwise.
 */
- (jboolean)isLeapYearWithInt:(jint)year;

/*!
 @brief Returns <code>true</code> indicating this <code>GregorianCalendar</code>
  supports week dates.
 @return <code>true</code> (always)
 - seealso: #getWeekYear()
 - seealso: #setWeekDate(int,int,int)
 - seealso: #getWeeksInWeekYear()
 @since 1.7
 */
- (jboolean)isWeekDateSupported;

/*!
 @brief Adds or subtracts (up/down) a single unit of time on the given time
  field without changing larger fields.
 <p>
  <em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to December 31, 1999. Calling <code>roll(Calendar.MONTH, true)</code>
  sets the calendar to January 31, 1999.  The <code>YEAR</code> field is unchanged
  because it is a larger field than <code>MONTH</code>.</p>
 @param up indicates if the value of the specified calendar field is to be  rolled up or rolled down. Use 
  <code> true </code>  if rolling up,  <code> false </code>  otherwise.
 @throw IllegalArgumentExceptionif <code>field</code> is 
 <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code>, or unknown,
  or if any calendar fields have out-of-range values in
  non-lenient mode.
 - seealso: #add(int,int)
 - seealso: #set(int,int)
 */
- (void)rollWithInt:(jint)field
        withBoolean:(jboolean)up;

/*!
 @brief Adds a signed amount to the specified calendar field without changing larger fields.
 A negative roll amount means to subtract from field without changing
  larger fields. If the specified amount is 0, this method performs nothing. 
 <p>This method calls <code>complete()</code> before adding the
  amount so that all the calendar fields are normalized. If there
  is any calendar field having an out-of-range value in non-lenient mode, then an 
 <code>IllegalArgumentException</code> is thrown. 
 <p>
  <em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to August 31, 1999. Calling <code>roll(Calendar.MONTH,
  8)</code> sets the calendar to April 30, <strong>1999</strong>. Using a 
 <code>GregorianCalendar</code>, the <code>DAY_OF_MONTH</code> field cannot
  be 31 in the month April. <code>DAY_OF_MONTH</code> is set to the closest possible
  value, 30. The <code>YEAR</code> field maintains the value of 1999 because it
  is a larger field than <code>MONTH</code>.
  <p>
  <em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to Sunday June 6, 1999. Calling 
 <code>roll(Calendar.WEEK_OF_MONTH, -1)</code> sets the calendar to
  Tuesday June 1, 1999, whereas calling 
 <code>add(Calendar.WEEK_OF_MONTH, -1)</code> sets the calendar to
  Sunday May 30, 1999. This is because the roll rule imposes an
  additional constraint: The <code>MONTH</code> must not change when the 
 <code>WEEK_OF_MONTH</code> is rolled. Taken together with add rule 1,
  the resultant date must be between Tuesday June 1 and Saturday June
  5. According to add rule 2, the <code>DAY_OF_WEEK</code>, an invariant
  when changing the <code>WEEK_OF_MONTH</code>, is set to Tuesday, the
  closest possible value to Sunday (where Sunday is the first day of the
  week).</p>
 @param field the calendar field.
 @param amount the signed amount to add to  <code> field </code>
  .
 @throw IllegalArgumentExceptionif <code>field</code> is 
 <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code>, or unknown,
  or if any calendar fields have out-of-range values in
  non-lenient mode.
 - seealso: #roll(int,boolean)
 - seealso: #add(int,int)
 - seealso: #set(int,int)
 @since 1.2
 */
- (void)rollWithInt:(jint)field
            withInt:(jint)amount;

/*!
 @brief Sets the <code>GregorianCalendar</code> change date.This is the point when the switch
  from Julian dates to Gregorian dates occurred.
 Default is October 15,
  1582 (Gregorian). Previous to this, dates will be in the Julian calendar. 
 <p>
  To obtain a pure Julian calendar, set the change date to 
 <code>Date(Long.MAX_VALUE)</code>.  To obtain a pure Gregorian calendar,
  set the change date to <code>Date(Long.MIN_VALUE)</code>.
 @param date the given Gregorian cutover date.
 */
- (void)setGregorianChangeWithJavaUtilDate:(JavaUtilDate *)date;

- (void)setTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)zone;

/*!
 @brief Sets this <code>GregorianCalendar</code> to the date given by the
  date specifiers - <a href="#week_year"><code>weekYear</code></a>,
  <code>weekOfYear</code>, and <code>dayOfWeek</code>.
 <code>weekOfYear</code>
  follows the <a href="#week_and_year"><code>WEEK_OF_YEAR</code>
  numbering</a>.  The <code>dayOfWeek</code> value must be one of the 
 <code>DAY_OF_WEEK</code> values: <code>SUNDAY</code>
  to <code>SATURDAY</code>.
  
 <p>Note that the numeric day-of-week representation differs from
  the ISO 8601 standard, and that the <code>weekOfYear</code>
  numbering is compatible with the standard when <code>getFirstDayOfWeek()</code>
  is <code>MONDAY</code> and <code>getMinimalDaysInFirstWeek()</code>
  is 4. 
 <p>Unlike the <code>set</code> method, all of the calendar fields
  and the instant of time value are calculated upon return. 
 <p>If <code>weekOfYear</code> is out of the valid week-of-year
  range in <code>weekYear</code>, the <code>weekYear</code>
  and <code>weekOfYear</code> values are adjusted in lenient
  mode, or an <code>IllegalArgumentException</code> is thrown in
  non-lenient mode.
 @param weekYear the week year
 @param weekOfYear the week number based on <code>weekYear</code>
 @param dayOfWeek the day of week value: one of the constants                     for the 
 <code>DAY_OF_WEEK</code>  field:                     
 <code>SUNDAY</code> , ...,                     
 <code>SATURDAY</code> .
 @throw IllegalArgumentException
 if any of the given date specifiers is invalid,
             or if any of the calendar fields are inconsistent
             with the given date specifiers in non-lenient mode
 - seealso: GregorianCalendar#isWeekDateSupported()
 - seealso: Calendar#getFirstDayOfWeek()
 - seealso: Calendar#getMinimalDaysInFirstWeek()
 @since 1.7
 */
- (void)setWeekDateWithInt:(jint)weekYear
                   withInt:(jint)weekOfYear
                   withInt:(jint)dayOfWeek;

#pragma mark Protected

/*!
 @brief Converts the time value (millisecond offset from the <a href="Calendar.html#Epoch">
 Epoch</a>) to calendar field values.
 The time is <em>not</em>
  recomputed first; to recompute the time, then the fields, call the 
 <code>complete</code> method.
 - seealso: Calendar#complete
 */
- (void)computeFields;

/*!
 @brief Converts calendar field values to the time value (millisecond
  offset from the <a href="Calendar.html#Epoch">Epoch</a>).
 @throw IllegalArgumentExceptionif any calendar fields are invalid.
 */
- (void)computeTime;

#pragma mark Package-Private

/*!
 @brief Constructs a <code>GregorianCalendar</code> with the given date
  and time set for the default time zone with the default locale.
 @param year the value used to set the  <code> YEAR </code>  calendar field in the calendar.
 @param month the value used to set the  <code> MONTH </code>  calendar field in the calendar.
   Month value is 0-based. e.g., 0 for January.
 @param dayOfMonth the value used to set the  <code> DAY_OF_MONTH </code>  calendar field in the calendar.
 @param hourOfDay the value used to set the  <code> HOUR_OF_DAY </code>  calendar field
   in the calendar.
 @param minute the value used to set the  <code> MINUTE </code>  calendar field
   in the calendar.
 @param second the value used to set the  <code> SECOND </code>  calendar field
   in the calendar.
 @param millis the value used to set the  <code> MILLISECOND </code>  calendar field
 */
- (instancetype __nonnull)initWithInt:(jint)year
                              withInt:(jint)month
                              withInt:(jint)dayOfMonth
                              withInt:(jint)hourOfDay
                              withInt:(jint)minute
                              withInt:(jint)second
                              withInt:(jint)millis;

- (instancetype __nonnull)initWithLong:(jlong)milliseconds;

/*!
 @brief Constructs an empty GregorianCalendar.
 @param zone the given time zone
 @param locale the given locale
 @param flag the flag requesting an empty instance
 */
- (instancetype __nonnull)initWithJavaUtilTimeZone:(JavaUtilTimeZone *)zone
                                withJavaUtilLocale:(JavaUtilLocale *)locale
                                       withBoolean:(jboolean)flag;

@end

J2OBJC_STATIC_INIT(JavaUtilGregorianCalendar)

/*!
 @brief Value of the <code>ERA</code> field indicating
  the period before the common era (before Christ), also known as BCE.
 The sequence of years at the transition from <code>BC</code> to <code>AD</code> is
  ..., 2 BC, 1 BC, 1 AD, 2 AD,...
 - seealso: #ERA
 */
inline jint JavaUtilGregorianCalendar_get_BC(void);
#define JavaUtilGregorianCalendar_BC 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, BC, jint)

/*!
 @brief Value of the <code>ERA</code> field indicating
  the period before the common era, the same value as <code>BC</code>.
 - seealso: #CE
 */
inline jint JavaUtilGregorianCalendar_get_BCE(void);
#define JavaUtilGregorianCalendar_BCE 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, BCE, jint)

/*!
 @brief Value of the <code>ERA</code> field indicating
  the common era (Anno Domini), also known as CE.
 The sequence of years at the transition from <code>BC</code> to <code>AD</code> is
  ..., 2 BC, 1 BC, 1 AD, 2 AD,...
 - seealso: #ERA
 */
inline jint JavaUtilGregorianCalendar_get_AD(void);
#define JavaUtilGregorianCalendar_AD 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, AD, jint)

/*!
 @brief Value of the <code>ERA</code> field indicating
  the common era, the same value as <code>AD</code>.
 - seealso: #BCE
 */
inline jint JavaUtilGregorianCalendar_get_CE(void);
#define JavaUtilGregorianCalendar_CE 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, CE, jint)

inline IOSIntArray *JavaUtilGregorianCalendar_get_MONTH_LENGTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *JavaUtilGregorianCalendar_MONTH_LENGTH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilGregorianCalendar, MONTH_LENGTH, IOSIntArray *)

inline IOSIntArray *JavaUtilGregorianCalendar_get_LEAP_MONTH_LENGTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *JavaUtilGregorianCalendar_LEAP_MONTH_LENGTH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilGregorianCalendar, LEAP_MONTH_LENGTH, IOSIntArray *)

inline IOSIntArray *JavaUtilGregorianCalendar_get_MIN_VALUES(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *JavaUtilGregorianCalendar_MIN_VALUES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilGregorianCalendar, MIN_VALUES, IOSIntArray *)

inline IOSIntArray *JavaUtilGregorianCalendar_get_LEAST_MAX_VALUES(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *JavaUtilGregorianCalendar_LEAST_MAX_VALUES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilGregorianCalendar, LEAST_MAX_VALUES, IOSIntArray *)

inline IOSIntArray *JavaUtilGregorianCalendar_get_MAX_VALUES(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *JavaUtilGregorianCalendar_MAX_VALUES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilGregorianCalendar, MAX_VALUES, IOSIntArray *)

inline jlong JavaUtilGregorianCalendar_get_serialVersionUID(void);
#define JavaUtilGregorianCalendar_serialVersionUID -8125100834729963327LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, serialVersionUID, jlong)

inline jlong JavaUtilGregorianCalendar_get_DEFAULT_GREGORIAN_CUTOVER(void);
#define JavaUtilGregorianCalendar_DEFAULT_GREGORIAN_CUTOVER -12219292800000LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, DEFAULT_GREGORIAN_CUTOVER, jlong)

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_init(JavaUtilGregorianCalendar *self);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_init(void);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_(JavaUtilGregorianCalendar *self, JavaUtilTimeZone *zone);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_(JavaUtilTimeZone *zone) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_(JavaUtilTimeZone *zone);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilLocale_(JavaUtilGregorianCalendar *self, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilLocale_(JavaUtilLocale *aLocale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithJavaUtilLocale_(JavaUtilLocale *aLocale);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_(JavaUtilGregorianCalendar *self, JavaUtilTimeZone *zone, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_(JavaUtilTimeZone *zone, JavaUtilLocale *aLocale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_(JavaUtilTimeZone *zone, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint dayOfMonth);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_(jint year, jint month, jint dayOfMonth) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_(jint year, jint month, jint dayOfMonth);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute, jint second);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute, jint second) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute, jint second);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute, jint second, jint millis);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute, jint second, jint millis) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint dayOfMonth, jint hourOfDay, jint minute, jint second, jint millis);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_withBoolean_(JavaUtilGregorianCalendar *self, JavaUtilTimeZone *zone, JavaUtilLocale *locale, jboolean flag);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_withBoolean_(JavaUtilTimeZone *zone, JavaUtilLocale *locale, jboolean flag) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_withBoolean_(JavaUtilTimeZone *zone, JavaUtilLocale *locale, jboolean flag);

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithLong_(JavaUtilGregorianCalendar *self, jlong milliseconds);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithLong_(jlong milliseconds) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilGregorianCalendar *create_JavaUtilGregorianCalendar_initWithLong_(jlong milliseconds);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilGregorianCalendar)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilGregorianCalendar")
