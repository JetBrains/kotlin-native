//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/Random.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilRandom")
#ifdef RESTRICT_JavaUtilRandom
#define INCLUDE_ALL_JavaUtilRandom 0
#else
#define INCLUDE_ALL_JavaUtilRandom 1
#endif
#undef RESTRICT_JavaUtilRandom

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilRandom_) && (INCLUDE_ALL_JavaUtilRandom || defined(INCLUDE_JavaUtilRandom))
#define JavaUtilRandom_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSByteArray;
@protocol JavaUtilStreamDoubleStream;
@protocol JavaUtilStreamIntStream;
@protocol JavaUtilStreamLongStream;

/*!
 @brief An instance of this class is used to generate a stream of
  pseudorandom numbers.The class uses a 48-bit seed, which is
  modified using a linear congruential formula.
 (See Donald Knuth, 
 <i>The Art of Computer Programming, Volume 2</i>, Section 3.2.1.) 
 <p>
  If two instances of <code>Random</code> are created with the same
  seed, and the same sequence of method calls is made for each, they
  will generate and return identical sequences of numbers. In order to
  guarantee this property, particular algorithms are specified for the
  class <code>Random</code>. Java implementations must use all the algorithms
  shown here for the class <code>Random</code>, for the sake of absolute
  portability of Java code. However, subclasses of class <code>Random</code>
  are permitted to use other algorithms, so long as they adhere to the
  general contracts for all the methods. 
 <p>
  The algorithms implemented by class <code>Random</code> use a 
 <code>protected</code> utility method that on each invocation can supply
  up to 32 pseudorandomly generated bits. 
 <p>
  Many applications will find the method <code>Math.random</code> simpler to use. 
 <p>Instances of <code>java.util.Random</code> are threadsafe.
  However, the concurrent use of the same <code>java.util.Random</code>
  instance across threads may encounter contention and consequent
  poor performance. Consider instead using 
 <code>java.util.concurrent.ThreadLocalRandom</code> in multithreaded
  designs. 
 <p>Instances of <code>java.util.Random</code> are not cryptographically
  secure.  Consider instead using <code>java.security.SecureRandom</code> to
  get a cryptographically secure pseudo-random number generator for use
  by security-sensitive applications.
 @author Frank Yellin
 @since 1.0
 */
@interface JavaUtilRandom : NSObject < JavaIoSerializable >
@property (readonly, class) jlong serialVersionUID NS_SWIFT_NAME(serialVersionUID);
@property (readonly, copy, class) NSString *BadBound NS_SWIFT_NAME(BadBound);
@property (readonly, copy, class) NSString *BadRange NS_SWIFT_NAME(BadRange);
@property (readonly, copy, class) NSString *BadSize NS_SWIFT_NAME(BadSize);

+ (jlong)serialVersionUID;

+ (NSString *)BadBound;

+ (NSString *)BadRange;

+ (NSString *)BadSize;

#pragma mark Public

/*!
 @brief Creates a new random number generator.This constructor sets
  the seed of the random number generator to a value very likely
  to be distinct from any other invocation of this constructor.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a new random number generator using a single <code>long</code> seed.
 The seed is the initial value of the internal state of the pseudorandom
  number generator which is maintained by method <code>next</code>.
  
 <p>The invocation <code>new Random(seed)</code> is equivalent to:
   @code
  Random rnd = new Random();
  rnd.setSeed(seed);
 
@endcode
 @param seed the initial seed
 - seealso: #setSeed(long)
 */
- (instancetype __nonnull)initWithLong:(jlong)seed;

/*!
 @brief Returns an effectively unlimited stream of pseudorandom <code>double</code>
  values, each between zero (inclusive) and one
  (exclusive).
 <p>A pseudorandom <code>double</code> value is generated as if it's the result
  of calling the method <code>nextDouble()</code>.
 @return a stream of pseudorandom <code>double</code> values
 @since 1.8
 */
- (id<JavaUtilStreamDoubleStream>)doubles;

/*!
 @brief Returns an effectively unlimited stream of pseudorandom <code>double</code>
  values, each conforming to the given origin (inclusive) and bound
  (exclusive).
 <p>A pseudorandom <code>double</code> value is generated as if it's the result
  of calling the following method with the origin and bound: 
 @code
  double nextDouble(double origin, double bound) {
    double r = nextDouble();
    r = r * (bound - origin) + origin;
    if (r >= bound) // correct for rounding
      r = Math.nextDown(bound);
    return r;
  }
 
@endcode
 @param randomNumberOrigin the origin (inclusive) of each random value
 @param randomNumberBound the bound (exclusive) of each random value
 @return a stream of pseudorandom <code>double</code> values,
          each with the given origin (inclusive) and bound (exclusive)
 @throw IllegalArgumentExceptionif <code>randomNumberOrigin</code>
          is greater than or equal to <code>randomNumberBound</code>
 @since 1.8
 */
- (id<JavaUtilStreamDoubleStream>)doublesWithDouble:(jdouble)randomNumberOrigin
                                         withDouble:(jdouble)randomNumberBound;

/*!
 @brief Returns a stream producing the given <code>streamSize</code> number of
  pseudorandom <code>double</code> values, each between zero
  (inclusive) and one (exclusive).
 <p>A pseudorandom <code>double</code> value is generated as if it's the result
  of calling the method <code>nextDouble()</code>.
 @param streamSize the number of values to generate
 @return a stream of <code>double</code> values
 @throw IllegalArgumentExceptionif <code>streamSize</code> is
          less than zero
 @since 1.8
 */
- (id<JavaUtilStreamDoubleStream>)doublesWithLong:(jlong)streamSize;

/*!
 @brief Returns a stream producing the given <code>streamSize</code> number of
  pseudorandom <code>double</code> values, each conforming to the given origin
  (inclusive) and bound (exclusive).
 <p>A pseudorandom <code>double</code> value is generated as if it's the result
  of calling the following method with the origin and bound: 
 @code
  double nextDouble(double origin, double bound) {
    double r = nextDouble();
    r = r * (bound - origin) + origin;
    if (r >= bound) // correct for rounding
      r = Math.nextDown(bound);
    return r;
  }
 
@endcode
 @param streamSize the number of values to generate
 @param randomNumberOrigin the origin (inclusive) of each random value
 @param randomNumberBound the bound (exclusive) of each random value
 @return a stream of pseudorandom <code>double</code> values,
          each with the given origin (inclusive) and bound (exclusive)
 @throw IllegalArgumentExceptionif <code>streamSize</code> is
          less than zero
 @throw IllegalArgumentExceptionif <code>randomNumberOrigin</code>
          is greater than or equal to <code>randomNumberBound</code>
 @since 1.8
 */
- (id<JavaUtilStreamDoubleStream>)doublesWithLong:(jlong)streamSize
                                       withDouble:(jdouble)randomNumberOrigin
                                       withDouble:(jdouble)randomNumberBound;

/*!
 @brief Returns an effectively unlimited stream of pseudorandom <code>int</code>
  values.
 <p>A pseudorandom <code>int</code> value is generated as if it's the result of
  calling the method <code>nextInt()</code>.
 @return a stream of pseudorandom <code>int</code> values
 @since 1.8
 */
- (id<JavaUtilStreamIntStream>)ints;

/*!
 @brief Returns an effectively unlimited stream of pseudorandom <code>int</code>
  values, each conforming to the given origin (inclusive) and bound
  (exclusive).
 <p>A pseudorandom <code>int</code> value is generated as if it's the result of
  calling the following method with the origin and bound: 
 @code
  int nextInt(int origin, int bound) {
    int n = bound - origin;
    if (n > 0) {
      return nextInt(n) + origin;
    }
    else {  // range not representable as int
      int r;
      do {
        r = nextInt();
      } while (r < origin || r >= bound);
      return r;
    }  }
 
@endcode
 @param randomNumberOrigin the origin (inclusive) of each random value
 @param randomNumberBound the bound (exclusive) of each random value
 @return a stream of pseudorandom <code>int</code> values,
          each with the given origin (inclusive) and bound (exclusive)
 @throw IllegalArgumentExceptionif <code>randomNumberOrigin</code>
          is greater than or equal to <code>randomNumberBound</code>
 @since 1.8
 */
- (id<JavaUtilStreamIntStream>)intsWithInt:(jint)randomNumberOrigin
                                   withInt:(jint)randomNumberBound;

/*!
 @brief Returns a stream producing the given <code>streamSize</code> number of
  pseudorandom <code>int</code> values.
 <p>A pseudorandom <code>int</code> value is generated as if it's the result of
  calling the method <code>nextInt()</code>.
 @param streamSize the number of values to generate
 @return a stream of pseudorandom <code>int</code> values
 @throw IllegalArgumentExceptionif <code>streamSize</code> is
          less than zero
 @since 1.8
 */
- (id<JavaUtilStreamIntStream>)intsWithLong:(jlong)streamSize;

/*!
 @brief Returns a stream producing the given <code>streamSize</code> number
  of pseudorandom <code>int</code> values, each conforming to the given
  origin (inclusive) and bound (exclusive).
 <p>A pseudorandom <code>int</code> value is generated as if it's the result of
  calling the following method with the origin and bound: 
 @code
  int nextInt(int origin, int bound) {
    int n = bound - origin;
    if (n > 0) {
      return nextInt(n) + origin;
    }
    else {  // range not representable as int
      int r;
      do {
        r = nextInt();
      } while (r < origin || r >= bound);
      return r;
    }  }
 
@endcode
 @param streamSize the number of values to generate
 @param randomNumberOrigin the origin (inclusive) of each random value
 @param randomNumberBound the bound (exclusive) of each random value
 @return a stream of pseudorandom <code>int</code> values,
          each with the given origin (inclusive) and bound (exclusive)
 @throw IllegalArgumentExceptionif <code>streamSize</code> is
          less than zero, or <code>randomNumberOrigin</code>
          is greater than or equal to <code>randomNumberBound</code>
 @since 1.8
 */
- (id<JavaUtilStreamIntStream>)intsWithLong:(jlong)streamSize
                                    withInt:(jint)randomNumberOrigin
                                    withInt:(jint)randomNumberBound;

/*!
 @brief Returns an effectively unlimited stream of pseudorandom <code>long</code>
  values.
 <p>A pseudorandom <code>long</code> value is generated as if it's the result
  of calling the method <code>nextLong()</code>.
 @return a stream of pseudorandom <code>long</code> values
 @since 1.8
 */
- (id<JavaUtilStreamLongStream>)longs;

/*!
 @brief Returns a stream producing the given <code>streamSize</code> number of
  pseudorandom <code>long</code> values.
 <p>A pseudorandom <code>long</code> value is generated as if it's the result
  of calling the method <code>nextLong()</code>.
 @param streamSize the number of values to generate
 @return a stream of pseudorandom <code>long</code> values
 @throw IllegalArgumentExceptionif <code>streamSize</code> is
          less than zero
 @since 1.8
 */
- (id<JavaUtilStreamLongStream>)longsWithLong:(jlong)streamSize;

/*!
 @brief Returns an effectively unlimited stream of pseudorandom <code>long</code>
  values, each conforming to the given origin (inclusive) and bound
  (exclusive).
 <p>A pseudorandom <code>long</code> value is generated as if it's the result
  of calling the following method with the origin and bound: 
 @code
  long nextLong(long origin, long bound) {
    long r = nextLong();
    long n = bound - origin, m = n - 1;
    if ((n & m) == 0L)  // power of two
      r = (r & m) + origin;
    else if (n > 0L) {  // reject over-represented candidates
      for (long u = r >>> 1;            // ensure nonnegative
           u + m - (r = u % n) < 0L;    // rejection check
           u = nextLong() >>> 1) // retry
          ;
      r += origin;
    }
    else {              // range not representable as long
      while (r < origin || r >= bound)
        r = nextLong();
    }
    return r;
  }
 
@endcode
 @param randomNumberOrigin the origin (inclusive) of each random value
 @param randomNumberBound the bound (exclusive) of each random value
 @return a stream of pseudorandom <code>long</code> values,
          each with the given origin (inclusive) and bound (exclusive)
 @throw IllegalArgumentExceptionif <code>randomNumberOrigin</code>
          is greater than or equal to <code>randomNumberBound</code>
 @since 1.8
 */
- (id<JavaUtilStreamLongStream>)longsWithLong:(jlong)randomNumberOrigin
                                     withLong:(jlong)randomNumberBound;

/*!
 @brief Returns a stream producing the given <code>streamSize</code> number of
  pseudorandom <code>long</code>, each conforming to the given origin
  (inclusive) and bound (exclusive).
 <p>A pseudorandom <code>long</code> value is generated as if it's the result
  of calling the following method with the origin and bound: 
 @code
  long nextLong(long origin, long bound) {
    long r = nextLong();
    long n = bound - origin, m = n - 1;
    if ((n & m) == 0L)  // power of two
      r = (r & m) + origin;
    else if (n > 0L) {  // reject over-represented candidates
      for (long u = r >>> 1;            // ensure nonnegative
           u + m - (r = u % n) < 0L;    // rejection check
           u = nextLong() >>> 1) // retry
          ;
      r += origin;
    }
    else {              // range not representable as long
      while (r < origin || r >= bound)
        r = nextLong();
    }
    return r;
  }
 
@endcode
 @param streamSize the number of values to generate
 @param randomNumberOrigin the origin (inclusive) of each random value
 @param randomNumberBound the bound (exclusive) of each random value
 @return a stream of pseudorandom <code>long</code> values,
          each with the given origin (inclusive) and bound (exclusive)
 @throw IllegalArgumentExceptionif <code>streamSize</code> is
          less than zero, or <code>randomNumberOrigin</code>
          is greater than or equal to <code>randomNumberBound</code>
 @since 1.8
 */
- (id<JavaUtilStreamLongStream>)longsWithLong:(jlong)streamSize
                                     withLong:(jlong)randomNumberOrigin
                                     withLong:(jlong)randomNumberBound;

/*!
 @brief Returns the next pseudorandom, uniformly distributed 
 <code>boolean</code> value from this random number generator's
  sequence.The general contract of <code>nextBoolean</code> is that one 
 <code>boolean</code> value is pseudorandomly generated and returned.
 The
  values <code>true</code> and <code>false</code> are produced with
  (approximately) equal probability. 
 <p>The method <code>nextBoolean</code> is implemented by class <code>Random</code>
  as if by:
   @code
  public boolean nextBoolean() {
    return next(1) != 0;
  }
 
@endcode
 @return the next pseudorandom, uniformly distributed
          <code>boolean</code> value from this random number generator's
          sequence
 @since 1.2
 */
- (jboolean)nextBoolean;

/*!
 @brief Generates random bytes and places them into a user-supplied
  byte array.The number of random bytes produced is equal to
  the length of the byte array.
 <p>The method <code>nextBytes</code> is implemented by class <code>Random</code>
  as if by:
   @code
  public void nextBytes(byte[] bytes) {
    for (int i = 0; i < bytes.length; )
      for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);
           n-- > 0; rnd >>= 8)
        bytes[i++] = (byte)rnd;
  }
 
@endcode
 @param bytes the byte array to fill with random bytes
 @throw NullPointerExceptionif the byte array is null
 @since 1.1
 */
- (void)nextBytesWithByteArray:(IOSByteArray *)bytes;

/*!
 @brief Returns the next pseudorandom, uniformly distributed 
 <code>double</code> value between <code>0.0</code> and 
 <code>1.0</code> from this random number generator's sequence.
 <p>The general contract of <code>nextDouble</code> is that one 
 <code>double</code> value, chosen (approximately) uniformly from the
  range <code>0.0d</code> (inclusive) to <code>1.0d</code> (exclusive), is
  pseudorandomly generated and returned. 
 <p>The method <code>nextDouble</code> is implemented by class <code>Random</code>
  as if by:
   @code
  public double nextDouble() {
    return (((long)next(26) << 27) + next(27))
      / (double)(1L << 53);
  }
 
@endcode
  
 <p>The hedge "approximately" is used in the foregoing description only
  because the <code>next</code> method is only approximately an unbiased
  source of independently chosen bits. If it were a perfect source of
  randomly chosen bits, then the algorithm shown would choose 
 <code>double</code> values from the stated range with perfect uniformity. 
 <p>[In early versions of Java, the result was incorrectly calculated as:
   @code
   return (((long)next(27) << 27) + next(27))
      / (double)(1L << 54);
 
@endcode
  This might seem to be equivalent, if not better, but in fact it
  introduced a large nonuniformity because of the bias in the rounding
  of floating-point numbers: it was three times as likely that the
  low-order bit of the significand would be 0 than that it would be 1!
  This nonuniformity probably doesn't matter much in practice, but we
  strive for perfection.]
 @return the next pseudorandom, uniformly distributed <code>double</code>
          value between <code>0.0</code> and <code>1.0</code> from this
          random number generator's sequence
 - seealso: Math#random
 */
- (jdouble)nextDouble;

/*!
 @brief Returns the next pseudorandom, uniformly distributed <code>float</code>
  value between <code>0.0</code> and <code>1.0</code> from this random
  number generator's sequence.
 <p>The general contract of <code>nextFloat</code> is that one 
 <code>float</code> value, chosen (approximately) uniformly from the
  range <code>0.0f</code> (inclusive) to <code>1.0f</code> (exclusive), is
  pseudorandomly generated and returned. All 2<sup>24</sup> possible 
 <code>float</code> values of the form <i>m&nbsp;x&nbsp;</i>2<sup>-24</sup>,
  where <i>m</i> is a positive integer less than 2<sup>24</sup>, are
  produced with (approximately) equal probability. 
 <p>The method <code>nextFloat</code> is implemented by class <code>Random</code>
  as if by:
   @code
  public float nextFloat() {
    return next(24) / ((float)(1 << 24));
  }
 
@endcode
  
 <p>The hedge "approximately" is used in the foregoing description only
  because the next method is only approximately an unbiased source of
  independently chosen bits. If it were a perfect source of randomly
  chosen bits, then the algorithm shown would choose <code>float</code>
  values from the stated range with perfect uniformity.<p>
  [In early versions of Java, the result was incorrectly calculated as:
   @code
   return next(30) / ((float)(1 << 30));
 
@endcode
  This might seem to be equivalent, if not better, but in fact it
  introduced a slight nonuniformity because of the bias in the rounding
  of floating-point numbers: it was slightly more likely that the
  low-order bit of the significand would be 0 than that it would be 1.]
 @return the next pseudorandom, uniformly distributed <code>float</code>
          value between <code>0.0</code> and <code>1.0</code> from this
          random number generator's sequence
 */
- (jfloat)nextFloat;

/*!
 @brief Returns the next pseudorandom, Gaussian ("normally") distributed 
 <code>double</code> value with mean <code>0.0</code> and standard
  deviation <code>1.0</code> from this random number generator's sequence.
 <p>
  The general contract of <code>nextGaussian</code> is that one 
 <code>double</code> value, chosen from (approximately) the usual
  normal distribution with mean <code>0.0</code> and standard deviation 
 <code>1.0</code>, is pseudorandomly generated and returned. 
 <p>The method <code>nextGaussian</code> is implemented by class 
 <code>Random</code> as if by a threadsafe version of the following:
   @code
  private double nextNextGaussian;
  private boolean haveNextNextGaussian = false;
  public double nextGaussian() {
    if (haveNextNextGaussian) {
      haveNextNextGaussian = false;
      return nextNextGaussian;
    } else {
      double v1, v2, s;
      do {
        v1 = 2 * nextDouble() - 1;   // between -1.0 and 1.0
        v2 = 2 * nextDouble() - 1;   // between -1.0 and 1.0
        s = v1 * v1 + v2 * v2;
      } while (s >= 1 || s == 0);
      double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s);
      nextNextGaussian = v2 * multiplier;
      haveNextNextGaussian = true;
      return v1 * multiplier;
    }  }
 
@endcode
  This uses the <i>polar method</i> of G. E. P. Box, M. E. Muller, and
  G. Marsaglia, as described by Donald E. Knuth in <i>The Art of
  Computer Programming</i>, Volume 3: <i>Seminumerical Algorithms</i>,
  section 3.4.1, subsection C, algorithm P. Note that it generates two
  independent values at the cost of only one call to <code>StrictMath.log</code>
  and one call to <code>StrictMath.sqrt</code>.
 @return the next pseudorandom, Gaussian ("normally") distributed
          <code>double</code> value with mean <code>0.0</code> and
          standard deviation <code>1.0</code> from this random number
          generator's sequence
 */
- (jdouble)nextGaussian;

/*!
 @brief Returns the next pseudorandom, uniformly distributed <code>int</code>
  value from this random number generator's sequence.The general
  contract of <code>nextInt</code> is that one <code>int</code> value is
  pseudorandomly generated and returned.
 All 2<sup>32</sup> possible 
 <code>int</code> values are produced with (approximately) equal probability. 
 <p>The method <code>nextInt</code> is implemented by class <code>Random</code>
  as if by:
   @code
  public int nextInt() {
    return next(32);
  }
 
@endcode
 @return the next pseudorandom, uniformly distributed <code>int</code>
          value from this random number generator's sequence
 */
- (jint)nextInt;

/*!
 @brief Returns a pseudorandom, uniformly distributed <code>int</code> value
  between 0 (inclusive) and the specified value (exclusive), drawn from
  this random number generator's sequence.The general contract of 
 <code>nextInt</code> is that one <code>int</code> value in the specified range
  is pseudorandomly generated and returned.
 All <code>bound</code> possible 
 <code>int</code> values are produced with (approximately) equal
  probability.  The method <code>nextInt(int bound)</code> is implemented by
  class <code>Random</code> as if by:
   @code
  public int nextInt(int bound) {
    if (bound <= 0)
      throw new IllegalArgumentException("bound must be positive");
    if ((bound & -bound) == bound)  // i.e., bound is a power of 2
      return (int)((bound * (long)next(31)) >> 31);
    int bits, val;
    do {
        bits = next(31);
        val = bits % bound;
    } while (bits - val + (bound-1) < 0);
    return val;
  }
 
@endcode
  
 <p>The hedge "approximately" is used in the foregoing description only
  because the next method is only approximately an unbiased source of
  independently chosen bits.  If it were a perfect source of randomly
  chosen bits, then the algorithm shown would choose <code>int</code>
  values from the stated range with perfect uniformity. 
 <p>
  The algorithm is slightly tricky.  It rejects values that would result
  in an uneven distribution (due to the fact that 2^31 is not divisible
  by n). The probability of a value being rejected depends on n.  The
  worst case is n=2^30+1, for which the probability of a reject is 1/2,
  and the expected number of iterations before the loop terminates is 2. 
 <p>
  The algorithm treats the case where n is a power of two specially: it
  returns the correct number of high-order bits from the underlying
  pseudo-random number generator.  In the absence of special treatment,
  the correct number of <i>low-order</i> bits would be returned.  Linear
  congruential pseudo-random number generators such as the one
  implemented by this class are known to have short periods in the
  sequence of values of their low-order bits.  Thus, this special case
  greatly increases the length of the sequence of values returned by
  successive calls to this method if n is a small power of two.
 @param bound the upper bound (exclusive).  Must be positive.
 @return the next pseudorandom, uniformly distributed <code>int</code>
          value between zero (inclusive) and <code>bound</code> (exclusive)
          from this random number generator's sequence
 @throw IllegalArgumentExceptionif bound is not positive
 @since 1.2
 */
- (jint)nextIntWithInt:(jint)n;

/*!
 @brief Returns the next pseudorandom, uniformly distributed <code>long</code>
  value from this random number generator's sequence.The general
  contract of <code>nextLong</code> is that one <code>long</code> value is
  pseudorandomly generated and returned.
 <p>The method <code>nextLong</code> is implemented by class <code>Random</code>
  as if by:
   @code
  public long nextLong() {
    return ((long)next(32) << 32) + next(32);
  }
 
@endcode
  Because class <code>Random</code> uses a seed with only 48 bits,
  this algorithm will not return all possible <code>long</code> values.
 @return the next pseudorandom, uniformly distributed <code>long</code>
          value from this random number generator's sequence
 */
- (jlong)nextLong;

/*!
 @brief Sets the seed of this random number generator using a single 
 <code>long</code> seed.The general contract of <code>setSeed</code> is
  that it alters the state of this random number generator object
  so as to be in exactly the same state as if it had just been
  created with the argument <code>seed</code> as a seed.
 The method 
 <code>setSeed</code> is implemented by class <code>Random</code> by
  atomically updating the seed to
   @code
(seed ^ 0x5DEECE66DL) & ((1L << 48) - 1)
@endcode
  and clearing the <code>haveNextNextGaussian</code> flag used by <code>nextGaussian</code>
 .
  
 <p>The implementation of <code>setSeed</code> by class <code>Random</code>
  happens to use only 48 bits of the given seed. In general, however,
  an overriding method may use all 64 bits of the <code>long</code>
  argument as a seed value.
 @param seed the initial seed
 */
- (void)setSeedWithLong:(jlong)seed;

#pragma mark Protected

/*!
 @brief Generates the next pseudorandom number.Subclasses should
  override this, as this is used by all other methods.
 <p>The general contract of <code>next</code> is that it returns an 
 <code>int</code> value and if the argument <code>bits</code> is between 
 <code>1</code> and <code>32</code> (inclusive), then that many low-order
  bits of the returned value will be (approximately) independently
  chosen bit values, each of which is (approximately) equally
  likely to be <code>0</code> or <code>1</code>. The method <code>next</code> is
  implemented by class <code>Random</code> by atomically updating the seed to
   @code
(seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1)
@endcode
  and returning
   @code
(int)(seed >>> (48 - bits)).
@endcode
  This is a linear congruential pseudorandom number generator, as
  defined by D. H. Lehmer and described by Donald E. Knuth in 
 <i>The Art of Computer Programming,</i> Volume 3: 
 <i>Seminumerical Algorithms</i>, section 3.2.1.
 @param bits random bits
 @return the next pseudorandom value from this random number
          generator's sequence
 @since 1.1
 */
- (jint)nextWithInt:(jint)bits;

#pragma mark Package-Private

/*!
 @brief The form of nextDouble used by DoubleStream Spliterators.
 @param origin the least value, unless greater than bound
 @param bound the upper bound (exclusive), must not equal origin
 @return a pseudorandom value
 */
- (jdouble)internalNextDoubleWithDouble:(jdouble)origin
                             withDouble:(jdouble)bound;

/*!
 @brief The form of nextInt used by IntStream Spliterators.
 For the unbounded case: uses nextInt().
  For the bounded case with representable range: uses nextInt(int bound)
  For the bounded case with unrepresentable range: uses nextInt()
 @param origin the least value, unless greater than bound
 @param bound the upper bound (exclusive), must not equal origin
 @return a pseudorandom value
 */
- (jint)internalNextIntWithInt:(jint)origin
                       withInt:(jint)bound;

/*!
 @brief The form of nextLong used by LongStream Spliterators.If
  origin is greater than bound, acts as unbounded form of
  nextLong, else as bounded form.
 @param origin the least value, unless greater than bound
 @param bound the upper bound (exclusive), must not equal origin
 @return a pseudorandom value
 */
- (jlong)internalNextLongWithLong:(jlong)origin
                         withLong:(jlong)bound;

@end

J2OBJC_STATIC_INIT(JavaUtilRandom)

/*!
 @brief use serialVersionUID from JDK 1.1 for interoperability
 */
inline jlong JavaUtilRandom_get_serialVersionUID(void);
#define JavaUtilRandom_serialVersionUID 3905348978240129619LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRandom, serialVersionUID, jlong)

inline NSString *JavaUtilRandom_get_BadBound(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *JavaUtilRandom_BadBound;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilRandom, BadBound, NSString *)

inline NSString *JavaUtilRandom_get_BadRange(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *JavaUtilRandom_BadRange;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilRandom, BadRange, NSString *)

inline NSString *JavaUtilRandom_get_BadSize(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *JavaUtilRandom_BadSize;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilRandom, BadSize, NSString *)

FOUNDATION_EXPORT void JavaUtilRandom_init(JavaUtilRandom *self);

FOUNDATION_EXPORT JavaUtilRandom *new_JavaUtilRandom_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilRandom *create_JavaUtilRandom_init(void);

FOUNDATION_EXPORT void JavaUtilRandom_initWithLong_(JavaUtilRandom *self, jlong seed);

FOUNDATION_EXPORT JavaUtilRandom *new_JavaUtilRandom_initWithLong_(jlong seed) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilRandom *create_JavaUtilRandom_initWithLong_(jlong seed);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilRandom)

#endif

#if !defined (JavaUtilRandom_RandomIntsSpliterator_) && (INCLUDE_ALL_JavaUtilRandom || defined(INCLUDE_JavaUtilRandom_RandomIntsSpliterator))
#define JavaUtilRandom_RandomIntsSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator_OfInt 1
#include "java/util/Spliterator.h"

@class JavaUtilRandom;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionIntConsumer;

/*!
 @brief Spliterator for int streams.We multiplex the four int
  versions into one class by treating a bound less than origin as
  unbounded, and also by treating "infinite" as equivalent to
  Long.MAX_VALUE.
 For splits, it uses the standard divide-by-two
  approach. The long and double versions of this class are
  identical except for types.
 */
@interface JavaUtilRandom_RandomIntsSpliterator : NSObject < JavaUtilSpliterator_OfInt > {
 @public
  JavaUtilRandom *rng_;
  jlong index_;
  jlong fence_;
  jint origin_;
  jint bound_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithId:(id<JavaUtilFunctionIntConsumer>)consumer;

- (jboolean)tryAdvanceWithId:(id<JavaUtilFunctionIntConsumer>)consumer;

- (JavaUtilRandom_RandomIntsSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilRandom:(JavaUtilRandom *)rng
                                        withLong:(jlong)index
                                        withLong:(jlong)fence
                                         withInt:(jint)origin
                                         withInt:(jint)bound;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilRandom_RandomIntsSpliterator)

J2OBJC_FIELD_SETTER(JavaUtilRandom_RandomIntsSpliterator, rng_, JavaUtilRandom *)

FOUNDATION_EXPORT void JavaUtilRandom_RandomIntsSpliterator_initWithJavaUtilRandom_withLong_withLong_withInt_withInt_(JavaUtilRandom_RandomIntsSpliterator *self, JavaUtilRandom *rng, jlong index, jlong fence, jint origin, jint bound);

FOUNDATION_EXPORT JavaUtilRandom_RandomIntsSpliterator *new_JavaUtilRandom_RandomIntsSpliterator_initWithJavaUtilRandom_withLong_withLong_withInt_withInt_(JavaUtilRandom *rng, jlong index, jlong fence, jint origin, jint bound) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilRandom_RandomIntsSpliterator *create_JavaUtilRandom_RandomIntsSpliterator_initWithJavaUtilRandom_withLong_withLong_withInt_withInt_(JavaUtilRandom *rng, jlong index, jlong fence, jint origin, jint bound);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilRandom_RandomIntsSpliterator)

#endif

#if !defined (JavaUtilRandom_RandomLongsSpliterator_) && (INCLUDE_ALL_JavaUtilRandom || defined(INCLUDE_JavaUtilRandom_RandomLongsSpliterator))
#define JavaUtilRandom_RandomLongsSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator_OfLong 1
#include "java/util/Spliterator.h"

@class JavaUtilRandom;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionLongConsumer;

/*!
 @brief Spliterator for long streams.
 */
@interface JavaUtilRandom_RandomLongsSpliterator : NSObject < JavaUtilSpliterator_OfLong > {
 @public
  JavaUtilRandom *rng_;
  jlong index_;
  jlong fence_;
  jlong origin_;
  jlong bound_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithId:(id<JavaUtilFunctionLongConsumer>)consumer;

- (jboolean)tryAdvanceWithId:(id<JavaUtilFunctionLongConsumer>)consumer;

- (JavaUtilRandom_RandomLongsSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilRandom:(JavaUtilRandom *)rng
                                        withLong:(jlong)index
                                        withLong:(jlong)fence
                                        withLong:(jlong)origin
                                        withLong:(jlong)bound;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilRandom_RandomLongsSpliterator)

J2OBJC_FIELD_SETTER(JavaUtilRandom_RandomLongsSpliterator, rng_, JavaUtilRandom *)

FOUNDATION_EXPORT void JavaUtilRandom_RandomLongsSpliterator_initWithJavaUtilRandom_withLong_withLong_withLong_withLong_(JavaUtilRandom_RandomLongsSpliterator *self, JavaUtilRandom *rng, jlong index, jlong fence, jlong origin, jlong bound);

FOUNDATION_EXPORT JavaUtilRandom_RandomLongsSpliterator *new_JavaUtilRandom_RandomLongsSpliterator_initWithJavaUtilRandom_withLong_withLong_withLong_withLong_(JavaUtilRandom *rng, jlong index, jlong fence, jlong origin, jlong bound) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilRandom_RandomLongsSpliterator *create_JavaUtilRandom_RandomLongsSpliterator_initWithJavaUtilRandom_withLong_withLong_withLong_withLong_(JavaUtilRandom *rng, jlong index, jlong fence, jlong origin, jlong bound);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilRandom_RandomLongsSpliterator)

#endif

#if !defined (JavaUtilRandom_RandomDoublesSpliterator_) && (INCLUDE_ALL_JavaUtilRandom || defined(INCLUDE_JavaUtilRandom_RandomDoublesSpliterator))
#define JavaUtilRandom_RandomDoublesSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator_OfDouble 1
#include "java/util/Spliterator.h"

@class JavaUtilRandom;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionDoubleConsumer;

/*!
 @brief Spliterator for double streams.
 */
@interface JavaUtilRandom_RandomDoublesSpliterator : NSObject < JavaUtilSpliterator_OfDouble > {
 @public
  JavaUtilRandom *rng_;
  jlong index_;
  jlong fence_;
  jdouble origin_;
  jdouble bound_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithId:(id<JavaUtilFunctionDoubleConsumer>)consumer;

- (jboolean)tryAdvanceWithId:(id<JavaUtilFunctionDoubleConsumer>)consumer;

- (JavaUtilRandom_RandomDoublesSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilRandom:(JavaUtilRandom *)rng
                                        withLong:(jlong)index
                                        withLong:(jlong)fence
                                      withDouble:(jdouble)origin
                                      withDouble:(jdouble)bound;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilRandom_RandomDoublesSpliterator)

J2OBJC_FIELD_SETTER(JavaUtilRandom_RandomDoublesSpliterator, rng_, JavaUtilRandom *)

FOUNDATION_EXPORT void JavaUtilRandom_RandomDoublesSpliterator_initWithJavaUtilRandom_withLong_withLong_withDouble_withDouble_(JavaUtilRandom_RandomDoublesSpliterator *self, JavaUtilRandom *rng, jlong index, jlong fence, jdouble origin, jdouble bound);

FOUNDATION_EXPORT JavaUtilRandom_RandomDoublesSpliterator *new_JavaUtilRandom_RandomDoublesSpliterator_initWithJavaUtilRandom_withLong_withLong_withDouble_withDouble_(JavaUtilRandom *rng, jlong index, jlong fence, jdouble origin, jdouble bound) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilRandom_RandomDoublesSpliterator *create_JavaUtilRandom_RandomDoublesSpliterator_initWithJavaUtilRandom_withLong_withLong_withDouble_withDouble_(JavaUtilRandom *rng, jlong index, jlong fence, jdouble origin, jdouble bound);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilRandom_RandomDoublesSpliterator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilRandom")
