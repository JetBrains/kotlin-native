//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/HashMap.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilHashMap")
#ifdef RESTRICT_JavaUtilHashMap
#define INCLUDE_ALL_JavaUtilHashMap 0
#else
#define INCLUDE_ALL_JavaUtilHashMap 1
#endif
#undef RESTRICT_JavaUtilHashMap
#ifdef INCLUDE_JavaUtilHashMap_EntrySpliterator
#define INCLUDE_JavaUtilHashMap_HashMapSpliterator 1
#endif
#ifdef INCLUDE_JavaUtilHashMap_ValueSpliterator
#define INCLUDE_JavaUtilHashMap_HashMapSpliterator 1
#endif
#ifdef INCLUDE_JavaUtilHashMap_KeySpliterator
#define INCLUDE_JavaUtilHashMap_HashMapSpliterator 1
#endif
#ifdef INCLUDE_JavaUtilHashMap_EntryIterator
#define INCLUDE_JavaUtilHashMap_HashIterator 1
#endif
#ifdef INCLUDE_JavaUtilHashMap_ValueIterator
#define INCLUDE_JavaUtilHashMap_HashIterator 1
#endif
#ifdef INCLUDE_JavaUtilHashMap_KeyIterator
#define INCLUDE_JavaUtilHashMap_HashIterator 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilHashMap_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap))
#define JavaUtilHashMap_

#define RESTRICT_JavaUtilAbstractMap 1
#define INCLUDE_JavaUtilAbstractMap 1
#include "java/util/AbstractMap.h"

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap 1
#include "java/util/Map.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@class IOSObjectArray;
@class JavaIoObjectOutputStream;
@class JavaUtilHashMap_Node;
@class JavaUtilHashMap_TreeNode;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilSet;

/*!
 @brief Hash table based implementation of the <tt>Map</tt> interface.This
  implementation provides all of the optional map operations, and permits 
 <tt>null</tt> values and the <tt>null</tt> key.
 (The <tt>HashMap</tt>
  class is roughly equivalent to <tt>Hashtable</tt>, except that it is
  unsynchronized and permits nulls.)  This class makes no guarantees as to
  the order of the map; in particular, it does not guarantee that the order
  will remain constant over time. 
 <p>This implementation provides constant-time performance for the basic
  operations (<tt>get</tt> and <tt>put</tt>), assuming the hash function
  disperses the elements properly among the buckets.  Iteration over
  collection views requires time proportional to the "capacity" of the 
 <tt>HashMap</tt> instance (the number of buckets) plus its size (the number
  of key-value mappings).  Thus, it's very important not to set the initial
  capacity too high (or the load factor too low) if iteration performance is
  important. 
 <p>An instance of <tt>HashMap</tt> has two parameters that affect its
  performance: <i>initial capacity</i> and <i>load factor</i>.  The 
 <i>capacity</i> is the number of buckets in the hash table, and the initial
  capacity is simply the capacity at the time the hash table is created.  The 
 <i>load factor</i> is a measure of how full the hash table is allowed to
  get before its capacity is automatically increased.  When the number of
  entries in the hash table exceeds the product of the load factor and the
  current capacity, the hash table is <i>rehashed</i> (that is, internal data
  structures are rebuilt) so that the hash table has approximately twice the
  number of buckets. 
 <p>As a general rule, the default load factor (.75) offers a good
  tradeoff between time and space costs.  Higher values decrease the
  space overhead but increase the lookup cost (reflected in most of
  the operations of the <tt>HashMap</tt> class, including 
 <tt>get</tt> and <tt>put</tt>).  The expected number of entries in
  the map and its load factor should be taken into account when
  setting its initial capacity, so as to minimize the number of
  rehash operations.  If the initial capacity is greater than the
  maximum number of entries divided by the load factor, no rehash
  operations will ever occur. 
 <p>If many mappings are to be stored in a <tt>HashMap</tt>
  instance, creating it with a sufficiently large capacity will allow
  the mappings to be stored more efficiently than letting it perform
  automatic rehashing as needed to grow the table.  Note that using
  many keys with the same <code>hashCode()</code> is a sure way to slow
  down performance of any hash table. To ameliorate impact, when keys
  are <code>Comparable</code>, this class may use comparison order among
  keys to help break ties. 
 <p><strong>Note that this implementation is not synchronized.</strong>
  If multiple threads access a hash map concurrently, and at least one of
  the threads modifies the map structurally, it <i>must</i> be
  synchronized externally.  (A structural modification is any operation
  that adds or deletes one or more mappings; merely changing the value
  associated with a key that an instance already contains is not a
  structural modification.)  This is typically accomplished by
  synchronizing on some object that naturally encapsulates the map.
  If no such object exists, the map should be "wrapped" using the 
 <code>Collections.synchronizedMap</code>
  method.  This is best done at creation time, to prevent accidental
  unsynchronized access to the map:@code

    Map m = Collections.synchronizedMap(new HashMap(...));
@endcode
  
 <p>The iterators returned by all of this class's "collection view methods"
  are <i>fail-fast</i>: if the map is structurally modified at any time after
  the iterator is created, in any way except through the iterator's own 
 <tt>remove</tt> method, the iterator will throw a 
 <code>ConcurrentModificationException</code>.  Thus, in the face of concurrent
  modification, the iterator fails quickly and cleanly, rather than risking
  arbitrary, non-deterministic behavior at an undetermined time in the
  future. 
 <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
  as it is, generally speaking, impossible to make any hard guarantees in the
  presence of unsynchronized concurrent modification.  Fail-fast iterators
  throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
  Therefore, it would be wrong to write a program that depended on this
  exception for its correctness: <i>the fail-fast behavior of iterators
  should be used only to detect bugs.</i>
  
 <p>This class is a member of the 
 <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/collections/index.html">
  Java Collections Framework</a>.
 @author Doug Lea
 @author Josh Bloch
 @author Arthur van Hoff
 @author Neal Gafter
 - seealso: Object#hashCode()
 - seealso: Collection
 - seealso: Map
 - seealso: TreeMap
 - seealso: Hashtable
 @since 1.2
 */
@interface JavaUtilHashMap : JavaUtilAbstractMap < JavaUtilMap, NSCopying, JavaIoSerializable > {
 @public
  /*!
   @brief The table, initialized on first use, and resized as
  necessary.When allocated, length is always a power of two.
   (We also tolerate length zero in some operations to allow
  bootstrapping mechanics that are currently not needed.)
   */
  IOSObjectArray *table_;
  /*!
   @brief Holds cached entrySet().Note that AbstractMap fields are used
  for keySet() and values().
   */
  id<JavaUtilSet> entrySet_;
  /*!
   @brief The number of key-value mappings contained in this map.
   */
  jint size_;
  /*!
   @brief The number of times this HashMap has been structurally modified
  Structural modifications are those that change the number of mappings in
  the HashMap or otherwise modify its internal structure (e.g.,
  rehash).This field is used to make iterators on Collection-views of
  the HashMap fail-fast.
   (See ConcurrentModificationException).
   */
  jint modCount_;
  /*!
   @brief The next size value at which to resize (capacity * load factor).
   */
  jint threshold_;
  /*!
   @brief The load factor for the hash table.
   */
  jfloat loadFactor_;
}
@property (readonly, class) jint DEFAULT_INITIAL_CAPACITY NS_SWIFT_NAME(DEFAULT_INITIAL_CAPACITY);
@property (readonly, class) jint MAXIMUM_CAPACITY NS_SWIFT_NAME(MAXIMUM_CAPACITY);
@property (readonly, class) jfloat DEFAULT_LOAD_FACTOR NS_SWIFT_NAME(DEFAULT_LOAD_FACTOR);
@property (readonly, class) jint TREEIFY_THRESHOLD NS_SWIFT_NAME(TREEIFY_THRESHOLD);
@property (readonly, class) jint UNTREEIFY_THRESHOLD NS_SWIFT_NAME(UNTREEIFY_THRESHOLD);
@property (readonly, class) jint MIN_TREEIFY_CAPACITY NS_SWIFT_NAME(MIN_TREEIFY_CAPACITY);

+ (jint)DEFAULT_INITIAL_CAPACITY;

+ (jint)MAXIMUM_CAPACITY;

+ (jfloat)DEFAULT_LOAD_FACTOR;

+ (jint)TREEIFY_THRESHOLD;

+ (jint)UNTREEIFY_THRESHOLD;

+ (jint)MIN_TREEIFY_CAPACITY;

#pragma mark Public

/*!
 @brief Constructs an empty <tt>HashMap</tt> with the default initial capacity
  (16) and the default load factor (0.75).
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs an empty <tt>HashMap</tt> with the specified initial
  capacity and the default load factor (0.75).
 @param initialCapacity the initial capacity.
 @throw IllegalArgumentExceptionif the initial capacity is negative.
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity;

/*!
 @brief Constructs an empty <tt>HashMap</tt> with the specified initial
  capacity and load factor.
 @param initialCapacity the initial capacity
 @param loadFactor the load factor
 @throw IllegalArgumentExceptionif the initial capacity is negative
          or the load factor is nonpositive
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity
                            withFloat:(jfloat)loadFactor;

/*!
 @brief Constructs a new <tt>HashMap</tt> with the same mappings as the
  specified <tt>Map</tt>.The <tt>HashMap</tt> is created with
  default load factor (0.75) and an initial capacity sufficient to
  hold the mappings in the specified <tt>Map</tt>.
 @param m the map whose mappings are to be placed in this map
 @throw NullPointerExceptionif the specified map is null
 */
- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Removes all of the mappings from this map.
 The map will be empty after this call returns.
 */
- (void)clear;

/*!
 @brief Returns a shallow copy of this <tt>HashMap</tt> instance: the keys and
  values themselves are not cloned.
 @return a shallow copy of this map
 */
- (id __nonnull)java_clone;

- (id __nullable)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id __nullable)computeIfAbsentWithId:(id)key
          withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

- (id __nullable)computeIfPresentWithId:(id)key
         withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief Returns <tt>true</tt> if this map contains a mapping for the
  specified key.
 @param key The key whose presence in this map is to be tested
 @return <tt>true</tt> if this map contains a mapping for the specified
  key.
 */
- (jboolean)containsKeyWithId:(id)key;

/*!
 @brief Returns <tt>true</tt> if this map maps one or more keys to the
  specified value.
 @param value value whose presence in this map is to be tested
 @return <tt>true</tt> if this map maps one or more keys to the
          specified value
 */
- (jboolean)containsValueWithId:(id)value;

/*!
 @brief Returns a <code>Set</code> view of the mappings contained in this map.
 The set is backed by the map, so changes to the map are
  reflected in the set, and vice-versa.  If the map is modified
  while an iteration over the set is in progress (except through
  the iterator's own <tt>remove</tt> operation, or through the 
 <tt>setValue</tt> operation on a map entry returned by the
  iterator) the results of the iteration are undefined.  The set
  supports element removal, which removes the corresponding
  mapping from the map, via the <tt>Iterator.remove</tt>,
  <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and 
 <tt>clear</tt> operations.  It does not support the 
 <tt>add</tt> or <tt>addAll</tt> operations.
 @return a set view of the mappings contained in this map
 */
- (id<JavaUtilSet> __nonnull)entrySet;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief Returns the value to which the specified key is mapped,
  or <code>null</code> if this map contains no mapping for the key.
 <p>More formally, if this map contains a mapping from a key 
 <code>k</code> to a value <code>v</code> such that <code>(key==null ? k==null :
  key.equals(k))</code>
 , then this method returns <code>v</code>; otherwise
  it returns <code>null</code>.  (There can be at most one such mapping.) 
 <p>A return value of <code>null</code> does not <i>necessarily</i>
  indicate that the map contains no mapping for the key; it's also
  possible that the map explicitly maps the key to <code>null</code>.
  The <code>containsKey</code> operation may be used to
  distinguish these two cases.
 - seealso: #put(Object, Object)
 */
- (id __nullable)getWithId:(id)key;

- (id __nullable)getOrDefaultWithId:(id)key
                             withId:(id)defaultValue;

/*!
 @brief Returns <tt>true</tt> if this map contains no key-value mappings.
 @return <tt>true</tt> if this map contains no key-value mappings
 */
- (jboolean)isEmpty;

/*!
 @brief Returns a <code>Set</code> view of the keys contained in this map.
 The set is backed by the map, so changes to the map are
  reflected in the set, and vice-versa.  If the map is modified
  while an iteration over the set is in progress (except through
  the iterator's own <tt>remove</tt> operation), the results of
  the iteration are undefined.  The set supports element removal,
  which removes the corresponding mapping from the map, via the 
 <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
  <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
  operations.  It does not support the <tt>add</tt> or <tt>addAll</tt>
  operations.
 @return a set view of the keys contained in this map
 */
- (id<JavaUtilSet> __nonnull)keySet;

- (id __nullable)mergeWithId:(id)key
                      withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief Associates the specified value with the specified key in this map.
 If the map previously contained a mapping for the key, the old
  value is replaced.
 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with <tt>key</tt>, or
          <tt>null</tt> if there was no mapping for <tt>key</tt>.
          (A <tt>null</tt> return can also indicate that the map
          previously associated <tt>null</tt> with <tt>key</tt>.)
 */
- (id __nullable)putWithId:(id)key
                    withId:(id)value;

/*!
 @brief Copies all of the mappings from the specified map to this map.
 These mappings will replace any mappings that this map had for
  any of the keys currently in the specified map.
 @param m mappings to be stored in this map
 @throw NullPointerExceptionif the specified map is null
 */
- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)m;

- (id __nullable)putIfAbsentWithId:(id)key
                            withId:(id)value;

/*!
 @brief Removes the mapping for the specified key from this map if present.
 @param key key whose mapping is to be removed from the map
 @return the previous value associated with <tt>key</tt>, or
          <tt>null</tt> if there was no mapping for <tt>key</tt>.
          (A <tt>null</tt> return can also indicate that the map
          previously associated <tt>null</tt> with <tt>key</tt>.)
 */
- (id __nullable)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id __nullable)replaceWithId:(id)key
                        withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

/*!
 @brief Returns the number of key-value mappings in this map.
 @return the number of key-value mappings in this map
 */
- (jint)size;

/*!
 @brief Returns a <code>Collection</code> view of the values contained in this map.
 The collection is backed by the map, so changes to the map are
  reflected in the collection, and vice-versa.  If the map is
  modified while an iteration over the collection is in progress
  (except through the iterator's own <tt>remove</tt> operation),
  the results of the iteration are undefined.  The collection
  supports element removal, which removes the corresponding
  mapping from the map, via the <tt>Iterator.remove</tt>,
  <tt>Collection.remove</tt>, <tt>removeAll</tt>,
  <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not
  support the <tt>add</tt> or <tt>addAll</tt> operations.
 @return a view of the values contained in this map
 */
- (id<JavaUtilCollection> __nonnull)values;

#pragma mark Package-Private

- (void)afterNodeAccessWithJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)p;

- (void)afterNodeInsertionWithBoolean:(jboolean)evict;

- (void)afterNodeRemovalWithJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)p;

- (jint)capacity;

/*!
 @brief Returns x's Class if it is of the form "class C implements
  Comparable<C>", else null.
 */
+ (IOSClass *)comparableClassForWithId:(id)x;

/*!
 @brief Returns k.compareTo(x) if x matches kc (k's screened comparable
  class), else 0.
 */
+ (jint)compareComparablesWithIOSClass:(IOSClass *)kc
                                withId:(id)k
                                withId:(id)x;

/*!
 @brief Implements Map.get and related methods
 @param hash_ hash for key
 @param key the key
 @return the node, or null if none
 */
- (JavaUtilHashMap_Node *)getNodeWithInt:(jint)hash_
                                  withId:(id)key;

/*!
 @brief Computes key.hashCode() and spreads (XORs) higher bits of hash
  to lower.Because the table uses power-of-two masking, sets of
  hashes that vary only in bits above the current mask will
  always collide.
 (Among known examples are sets of Float keys
  holding consecutive whole numbers in small tables.)  So we
  apply a transform that spreads the impact of higher bits
  downward. There is a tradeoff between speed, utility, and
  quality of bit-spreading. Because many common sets of hashes
  are already reasonably distributed (so don't benefit from
  spreading), and because we use trees to handle large sets of
  collisions in bins, we just XOR some shifted bits in the
  cheapest possible way to reduce systematic lossage, as well as
  to incorporate impact of the highest bits that would otherwise
  never be used in index calculations because of table bounds.
 */
+ (jint)hash__WithId:(id)key;

- (void)internalWriteEntriesWithJavaIoObjectOutputStream:(JavaIoObjectOutputStream *)s;

- (jfloat)loadFactor;

- (JavaUtilHashMap_Node *)newNodeWithInt:(jint)hash_
                                  withId:(id)key
                                  withId:(id)value
                withJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)next OBJC_METHOD_FAMILY_NONE;

- (JavaUtilHashMap_TreeNode *)newTreeNodeWithInt:(jint)hash_
                                          withId:(id)key
                                          withId:(id)value
                        withJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)next OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Implements Map.putAll and Map constructor
 @param m the map
 @param evict false when initially constructing this map, else  true (relayed to method afterNodeInsertion).
 */
- (void)putMapEntriesWithJavaUtilMap:(id<JavaUtilMap>)m
                         withBoolean:(jboolean)evict;

/*!
 @brief Implements Map.put and related methods
 @param hash_ hash for key
 @param key the key
 @param value the value to put
 @param onlyIfAbsent if true, don't change existing value
 @param evict if false, the table is in creation mode.
 @return previous value, or null if none
 */
- (id)putValWithInt:(jint)hash_
             withId:(id)key
             withId:(id)value
        withBoolean:(jboolean)onlyIfAbsent
        withBoolean:(jboolean)evict;

/*!
 @brief Reset to initial default state.Called by clone and readObject.
 */
- (void)reinitialize;

/*!
 @brief Implements Map.remove and related methods
 @param hash_ hash for key
 @param key the key
 @param value the value to match if matchValue, else ignored
 @param matchValue if true only remove if value is equal
 @param movable if false do not move other nodes while removing
 @return the node, or null if none
 */
- (JavaUtilHashMap_Node *)removeNodeWithInt:(jint)hash_
                                     withId:(id)key
                                     withId:(id)value
                                withBoolean:(jboolean)matchValue
                                withBoolean:(jboolean)movable;

- (JavaUtilHashMap_Node *)replacementNodeWithJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)p
                                         withJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)next;

- (JavaUtilHashMap_TreeNode *)replacementTreeNodeWithJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)p
                                                 withJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)next;

/*!
 @brief Initializes or doubles table size.If null, allocates in
  accord with initial capacity target held in field threshold.
 Otherwise, because we are using power-of-two expansion, the
  elements from each bin must either stay at same index, or move
  with a power of two offset in the new table.
 @return the table
 */
- (IOSObjectArray *)resize;

/*!
 @brief Returns a power of two size for the given target capacity.
 */
+ (jint)tableSizeForWithInt:(jint)cap;

/*!
 @brief Replaces all linked nodes in bin at index for given hash unless
  table is too small, in which case resizes instead.
 */
- (void)treeifyBinWithJavaUtilHashMap_NodeArray:(IOSObjectArray *)tab
                                        withInt:(jint)hash_;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap)

J2OBJC_FIELD_SETTER(JavaUtilHashMap, table_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilHashMap, entrySet_, id<JavaUtilSet>)

/*!
 @brief The default initial capacity - MUST be a power of two.
 */
inline jint JavaUtilHashMap_get_DEFAULT_INITIAL_CAPACITY(void);
#define JavaUtilHashMap_DEFAULT_INITIAL_CAPACITY 16
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilHashMap, DEFAULT_INITIAL_CAPACITY, jint)

/*!
 @brief The maximum capacity, used if a higher value is implicitly specified
  by either of the constructors with arguments.
 MUST be a power of two <= 1<<30.
 */
inline jint JavaUtilHashMap_get_MAXIMUM_CAPACITY(void);
#define JavaUtilHashMap_MAXIMUM_CAPACITY 1073741824
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilHashMap, MAXIMUM_CAPACITY, jint)

/*!
 @brief The load factor used when none specified in constructor.
 */
inline jfloat JavaUtilHashMap_get_DEFAULT_LOAD_FACTOR(void);
#define JavaUtilHashMap_DEFAULT_LOAD_FACTOR 0.75f
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilHashMap, DEFAULT_LOAD_FACTOR, jfloat)

/*!
 @brief The bin count threshold for using a tree rather than list for a
  bin.Bins are converted to trees when adding an element to a
  bin with at least this many nodes.
 The value must be greater
  than 2 and should be at least 8 to mesh with assumptions in
  tree removal about conversion back to plain bins upon
  shrinkage.
 */
inline jint JavaUtilHashMap_get_TREEIFY_THRESHOLD(void);
#define JavaUtilHashMap_TREEIFY_THRESHOLD 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilHashMap, TREEIFY_THRESHOLD, jint)

/*!
 @brief The bin count threshold for untreeifying a (split) bin during a
  resize operation.Should be less than TREEIFY_THRESHOLD, and at
  most 6 to mesh with shrinkage detection under removal.
 */
inline jint JavaUtilHashMap_get_UNTREEIFY_THRESHOLD(void);
#define JavaUtilHashMap_UNTREEIFY_THRESHOLD 6
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilHashMap, UNTREEIFY_THRESHOLD, jint)

/*!
 @brief The smallest table capacity for which bins may be treeified.
 (Otherwise the table is resized if too many nodes in a bin.)
  Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
  between resizing and treeification thresholds.
 */
inline jint JavaUtilHashMap_get_MIN_TREEIFY_CAPACITY(void);
#define JavaUtilHashMap_MIN_TREEIFY_CAPACITY 64
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilHashMap, MIN_TREEIFY_CAPACITY, jint)

FOUNDATION_EXPORT jint JavaUtilHashMap_hash__WithId_(id key);

FOUNDATION_EXPORT IOSClass *JavaUtilHashMap_comparableClassForWithId_(id x);

FOUNDATION_EXPORT jint JavaUtilHashMap_compareComparablesWithIOSClass_withId_withId_(IOSClass *kc, id k, id x);

FOUNDATION_EXPORT jint JavaUtilHashMap_tableSizeForWithInt_(jint cap);

FOUNDATION_EXPORT void JavaUtilHashMap_initWithInt_withFloat_(JavaUtilHashMap *self, jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT JavaUtilHashMap *new_JavaUtilHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap *create_JavaUtilHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT void JavaUtilHashMap_initWithInt_(JavaUtilHashMap *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilHashMap *new_JavaUtilHashMap_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap *create_JavaUtilHashMap_initWithInt_(jint initialCapacity);

FOUNDATION_EXPORT void JavaUtilHashMap_init(JavaUtilHashMap *self);

FOUNDATION_EXPORT JavaUtilHashMap *new_JavaUtilHashMap_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap *create_JavaUtilHashMap_init(void);

FOUNDATION_EXPORT void JavaUtilHashMap_initWithJavaUtilMap_(JavaUtilHashMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilHashMap *new_JavaUtilHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap *create_JavaUtilHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap)

#endif

#if !defined (JavaUtilHashMap_Node_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_Node))
#define JavaUtilHashMap_Node_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap_Entry 1
#include "java/util/Map.h"

/*!
 @brief Basic hash bin node, used for most entries.
 (See below for
  TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
 */
@interface JavaUtilHashMap_Node : NSObject < JavaUtilMap_Entry > {
 @public
  jint hash__;
  id key_;
  id value_;
  JavaUtilHashMap_Node *next_;
}

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (id)getKey;

- (id)getValue;

- (NSUInteger)hash;

- (id)setValueWithId:(id)newValue;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)hash_
                               withId:(id)key
                               withId:(id)value
             withJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)next;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_Node)

J2OBJC_FIELD_SETTER(JavaUtilHashMap_Node, key_, id)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_Node, value_, id)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_Node, next_, JavaUtilHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilHashMap_Node_initWithInt_withId_withId_withJavaUtilHashMap_Node_(JavaUtilHashMap_Node *self, jint hash_, id key, id value, JavaUtilHashMap_Node *next);

FOUNDATION_EXPORT JavaUtilHashMap_Node *new_JavaUtilHashMap_Node_initWithInt_withId_withId_withJavaUtilHashMap_Node_(jint hash_, id key, id value, JavaUtilHashMap_Node *next) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_Node *create_JavaUtilHashMap_Node_initWithInt_withId_withId_withJavaUtilHashMap_Node_(jint hash_, id key, id value, JavaUtilHashMap_Node *next);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_Node)

#endif

#if !defined (JavaUtilHashMap_KeySet_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_KeySet))
#define JavaUtilHashMap_KeySet_

#define RESTRICT_JavaUtilAbstractSet 1
#define INCLUDE_JavaUtilAbstractSet 1
#include "java/util/AbstractSet.h"

@class JavaUtilHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

@interface JavaUtilHashMap_KeySet : JavaUtilAbstractSet

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)key;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_KeySet)

FOUNDATION_EXPORT void JavaUtilHashMap_KeySet_initWithJavaUtilHashMap_(JavaUtilHashMap_KeySet *self, JavaUtilHashMap *outer$);

FOUNDATION_EXPORT JavaUtilHashMap_KeySet *new_JavaUtilHashMap_KeySet_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_KeySet *create_JavaUtilHashMap_KeySet_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_KeySet)

#endif

#if !defined (JavaUtilHashMap_Values_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_Values))
#define JavaUtilHashMap_Values_

#define RESTRICT_JavaUtilAbstractCollection 1
#define INCLUDE_JavaUtilAbstractCollection 1
#include "java/util/AbstractCollection.h"

@class JavaUtilHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

@interface JavaUtilHashMap_Values : JavaUtilAbstractCollection

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilIterator>)iterator;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_Values)

FOUNDATION_EXPORT void JavaUtilHashMap_Values_initWithJavaUtilHashMap_(JavaUtilHashMap_Values *self, JavaUtilHashMap *outer$);

FOUNDATION_EXPORT JavaUtilHashMap_Values *new_JavaUtilHashMap_Values_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_Values *create_JavaUtilHashMap_Values_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_Values)

#endif

#if !defined (JavaUtilHashMap_EntrySet_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_EntrySet))
#define JavaUtilHashMap_EntrySet_

#define RESTRICT_JavaUtilAbstractSet 1
#define INCLUDE_JavaUtilAbstractSet 1
#include "java/util/AbstractSet.h"

@class JavaUtilHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

@interface JavaUtilHashMap_EntrySet : JavaUtilAbstractSet

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_EntrySet)

FOUNDATION_EXPORT void JavaUtilHashMap_EntrySet_initWithJavaUtilHashMap_(JavaUtilHashMap_EntrySet *self, JavaUtilHashMap *outer$);

FOUNDATION_EXPORT JavaUtilHashMap_EntrySet *new_JavaUtilHashMap_EntrySet_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_EntrySet *create_JavaUtilHashMap_EntrySet_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_EntrySet)

#endif

#if !defined (JavaUtilHashMap_HashIterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_HashIterator))
#define JavaUtilHashMap_HashIterator_

@class JavaUtilHashMap;
@class JavaUtilHashMap_Node;

@interface JavaUtilHashMap_HashIterator : NSObject {
 @public
  JavaUtilHashMap_Node *next_;
  JavaUtilHashMap_Node *current_;
  jint expectedModCount_;
  jint index_;
}

#pragma mark Public

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

- (JavaUtilHashMap_Node *)nextNode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_HashIterator)

J2OBJC_FIELD_SETTER(JavaUtilHashMap_HashIterator, next_, JavaUtilHashMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_HashIterator, current_, JavaUtilHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilHashMap_HashIterator_initWithJavaUtilHashMap_(JavaUtilHashMap_HashIterator *self, JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_HashIterator)

#endif

#if !defined (JavaUtilHashMap_KeyIterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_KeyIterator))
#define JavaUtilHashMap_KeyIterator_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

@class JavaUtilHashMap;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilHashMap_KeyIterator : JavaUtilHashMap_HashIterator < JavaUtilIterator >

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_KeyIterator)

FOUNDATION_EXPORT void JavaUtilHashMap_KeyIterator_initWithJavaUtilHashMap_(JavaUtilHashMap_KeyIterator *self, JavaUtilHashMap *outer$);

FOUNDATION_EXPORT JavaUtilHashMap_KeyIterator *new_JavaUtilHashMap_KeyIterator_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_KeyIterator *create_JavaUtilHashMap_KeyIterator_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_KeyIterator)

#endif

#if !defined (JavaUtilHashMap_ValueIterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_ValueIterator))
#define JavaUtilHashMap_ValueIterator_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

@class JavaUtilHashMap;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilHashMap_ValueIterator : JavaUtilHashMap_HashIterator < JavaUtilIterator >

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_ValueIterator)

FOUNDATION_EXPORT void JavaUtilHashMap_ValueIterator_initWithJavaUtilHashMap_(JavaUtilHashMap_ValueIterator *self, JavaUtilHashMap *outer$);

FOUNDATION_EXPORT JavaUtilHashMap_ValueIterator *new_JavaUtilHashMap_ValueIterator_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_ValueIterator *create_JavaUtilHashMap_ValueIterator_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_ValueIterator)

#endif

#if !defined (JavaUtilHashMap_EntryIterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_EntryIterator))
#define JavaUtilHashMap_EntryIterator_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

@class JavaUtilHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilMap_Entry;

@interface JavaUtilHashMap_EntryIterator : JavaUtilHashMap_HashIterator < JavaUtilIterator >

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_EntryIterator)

FOUNDATION_EXPORT void JavaUtilHashMap_EntryIterator_initWithJavaUtilHashMap_(JavaUtilHashMap_EntryIterator *self, JavaUtilHashMap *outer$);

FOUNDATION_EXPORT JavaUtilHashMap_EntryIterator *new_JavaUtilHashMap_EntryIterator_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_EntryIterator *create_JavaUtilHashMap_EntryIterator_initWithJavaUtilHashMap_(JavaUtilHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_EntryIterator)

#endif

#if !defined (JavaUtilHashMap_HashMapSpliterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_HashMapSpliterator))
#define JavaUtilHashMap_HashMapSpliterator_

@class JavaUtilHashMap;
@class JavaUtilHashMap_Node;

@interface JavaUtilHashMap_HashMapSpliterator : NSObject {
 @public
  JavaUtilHashMap *map_;
  JavaUtilHashMap_Node *current_;
  jint index_;
  jint fence_;
  jint est_;
  jint expectedModCount_;
}

#pragma mark Public

- (jlong)estimateSize;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)m
                                          withInt:(jint)origin
                                          withInt:(jint)fence
                                          withInt:(jint)est
                                          withInt:(jint)expectedModCount;

- (jint)getFence;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_HashMapSpliterator)

J2OBJC_FIELD_SETTER(JavaUtilHashMap_HashMapSpliterator, map_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_HashMapSpliterator, current_, JavaUtilHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilHashMap_HashMapSpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap_HashMapSpliterator *self, JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

FOUNDATION_EXPORT JavaUtilHashMap_HashMapSpliterator *new_JavaUtilHashMap_HashMapSpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_HashMapSpliterator *create_JavaUtilHashMap_HashMapSpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_HashMapSpliterator)

#endif

#if !defined (JavaUtilHashMap_KeySpliterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_KeySpliterator))
#define JavaUtilHashMap_KeySpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilHashMap;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilHashMap_KeySpliterator : JavaUtilHashMap_HashMapSpliterator < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilHashMap_KeySpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)m
                                          withInt:(jint)origin
                                          withInt:(jint)fence
                                          withInt:(jint)est
                                          withInt:(jint)expectedModCount;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_KeySpliterator)

FOUNDATION_EXPORT void JavaUtilHashMap_KeySpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap_KeySpliterator *self, JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

FOUNDATION_EXPORT JavaUtilHashMap_KeySpliterator *new_JavaUtilHashMap_KeySpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_KeySpliterator *create_JavaUtilHashMap_KeySpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_KeySpliterator)

#endif

#if !defined (JavaUtilHashMap_ValueSpliterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_ValueSpliterator))
#define JavaUtilHashMap_ValueSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilHashMap;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilHashMap_ValueSpliterator : JavaUtilHashMap_HashMapSpliterator < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilHashMap_ValueSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)m
                                          withInt:(jint)origin
                                          withInt:(jint)fence
                                          withInt:(jint)est
                                          withInt:(jint)expectedModCount;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_ValueSpliterator)

FOUNDATION_EXPORT void JavaUtilHashMap_ValueSpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap_ValueSpliterator *self, JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

FOUNDATION_EXPORT JavaUtilHashMap_ValueSpliterator *new_JavaUtilHashMap_ValueSpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_ValueSpliterator *create_JavaUtilHashMap_ValueSpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_ValueSpliterator)

#endif

#if !defined (JavaUtilHashMap_EntrySpliterator_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_EntrySpliterator))
#define JavaUtilHashMap_EntrySpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilHashMap;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilHashMap_EntrySpliterator : JavaUtilHashMap_HashMapSpliterator < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilHashMap_EntrySpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilHashMap:(JavaUtilHashMap *)m
                                          withInt:(jint)origin
                                          withInt:(jint)fence
                                          withInt:(jint)est
                                          withInt:(jint)expectedModCount;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_EntrySpliterator)

FOUNDATION_EXPORT void JavaUtilHashMap_EntrySpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap_EntrySpliterator *self, JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

FOUNDATION_EXPORT JavaUtilHashMap_EntrySpliterator *new_JavaUtilHashMap_EntrySpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_EntrySpliterator *create_JavaUtilHashMap_EntrySpliterator_initWithJavaUtilHashMap_withInt_withInt_withInt_withInt_(JavaUtilHashMap *m, jint origin, jint fence, jint est, jint expectedModCount);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_EntrySpliterator)

#endif

#if !defined (JavaUtilHashMap_TreeNode_) && (INCLUDE_ALL_JavaUtilHashMap || defined(INCLUDE_JavaUtilHashMap_TreeNode))
#define JavaUtilHashMap_TreeNode_

#define RESTRICT_JavaUtilLinkedHashMap 1
#define INCLUDE_JavaUtilLinkedHashMap_LinkedHashMapEntry 1
#include "java/util/LinkedHashMap.h"

@class IOSClass;
@class IOSObjectArray;
@class JavaUtilHashMap;
@class JavaUtilHashMap_Node;

/*!
 @brief Entry for Tree bins.Extends LinkedHashMap.Entry (which in turn
  extends Node) so can be used as extension of either regular or
  linked node.
 */
@interface JavaUtilHashMap_TreeNode : JavaUtilLinkedHashMap_LinkedHashMapEntry {
 @public
  JavaUtilHashMap_TreeNode *parent_;
  JavaUtilHashMap_TreeNode *left_;
  JavaUtilHashMap_TreeNode *right_;
  JavaUtilHashMap_TreeNode *prev_;
  jboolean red_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)hash_
                               withId:(id)key
                               withId:(id)val
             withJavaUtilHashMap_Node:(JavaUtilHashMap_Node *)next;

+ (JavaUtilHashMap_TreeNode *)balanceDeletionWithJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)root
                                             withJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)x;

+ (JavaUtilHashMap_TreeNode *)balanceInsertionWithJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)root
                                              withJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)x;

/*!
 @brief Recursive invariant check
 */
+ (jboolean)checkInvariantsWithJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)t;

/*!
 @brief Finds the node starting at root p with the given hash and key.
 The kc argument caches comparableClassFor(key) upon first use
  comparing keys.
 */
- (JavaUtilHashMap_TreeNode *)findWithInt:(jint)h
                                   withId:(id)k
                             withIOSClass:(IOSClass *)kc;

/*!
 @brief Calls find for root node.
 */
- (JavaUtilHashMap_TreeNode *)getTreeNodeWithInt:(jint)h
                                          withId:(id)k;

/*!
 @brief Ensures that the given root is the first node of its bin.
 */
+ (void)moveRootToFrontWithJavaUtilHashMap_NodeArray:(IOSObjectArray *)tab
                        withJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)root;

/*!
 @brief Tree version of putVal.
 */
- (JavaUtilHashMap_TreeNode *)putTreeValWithJavaUtilHashMap:(JavaUtilHashMap *)map
                              withJavaUtilHashMap_NodeArray:(IOSObjectArray *)tab
                                                    withInt:(jint)h
                                                     withId:(id)k
                                                     withId:(id)v;

/*!
 @brief Removes the given node, that must be present before this call.
 This is messier than typical red-black deletion code because we
  cannot swap the contents of an interior node with a leaf
  successor that is pinned by "next" pointers that are accessible
  independently during traversal. So instead we swap the tree
  linkages. If the current tree appears to have too few nodes,
  the bin is converted back to a plain bin. (The test triggers
  somewhere between 2 and 6 nodes, depending on tree structure).
 */
- (void)removeTreeNodeWithJavaUtilHashMap:(JavaUtilHashMap *)map
            withJavaUtilHashMap_NodeArray:(IOSObjectArray *)tab
                              withBoolean:(jboolean)movable;

/*!
 @brief Returns root of tree containing this node.
 */
- (JavaUtilHashMap_TreeNode *)root;

+ (JavaUtilHashMap_TreeNode *)rotateLeftWithJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)root
                                        withJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)p;

+ (JavaUtilHashMap_TreeNode *)rotateRightWithJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)root
                                         withJavaUtilHashMap_TreeNode:(JavaUtilHashMap_TreeNode *)p;

/*!
 @brief Splits nodes in a tree bin into lower and upper tree bins,
  or untreeifies if now too small.Called only from resize;
  see above discussion about split bits and indices.
 @param map the map
 @param tab the table for recording bin heads
 @param index the index of the table being split
 @param bit the bit of hash to split on
 */
- (void)splitWithJavaUtilHashMap:(JavaUtilHashMap *)map
   withJavaUtilHashMap_NodeArray:(IOSObjectArray *)tab
                         withInt:(jint)index
                         withInt:(jint)bit;

/*!
 @brief Tie-breaking utility for ordering insertions when equal
  hashCodes and non-comparable.We don't require a total
  order, just a consistent insertion rule to maintain
  equivalence across rebalancings.
 Tie-breaking further than
  necessary simplifies testing a bit.
 */
+ (jint)tieBreakOrderWithId:(id)a
                     withId:(id)b;

/*!
 @brief Forms tree of the nodes linked from this node.
 @return root of tree
 */
- (void)treeifyWithJavaUtilHashMap_NodeArray:(IOSObjectArray *)tab;

/*!
 @brief Returns a list of non-TreeNodes replacing those linked from
  this node.
 */
- (JavaUtilHashMap_Node *)untreeifyWithJavaUtilHashMap:(JavaUtilHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilHashMap_TreeNode)

J2OBJC_FIELD_SETTER(JavaUtilHashMap_TreeNode, parent_, JavaUtilHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_TreeNode, left_, JavaUtilHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_TreeNode, right_, JavaUtilHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilHashMap_TreeNode, prev_, JavaUtilHashMap_TreeNode *)

FOUNDATION_EXPORT void JavaUtilHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilHashMap_Node_(JavaUtilHashMap_TreeNode *self, jint hash_, id key, id val, JavaUtilHashMap_Node *next);

FOUNDATION_EXPORT JavaUtilHashMap_TreeNode *new_JavaUtilHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilHashMap_Node_(jint hash_, id key, id val, JavaUtilHashMap_Node *next) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilHashMap_TreeNode *create_JavaUtilHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilHashMap_Node_(jint hash_, id key, id val, JavaUtilHashMap_Node *next);

FOUNDATION_EXPORT void JavaUtilHashMap_TreeNode_moveRootToFrontWithJavaUtilHashMap_NodeArray_withJavaUtilHashMap_TreeNode_(IOSObjectArray *tab, JavaUtilHashMap_TreeNode *root);

FOUNDATION_EXPORT jint JavaUtilHashMap_TreeNode_tieBreakOrderWithId_withId_(id a, id b);

FOUNDATION_EXPORT JavaUtilHashMap_TreeNode *JavaUtilHashMap_TreeNode_rotateLeftWithJavaUtilHashMap_TreeNode_withJavaUtilHashMap_TreeNode_(JavaUtilHashMap_TreeNode *root, JavaUtilHashMap_TreeNode *p);

FOUNDATION_EXPORT JavaUtilHashMap_TreeNode *JavaUtilHashMap_TreeNode_rotateRightWithJavaUtilHashMap_TreeNode_withJavaUtilHashMap_TreeNode_(JavaUtilHashMap_TreeNode *root, JavaUtilHashMap_TreeNode *p);

FOUNDATION_EXPORT JavaUtilHashMap_TreeNode *JavaUtilHashMap_TreeNode_balanceInsertionWithJavaUtilHashMap_TreeNode_withJavaUtilHashMap_TreeNode_(JavaUtilHashMap_TreeNode *root, JavaUtilHashMap_TreeNode *x);

FOUNDATION_EXPORT JavaUtilHashMap_TreeNode *JavaUtilHashMap_TreeNode_balanceDeletionWithJavaUtilHashMap_TreeNode_withJavaUtilHashMap_TreeNode_(JavaUtilHashMap_TreeNode *root, JavaUtilHashMap_TreeNode *x);

FOUNDATION_EXPORT jboolean JavaUtilHashMap_TreeNode_checkInvariantsWithJavaUtilHashMap_TreeNode_(JavaUtilHashMap_TreeNode *t);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilHashMap_TreeNode)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilHashMap")
