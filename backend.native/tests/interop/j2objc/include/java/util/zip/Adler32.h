//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/zip/Adler32.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilZipAdler32")
#ifdef RESTRICT_JavaUtilZipAdler32
#define INCLUDE_ALL_JavaUtilZipAdler32 0
#else
#define INCLUDE_ALL_JavaUtilZipAdler32 1
#endif
#undef RESTRICT_JavaUtilZipAdler32

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilZipAdler32_) && (INCLUDE_ALL_JavaUtilZipAdler32 || defined(INCLUDE_JavaUtilZipAdler32))
#define JavaUtilZipAdler32_

#define RESTRICT_JavaUtilZipChecksum 1
#define INCLUDE_JavaUtilZipChecksum 1
#include "java/util/zip/Checksum.h"

@class IOSByteArray;
@class JavaNioByteBuffer;

/*!
 @brief A class that can be used to compute the Adler-32 checksum of a data
  stream.An Adler-32 checksum is almost as reliable as a CRC-32 but
  can be computed much faster.
 <p> Passing a <code>null</code> argument to a method in this class will cause a 
 <code>NullPointerException</code> to be thrown.
 - seealso: Checksum
 @author David Connelly
 */
@interface JavaUtilZipAdler32 : NSObject < JavaUtilZipChecksum >

#pragma mark Public

/*!
 @brief Creates a new Adler32 object.
 */
- (instancetype __nonnull)init;

/*!
 @brief Returns the checksum value.
 */
- (jlong)getValue;

/*!
 @brief Resets the checksum to initial value.
 */
- (void)reset;

/*!
 @brief Updates the checksum with the specified array of bytes.
 @param b the byte array to update the checksum with
 */
- (void)updateWithByteArray:(IOSByteArray *)b;

/*!
 @brief Updates the checksum with the specified array of bytes.
 @throw ArrayIndexOutOfBoundsException
 if <code>off</code> is negative, or <code>len</code> is negative,
           or <code>off+len</code> is greater than the length of the
           array <code>b</code>
 */
- (void)updateWithByteArray:(IOSByteArray *)b
                    withInt:(jint)off
                    withInt:(jint)len;

/*!
 @brief Updates the checksum with the bytes from the specified buffer.
 The checksum is updated using
  buffer.<code>remaining()</code>
  bytes starting at
  buffer.<code>position()</code>
  Upon return, the buffer's position will be updated to its
  limit; its limit will not have been changed.
 @param buffer the ByteBuffer to update the checksum with
 @since 1.8
 */
- (void)updateWithJavaNioByteBuffer:(JavaNioByteBuffer *)buffer;

/*!
 @brief Updates the checksum with the specified byte (the low eight
  bits of the argument b).
 @param b the byte to update the checksum with
 */
- (void)updateWithInt:(jint)b;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilZipAdler32)

FOUNDATION_EXPORT void JavaUtilZipAdler32_init(JavaUtilZipAdler32 *self);

FOUNDATION_EXPORT JavaUtilZipAdler32 *new_JavaUtilZipAdler32_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilZipAdler32 *create_JavaUtilZipAdler32_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilZipAdler32)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilZipAdler32")
