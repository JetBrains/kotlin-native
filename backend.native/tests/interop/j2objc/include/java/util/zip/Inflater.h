//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/zip/Inflater.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilZipInflater")
#ifdef RESTRICT_JavaUtilZipInflater
#define INCLUDE_ALL_JavaUtilZipInflater 0
#else
#define INCLUDE_ALL_JavaUtilZipInflater 1
#endif
#undef RESTRICT_JavaUtilZipInflater

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilZipInflater_) && (INCLUDE_ALL_JavaUtilZipInflater || defined(INCLUDE_JavaUtilZipInflater))
#define JavaUtilZipInflater_

@class IOSByteArray;

/*!
 @brief This class provides support for general purpose decompression using the
  popular ZLIB compression library.The ZLIB compression library was
  initially developed as part of the PNG graphics standard and is not
  protected by patents.
 It is fully described in the specifications at the 
 <a href="package-summary.html#package_description">java.util.zip
  package description</a>.
  
 <p>The following code fragment demonstrates a trivial compression
  and decompression of a string using <tt>Deflater</tt> and 
 <tt>Inflater</tt>.
  
 <blockquote>@code

  try {
      // Encode a String into bytes     String inputString = "blahblahblah€€";
      byte[] input = inputString.getBytes("UTF-8");
      // Compress the bytes
      byte[] output = new byte[100];
      Deflater compresser = new Deflater();
      compresser.setInput(input);
      compresser.finish();
      int compressedDataLength = compresser.deflate(output);
      // Decompress the bytes
      Inflater decompresser = new Inflater();
      decompresser.setInput(output, 0, compressedDataLength);
      byte[] result = new byte[100];
      int resultLength = decompresser.inflate(result);
      decompresser.end();
      // Decode the bytes into a String
      String outputString = new String(result, 0, resultLength, "UTF-8");
  } catch(java.io.UnsupportedEncodingException ex) {
      // handle
  } catch (java.util.zip.DataFormatException ex) {
      // handle
  } 
  
@endcode</blockquote>
 - seealso: Deflater
 @author David Connelly
 */
@interface JavaUtilZipInflater : NSObject {
 @public
  IOSByteArray *buf_;
  jint off_;
  jint len_;
  jboolean finished_;
  jboolean needDict_;
}

#pragma mark Public

/*!
 @brief Creates a new decompressor.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a new decompressor.If the parameter 'nowrap' is true then
  the ZLIB header and checksum fields will not be used.
 This provides
  compatibility with the compression format used by both GZIP and PKZIP. 
 <p>
  Note: When using the 'nowrap' option it is also necessary to provide
  an extra "dummy" byte as input. This is required by the ZLIB native
  library in order to support certain optimizations.
 @param nowrap if true then support GZIP compatible compression
 */
- (instancetype __nonnull)initWithBoolean:(jboolean)nowrap;

/*!
 @brief Closes the decompressor and discards any unprocessed input.
 This method should be called when the decompressor is no longer
  being used, but will also be called automatically by the finalize()
  method. Once this method is called, the behavior of the Inflater
  object is undefined.
 */
- (void)end;

/*!
 @brief Returns true if the end of the compressed data stream has been
  reached.
 @return true if the end of the compressed data stream has been
  reached
 */
- (jboolean)finished;

/*!
 @brief Returns the ADLER-32 value of the uncompressed data.
 @return the ADLER-32 value of the uncompressed data
 */
- (jint)getAdler;

/*!
 @brief Returns the total number of compressed bytes input so far.
 @return the total (non-negative) number of compressed bytes input so far
 @since 1.5
 */
- (jlong)getBytesRead;

/*!
 @brief Returns the total number of uncompressed bytes output so far.
 @return the total (non-negative) number of uncompressed bytes output so far
 @since 1.5
 */
- (jlong)getBytesWritten;

/*!
 @brief Returns the total number of bytes remaining in the input buffer.
 This can be used to find out what bytes still remain in the input
  buffer after decompression has finished.
 @return the total number of bytes remaining in the input buffer
 */
- (jint)getRemaining;

/*!
 @brief Returns the total number of compressed bytes input so far.
 <p>Since the number of bytes may be greater than
  Integer.MAX_VALUE, the <code>getBytesRead()</code> method is now
  the preferred means of obtaining this information.</p>
 @return the total number of compressed bytes input so far
 */
- (jint)getTotalIn;

/*!
 @brief Returns the total number of uncompressed bytes output so far.
 <p>Since the number of bytes may be greater than
  Integer.MAX_VALUE, the <code>getBytesWritten()</code> method is now
  the preferred means of obtaining this information.</p>
 @return the total number of uncompressed bytes output so far
 */
- (jint)getTotalOut;

/*!
 @brief Uncompresses bytes into specified buffer.Returns actual number
  of bytes uncompressed.
 A return value of 0 indicates that
  needsInput() or needsDictionary() should be called in order to
  determine if more input data or a preset dictionary is required.
  In the latter case, getAdler() can be used to get the Adler-32
  value of the dictionary required.
 @param b the buffer for the uncompressed data
 @return the actual number of uncompressed bytes
 @throw DataFormatExceptionif the compressed data format is invalid
 - seealso: Inflater#needsInput
 - seealso: Inflater#needsDictionary
 */
- (jint)inflateWithByteArray:(IOSByteArray *)b;

/*!
 @brief Uncompresses bytes into specified buffer.Returns actual number
  of bytes uncompressed.
 A return value of 0 indicates that
  needsInput() or needsDictionary() should be called in order to
  determine if more input data or a preset dictionary is required.
  In the latter case, getAdler() can be used to get the Adler-32
  value of the dictionary required.
 @param b the buffer for the uncompressed data
 @param off the start offset of the data
 @param len the maximum number of uncompressed bytes
 @return the actual number of uncompressed bytes
 @throw DataFormatExceptionif the compressed data format is invalid
 - seealso: Inflater#needsInput
 - seealso: Inflater#needsDictionary
 */
- (jint)inflateWithByteArray:(IOSByteArray *)b
                     withInt:(jint)off
                     withInt:(jint)len;

/*!
 @brief Returns true if a preset dictionary is needed for decompression.
 @return true if a preset dictionary is needed for decompression
 - seealso: Inflater#setDictionary
 */
- (jboolean)needsDictionary;

/*!
 @brief Returns true if no data remains in the input buffer.This can
  be used to determine if #setInput should be called in order
  to provide more input.
 @return true if no data remains in the input buffer
 */
- (jboolean)needsInput;

/*!
 @brief Resets inflater so that a new set of input data can be processed.
 */
- (void)reset;

/*!
 @brief Sets the preset dictionary to the given array of bytes.Should be
  called when inflate() returns 0 and needsDictionary() returns true
  indicating that a preset dictionary is required.
 The method getAdler()
  can be used to get the Adler-32 value of the dictionary needed.
 @param b the dictionary data bytes
 - seealso: Inflater#needsDictionary
 - seealso: Inflater#getAdler
 */
- (void)setDictionaryWithByteArray:(IOSByteArray *)b;

/*!
 @brief Sets the preset dictionary to the given array of bytes.Should be
  called when inflate() returns 0 and needsDictionary() returns true
  indicating that a preset dictionary is required.
 The method getAdler()
  can be used to get the Adler-32 value of the dictionary needed.
 @param b the dictionary data bytes
 @param off the start offset of the data
 @param len the length of the data
 - seealso: Inflater#needsDictionary
 - seealso: Inflater#getAdler
 */
- (void)setDictionaryWithByteArray:(IOSByteArray *)b
                           withInt:(jint)off
                           withInt:(jint)len;

/*!
 @brief Sets input data for decompression.Should be called whenever
  needsInput() returns true indicating that more input data is
  required.
 @param b the input data bytes
 - seealso: Inflater#needsInput
 */
- (void)setInputWithByteArray:(IOSByteArray *)b;

/*!
 @brief Sets input data for decompression.Should be called whenever
  needsInput() returns true indicating that more input data is
  required.
 @param b the input data bytes
 @param off the start offset of the input data
 @param len the length of the input data
 - seealso: Inflater#needsInput
 */
- (void)setInputWithByteArray:(IOSByteArray *)b
                      withInt:(jint)off
                      withInt:(jint)len;

#pragma mark Protected

/*!
 @brief Closes the decompressor when garbage is collected.
 */
- (void)java_finalize;

#pragma mark Package-Private

- (jboolean)ended;

@end

J2OBJC_STATIC_INIT(JavaUtilZipInflater)

J2OBJC_FIELD_SETTER(JavaUtilZipInflater, buf_, IOSByteArray *)

FOUNDATION_EXPORT void JavaUtilZipInflater_initWithBoolean_(JavaUtilZipInflater *self, jboolean nowrap);

FOUNDATION_EXPORT JavaUtilZipInflater *new_JavaUtilZipInflater_initWithBoolean_(jboolean nowrap) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilZipInflater *create_JavaUtilZipInflater_initWithBoolean_(jboolean nowrap);

FOUNDATION_EXPORT void JavaUtilZipInflater_init(JavaUtilZipInflater *self);

FOUNDATION_EXPORT JavaUtilZipInflater *new_JavaUtilZipInflater_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilZipInflater *create_JavaUtilZipInflater_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilZipInflater)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilZipInflater")
