//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/ForkJoinTask.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentForkJoinTask")
#ifdef RESTRICT_JavaUtilConcurrentForkJoinTask
#define INCLUDE_ALL_JavaUtilConcurrentForkJoinTask 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentForkJoinTask 1
#endif
#undef RESTRICT_JavaUtilConcurrentForkJoinTask
#ifdef INCLUDE_JavaUtilConcurrentForkJoinTask_AdaptedCallable
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentForkJoinTask_RunnableExecuteAction
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentForkJoinTask_AdaptedRunnable
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentForkJoinTask_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinTask || defined(INCLUDE_JavaUtilConcurrentForkJoinTask))
#define JavaUtilConcurrentForkJoinTask_

#define RESTRICT_JavaUtilConcurrentFuture 1
#define INCLUDE_JavaUtilConcurrentFuture 1
#include "java/util/concurrent/Future.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@class JavaLangThrowable;
@class JavaUtilConcurrentForkJoinPool;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilCollection;
@protocol JavaUtilConcurrentCallable;

/*!
 @brief Abstract base class for tasks that run within a <code>ForkJoinPool</code>.
 A <code>ForkJoinTask</code> is a thread-like entity that is much
  lighter weight than a normal thread.  Huge numbers of tasks and
  subtasks may be hosted by a small number of actual threads in a
  ForkJoinPool, at the price of some usage limitations. 
 <p>A "main" <code>ForkJoinTask</code> begins execution when it is
  explicitly submitted to a <code>ForkJoinPool</code>, or, if not already
  engaged in a ForkJoin computation, commenced in the <code>ForkJoinPool.commonPool()</code>
  via <code>fork</code>, <code>invoke</code>, or
  related methods.  Once started, it will usually in turn start other
  subtasks.  As indicated by the name of this class, many programs
  using <code>ForkJoinTask</code> employ only methods <code>fork</code> and 
 <code>join</code>, or derivatives such as <code>invokeAll</code>
 .  However, this class also
  provides a number of other methods that can come into play in
  advanced usages, as well as extension mechanics that allow support
  of new forms of fork/join processing. 
 <p>A <code>ForkJoinTask</code> is a lightweight form of <code>Future</code>.
  The efficiency of <code>ForkJoinTask</code>s stems from a set of
  restrictions (that are only partially statically enforceable)
  reflecting their main use as computational tasks calculating pure
  functions or operating on purely isolated objects.  The primary
  coordination mechanisms are <code>fork</code>, that arranges
  asynchronous execution, and <code>join</code>, that doesn't proceed
  until the task's result has been computed.  Computations should
  ideally avoid <code>synchronized</code> methods or blocks, and should
  minimize other blocking synchronization apart from joining other
  tasks or using synchronizers such as Phasers that are advertised to
  cooperate with fork/join scheduling. Subdividable tasks should also
  not perform blocking I/O, and should ideally access variables that
  are completely independent of those accessed by other running
  tasks. These guidelines are loosely enforced by not permitting
  checked exceptions such as <code>IOExceptions</code> to be
  thrown. However, computations may still encounter unchecked
  exceptions, that are rethrown to callers attempting to join
  them. These exceptions may additionally include <code>RejectedExecutionException</code>
  stemming from internal resource
  exhaustion, such as failure to allocate internal task
  queues. Rethrown exceptions behave in the same way as regular
  exceptions, but, when possible, contain stack traces (as displayed
  for example using <code>ex.printStackTrace()</code>) of both the thread
  that initiated the computation as well as the thread actually
  encountering the exception; minimally only the latter. 
 <p>It is possible to define and use ForkJoinTasks that may block,
  but doing do requires three further considerations: (1) Completion
  of few if any <em>other</em> tasks should be dependent on a task
  that blocks on external synchronization or I/O. Event-style async
  tasks that are never joined (for example, those subclassing <code>CountedCompleter</code>
 ) often fall into this category.  (2) To minimize
  resource impact, tasks should be small; ideally performing only the
  (possibly) blocking action. (3) Unless the <code>ForkJoinPool.ManagedBlocker</code>
  API is used, or the number of possibly
  blocked tasks is known to be less than the pool's <code>ForkJoinPool.getParallelism</code>
  level, the pool cannot guarantee that
  enough threads will be available to ensure progress or good
  performance. 
 <p>The primary method for awaiting completion and extracting
  results of a task is <code>join</code>, but there are several variants:
  The <code>Future.get</code> methods support interruptible and/or timed
  waits for completion and report results using <code>Future</code>
  conventions. Method <code>invoke</code> is semantically
  equivalent to <code>fork(); join()</code> but always attempts to begin
  execution in the current thread. The "<em>quiet</em>" forms of
  these methods do not extract results or report exceptions. These
  may be useful when a set of tasks are being executed, and you need
  to delay processing of results or exceptions until all complete.
  Method <code>invokeAll</code> (available in multiple versions)
  performs the most common form of parallel invocation: forking a set
  of tasks and joining them all. 
 <p>In the most typical usages, a fork-join pair act like a call
  (fork) and return (join) from a parallel recursive function. As is
  the case with other forms of recursive calls, returns (joins)
  should be performed innermost-first. For example, <code>a.fork();
  b.fork(); b.join(); a.join();</code>
  is likely to be substantially more
  efficient than joining <code>a</code> before <code>b</code>.
  
 <p>The execution status of tasks may be queried at several levels
  of detail: <code>isDone</code> is true if a task completed in any way
  (including the case where a task was cancelled without executing); 
 <code>isCompletedNormally</code> is true if a task completed without
  cancellation or encountering an exception; <code>isCancelled</code> is
  true if the task was cancelled (in which case <code>getException</code>
  returns a <code>java.util.concurrent.CancellationException</code>); and 
 <code>isCompletedAbnormally</code> is true if a task was either
  cancelled or encountered an exception, in which case <code>getException</code>
  will return either the encountered exception or 
 <code>java.util.concurrent.CancellationException</code>.
  
 <p>The ForkJoinTask class is not usually directly subclassed.
  Instead, you subclass one of the abstract classes that support a
  particular style of fork/join processing, typically <code>RecursiveAction</code>
  for most computations that do not return results, 
 <code>RecursiveTask</code> for those that do, and <code>CountedCompleter</code>
  for those in which completed actions trigger
  other actions.  Normally, a concrete ForkJoinTask subclass declares
  fields comprising its parameters, established in a constructor, and
  then defines a <code>compute</code> method that somehow uses the control
  methods supplied by this base class. 
 <p>Method <code>join</code> and its variants are appropriate for use
  only when completion dependencies are acyclic; that is, the
  parallel computation can be described as a directed acyclic graph
  (DAG). Otherwise, executions may encounter a form of deadlock as
  tasks cyclically wait for each other.  However, this framework
  supports other methods and techniques (for example the use of 
 <code>Phaser</code>, <code>helpQuiesce</code>, and <code>complete</code>) that
  may be of use in constructing custom subclasses for problems that
  are not statically structured as DAGs. To support such usages, a
  ForkJoinTask may be atomically <em>tagged</em> with a <code>short</code>
  value using <code>setForkJoinTaskTag</code> or <code>compareAndSetForkJoinTaskTag</code>
  and checked using <code>getForkJoinTaskTag</code>
 . The ForkJoinTask implementation does not use
  these <code>protected</code> methods or tags for any purpose, but they
  may be of use in the construction of specialized subclasses.  For
  example, parallel graph traversals can use the supplied methods to
  avoid revisiting nodes/tasks that have already been processed.
  (Method names for tagging are bulky in part to encourage definition
  of methods that reflect their usage patterns.) 
 <p>Most base support methods are <code>final</code>, to prevent
  overriding of implementations that are intrinsically tied to the
  underlying lightweight task scheduling framework.  Developers
  creating new basic styles of fork/join processing should minimally
  implement <code>protected</code> methods <code>exec</code>, <code>setRawResult</code>
 , and <code>getRawResult</code>, while also introducing
  an abstract computational method that can be implemented in its
  subclasses, possibly relying on other <code>protected</code> methods
  provided by this class. 
 <p>ForkJoinTasks should perform relatively small amounts of
  computation. Large tasks should be split into smaller subtasks,
  usually via recursive decomposition. As a very rough rule of thumb,
  a task should perform more than 100 and less than 10000 basic
  computational steps, and should avoid indefinite looping. If tasks
  are too big, then parallelism cannot improve throughput. If too
  small, then memory and internal task maintenance overhead may
  overwhelm processing. 
 <p>This class provides <code>adapt</code> methods for <code>Runnable</code>
  and <code>Callable</code>, that may be of use when mixing execution of 
 <code>ForkJoinTasks</code> with other kinds of tasks. When all tasks are
  of this form, consider using a pool constructed in <em>asyncMode</em>.
  
 <p>ForkJoinTasks are <code>Serializable</code>, which enables them to be
  used in extensions such as remote execution frameworks. It is
  sensible to serialize tasks only before or after, but not during,
  execution. Serialization is not relied on during execution itself.
 @since 1.7
 @author Doug Lea
 */
@interface JavaUtilConcurrentForkJoinTask : NSObject < JavaUtilConcurrentFuture, JavaIoSerializable > {
 @public
  /*!
   @brief The run status of this task
   */
  volatile_jint status_;
}
@property (readonly, class) jint DONE_MASK NS_SWIFT_NAME(DONE_MASK);
@property (readonly, class) jint NORMAL NS_SWIFT_NAME(NORMAL);
@property (readonly, class) jint CANCELLED NS_SWIFT_NAME(CANCELLED);
@property (readonly, class) jint EXCEPTIONAL NS_SWIFT_NAME(EXCEPTIONAL);
@property (readonly, class) jint SIGNAL NS_SWIFT_NAME(SIGNAL);
@property (readonly, class) jint SMASK NS_SWIFT_NAME(SMASK);

+ (jint)DONE_MASK;

+ (jint)NORMAL;

+ (jint)CANCELLED;

+ (jint)EXCEPTIONAL;

+ (jint)SIGNAL;

+ (jint)SMASK;

#pragma mark Public

- (instancetype __nonnull)init;

/*!
 @brief Returns a new <code>ForkJoinTask</code> that performs the <code>call</code>
  method of the given <code>Callable</code> as its action, and returns
  its result upon <code>join</code>, translating any checked exceptions
  encountered into <code>RuntimeException</code>.
 @param callable the callable action
 @return the task
 */
+ (JavaUtilConcurrentForkJoinTask *)adaptWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)callable;

/*!
 @brief Returns a new <code>ForkJoinTask</code> that performs the <code>run</code>
  method of the given <code>Runnable</code> as its action, and returns
  a null result upon <code>join</code>.
 @param runnable the runnable action
 @return the task
 */
+ (JavaUtilConcurrentForkJoinTask *)adaptWithJavaLangRunnable:(id<JavaLangRunnable>)runnable;

/*!
 @brief Returns a new <code>ForkJoinTask</code> that performs the <code>run</code>
  method of the given <code>Runnable</code> as its action, and returns
  the given result upon <code>join</code>.
 @param runnable the runnable action
 @param result the result upon completion
 @return the task
 */
+ (JavaUtilConcurrentForkJoinTask *)adaptWithJavaLangRunnable:(id<JavaLangRunnable>)runnable
                                                       withId:(id)result;

/*!
 @brief Attempts to cancel execution of this task.This attempt will
  fail if the task has already completed or could not be
  cancelled for some other reason.
 If successful, and this task
  has not started when <code>cancel</code> is called, execution of
  this task is suppressed. After this method returns
  successfully, unless there is an intervening call to <code>reinitialize</code>
 , subsequent calls to <code>isCancelled</code>,
  <code>isDone</code>, and <code>cancel</code> will return <code>true</code>
  and calls to <code>join</code> and related methods will result in 
 <code>CancellationException</code>.
  
 <p>This method may be overridden in subclasses, but if so, must
  still ensure that these properties hold. In particular, the 
 <code>cancel</code> method itself must not throw exceptions. 
 <p>This method is designed to be invoked by <em>other</em>
  tasks. To terminate the current task, you can just return or
  throw an unchecked exception from its computation method, or
  invoke <code>completeExceptionally(Throwable)</code>.
 @param mayInterruptIfRunning this value has no effect in the  default implementation because interrupts are not used to
   control cancellation.
 @return <code>true</code> if this task is now cancelled
 */
- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

/*!
 @brief Atomically conditionally sets the tag value for this task.
 Among other applications, tags can be used as visit markers
  in tasks operating on graphs, as in methods that check: <code>if (task.compareAndSetForkJoinTaskTag((short)0, (short)1))</code>
  before processing, otherwise exiting because the node has
  already been visited.
 @param expect the expected tag value
 @param update the new tag value
 @return <code>true</code> if successful; i.e., the current value was
  equal to <code>expect</code> and was changed to <code>update</code>.
 @since 1.8
 */
- (jboolean)compareAndSetForkJoinTaskTagWithShort:(jshort)expect
                                        withShort:(jshort)update;

/*!
 @brief Completes this task, and if not already aborted or cancelled,
  returning the given value as the result of subsequent
  invocations of <code>join</code> and related operations.This method
  may be used to provide results for asynchronous tasks, or to
  provide alternative handling for tasks that would not otherwise
  complete normally.
 Its use in other situations is
  discouraged. This method is overridable, but overridden
  versions must invoke <code>super</code> implementation to maintain
  guarantees.
 @param value the result value for this task
 */
- (void)completeWithId:(id)value;

/*!
 @brief Completes this task abnormally, and if not already aborted or
  cancelled, causes it to throw the given exception upon 
 <code>join</code> and related operations.This method may be used
  to induce exceptions in asynchronous tasks, or to force
  completion of tasks that would not otherwise complete.
 Its use
  in other situations is discouraged.  This method is
  overridable, but overridden versions must invoke <code>super</code>
  implementation to maintain guarantees.
 @param ex the exception to throw. If this exception is not a  
 <code>RuntimeException</code>  or <code>Error</code> , the actual exception  thrown will be a 
 <code>RuntimeException</code>  with cause <code>ex</code> .
 */
- (void)completeExceptionallyWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief Arranges to asynchronously execute this task in the pool the
  current task is running in, if applicable, or using the <code>ForkJoinPool.commonPool()</code>
  if not <code>inForkJoinPool</code>.While
  it is not necessarily enforced, it is a usage error to fork a
  task more than once unless it has completed and been
  reinitialized.
 Subsequent modifications to the state of this
  task or any data it operates on are not necessarily
  consistently observable by any thread other than the one
  executing it unless preceded by a call to <code>join</code> or
  related methods, or a call to <code>isDone</code> returning <code>true</code>
 .
 @return <code>this</code>, to simplify usage
 */
- (JavaUtilConcurrentForkJoinTask *)fork;

/*!
 @brief Waits if necessary for the computation to complete, and then
  retrieves its result.
 @return the computed result
 @throw CancellationExceptionif the computation was cancelled
 @throw ExecutionExceptionif the computation threw an
  exception
 @throw InterruptedExceptionif the current thread is not a
  member of a ForkJoinPool and was interrupted while waiting
 */
- (id)get;

/*!
 @brief Waits if necessary for at most the given time for the computation
  to complete, and then retrieves its result, if available.
 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @return the computed result
 @throw CancellationExceptionif the computation was cancelled
 @throw ExecutionExceptionif the computation threw an
  exception
 @throw InterruptedExceptionif the current thread is not a
  member of a ForkJoinPool and was interrupted while waiting
 @throw TimeoutExceptionif the wait timed out
 */
- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns the exception thrown by the base computation, or a 
 <code>CancellationException</code> if cancelled, or <code>null</code> if
  none or if the method has not yet completed.
 @return the exception, or <code>null</code> if none
 */
- (JavaLangThrowable *)getException;

/*!
 @brief Returns the tag for this task.
 @return the tag for this task
 @since 1.8
 */
- (jshort)getForkJoinTaskTag;

/*!
 @brief Returns the pool hosting the current thread, or <code>null</code>
  if the current thread is executing outside of any ForkJoinPool.
 <p>This method returns <code>null</code> if and only if <code>inForkJoinPool</code>
  returns <code>false</code>.
 @return the pool, or <code>null</code> if none
 */
+ (JavaUtilConcurrentForkJoinPool *)getPool;

/*!
 @brief Returns an estimate of the number of tasks that have been
  forked by the current worker thread but not yet executed.This
  value may be useful for heuristic decisions about whether to
  fork other tasks.
 @return the number of tasks
 */
+ (jint)getQueuedTaskCount;

/*!
 @brief Returns the result that would be returned by <code>join</code>, even
  if this task completed abnormally, or <code>null</code> if this task
  is not known to have been completed.This method is designed
  to aid debugging, as well as to support extensions.
 Its use in
  any other context is discouraged.
 @return the result, or <code>null</code> if not completed
 */
- (id)getRawResult;

/*!
 @brief Returns an estimate of how many more locally queued tasks are
  held by the current worker thread than there are other worker
  threads that might steal them, or zero if this thread is not
  operating in a ForkJoinPool.This value may be useful for
  heuristic decisions about whether to fork other tasks.
 In many
  usages of ForkJoinTasks, at steady state, each worker should
  aim to maintain a small constant surplus (for example, 3) of
  tasks, and to process computations locally if this threshold is
  exceeded.
 @return the surplus number of tasks, which may be negative
 */
+ (jint)getSurplusQueuedTaskCount;

/*!
 @brief Possibly executes tasks until the pool hosting the current task 
 is quiescent.This
  method may be of use in designs in which many tasks are forked,
  but none are explicitly joined, instead executing them until
  all are processed.
 */
+ (void)helpQuiesce;

/*!
 @brief Returns <code>true</code> if the current thread is a <code>ForkJoinWorkerThread</code>
  executing as a ForkJoinPool computation.
 @return <code>true</code> if the current thread is a <code>ForkJoinWorkerThread</code>
  executing as a ForkJoinPool computation,
  or <code>false</code> otherwise
 */
+ (jboolean)inForkJoinPool;

/*!
 @brief Commences performing this task, awaits its completion if
  necessary, and returns its result, or throws an (unchecked) 
 <code>RuntimeException</code> or <code>Error</code> if the underlying
  computation did so.
 @return the computed result
 */
- (id)invoke;

/*!
 @brief Forks all tasks in the specified collection, returning when 
 <code>isDone</code> holds for each task or an (unchecked) exception
  is encountered, in which case the exception is rethrown.If
  more than one task encounters an exception, then this method
  throws any one of these exceptions.
 If any task encounters an
  exception, others may be cancelled. However, the execution
  status of individual tasks is not guaranteed upon exceptional
  return. The status of each task may be obtained using <code>getException()</code>
  and related methods to check if they have been
  cancelled, completed normally or exceptionally, or left
  unprocessed.
 @param tasks the collection of tasks
 @return the tasks argument, to simplify usage
 @throw NullPointerExceptionif tasks or any element are null
 */
+ (id<JavaUtilCollection>)invokeAllWithJavaUtilCollection:(id<JavaUtilCollection>)tasks;

/*!
 @brief Forks the given tasks, returning when <code>isDone</code> holds for
  each task or an (unchecked) exception is encountered, in which
  case the exception is rethrown.If more than one task
  encounters an exception, then this method throws any one of
  these exceptions.
 If any task encounters an exception, others
  may be cancelled. However, the execution status of individual
  tasks is not guaranteed upon exceptional return. The status of
  each task may be obtained using <code>getException()</code> and
  related methods to check if they have been cancelled, completed
  normally or exceptionally, or left unprocessed.
 @param tasks the tasks
 @throw NullPointerExceptionif any task is null
 */
+ (void)invokeAllWithJavaUtilConcurrentForkJoinTaskArray:(IOSObjectArray *)tasks;

/*!
 @brief Forks the given tasks, returning when <code>isDone</code> holds for
  each task or an (unchecked) exception is encountered, in which
  case the exception is rethrown.If more than one task
  encounters an exception, then this method throws any one of
  these exceptions.
 If any task encounters an exception, the
  other may be cancelled. However, the execution status of
  individual tasks is not guaranteed upon exceptional return. The
  status of each task may be obtained using <code>getException()</code>
  and related methods to check if they have been
  cancelled, completed normally or exceptionally, or left
  unprocessed.
 @param t1 the first task
 @param t2 the second task
 @throw NullPointerExceptionif any task is null
 */
+ (void)invokeAllWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)t1
                 withJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)t2;

- (jboolean)isCancelled;

/*!
 @brief Returns <code>true</code> if this task threw an exception or was cancelled.
 @return <code>true</code> if this task threw an exception or was cancelled
 */
- (jboolean)isCompletedAbnormally;

/*!
 @brief Returns <code>true</code> if this task completed without throwing an
  exception and was not cancelled.
 @return <code>true</code> if this task completed without throwing an
  exception and was not cancelled
 */
- (jboolean)isCompletedNormally;

- (jboolean)isDone;

/*!
 @brief Returns the result of the computation when it <code>is
  done</code>
 .This method differs from <code>get()</code> in that
  abnormal completion results in <code>RuntimeException</code> or 
 <code>Error</code>, not <code>ExecutionException</code>, and that
  interrupts of the calling thread do <em>not</em> cause the
  method to abruptly return by throwing <code>InterruptedException</code>
 .
 @return the computed result
 */
- (id)join;

/*!
 @brief Completes this task normally without setting a value.The most
  recent value established by <code>setRawResult</code> (or <code>null</code>
  by default) will be returned as the result of subsequent
  invocations of <code>join</code> and related operations.
 @since 1.8
 */
- (void)quietlyComplete;

/*!
 @brief Commences performing this task and awaits its completion if
  necessary, without returning its result or throwing its
  exception.
 */
- (void)quietlyInvoke;

/*!
 @brief Joins this task, without returning its result or throwing its
  exception.This method may be useful when processing
  collections of tasks when some have been cancelled or otherwise
  known to have aborted.
 */
- (void)quietlyJoin;

/*!
 @brief Resets the internal bookkeeping state of this task, allowing a
  subsequent <code>fork</code>.This method allows repeated reuse of
  this task, but only if reuse occurs when this task has either
  never been forked, or has been forked, then completed and all
  outstanding joins of this task have also completed.
 Effects
  under any other usage conditions are not guaranteed.
  This method may be useful when executing
  pre-constructed trees of subtasks in loops. 
 <p>Upon completion of this method, <code>isDone()</code> reports 
 <code>false</code>, and <code>getException()</code> reports <code>null</code>
 . However, the value returned by <code>getRawResult</code> is
  unaffected. To clear this value, you can invoke <code>setRawResult(null)</code>
 .
 */
- (void)reinitialize;

/*!
 @brief Atomically sets the tag value for this task and returns the old value.
 @param newValue the new tag value
 @return the previous value of the tag
 @since 1.8
 */
- (jshort)setForkJoinTaskTagWithShort:(jshort)newValue;

/*!
 @brief Tries to unschedule this task for execution.This method will
  typically (but is not guaranteed to) succeed if this task is
  the most recently forked task by the current thread, and has
  not commenced executing in another thread.
 This method may be
  useful when arranging alternative local processing of tasks
  that could have been, but were not, stolen.
 @return <code>true</code> if unforked
 */
- (jboolean)tryUnfork;

#pragma mark Protected

/*!
 @brief Immediately performs the base action of this task and returns
  true if, upon return from this method, this task is guaranteed
  to have completed normally.This method may return false
  otherwise, to indicate that this task is not necessarily
  complete (or is not known to be complete), for example in
  asynchronous actions that require explicit invocations of
  completion methods.
 This method may also throw an (unchecked)
  exception to indicate abnormal exit. This method is designed to
  support extensions, and should not in general be called
  otherwise.
 @return <code>true</code> if this task is known to have completed normally
 */
- (jboolean)exec;

/*!
 @brief Returns, but does not unschedule or execute, a task queued by
  the current thread but not yet executed, if one is immediately
  available.There is no guarantee that this task will actually
  be polled or executed next.
 Conversely, this method may return
  null even if a task exists but cannot be accessed without
  contention with other threads.  This method is designed
  primarily to support extensions, and is unlikely to be useful
  otherwise.
 @return the next task, or <code>null</code> if none are available
 */
+ (JavaUtilConcurrentForkJoinTask *)peekNextLocalTask;

/*!
 @brief Unschedules and returns, without executing, the next task
  queued by the current thread but not yet executed, if the
  current thread is operating in a ForkJoinPool.This method is
  designed primarily to support extensions, and is unlikely to be
  useful otherwise.
 @return the next task, or <code>null</code> if none are available
 */
+ (JavaUtilConcurrentForkJoinTask *)pollNextLocalTask;

/*!
 @brief If the current thread is operating in a ForkJoinPool,
  unschedules and returns, without executing, a task externally
  submitted to the pool, if one is available.Availability may be
  transient, so a <code>null</code> result does not necessarily imply
  quiescence of the pool.
 This method is designed primarily to
  support extensions, and is unlikely to be useful otherwise.
 @return a task, or <code>null</code> if none are available
 @since 9
 */
+ (JavaUtilConcurrentForkJoinTask *)pollSubmission;

/*!
 @brief If the current thread is operating in a ForkJoinPool,
  unschedules and returns, without executing, the next task
  queued by the current thread but not yet executed, if one is
  available, or if not available, a task that was forked by some
  other thread, if available.Availability may be transient, so a 
 <code>null</code> result does not necessarily imply quiescence of
  the pool this task is operating in.
 This method is designed
  primarily to support extensions, and is unlikely to be useful
  otherwise.
 @return a task, or <code>null</code> if none are available
 */
+ (JavaUtilConcurrentForkJoinTask *)pollTask;

/*!
 @brief Forces the given value to be returned as a result.This method
  is designed to support extensions, and should not in general be
  called otherwise.
 @param value the value
 */
- (void)setRawResultWithId:(id)value;

#pragma mark Package-Private

/*!
 @brief Cancels, ignoring any exceptions thrown by cancel.Used during
  worker and pool shutdown.
 Cancel is spec'ed not to throw any
  exceptions, but if it does anyway, we have no recourse during
  shutdown, so guard against this case.
 */
+ (void)cancelIgnoringExceptionsWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)t;

/*!
 @brief Primary execution method for stolen tasks.Unless done, calls
  exec and records status if completed, but doesn't wait for
  completion otherwise.
 @return status on exit from this method
 */
- (jint)doExec;

/*!
 @brief If lock is available, polls stale refs and removes them.
 Called from ForkJoinPool when pools become quiescent.
 */
+ (void)helpExpungeStaleExceptions;

/*!
 @brief Hook for exception propagation support for tasks with completers.
 */
- (void)internalPropagateExceptionWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief If not done, sets SIGNAL status and performs Object.wait(timeout).
 This task may or may not be done on exit. Ignores interrupts.
 @param timeout using Object.wait conventions.
 */
- (void)internalWaitWithLong:(jlong)timeout;

/*!
 @brief Records exception and sets status.
 @return status on exit
 */
- (jint)recordExceptionalCompletionWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief A version of "sneaky throw" to relay exceptions.
 */
+ (void)rethrowWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief The sneaky part of sneaky throw, relying on generics
  limitations to evade compiler complaints about rethrowing
  unchecked exceptions.
 */
+ (void)uncheckedThrowWithJavaLangThrowable:(JavaLangThrowable *)t;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentForkJoinTask)

inline jint JavaUtilConcurrentForkJoinTask_get_DONE_MASK(void);
#define JavaUtilConcurrentForkJoinTask_DONE_MASK -268435456
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinTask, DONE_MASK, jint)

inline jint JavaUtilConcurrentForkJoinTask_get_NORMAL(void);
#define JavaUtilConcurrentForkJoinTask_NORMAL -268435456
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinTask, NORMAL, jint)

inline jint JavaUtilConcurrentForkJoinTask_get_CANCELLED(void);
#define JavaUtilConcurrentForkJoinTask_CANCELLED -1073741824
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinTask, CANCELLED, jint)

inline jint JavaUtilConcurrentForkJoinTask_get_EXCEPTIONAL(void);
#define JavaUtilConcurrentForkJoinTask_EXCEPTIONAL ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinTask, EXCEPTIONAL, jint)

inline jint JavaUtilConcurrentForkJoinTask_get_SIGNAL(void);
#define JavaUtilConcurrentForkJoinTask_SIGNAL 65536
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinTask, SIGNAL, jint)

inline jint JavaUtilConcurrentForkJoinTask_get_SMASK(void);
#define JavaUtilConcurrentForkJoinTask_SMASK 65535
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinTask, SMASK, jint)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_init(JavaUtilConcurrentForkJoinTask *self);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_cancelIgnoringExceptionsWithJavaUtilConcurrentForkJoinTask_(JavaUtilConcurrentForkJoinTask *t);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_helpExpungeStaleExceptions(void);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_rethrowWithJavaLangThrowable_(JavaLangThrowable *ex);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_uncheckedThrowWithJavaLangThrowable_(JavaLangThrowable *t);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_invokeAllWithJavaUtilConcurrentForkJoinTask_withJavaUtilConcurrentForkJoinTask_(JavaUtilConcurrentForkJoinTask *t1, JavaUtilConcurrentForkJoinTask *t2);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_invokeAllWithJavaUtilConcurrentForkJoinTaskArray_(IOSObjectArray *tasks);

FOUNDATION_EXPORT id<JavaUtilCollection> JavaUtilConcurrentForkJoinTask_invokeAllWithJavaUtilCollection_(id<JavaUtilCollection> tasks);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_helpQuiesce(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinTask_getPool(void);

FOUNDATION_EXPORT jboolean JavaUtilConcurrentForkJoinTask_inForkJoinPool(void);

FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinTask_getQueuedTaskCount(void);

FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinTask_getSurplusQueuedTaskCount(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_peekNextLocalTask(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_pollNextLocalTask(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_pollTask(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_pollSubmission(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_adaptWithJavaLangRunnable_(id<JavaLangRunnable> runnable);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_adaptWithJavaLangRunnable_withId_(id<JavaLangRunnable> runnable, id result);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask *JavaUtilConcurrentForkJoinTask_adaptWithJavaUtilConcurrentCallable_(id<JavaUtilConcurrentCallable> callable);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinTask)

#endif

#if !defined (JavaUtilConcurrentForkJoinTask_ExceptionNode_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinTask || defined(INCLUDE_JavaUtilConcurrentForkJoinTask_ExceptionNode))
#define JavaUtilConcurrentForkJoinTask_ExceptionNode_

#define RESTRICT_JavaLangRefWeakReference 1
#define INCLUDE_JavaLangRefWeakReference 1
#include "java/lang/ref/WeakReference.h"

@class JavaLangRefReferenceQueue;
@class JavaLangThrowable;
@class JavaUtilConcurrentForkJoinTask;

/*!
 @brief Key-value nodes for exception table.The chained hash table
  uses identity comparisons, full locking, and weak references
  for keys.
 The table has a fixed capacity because it only
  maintains task exceptions long enough for joiners to access
  them, so should never become very large for sustained
  periods. However, since we do not know when the last joiner
  completes, we must use weak references and expunge them. We do
  so on each operation (hence full locking). Also, some thread in
  any ForkJoinPool will call helpExpungeStaleExceptions when its
  pool becomes isQuiescent.
 */
@interface JavaUtilConcurrentForkJoinTask_ExceptionNode : JavaLangRefWeakReference {
 @public
  JavaLangThrowable *ex_;
  JavaUtilConcurrentForkJoinTask_ExceptionNode *next_;
  jlong thrower_;
  jint hashCode_;
}

#pragma mark Public

- (JavaUtilConcurrentForkJoinTask *)get;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task
                                           withJavaLangThrowable:(JavaLangThrowable *)ex
                withJavaUtilConcurrentForkJoinTask_ExceptionNode:(JavaUtilConcurrentForkJoinTask_ExceptionNode *)next
                                   withJavaLangRefReferenceQueue:(JavaLangRefReferenceQueue *)exceptionTableRefQueue;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithId:(id)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithId:(id)arg0
       withJavaLangRefReferenceQueue:(JavaLangRefReferenceQueue *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinTask_ExceptionNode)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_ExceptionNode, ex_, JavaLangThrowable *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_ExceptionNode, next_, JavaUtilConcurrentForkJoinTask_ExceptionNode *)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_ExceptionNode_initWithJavaUtilConcurrentForkJoinTask_withJavaLangThrowable_withJavaUtilConcurrentForkJoinTask_ExceptionNode_withJavaLangRefReferenceQueue_(JavaUtilConcurrentForkJoinTask_ExceptionNode *self, JavaUtilConcurrentForkJoinTask *task, JavaLangThrowable *ex, JavaUtilConcurrentForkJoinTask_ExceptionNode *next, JavaLangRefReferenceQueue *exceptionTableRefQueue);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_ExceptionNode *new_JavaUtilConcurrentForkJoinTask_ExceptionNode_initWithJavaUtilConcurrentForkJoinTask_withJavaLangThrowable_withJavaUtilConcurrentForkJoinTask_ExceptionNode_withJavaLangRefReferenceQueue_(JavaUtilConcurrentForkJoinTask *task, JavaLangThrowable *ex, JavaUtilConcurrentForkJoinTask_ExceptionNode *next, JavaLangRefReferenceQueue *exceptionTableRefQueue) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_ExceptionNode *create_JavaUtilConcurrentForkJoinTask_ExceptionNode_initWithJavaUtilConcurrentForkJoinTask_withJavaLangThrowable_withJavaUtilConcurrentForkJoinTask_ExceptionNode_withJavaLangRefReferenceQueue_(JavaUtilConcurrentForkJoinTask *task, JavaLangThrowable *ex, JavaUtilConcurrentForkJoinTask_ExceptionNode *next, JavaLangRefReferenceQueue *exceptionTableRefQueue);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinTask_ExceptionNode)

#endif

#if !defined (JavaUtilConcurrentForkJoinTask_AdaptedRunnable_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinTask || defined(INCLUDE_JavaUtilConcurrentForkJoinTask_AdaptedRunnable))
#define JavaUtilConcurrentForkJoinTask_AdaptedRunnable_

#define RESTRICT_JavaUtilConcurrentRunnableFuture 1
#define INCLUDE_JavaUtilConcurrentRunnableFuture 1
#include "java/util/concurrent/RunnableFuture.h"

@protocol JavaLangRunnable;

/*!
 @brief Adapter for Runnables.This implements RunnableFuture
  to be compliant with AbstractExecutorService constraints
  when used in ForkJoinPool.
 */
@interface JavaUtilConcurrentForkJoinTask_AdaptedRunnable : JavaUtilConcurrentForkJoinTask < JavaUtilConcurrentRunnableFuture > {
 @public
  id<JavaLangRunnable> runnable_;
  id result_;
}

#pragma mark Public

- (jboolean)exec;

- (id)getRawResult;

- (void)run;

- (void)setRawResultWithId:(id)v;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaLangRunnable:(id<JavaLangRunnable>)runnable
                                            withId:(id)result;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinTask_AdaptedRunnable)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_AdaptedRunnable, runnable_, id<JavaLangRunnable>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_AdaptedRunnable, result_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_AdaptedRunnable_initWithJavaLangRunnable_withId_(JavaUtilConcurrentForkJoinTask_AdaptedRunnable *self, id<JavaLangRunnable> runnable, id result);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_AdaptedRunnable *new_JavaUtilConcurrentForkJoinTask_AdaptedRunnable_initWithJavaLangRunnable_withId_(id<JavaLangRunnable> runnable, id result) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_AdaptedRunnable *create_JavaUtilConcurrentForkJoinTask_AdaptedRunnable_initWithJavaLangRunnable_withId_(id<JavaLangRunnable> runnable, id result);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinTask_AdaptedRunnable)

#endif

#if !defined (JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinTask || defined(INCLUDE_JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction))
#define JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction_

#define RESTRICT_JavaUtilConcurrentRunnableFuture 1
#define INCLUDE_JavaUtilConcurrentRunnableFuture 1
#include "java/util/concurrent/RunnableFuture.h"

@class JavaLangVoid;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;

/*!
 @brief Adapter for Runnables without results.
 */
@interface JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction : JavaUtilConcurrentForkJoinTask < JavaUtilConcurrentRunnableFuture > {
 @public
  id<JavaLangRunnable> runnable_;
}

#pragma mark Public

- (jboolean)exec;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

- (void)run;

- (void)setRawResultWithId:(JavaLangVoid *)v;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaLangRunnable:(id<JavaLangRunnable>)runnable;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction, runnable_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction_initWithJavaLangRunnable_(JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction *self, id<JavaLangRunnable> runnable);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction *new_JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction_initWithJavaLangRunnable_(id<JavaLangRunnable> runnable) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction *create_JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction_initWithJavaLangRunnable_(id<JavaLangRunnable> runnable);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinTask_AdaptedRunnableAction)

#endif

#if !defined (JavaUtilConcurrentForkJoinTask_RunnableExecuteAction_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinTask || defined(INCLUDE_JavaUtilConcurrentForkJoinTask_RunnableExecuteAction))
#define JavaUtilConcurrentForkJoinTask_RunnableExecuteAction_

@class JavaLangThrowable;
@class JavaLangVoid;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;

/*!
 @brief Adapter for Runnables in which failure forces worker exception.
 */
@interface JavaUtilConcurrentForkJoinTask_RunnableExecuteAction : JavaUtilConcurrentForkJoinTask {
 @public
  id<JavaLangRunnable> runnable_;
}

#pragma mark Public

- (jboolean)exec;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

- (void)setRawResultWithId:(JavaLangVoid *)v;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaLangRunnable:(id<JavaLangRunnable>)runnable;

- (void)internalPropagateExceptionWithJavaLangThrowable:(JavaLangThrowable *)ex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinTask_RunnableExecuteAction)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_RunnableExecuteAction, runnable_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_RunnableExecuteAction_initWithJavaLangRunnable_(JavaUtilConcurrentForkJoinTask_RunnableExecuteAction *self, id<JavaLangRunnable> runnable);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_RunnableExecuteAction *new_JavaUtilConcurrentForkJoinTask_RunnableExecuteAction_initWithJavaLangRunnable_(id<JavaLangRunnable> runnable) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_RunnableExecuteAction *create_JavaUtilConcurrentForkJoinTask_RunnableExecuteAction_initWithJavaLangRunnable_(id<JavaLangRunnable> runnable);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinTask_RunnableExecuteAction)

#endif

#if !defined (JavaUtilConcurrentForkJoinTask_AdaptedCallable_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinTask || defined(INCLUDE_JavaUtilConcurrentForkJoinTask_AdaptedCallable))
#define JavaUtilConcurrentForkJoinTask_AdaptedCallable_

#define RESTRICT_JavaUtilConcurrentRunnableFuture 1
#define INCLUDE_JavaUtilConcurrentRunnableFuture 1
#include "java/util/concurrent/RunnableFuture.h"

@protocol JavaUtilConcurrentCallable;

/*!
 @brief Adapter for Callables.
 */
@interface JavaUtilConcurrentForkJoinTask_AdaptedCallable : JavaUtilConcurrentForkJoinTask < JavaUtilConcurrentRunnableFuture > {
 @public
  id<JavaUtilConcurrentCallable> callable_;
  id result_;
}

#pragma mark Public

- (jboolean)exec;

- (id)getRawResult;

- (void)run;

- (void)setRawResultWithId:(id)v;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)callable;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinTask_AdaptedCallable)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_AdaptedCallable, callable_, id<JavaUtilConcurrentCallable>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinTask_AdaptedCallable, result_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinTask_AdaptedCallable_initWithJavaUtilConcurrentCallable_(JavaUtilConcurrentForkJoinTask_AdaptedCallable *self, id<JavaUtilConcurrentCallable> callable);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_AdaptedCallable *new_JavaUtilConcurrentForkJoinTask_AdaptedCallable_initWithJavaUtilConcurrentCallable_(id<JavaUtilConcurrentCallable> callable) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinTask_AdaptedCallable *create_JavaUtilConcurrentForkJoinTask_AdaptedCallable_initWithJavaUtilConcurrentCallable_(id<JavaUtilConcurrentCallable> callable);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinTask_AdaptedCallable)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentForkJoinTask")
