//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/atomic/DoubleAccumulator.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentAtomicDoubleAccumulator")
#ifdef RESTRICT_JavaUtilConcurrentAtomicDoubleAccumulator
#define INCLUDE_ALL_JavaUtilConcurrentAtomicDoubleAccumulator 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentAtomicDoubleAccumulator 1
#endif
#undef RESTRICT_JavaUtilConcurrentAtomicDoubleAccumulator

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentAtomicDoubleAccumulator_) && (INCLUDE_ALL_JavaUtilConcurrentAtomicDoubleAccumulator || defined(INCLUDE_JavaUtilConcurrentAtomicDoubleAccumulator))
#define JavaUtilConcurrentAtomicDoubleAccumulator_

#define RESTRICT_JavaUtilConcurrentAtomicStriped64 1
#define INCLUDE_JavaUtilConcurrentAtomicStriped64 1
#include "java/util/concurrent/atomic/Striped64.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilFunctionDoubleBinaryOperator;

/*!
 @brief One or more variables that together maintain a running <code>double</code>
  value updated using a supplied function.When updates (method 
 <code>accumulate</code>) are contended across threads, the set of variables
  may grow dynamically to reduce contention.
 Method <code>get</code>
  (or, equivalently, <code>doubleValue</code>) returns the current value
  across the variables maintaining updates. 
 <p>This class is usually preferable to alternatives when multiple
  threads update a common value that is used for purposes such as
  summary statistics that are frequently updated but less frequently
  read. 
 <p>The supplied accumulator function should be side-effect-free,
  since it may be re-applied when attempted updates fail due to
  contention among threads. The function is applied with the current
  value as its first argument, and the given update as the second
  argument.  For example, to maintain a running maximum value, you
  could supply <code>Double::max</code> along with <code>Double.NEGATIVE_INFINITY</code>
  as the identity. The order of
  accumulation within or across threads is not guaranteed. Thus, this
  class may not be applicable if numerical stability is required,
  especially when combining values of substantially different orders
  of magnitude. 
 <p>Class <code>DoubleAdder</code> provides analogs of the functionality
  of this class for the common special case of maintaining sums.  The
  call <code>new DoubleAdder()</code> is equivalent to <code>new
  DoubleAccumulator((x, y) -> x + y, 0.0)</code>
 .
  
 <p>This class extends <code>Number</code>, but does <em>not</em> define
  methods such as <code>equals</code>, <code>hashCode</code> and <code>compareTo</code>
  because instances are expected to be mutated, and so are
  not useful as collection keys.
 @since 1.8
 @author Doug Lea
 */
@interface JavaUtilConcurrentAtomicDoubleAccumulator : JavaUtilConcurrentAtomicStriped64 < JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a new instance using the given accumulator function
  and identity element.
 @param accumulatorFunction a side-effect-free function of two arguments
 @param identity identity (initial value) for the accumulator function
 */
- (instancetype __nonnull)initWithJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)accumulatorFunction
                                                            withDouble:(jdouble)identity;

/*!
 @brief Updates with the given value.
 @param x the value
 */
- (void)accumulateWithDouble:(jdouble)x;

/*!
 @brief Equivalent to <code>get</code>.
 @return the current value
 */
- (jdouble)doubleValue;

/*!
 @brief Returns the current value as a <code>float</code>
  after a narrowing primitive conversion.
 */
- (jfloat)floatValue;

/*!
 @brief Returns the current value.The returned value is <em>NOT</em>
  an atomic snapshot; invocation in the absence of concurrent
  updates returns an accurate result, but concurrent updates that
  occur while the value is being calculated might not be
  incorporated.
 @return the current value
 */
- (jdouble)get;

/*!
 @brief Equivalent in effect to <code>get</code> followed by <code>reset</code>
 .This method may apply for example during quiescent
  points between multithreaded computations.
 If there are
  updates concurrent with this method, the returned value is 
 <em>not</em> guaranteed to be the final value occurring before
  the reset.
 @return the value before reset
 */
- (jdouble)getThenReset;

- (NSUInteger)hash;

/*!
 @brief Returns the current value as an <code>int</code>
  after a narrowing primitive conversion.
 */
- (jint)intValue;

- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns the current value as a <code>long</code>
  after a narrowing primitive conversion.
 */
- (jlong)longLongValue;

/*!
 @brief Resets variables maintaining updates to the identity value.
 This method may be a useful alternative to creating a new
  updater, but is only effective if there are no concurrent
  updates.  Because this method is intrinsically racy, it should
  only be used when it is known that no threads are concurrently
  updating.
 */
- (void)reset;

/*!
 @brief Returns the String representation of the current value.
 @return the String representation of the current value
 */
- (NSString *)description;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initPackagePrivate NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentAtomicDoubleAccumulator)

FOUNDATION_EXPORT void JavaUtilConcurrentAtomicDoubleAccumulator_initWithJavaUtilFunctionDoubleBinaryOperator_withDouble_(JavaUtilConcurrentAtomicDoubleAccumulator *self, id<JavaUtilFunctionDoubleBinaryOperator> accumulatorFunction, jdouble identity);

FOUNDATION_EXPORT JavaUtilConcurrentAtomicDoubleAccumulator *new_JavaUtilConcurrentAtomicDoubleAccumulator_initWithJavaUtilFunctionDoubleBinaryOperator_withDouble_(id<JavaUtilFunctionDoubleBinaryOperator> accumulatorFunction, jdouble identity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentAtomicDoubleAccumulator *create_JavaUtilConcurrentAtomicDoubleAccumulator_initWithJavaUtilFunctionDoubleBinaryOperator_withDouble_(id<JavaUtilFunctionDoubleBinaryOperator> accumulatorFunction, jdouble identity);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentAtomicDoubleAccumulator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentAtomicDoubleAccumulator")
