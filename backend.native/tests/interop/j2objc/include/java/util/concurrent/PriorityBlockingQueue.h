//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/PriorityBlockingQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue")
#ifdef RESTRICT_JavaUtilConcurrentPriorityBlockingQueue
#define INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue 1
#endif
#undef RESTRICT_JavaUtilConcurrentPriorityBlockingQueue

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentPriorityBlockingQueue_) && (INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue || defined(INCLUDE_JavaUtilConcurrentPriorityBlockingQueue))
#define JavaUtilConcurrentPriorityBlockingQueue_

#define RESTRICT_JavaUtilAbstractQueue 1
#define INCLUDE_JavaUtilAbstractQueue 1
#include "java/util/AbstractQueue.h"

#define RESTRICT_JavaUtilConcurrentBlockingQueue 1
#define INCLUDE_JavaUtilConcurrentBlockingQueue 1
#include "java/util/concurrent/BlockingQueue.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

/*!
 @brief An unbounded blocking queue that uses
  the same ordering rules as class <code>PriorityQueue</code> and supplies
  blocking retrieval operations.While this queue is logically
  unbounded, attempted additions may fail due to resource exhaustion
  (causing <code>OutOfMemoryError</code>).
 This class does not permit 
 <code>null</code> elements.  A priority queue relying on natural ordering
  also does not permit insertion of
  non-comparable objects (doing so results in 
 <code>ClassCastException</code>).
  
 <p>This class and its iterator implement all of the 
 <em>optional</em> methods of the <code>Collection</code> and <code>Iterator</code>
  interfaces.  The Iterator provided in method <code>iterator()</code>
  is <em>not</em> guaranteed to traverse the elements of
  the PriorityBlockingQueue in any particular order. If you need
  ordered traversal, consider using 
 <code>Arrays.sort(pq.toArray())</code>.  Also, method <code>drainTo</code>
  can be used to <em>remove</em> some or all elements in priority
  order and place them in another collection. 
 <p>Operations on this class make no guarantees about the ordering
  of elements with equal priority. If you need to enforce an
  ordering, you can define custom classes or comparators that use a
  secondary key to break ties in primary priority values.  For
  example, here is a class that applies first-in-first-out
  tie-breaking to comparable elements. To use it, you would insert a 
 <code>new FIFOEntry(anEntry)</code> instead of a plain entry object. 
 @code
  class FIFOEntry<E extends Comparable<? super E>>
      implements Comparable<FIFOEntry<E>> {
    static final AtomicLong seq = new AtomicLong(0);
    final long seqNum;
    final E entry;
    public FIFOEntry(E entry) {
      seqNum = seq.getAndIncrement();
      this.entry = entry;
    }
    public E getEntry() { return entry; }
    public int compareTo(FIFOEntry<E> other) {
      int res = entry.compareTo(other.entry);
      if (res == 0 && other.entry != this.entry)
        res = (seqNum < other.seqNum ? -1 : 1);
      return res;
    }  }
 
@endcode
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentPriorityBlockingQueue : JavaUtilAbstractQueue < JavaUtilConcurrentBlockingQueue, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> with the default
  initial capacity (11) that orders its elements according to
  their natural ordering.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> containing the elements
  in the specified collection.If the specified collection is a 
 <code>SortedSet</code> or a <code>PriorityQueue</code>, this
  priority queue will be ordered according to the same ordering.
 Otherwise, this priority queue will be ordered according to the 
 natural ordering of its elements.
 @param c the collection whose elements are to be placed          into this priority queue
 @throw ClassCastExceptionif elements of the specified collection
          cannot be compared to one another according to the priority
          queue's ordering
 @throw NullPointerExceptionif the specified collection or any
          of its elements are null
 */
- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> with the specified
  initial capacity that orders its elements according to their 
 natural ordering.
 @param initialCapacity the initial capacity for this priority queue
 @throw IllegalArgumentExceptionif <code>initialCapacity</code> is less
          than 1
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity;

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> with the specified initial
  capacity that orders its elements according to the specified
  comparator.
 @param initialCapacity the initial capacity for this priority queue
 @param comparator the comparator that will be used to order this          priority queue.  If 
 <code>null</code> , the natural ordering
   of the elements will be used.
 @throw IllegalArgumentExceptionif <code>initialCapacity</code> is less
          than 1
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity
               withJavaUtilComparator:(id<JavaUtilComparator>)comparator;

/*!
 @brief Inserts the specified element into this priority queue.
 @param e the element to add
 @return <code>true</code> (as specified by <code>Collection.add</code>)
 @throw ClassCastExceptionif the specified element cannot be compared
          with elements currently in the priority queue according to the
          priority queue's ordering
 @throw NullPointerExceptionif the specified element is null
 */
- (jboolean)addWithId:(id)e;

/*!
 @brief Atomically removes all of the elements from this queue.
 The queue will be empty after this call returns.
 */
- (void)clear;

/*!
 @brief Returns the comparator used to order the elements in this queue,
  or <code>null</code> if this queue uses the natural ordering
  of its elements.
 @return the comparator used to order the elements in this queue,
          or <code>null</code> if this queue uses the natural
          ordering of its elements
 */
- (id<JavaUtilComparator>)comparator;

/*!
 @brief Returns <code>true</code> if this queue contains the specified element.
 More formally, returns <code>true</code> if and only if this queue contains
  at least one element <code>e</code> such that <code>o.equals(e)</code>.
 @param o object to be checked for containment in this queue
 @return <code>true</code> if this queue contains the specified element
 */
- (jboolean)containsWithId:(id)o;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 */
- (jint)drainToWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 */
- (jint)drainToWithJavaUtilCollection:(id<JavaUtilCollection>)c
                              withInt:(jint)maxElements;

/*!
 @brief Returns an iterator over the elements in this queue.The
  iterator does not return the elements in any particular order.
 <p>The returned iterator is 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
 @return an iterator over the elements in this queue
 */
- (id<JavaUtilIterator>)iterator;

/*!
 @brief Inserts the specified element into this priority queue.
 As the queue is unbounded, this method will never return <code>false</code>.
 @param e the element to add
 @return <code>true</code> (as specified by <code>Queue.offer</code>)
 @throw ClassCastExceptionif the specified element cannot be compared
          with elements currently in the priority queue according to the
          priority queue's ordering
 @throw NullPointerExceptionif the specified element is null
 */
- (jboolean)offerWithId:(id)e;

/*!
 @brief Inserts the specified element into this priority queue.
 As the queue is unbounded, this method will never block or
  return <code>false</code>.
 @param e the element to add
 @param timeout This parameter is ignored as the method never blocks
 @param unit This parameter is ignored as the method never blocks
 @return <code>true</code> (as specified by
   <code>BlockingQueue.offer</code>)
 @throw ClassCastExceptionif the specified element cannot be compared
          with elements currently in the priority queue according to the
          priority queue's ordering
 @throw NullPointerExceptionif the specified element is null
 */
- (jboolean)offerWithId:(id)e
               withLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id)peek;

- (id)poll;

- (id)pollWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Inserts the specified element into this priority queue.
 As the queue is unbounded, this method will never block.
 @param e the element to add
 @throw ClassCastExceptionif the specified element cannot be compared
          with elements currently in the priority queue according to the
          priority queue's ordering
 @throw NullPointerExceptionif the specified element is null
 */
- (void)putWithId:(id)e;

/*!
 @brief Always returns <code>Integer.MAX_VALUE</code> because
  a <code>PriorityBlockingQueue</code> is not capacity constrained.
 @return <code>Integer.MAX_VALUE</code> always
 */
- (jint)remainingCapacity;

/*!
 @brief Removes a single instance of the specified element from this queue,
  if it is present.More formally, removes an element <code>e</code> such
  that <code>o.equals(e)</code>, if this queue contains one or more such
  elements.
 Returns <code>true</code> if and only if this queue contained
  the specified element (or equivalently, if this queue changed as a
  result of the call).
 @param o element to be removed from this queue, if present
 @return <code>true</code> if this queue changed as a result of the call
 */
- (jboolean)removeWithId:(id)o;

- (jint)size;

/*!
 @brief Returns a <code>Spliterator</code> over the elements in this queue.
 <p>The returned spliterator is 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>The <code>Spliterator</code> reports <code>Spliterator.SIZED</code> and 
 <code>Spliterator.NONNULL</code>.
 @return a <code>Spliterator</code> over the elements in this queue
 @since 1.8
 */
- (id<JavaUtilSpliterator>)spliterator;

- (id)take;

/*!
 @brief Returns an array containing all of the elements in this queue.
 The returned array elements are in no particular order. 
 <p>The returned array will be "safe" in that no references to it are
  maintained by this queue.  (In other words, this method must allocate
  a new array).  The caller is thus free to modify the returned array. 
 <p>This method acts as bridge between array-based and collection-based
  APIs.
 @return an array containing all of the elements in this queue
 */
- (IOSObjectArray *)toArray;

/*!
 @brief Returns an array containing all of the elements in this queue; the
  runtime type of the returned array is that of the specified array.
 The returned array elements are in no particular order.
  If the queue fits in the specified array, it is returned therein.
  Otherwise, a new array is allocated with the runtime type of the
  specified array and the size of this queue. 
 <p>If this queue fits in the specified array with room to spare
  (i.e., the array has more elements than this queue), the element in
  the array immediately following the end of the queue is set to 
 <code>null</code>.
  
 <p>Like the <code>toArray()</code> method, this method acts as bridge between
  array-based and collection-based APIs.  Further, this method allows
  precise control over the runtime type of the output array, and may,
  under certain circumstances, be used to save allocation costs. 
 <p>Suppose <code>x</code> is a queue known to contain only strings.
  The following code can be used to dump the queue into a newly
  allocated array of <code>String</code>:
  
 @code
 String[] y = x.toArray(new String[0]);
@endcode
  Note that <code>toArray(new Object[0])</code> is identical in function to 
 <code>toArray()</code>.
 @param a the array into which the elements of the queue are to           be stored, if it is big enough; otherwise, a new array of the
            same runtime type is allocated for this purpose
 @return an array containing all of the elements in this queue
 @throw ArrayStoreExceptionif the runtime type of the specified array
          is not a supertype of the runtime type of every element in
          this queue
 @throw NullPointerExceptionif the specified array is null
 */
- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Identity-based version for use in Itr.remove.
 */
- (void)removeEQWithId:(id)o;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentPriorityBlockingQueue)

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_init(JavaUtilConcurrentPriorityBlockingQueue *self);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *create_JavaUtilConcurrentPriorityBlockingQueue_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_initWithInt_(JavaUtilConcurrentPriorityBlockingQueue *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *create_JavaUtilConcurrentPriorityBlockingQueue_initWithInt_(jint initialCapacity);

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_initWithInt_withJavaUtilComparator_(JavaUtilConcurrentPriorityBlockingQueue *self, jint initialCapacity, id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_initWithInt_withJavaUtilComparator_(jint initialCapacity, id<JavaUtilComparator> comparator) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *create_JavaUtilConcurrentPriorityBlockingQueue_initWithInt_withJavaUtilComparator_(jint initialCapacity, id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_initWithJavaUtilCollection_(JavaUtilConcurrentPriorityBlockingQueue *self, id<JavaUtilCollection> c);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_initWithJavaUtilCollection_(id<JavaUtilCollection> c) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *create_JavaUtilConcurrentPriorityBlockingQueue_initWithJavaUtilCollection_(id<JavaUtilCollection> c);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentPriorityBlockingQueue)

#endif

#if !defined (JavaUtilConcurrentPriorityBlockingQueue_Itr_) && (INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue || defined(INCLUDE_JavaUtilConcurrentPriorityBlockingQueue_Itr))
#define JavaUtilConcurrentPriorityBlockingQueue_Itr_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

@class IOSObjectArray;
@class JavaUtilConcurrentPriorityBlockingQueue;
@protocol JavaUtilFunctionConsumer;

/*!
 @brief Snapshot iterator that works off copy of underlying q array.
 */
@interface JavaUtilConcurrentPriorityBlockingQueue_Itr : NSObject < JavaUtilIterator > {
 @public
  IOSObjectArray *array_;
  jint cursor_;
  jint lastRet_;
}

#pragma mark Public

- (jboolean)hasNext;

- (id)next;

- (void)remove;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentPriorityBlockingQueue:(JavaUtilConcurrentPriorityBlockingQueue *)outer$
                                                        withNSObjectArray:(IOSObjectArray *)array;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentPriorityBlockingQueue_Itr)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentPriorityBlockingQueue_Itr, array_, IOSObjectArray *)

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_Itr_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_(JavaUtilConcurrentPriorityBlockingQueue_Itr *self, JavaUtilConcurrentPriorityBlockingQueue *outer$, IOSObjectArray *array);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue_Itr *new_JavaUtilConcurrentPriorityBlockingQueue_Itr_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_(JavaUtilConcurrentPriorityBlockingQueue *outer$, IOSObjectArray *array) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue_Itr *create_JavaUtilConcurrentPriorityBlockingQueue_Itr_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_(JavaUtilConcurrentPriorityBlockingQueue *outer$, IOSObjectArray *array);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentPriorityBlockingQueue_Itr)

#endif

#if !defined (JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue || defined(INCLUDE_JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator))
#define JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class IOSObjectArray;
@class JavaUtilConcurrentPriorityBlockingQueue;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator : NSObject < JavaUtilSpliterator > {
 @public
  JavaUtilConcurrentPriorityBlockingQueue *queue_;
  IOSObjectArray *array_;
  jint index_;
  jint fence_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentPriorityBlockingQueue:(JavaUtilConcurrentPriorityBlockingQueue *)queue
                                                        withNSObjectArray:(IOSObjectArray *)array
                                                                  withInt:(jint)index
                                                                  withInt:(jint)fence;

- (jint)getFence;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator, queue_, JavaUtilConcurrentPriorityBlockingQueue *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator, array_, IOSObjectArray *)

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_withInt_withInt_(JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator *self, JavaUtilConcurrentPriorityBlockingQueue *queue, IOSObjectArray *array, jint index, jint fence);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator *new_JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_withInt_withInt_(JavaUtilConcurrentPriorityBlockingQueue *queue, IOSObjectArray *array, jint index, jint fence) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator *create_JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_withInt_withInt_(JavaUtilConcurrentPriorityBlockingQueue *queue, IOSObjectArray *array, jint index, jint fence);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentPriorityBlockingQueue_PBQSpliterator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentPriorityBlockingQueue")
