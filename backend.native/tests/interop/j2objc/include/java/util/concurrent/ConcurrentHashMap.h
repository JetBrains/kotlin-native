//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/ConcurrentHashMap.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap")
#ifdef RESTRICT_JavaUtilConcurrentConcurrentHashMap
#define INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap 1
#endif
#undef RESTRICT_JavaUtilConcurrentConcurrentHashMap
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchValuesTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchKeysTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachValueTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_EntrySetView
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_CollectionView 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ValuesView
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_CollectionView 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_KeySetView
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_CollectionView 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_EntrySpliterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Traverser 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ValueSpliterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Traverser 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_KeySpliterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Traverser 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_EntryIterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BaseIterator 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ValueIterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BaseIterator 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_KeyIterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_BaseIterator 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_BaseIterator
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Traverser 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_TreeBin
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Node 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_TreeNode
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Node 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReservationNode
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Node 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForwardingNode
#define INCLUDE_JavaUtilConcurrentConcurrentHashMap_Node 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap))
#define JavaUtilConcurrentConcurrentHashMap_

#define RESTRICT_JavaUtilAbstractMap 1
#define INCLUDE_JavaUtilAbstractMap 1
#include "java/util/AbstractMap.h"

#define RESTRICT_JavaUtilConcurrentConcurrentMap 1
#define INCLUDE_JavaUtilConcurrentConcurrentMap 1
#include "java/util/concurrent/ConcurrentMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_KeySetView;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@protocol JavaUtilCollection;
@protocol JavaUtilEnumeration;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionDoubleBinaryOperator;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionIntBinaryOperator;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilFunctionToDoubleBiFunction;
@protocol JavaUtilFunctionToDoubleFunction;
@protocol JavaUtilFunctionToIntBiFunction;
@protocol JavaUtilFunctionToIntFunction;
@protocol JavaUtilFunctionToLongBiFunction;
@protocol JavaUtilFunctionToLongFunction;
@protocol JavaUtilMap;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilSet;

/*!
 @brief A hash table supporting full concurrency of retrievals and
  high expected concurrency for updates.This class obeys the
  same functional specification as <code>java.util.Hashtable</code>, and
  includes versions of methods corresponding to each method of 
 <code>Hashtable</code>.
 However, even though all operations are
  thread-safe, retrieval operations do <em>not</em> entail locking,
  and there is <em>not</em> any support for locking the entire table
  in a way that prevents all access.  This class is fully
  interoperable with <code>Hashtable</code> in programs that rely on its
  thread safety but not on its synchronization details. 
 <p>Retrieval operations (including <code>get</code>) generally do not
  block, so may overlap with update operations (including <code>put</code>
  and <code>remove</code>). Retrievals reflect the results of the most
  recently <em>completed</em> update operations holding upon their
  onset. (More formally, an update operation for a given key bears a 
 <em>happens-before</em> relation with any (non-null) retrieval for
  that key reporting the updated value.)  For aggregate operations
  such as <code>putAll</code> and <code>clear</code>, concurrent retrievals may
  reflect insertion or removal of only some entries.  Similarly,
  Iterators, Spliterators and Enumerations return elements reflecting the
  state of the hash table at some point at or since the creation of the
  iterator/enumeration.  They do <em>not</em> throw <code>ConcurrentModificationException</code>
 .
  However, iterators are designed to be used by only one thread at a time.
  Bear in mind that the results of aggregate status methods including 
 <code>size</code>, <code>isEmpty</code>, and <code>containsValue</code> are typically
  useful only when a map is not undergoing concurrent updates in other threads.
  Otherwise the results of these methods reflect transient states
  that may be adequate for monitoring or estimation purposes, but not
  for program control. 
 <p>The table is dynamically expanded when there are too many
  collisions (i.e., keys that have distinct hash codes but fall into
  the same slot modulo the table size), with the expected average
  effect of maintaining roughly two bins per mapping (corresponding
  to a 0.75 load factor threshold for resizing). There may be much
  variance around this average as mappings are added and removed, but
  overall, this maintains a commonly accepted time/space tradeoff for
  hash tables.  However, resizing this or any other kind of hash
  table may be a relatively slow operation. When possible, it is a
  good idea to provide a size estimate as an optional <code>initialCapacity</code>
  constructor argument. An additional optional 
 <code>loadFactor</code> constructor argument provides a further means of
  customizing initial table capacity by specifying the table density
  to be used in calculating the amount of space to allocate for the
  given number of elements.  Also, for compatibility with previous
  versions of this class, constructors may optionally specify an
  expected <code>concurrencyLevel</code> as an additional hint for
  internal sizing.  Note that using many keys with exactly the same 
 <code>hashCode()</code> is a sure way to slow down performance of any
  hash table. To ameliorate impact, when keys are <code>Comparable</code>,
  this class may use comparison order among keys to help break ties. 
 <p>A <code>Set</code> projection of a ConcurrentHashMap may be created
  (using <code>newKeySet()</code> or <code>newKeySet(int)</code>), or viewed
  (using <code>keySet(Object)</code> when only keys are of interest, and the
  mapped values are (perhaps transiently) not used or all take the
  same mapping value. 
 <p>A ConcurrentHashMap can be used as a scalable frequency map (a
  form of histogram or multiset) by using <code>java.util.concurrent.atomic.LongAdder</code>
  values and initializing via 
 <code>computeIfAbsent</code>. For example, to add a count
  to a <code>ConcurrentHashMap<String,LongAdder> freqs</code>, you can use 
 <code>freqs.computeIfAbsent(key, k -> new LongAdder()).increment();</code>
  
 <p>This class and its views and iterators implement all of the 
 <em>optional</em> methods of the <code>Map</code> and <code>Iterator</code>
  interfaces. 
 <p>Like <code>Hashtable</code> but unlike <code>HashMap</code>, this class
  does <em>not</em> allow <code>null</code> to be used as a key or value. 
 <p>ConcurrentHashMaps support a set of sequential and parallel bulk
  operations that, unlike most <code>Stream</code> methods, are designed
  to be safely, and often sensibly, applied even with maps that are
  being concurrently updated by other threads; for example, when
  computing a snapshot summary of the values in a shared registry.
  There are three kinds of operation, each with four forms, accepting
  functions with keys, values, entries, and (key, value) pairs as
  arguments and/or return values. Because the elements of a
  ConcurrentHashMap are not ordered in any particular way, and may be
  processed in different orders in different parallel executions, the
  correctness of supplied functions should not depend on any
  ordering, or on any other objects or values that may transiently
  change while computation is in progress; and except for forEach
  actions, should ideally be side-effect-free. Bulk operations on 
 <code>java.util.Map.Entry</code> objects do not support method <code>setValue</code>
 .
  
 <ul>
  <li>forEach: Performs a given action on each element.
  A variant form applies a given transformation on each element
  before performing the action. 
 <li>search: Returns the first available non-null result of
  applying a given function on each element; skipping further
  search when a result is found. 
 <li>reduce: Accumulates each element.  The supplied reduction
  function cannot rely on ordering (more formally, it should be
  both associative and commutative).  There are five variants: 
 <ul>
  
 <li>Plain reductions. (There is not a form of this method for
  (key, value) function arguments since there is no corresponding
  return type.) 
 <li>Mapped reductions that accumulate the results of a given
  function applied to each element. 
 <li>Reductions to scalar doubles, longs, and ints, using a
  given basis value. 
 </ul>
  </ul>
  
 <p>These bulk operations accept a <code>parallelismThreshold</code>
  argument. Methods proceed sequentially if the current map size is
  estimated to be less than the given threshold. Using a value of 
 <code>Long.MAX_VALUE</code> suppresses all parallelism.  Using a value
  of <code>1</code> results in maximal parallelism by partitioning into
  enough subtasks to fully utilize the <code>ForkJoinPool.commonPool()</code>
  that is used for all parallel
  computations. Normally, you would initially choose one of these
  extreme values, and then measure performance of using in-between
  values that trade off overhead versus throughput. 
 <p>The concurrency properties of bulk operations follow
  from those of ConcurrentHashMap: Any non-null result returned from 
 <code>get(key)</code> and related access methods bears a
  happens-before relation with the associated insertion or
  update.  The result of any bulk operation reflects the
  composition of these per-element relations (but is not
  necessarily atomic with respect to the map as a whole unless it
  is somehow known to be quiescent).  Conversely, because keys
  and values in the map are never null, null serves as a reliable
  atomic indicator of the current lack of any result.  To
  maintain this property, null serves as an implicit basis for
  all non-scalar reduction operations. For the double, long, and
  int versions, the basis should be one that, when combined with
  any other value, returns that other value (more formally, it
  should be the identity element for the reduction). Most common
  reductions have these properties; for example, computing a sum
  with basis 0 or a minimum with basis MAX_VALUE. 
 <p>Search and transformation functions provided as arguments
  should similarly return null to indicate the lack of any result
  (in which case it is not used). In the case of mapped
  reductions, this also enables transformations to serve as
  filters, returning null (or, in the case of primitive
  specializations, the identity basis) if the element should not
  be combined. You can create compound transformations and
  filterings by composing them yourself under this "null means
  there is nothing there now" rule before using them in search or
  reduce operations. 
 <p>Methods accepting and/or returning Entry arguments maintain
  key-value associations. They may be useful for example when
  finding the key for the greatest value. Note that "plain" Entry
  arguments can be supplied using <code>new
  AbstractMap.SimpleEntry(k,v)</code>
 .
  
 <p>Bulk operations may complete abruptly, throwing an
  exception encountered in the application of a supplied
  function. Bear in mind when handling such exceptions that other
  concurrently executing functions could also have thrown
  exceptions, or would have done so if the first exception had
  not occurred. 
 <p>Speedups for parallel compared to sequential forms are common
  but not guaranteed.  Parallel operations involving brief functions
  on small maps may execute more slowly than sequential forms if the
  underlying work to parallelize the computation is more expensive
  than the computation itself.  Similarly, parallelization may not
  lead to much actual parallelism if all processors are busy
  performing unrelated tasks. 
 <p>All arguments to all task methods must be non-null.
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentConcurrentHashMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentMap, JavaIoSerializable > {
 @public
  /*!
   @brief The array of bins.Lazily initialized upon first insertion.
   Size is always a power of two. Accessed directly by iterators.
   */
  volatile_id table_;
}
@property (readonly, class) jint MAX_ARRAY_SIZE NS_SWIFT_NAME(MAX_ARRAY_SIZE);
@property (readonly, class) jint TREEIFY_THRESHOLD NS_SWIFT_NAME(TREEIFY_THRESHOLD);
@property (readonly, class) jint UNTREEIFY_THRESHOLD NS_SWIFT_NAME(UNTREEIFY_THRESHOLD);
@property (readonly, class) jint MIN_TREEIFY_CAPACITY NS_SWIFT_NAME(MIN_TREEIFY_CAPACITY);
@property (readonly, class) jint MOVED NS_SWIFT_NAME(MOVED);
@property (readonly, class) jint TREEBIN NS_SWIFT_NAME(TREEBIN);
@property (readonly, class) jint RESERVED NS_SWIFT_NAME(RESERVED);
@property (readonly, class) jint HASH_BITS NS_SWIFT_NAME(HASH_BITS);
@property (readonly, class) jint NCPU NS_SWIFT_NAME(NCPU);

+ (jint)MAX_ARRAY_SIZE;

+ (jint)TREEIFY_THRESHOLD;

+ (jint)UNTREEIFY_THRESHOLD;

+ (jint)MIN_TREEIFY_CAPACITY;

+ (jint)MOVED;

+ (jint)TREEBIN;

+ (jint)RESERVED;

+ (jint)HASH_BITS;

+ (jint)NCPU;

#pragma mark Public

/*!
 @brief Creates a new, empty map with the default initial table size (16).
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a new, empty map with an initial table size
  accommodating the specified number of elements without the need
  to dynamically resize.
 @param initialCapacity The implementation performs internal  sizing to accommodate this many elements.
 @throw IllegalArgumentExceptionif the initial capacity of
  elements is negative
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity;

/*!
 @brief Creates a new, empty map with an initial table size based on
  the given number of elements (<code>initialCapacity</code>) and
  initial table density (<code>loadFactor</code>).
 @param initialCapacity the initial capacity. The implementation  performs internal sizing to accommodate this many elements,
   given the specified load factor.
 @param loadFactor the load factor (table density) for  establishing the initial table size
 @throw IllegalArgumentExceptionif the initial capacity of
  elements is negative or the load factor is nonpositive
 @since 1.6
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity
                            withFloat:(jfloat)loadFactor;

/*!
 @brief Creates a new, empty map with an initial table size based on
  the given number of elements (<code>initialCapacity</code>), table
  density (<code>loadFactor</code>), and number of concurrently
  updating threads (<code>concurrencyLevel</code>).
 @param initialCapacity the initial capacity. The implementation  performs internal sizing to accommodate this many elements,
   given the specified load factor.
 @param loadFactor the load factor (table density) for  establishing the initial table size
 @param concurrencyLevel the estimated number of concurrently  updating threads. The implementation may use this value as
   a sizing hint.
 @throw IllegalArgumentExceptionif the initial capacity is
  negative or the load factor or concurrencyLevel are
  nonpositive
 */
- (instancetype __nonnull)initWithInt:(jint)initialCapacity
                            withFloat:(jfloat)loadFactor
                              withInt:(jint)concurrencyLevel;

/*!
 @brief Creates a new map with the same mappings as the given map.
 @param m the map
 */
- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Removes all of the mappings from this map.
 */
- (void)clear;

/*!
 @brief Attempts to compute a mapping for the specified key and its
  current mapped value (or <code>null</code> if there is no current
  mapping).The entire method invocation is performed atomically.
 Some attempted update operations on this map by other threads
  may be blocked while computation is in progress, so the
  computation should be short and simple, and must not attempt to
  update any other mappings of this Map.
 @param key key with which the specified value is to be associated
 @param remappingFunction the function to compute a value
 @return the new value associated with the specified key, or null if none
 @throw NullPointerExceptionif the specified key or remappingFunction
          is null
 @throw IllegalStateExceptionif the computation detectably
          attempts a recursive update to this map that would
          otherwise never complete
 @throw RuntimeExceptionor Error if the remappingFunction does so,
          in which case the mapping is unchanged
 */
- (id __nullable)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief If the specified key is not already associated with a value,
  attempts to compute its value using the given mapping function
  and enters it into this map unless <code>null</code>.The entire
  method invocation is performed atomically, so the function is
  applied at most once per key.
 Some attempted update operations
  on this map by other threads may be blocked while computation
  is in progress, so the computation should be short and simple,
  and must not attempt to update any other mappings of this map.
 @param key key with which the specified value is to be associated
 @param mappingFunction the function to compute a value
 @return the current (existing or computed) value associated with
          the specified key, or null if the computed value is null
 @throw NullPointerExceptionif the specified key or mappingFunction
          is null
 @throw IllegalStateExceptionif the computation detectably
          attempts a recursive update to this map that would
          otherwise never complete
 @throw RuntimeExceptionor Error if the mappingFunction does so,
          in which case the mapping is left unestablished
 */
- (id __nullable)computeIfAbsentWithId:(id)key
          withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

/*!
 @brief If the value for the specified key is present, attempts to
  compute a new mapping given the key and its current mapped
  value.The entire method invocation is performed atomically.
 Some attempted update operations on this map by other threads
  may be blocked while computation is in progress, so the
  computation should be short and simple, and must not attempt to
  update any other mappings of this map.
 @param key key with which a value may be associated
 @param remappingFunction the function to compute a value
 @return the new value associated with the specified key, or null if none
 @throw NullPointerExceptionif the specified key or remappingFunction
          is null
 @throw IllegalStateExceptionif the computation detectably
          attempts a recursive update to this map that would
          otherwise never complete
 @throw RuntimeExceptionor Error if the remappingFunction does so,
          in which case the mapping is unchanged
 */
- (id __nullable)computeIfPresentWithId:(id)key
         withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief Tests if some key maps into the specified value in this table.
 <p>Note that this method is identical in functionality to 
 <code>containsValue(Object)</code>, and exists solely to ensure
  full compatibility with class <code>java.util.Hashtable</code>,
  which supported this method prior to introduction of the
  Java Collections Framework.
 @param value a value to search for
 @return <code>true</code> if and only if some key maps to the
          <code>value</code> argument in this table as
          determined by the <code>equals</code> method;
          <code>false</code> otherwise
 @throw NullPointerExceptionif the specified value is null
 */
- (jboolean)containsWithId:(id)value;

/*!
 @brief Tests if the specified object is a key in this table.
 @param key possible key
 @return <code>true</code> if and only if the specified object
          is a key in this table, as determined by the         
 <code>equals</code> method; <code>false</code> otherwise
 @throw NullPointerExceptionif the specified key is null
 */
- (jboolean)containsKeyWithId:(id)key;

/*!
 @brief Returns <code>true</code> if this map maps one or more keys to the
  specified value.Note: This method may require a full traversal
  of the map, and is much slower than method <code>containsKey</code>.
 @param value value whose presence in this map is to be tested
 @return <code>true</code> if this map maps one or more keys to the
          specified value
 @throw NullPointerExceptionif the specified value is null
 */
- (jboolean)containsValueWithId:(id)value;

/*!
 @brief Returns an enumeration of the values in this table.
 @return an enumeration of the values in this table
 - seealso: #values()
 */
- (id<JavaUtilEnumeration> __nonnull)elements;

/*!
 @brief Returns a <code>Set</code> view of the mappings contained in this map.
 The set is backed by the map, so changes to the map are
  reflected in the set, and vice-versa.  The set supports element
  removal, which removes the corresponding mapping from the map,
  via the <code>Iterator.remove</code>, <code>Set.remove</code>,
  <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>
  operations. 
 <p>The view's iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>The view's <code>spliterator</code> reports <code>Spliterator.CONCURRENT</code>,
  <code>Spliterator.DISTINCT</code>, and <code>Spliterator.NONNULL</code>.
 @return the set view
 */
- (id<JavaUtilSet> __nonnull)entrySet;

/*!
 @brief Compares the specified object with this map for equality.
 Returns <code>true</code> if the given object is a map with the same
  mappings as this map.  This operation may return misleading
  results if either map is concurrently modified during execution
  of this method.
 @param o object to be compared for equality with this map
 @return <code>true</code> if the specified object is equal to this map
 */
- (jboolean)isEqual:(id)o;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief Performs the given action for each (key, value).
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param action the action
 @since 1.8
 */
- (void)forEachWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief Performs the given action for each non-null transformation
  of each (key, value).
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case the action is not applied)
 @param action the action
 @since 1.8
 */
- (void)forEachWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)transformer
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Performs the given action for each entry.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param action the action
 @since 1.8
 */
- (void)forEachEntryWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Performs the given action for each non-null transformation
  of each entry.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case the action is not applied)
 @param action the action
 @since 1.8
 */
- (void)forEachEntryWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Performs the given action for each key.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param action the action
 @since 1.8
 */
- (void)forEachKeyWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Performs the given action for each non-null transformation
  of each key.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case the action is not applied)
 @param action the action
 @since 1.8
 */
- (void)forEachKeyWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Performs the given action for each value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param action the action
 @since 1.8
 */
- (void)forEachValueWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Performs the given action for each non-null transformation
  of each value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case the action is not applied)
 @param action the action
 @since 1.8
 */
- (void)forEachValueWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Returns the value to which the specified key is mapped,
  or <code>null</code> if this map contains no mapping for the key.
 <p>More formally, if this map contains a mapping from a key 
 <code>k</code> to a value <code>v</code> such that <code>key.equals(k)</code>,
  then this method returns <code>v</code>; otherwise it returns 
 <code>null</code>.  (There can be at most one such mapping.)
 @throw NullPointerExceptionif the specified key is null
 */
- (id __nullable)getWithId:(id)key;

/*!
 @brief Returns the value to which the specified key is mapped, or the
  given default value if this map contains no mapping for the
  key.
 @param key the key whose associated value is to be returned
 @param defaultValue the value to return if this map contains  no mapping for the given key
 @return the mapping for the key, if present; else the default value
 @throw NullPointerExceptionif the specified key is null
 */
- (id __nullable)getOrDefaultWithId:(id)key
                             withId:(id)defaultValue;

/*!
 @brief Returns the hash code value for this <code>Map</code>, i.e.,
  the sum of, for each key-value pair in the map, 
 <code>key.hashCode() ^ value.hashCode()</code>.
 @return the hash code value for this map
 */
- (NSUInteger)hash;

/*!
 */
- (jboolean)isEmpty;

/*!
 @brief Returns an enumeration of the keys in this table.
 @return an enumeration of the keys in this table
 - seealso: #keySet()
 */
- (id<JavaUtilEnumeration> __nonnull)keys;

/*!
 @brief Returns a <code>Set</code> view of the keys contained in this map.
 The set is backed by the map, so changes to the map are
  reflected in the set, and vice-versa. The set supports element
  removal, which removes the corresponding mapping from this map,
  via the <code>Iterator.remove</code>, <code>Set.remove</code>,
  <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>
  operations.  It does not support the <code>add</code> or 
 <code>addAll</code> operations. 
 <p> The set returned by this method is guaranteed to an instance of 
 <code>KeySetView</code>.
  
 <p>The view's iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>The view's <code>spliterator</code> reports <code>Spliterator.CONCURRENT</code>,
  <code>Spliterator.DISTINCT</code>, and <code>Spliterator.NONNULL</code>.
 @return the set view
 */
- (id<JavaUtilSet> __nonnull)keySet;

/*!
 @brief Returns a <code>Set</code> view of the keys in this map, using the
  given common mapped value for any additions (i.e., <code>Collection.add</code>
  and <code>Collection.addAll(Collection)</code>).
 This is of course only appropriate if it is acceptable to use
  the same value for all additions from this view.
 @param mappedValue the mapped value to use for any additions
 @return the set view
 @throw NullPointerExceptionif the mappedValue is null
 */
- (JavaUtilConcurrentConcurrentHashMap_KeySetView * __nonnull)keySetWithId:(id)mappedValue;

/*!
 @brief Returns the number of mappings.This method should be used
  instead of <code>size</code> because a ConcurrentHashMap may
  contain more mappings than can be represented as an int.
 The
  value returned is an estimate; the actual count may differ if
  there are concurrent insertions or removals.
 @return the number of mappings
 @since 1.8
 */
- (jlong)mappingCount;

/*!
 @brief If the specified key is not already associated with a
  (non-null) value, associates it with the given value.
 Otherwise, replaces the value with the results of the given
  remapping function, or removes if <code>null</code>. The entire
  method invocation is performed atomically.  Some attempted
  update operations on this map by other threads may be blocked
  while computation is in progress, so the computation should be
  short and simple, and must not attempt to update any other
  mappings of this Map.
 @param key key with which the specified value is to be associated
 @param value the value to use if absent
 @param remappingFunction the function to recompute a value if present
 @return the new value associated with the specified key, or null if none
 @throw NullPointerExceptionif the specified key or the
          remappingFunction is null
 @throw RuntimeExceptionor Error if the remappingFunction does so,
          in which case the mapping is unchanged
 */
- (id __nullable)mergeWithId:(id)key
                      withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief Creates a new <code>Set</code> backed by a ConcurrentHashMap
  from the given type to <code>Boolean.TRUE</code>.
 @return the new set
 @since 1.8
 */
+ (JavaUtilConcurrentConcurrentHashMap_KeySetView * __nonnull)newKeySet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new <code>Set</code> backed by a ConcurrentHashMap
  from the given type to <code>Boolean.TRUE</code>.
 @param initialCapacity The implementation performs internal  sizing to accommodate this many elements.
 @return the new set
 @throw IllegalArgumentExceptionif the initial capacity of
  elements is negative
 @since 1.8
 */
+ (JavaUtilConcurrentConcurrentHashMap_KeySetView * __nonnull)newKeySetWithInt:(jint)initialCapacity OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Maps the specified key to the specified value in this table.
 Neither the key nor the value can be null. 
 <p>The value can be retrieved by calling the <code>get</code> method
  with a key that is equal to the original key.
 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with <code>key</code>, or
          <code>null</code> if there was no mapping for <code>key</code>
 @throw NullPointerExceptionif the specified key or value is null
 */
- (id __nullable)putWithId:(id)key
                    withId:(id)value;

/*!
 @brief Copies all of the mappings from the specified map to this one.
 These mappings replace any mappings that this map had for any of the
  keys currently in the specified map.
 @param m mappings to be stored in this map
 */
- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @return the previous value associated with the specified key,
          or <code>null</code> if there was no mapping for the key
 @throw NullPointerExceptionif the specified key or value is null
 */
- (id __nullable)putIfAbsentWithId:(id)key
                            withId:(id)value;

/*!
 @brief Returns the result of accumulating the given transformation
  of all (key, value) pairs using the given reducer to
  combine values, or null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case it is not combined)
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all (key, value) pairs
 @since 1.8
 */
- (id __nullable)reduceWithLong:(jlong)parallelismThreshold
 withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)transformer
 withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating all entries using the
  given reducer to combine values, or null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param reducer a commutative associative combining function
 @return the result of accumulating all entries
 @since 1.8
 */
- (id<JavaUtilMap_Entry> __nullable)reduceEntriesWithLong:(jlong)parallelismThreshold
                           withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all entries using the given reducer to combine values,
  or null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case it is not combined)
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all entries
 @since 1.8
 */
- (id __nullable)reduceEntriesWithLong:(jlong)parallelismThreshold
          withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
        withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all entries using the given reducer to combine values,
  and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all entries
 @since 1.8
 */
- (jdouble)reduceEntriesToDoubleWithLong:(jlong)parallelismThreshold
    withJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)transformer
                              withDouble:(jdouble)basis
withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all entries using the given reducer to combine values,
  and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all entries
 @since 1.8
 */
- (jint)reduceEntriesToIntWithLong:(jlong)parallelismThreshold
 withJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)transformer
                           withInt:(jint)basis
withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all entries using the given reducer to combine values,
  and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all entries
 @since 1.8
 */
- (jlong)reduceEntriesToLongWithLong:(jlong)parallelismThreshold
  withJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)transformer
                            withLong:(jlong)basis
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating all keys using the given
  reducer to combine values, or null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param reducer a commutative associative combining function
 @return the result of accumulating all keys using the given
  reducer to combine values, or null if none
 @since 1.8
 */
- (id __nullable)reduceKeysWithLong:(jlong)parallelismThreshold
     withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all keys using the given reducer to combine values, or
  null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case it is not combined)
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all keys
 @since 1.8
 */
- (id __nullable)reduceKeysWithLong:(jlong)parallelismThreshold
       withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
     withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all keys using the given reducer to combine values, and
  the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all keys
 @since 1.8
 */
- (jdouble)reduceKeysToDoubleWithLong:(jlong)parallelismThreshold
 withJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)transformer
                           withDouble:(jdouble)basis
withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all keys using the given reducer to combine values, and
  the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all keys
 @since 1.8
 */
- (jint)reduceKeysToIntWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)transformer
                        withInt:(jint)basis
withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all keys using the given reducer to combine values, and
  the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all keys
 @since 1.8
 */
- (jlong)reduceKeysToLongWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)transformer
                         withLong:(jlong)basis
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all (key, value) pairs using the given reducer to
  combine values, and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all (key, value) pairs
 @since 1.8
 */
- (jdouble)reduceToDoubleWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionToDoubleBiFunction:(id<JavaUtilFunctionToDoubleBiFunction>)transformer
                       withDouble:(jdouble)basis
withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all (key, value) pairs using the given reducer to
  combine values, and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all (key, value) pairs
 @since 1.8
 */
- (jint)reduceToIntWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionToIntBiFunction:(id<JavaUtilFunctionToIntBiFunction>)transformer
                    withInt:(jint)basis
withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all (key, value) pairs using the given reducer to
  combine values, and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all (key, value) pairs
 @since 1.8
 */
- (jlong)reduceToLongWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionToLongBiFunction:(id<JavaUtilFunctionToLongBiFunction>)transformer
                     withLong:(jlong)basis
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating all values using the
  given reducer to combine values, or null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param reducer a commutative associative combining function
 @return the result of accumulating all values
 @since 1.8
 */
- (id __nullable)reduceValuesWithLong:(jlong)parallelismThreshold
       withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all values using the given reducer to combine values, or
  null if none.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element, or null if there is no transformation (in
   which case it is not combined)
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all values
 @since 1.8
 */
- (id __nullable)reduceValuesWithLong:(jlong)parallelismThreshold
         withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
       withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all values using the given reducer to combine values,
  and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all values
 @since 1.8
 */
- (jdouble)reduceValuesToDoubleWithLong:(jlong)parallelismThreshold
   withJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)transformer
                             withDouble:(jdouble)basis
withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all values using the given reducer to combine values,
  and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all values
 @since 1.8
 */
- (jint)reduceValuesToIntWithLong:(jlong)parallelismThreshold
withJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)transformer
                          withInt:(jint)basis
withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

/*!
 @brief Returns the result of accumulating the given transformation
  of all values using the given reducer to combine values,
  and the given basis as an identity value.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param transformer a function returning the transformation  for an element
 @param basis the identity (initial default value) for the reduction
 @param reducer a commutative associative combining function
 @return the result of accumulating the given transformation
  of all values
 @since 1.8
 */
- (jlong)reduceValuesToLongWithLong:(jlong)parallelismThreshold
 withJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)transformer
                           withLong:(jlong)basis
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

/*!
 @brief Removes the key (and its corresponding value) from this map.
 This method does nothing if the key is not in the map.
 @param key the key that needs to be removed
 @return the previous value associated with <code>key</code>, or
          <code>null</code> if there was no mapping for <code>key</code>
 @throw NullPointerExceptionif the specified key is null
 */
- (id __nullable)removeWithId:(id)key;

/*!
 @throw NullPointerExceptionif the specified key is null
 */
- (jboolean)removeWithId:(id)key
                  withId:(id)value;

/*!
 @return the previous value associated with the specified key,
          or <code>null</code> if there was no mapping for the key
 @throw NullPointerExceptionif the specified key or value is null
 */
- (id __nullable)replaceWithId:(id)key
                        withId:(id)value;

/*!
 @throw NullPointerExceptionif any of the arguments are null
 */
- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

/*!
 @brief Returns a non-null result from applying the given search
  function on each (key, value), or null if none.Upon
  success, further element processing is suppressed and the
  results of any other parallel invocations of the search
  function are ignored.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param searchFunction a function returning a non-null  result on success, else null
 @return a non-null result from applying the given search
  function on each (key, value), or null if none
 @since 1.8
 */
- (id __nullable)searchWithLong:(jlong)parallelismThreshold
 withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)searchFunction;

/*!
 @brief Returns a non-null result from applying the given search
  function on each entry, or null if none.Upon success,
  further element processing is suppressed and the results of
  any other parallel invocations of the search function are
  ignored.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param searchFunction a function returning a non-null  result on success, else null
 @return a non-null result from applying the given search
  function on each entry, or null if none
 @since 1.8
 */
- (id __nullable)searchEntriesWithLong:(jlong)parallelismThreshold
          withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)searchFunction;

/*!
 @brief Returns a non-null result from applying the given search
  function on each key, or null if none.Upon success,
  further element processing is suppressed and the results of
  any other parallel invocations of the search function are
  ignored.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param searchFunction a function returning a non-null  result on success, else null
 @return a non-null result from applying the given search
  function on each key, or null if none
 @since 1.8
 */
- (id __nullable)searchKeysWithLong:(jlong)parallelismThreshold
       withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)searchFunction;

/*!
 @brief Returns a non-null result from applying the given search
  function on each value, or null if none.Upon success,
  further element processing is suppressed and the results of
  any other parallel invocations of the search function are
  ignored.
 @param parallelismThreshold the (estimated) number of elements  needed for this operation to be executed in parallel
 @param searchFunction a function returning a non-null  result on success, else null
 @return a non-null result from applying the given search
  function on each value, or null if none
 @since 1.8
 */
- (id __nullable)searchValuesWithLong:(jlong)parallelismThreshold
         withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)searchFunction;

/*!
 */
- (jint)size;

/*!
 @brief Returns a string representation of this map.The string
  representation consists of a list of key-value mappings (in no
  particular order) enclosed in braces ("<code>{}</code>").
 Adjacent
  mappings are separated by the characters <code>", "</code> (comma
  and space).  Each key-value mapping is rendered as the key
  followed by an equals sign ("<code>=</code>") followed by the
  associated value.
 @return a string representation of this map
 */
- (NSString * __nonnull)description;

/*!
 @brief Returns a <code>Collection</code> view of the values contained in this map.
 The collection is backed by the map, so changes to the map are
  reflected in the collection, and vice-versa.  The collection
  supports element removal, which removes the corresponding
  mapping from this map, via the <code>Iterator.remove</code>,
  <code>Collection.remove</code>, <code>removeAll</code>,
  <code>retainAll</code>, and <code>clear</code> operations.  It does not
  support the <code>add</code> or <code>addAll</code> operations. 
 <p>The view's iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>The view's <code>spliterator</code> reports <code>Spliterator.CONCURRENT</code>
  and <code>Spliterator.NONNULL</code>.
 @return the collection view
 */
- (id<JavaUtilCollection> __nonnull)values;

#pragma mark Package-Private

/*!
 @brief Computes initial batch value for bulk tasks.The returned value
  is approximately exp2 of the number of times (minus one) to
  split task by two before executing leaf action.
 This value is
  faster to compute and more convenient to use as a guide to
  splitting than is the depth, since it is used while dividing by
  two anyway.
 */
- (jint)batchForWithLong:(jlong)b;

+ (jboolean)casTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)i
                         withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)c
                         withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)v;

/*!
 @brief Returns x's Class if it is of the form "class C implements
  Comparable<C>", else null.
 */
+ (IOSClass *)comparableClassForWithId:(id)x;

/*!
 @brief Returns k.compareTo(x) if x matches kc (k's screened comparable
  class), else 0.
 */
+ (jint)compareComparablesWithIOSClass:(IOSClass *)kc
                                withId:(id)k
                                withId:(id)x;

/*!
 @brief Helps transfer if a resize is in progress.
 */
- (IOSObjectArray *)helpTransferWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                     withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)f;

/*!
 @brief Implementation for put and putIfAbsent
 */
- (id)putValWithId:(id)key
            withId:(id)value
       withBoolean:(jboolean)onlyIfAbsent;

/*!
 @brief Helper method for EntrySetView.removeIf.
 */
- (jboolean)removeEntryIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)function;

/*!
 @brief Helper method for ValuesView.removeIf.
 */
- (jboolean)removeValueIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)function;

/*!
 @brief Implementation for the four public remove/replace methods:
  Replaces node value with v, conditional upon match of cv if
  non-null.If resulting value is null, delete.
 */
- (id)replaceNodeWithId:(id)key
                 withId:(id)value
                 withId:(id)cv;

/*!
 @brief Returns the stamp bits for resizing a table of size n.
 Must be negative when shifted left by RESIZE_STAMP_SHIFT.
 */
+ (jint)resizeStampWithInt:(jint)n;

+ (void)setTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                          withInt:(jint)i
                     withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)v;

/*!
 @brief Spreads (XORs) higher bits of hash to lower and also forces top
  bit to 0.Because the table uses power-of-two masking, sets of
  hashes that vary only in bits above the current mask will
  always collide.
 (Among known examples are sets of Float keys
  holding consecutive whole numbers in small tables.)  So we
  apply a transform that spreads the impact of higher bits
  downward. There is a tradeoff between speed, utility, and
  quality of bit-spreading. Because many common sets of hashes
  are already reasonably distributed (so don't benefit from
  spreading), and because we use trees to handle large sets of
  collisions in bins, we just XOR some shifted bits in the
  cheapest possible way to reduce systematic lossage, as well as
  to incorporate impact of the highest bits that would otherwise
  never be used in index calculations because of table bounds.
 */
+ (jint)spreadWithInt:(jint)h;

- (jlong)sumCount;

+ (JavaUtilConcurrentConcurrentHashMap_Node *)tabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                                             withInt:(jint)i;

/*!
 @brief Returns a list on non-TreeNodes replacing those in given list.
 */
+ (JavaUtilConcurrentConcurrentHashMap_Node *)untreeifyWithJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)b;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap, table_, IOSObjectArray *)

/*!
 @brief The largest possible (non-power of two) array size.
 Needed by toArray and related methods.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_MAX_ARRAY_SIZE(void);
#define JavaUtilConcurrentConcurrentHashMap_MAX_ARRAY_SIZE 2147483639
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, MAX_ARRAY_SIZE, jint)

/*!
 @brief The bin count threshold for using a tree rather than list for a
  bin.Bins are converted to trees when adding an element to a
  bin with at least this many nodes.
 The value must be greater
  than 2, and should be at least 8 to mesh with assumptions in
  tree removal about conversion back to plain bins upon
  shrinkage.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_TREEIFY_THRESHOLD(void);
#define JavaUtilConcurrentConcurrentHashMap_TREEIFY_THRESHOLD 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, TREEIFY_THRESHOLD, jint)

/*!
 @brief The bin count threshold for untreeifying a (split) bin during a
  resize operation.Should be less than TREEIFY_THRESHOLD, and at
  most 6 to mesh with shrinkage detection under removal.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_UNTREEIFY_THRESHOLD(void);
#define JavaUtilConcurrentConcurrentHashMap_UNTREEIFY_THRESHOLD 6
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, UNTREEIFY_THRESHOLD, jint)

/*!
 @brief The smallest table capacity for which bins may be treeified.
 (Otherwise the table is resized if too many nodes in a bin.)
  The value should be at least 4 * TREEIFY_THRESHOLD to avoid
  conflicts between resizing and treeification thresholds.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_MIN_TREEIFY_CAPACITY(void);
#define JavaUtilConcurrentConcurrentHashMap_MIN_TREEIFY_CAPACITY 64
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, MIN_TREEIFY_CAPACITY, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_MOVED(void);
#define JavaUtilConcurrentConcurrentHashMap_MOVED -1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, MOVED, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_TREEBIN(void);
#define JavaUtilConcurrentConcurrentHashMap_TREEBIN -2
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, TREEBIN, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_RESERVED(void);
#define JavaUtilConcurrentConcurrentHashMap_RESERVED -3
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, RESERVED, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_HASH_BITS(void);
#define JavaUtilConcurrentConcurrentHashMap_HASH_BITS 2147483647
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, HASH_BITS, jint)

/*!
 @brief Number of CPUS, to place bounds on some sizings
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_NCPU(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_NCPU;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentConcurrentHashMap, NCPU, jint)

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_spreadWithInt_(jint h);

FOUNDATION_EXPORT IOSClass *JavaUtilConcurrentConcurrentHashMap_comparableClassForWithId_(id x);

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_compareComparablesWithIOSClass_withId_withId_(IOSClass *kc, id k, id x);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *JavaUtilConcurrentConcurrentHashMap_tabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_(IOSObjectArray *tab, jint i);

FOUNDATION_EXPORT jboolean JavaUtilConcurrentConcurrentHashMap_casTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_Node_(IOSObjectArray *tab, jint i, JavaUtilConcurrentConcurrentHashMap_Node *c, JavaUtilConcurrentConcurrentHashMap_Node *v);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_setTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withJavaUtilConcurrentConcurrentHashMap_Node_(IOSObjectArray *tab, jint i, JavaUtilConcurrentConcurrentHashMap_Node *v);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_init(JavaUtilConcurrentConcurrentHashMap *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *create_JavaUtilConcurrentConcurrentHashMap_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *create_JavaUtilConcurrentConcurrentHashMap_initWithInt_(jint initialCapacity);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(JavaUtilConcurrentConcurrentHashMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *create_JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *create_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity, jfloat loadFactor, jint concurrencyLevel);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(jint initialCapacity, jfloat loadFactor, jint concurrencyLevel) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *create_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(jint initialCapacity, jfloat loadFactor, jint concurrencyLevel);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *JavaUtilConcurrentConcurrentHashMap_newKeySet(void);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *JavaUtilConcurrentConcurrentHashMap_newKeySetWithInt_(jint initialCapacity);

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_resizeStampWithInt_(jint n);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *JavaUtilConcurrentConcurrentHashMap_untreeifyWithJavaUtilConcurrentConcurrentHashMap_Node_(JavaUtilConcurrentConcurrentHashMap_Node *b);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_Node_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_Node))
#define JavaUtilConcurrentConcurrentHashMap_Node_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap_Entry 1
#include "java/util/Map.h"

/*!
 @brief Key-value entry.This class is never exported out as a
  user-mutable Map.Entry (i.e., one supporting setValue; see
  MapEntry below), but can be used for read-only traversals used
  in bulk tasks.
 Subclasses of Node with a negative hash field
  are special, and contain null keys and values (but are never
  exported).  Otherwise, keys and vals are never null.
 */
@interface JavaUtilConcurrentConcurrentHashMap_Node : NSObject < JavaUtilMap_Entry > {
 @public
  jint hash__;
  id key_;
  volatile_id val_;
  volatile_id next_;
}

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (id)getKey;

- (id)getValue;

- (NSUInteger)hash;

- (id)setValueWithId:(id)value;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)hash_
                               withId:(id)key
                               withId:(id)val
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)next;

/*!
 @brief Virtualized support for map.get(); overridden in subclasses.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Node)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Node, key_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Node, val_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Node, next_, JavaUtilConcurrentConcurrentHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Node_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_(JavaUtilConcurrentConcurrentHashMap_Node *self, jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *new_JavaUtilConcurrentConcurrentHashMap_Node_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_(jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *create_JavaUtilConcurrentConcurrentHashMap_Node_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_(jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Node)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_Segment_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_Segment))
#define JavaUtilConcurrentConcurrentHashMap_Segment_

#define RESTRICT_JavaUtilConcurrentLocksReentrantLock 1
#define INCLUDE_JavaUtilConcurrentLocksReentrantLock 1
#include "java/util/concurrent/locks/ReentrantLock.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

/*!
 @brief Stripped-down version of helper class used in previous version,
  declared for the sake of serialization compatibility.
 */
@interface JavaUtilConcurrentConcurrentHashMap_Segment : JavaUtilConcurrentLocksReentrantLock < JavaIoSerializable > {
 @public
  jfloat loadFactor_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithFloat:(jfloat)lf;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

- (instancetype __nonnull)initWithBoolean:(jboolean)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Segment)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_(JavaUtilConcurrentConcurrentHashMap_Segment *self, jfloat lf);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Segment *new_JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_(jfloat lf) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Segment *create_JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_(jfloat lf);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Segment)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForwardingNode_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForwardingNode))
#define JavaUtilConcurrentConcurrentHashMap_ForwardingNode_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief A node inserted at head of bins during transfer operations.
 */
@interface JavaUtilConcurrentConcurrentHashMap_ForwardingNode : JavaUtilConcurrentConcurrentHashMap_Node {
 @public
  IOSObjectArray *nextTable_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab;

- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithInt:(jint)arg0
                               withId:(id)arg1
                               withId:(id)arg2
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForwardingNode)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForwardingNode, nextTable_, IOSObjectArray *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForwardingNode_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_(JavaUtilConcurrentConcurrentHashMap_ForwardingNode *self, IOSObjectArray *tab);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForwardingNode *new_JavaUtilConcurrentConcurrentHashMap_ForwardingNode_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_(IOSObjectArray *tab) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForwardingNode *create_JavaUtilConcurrentConcurrentHashMap_ForwardingNode_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_(IOSObjectArray *tab);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForwardingNode)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ReservationNode_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReservationNode))
#define JavaUtilConcurrentConcurrentHashMap_ReservationNode_

@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief A place-holder node used in computeIfAbsent and compute.
 */
@interface JavaUtilConcurrentConcurrentHashMap_ReservationNode : JavaUtilConcurrentConcurrentHashMap_Node

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithInt:(jint)arg0
                               withId:(id)arg1
                               withId:(id)arg2
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ReservationNode)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ReservationNode_init(JavaUtilConcurrentConcurrentHashMap_ReservationNode *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReservationNode *new_JavaUtilConcurrentConcurrentHashMap_ReservationNode_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReservationNode *create_JavaUtilConcurrentConcurrentHashMap_ReservationNode_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ReservationNode)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_CounterCell_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_CounterCell))
#define JavaUtilConcurrentConcurrentHashMap_CounterCell_

/*!
 @brief A padded cell for distributing counts.Adapted from LongAdder
  and Striped64.
 See their internal docs for explanation.
 */
@interface JavaUtilConcurrentConcurrentHashMap_CounterCell : NSObject {
 @public
  volatile_jlong value_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithLong:(jlong)x;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_CounterCell)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_CounterCell_initWithLong_(JavaUtilConcurrentConcurrentHashMap_CounterCell *self, jlong x);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_CounterCell *new_JavaUtilConcurrentConcurrentHashMap_CounterCell_initWithLong_(jlong x) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_CounterCell *create_JavaUtilConcurrentConcurrentHashMap_CounterCell_initWithLong_(jlong x);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_CounterCell)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_TreeNode_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_TreeNode))
#define JavaUtilConcurrentConcurrentHashMap_TreeNode_

@class IOSClass;
@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief Nodes for use in TreeBins.
 */
@interface JavaUtilConcurrentConcurrentHashMap_TreeNode : JavaUtilConcurrentConcurrentHashMap_Node {
 @public
  JavaUtilConcurrentConcurrentHashMap_TreeNode *parent_;
  JavaUtilConcurrentConcurrentHashMap_TreeNode *left_;
  JavaUtilConcurrentConcurrentHashMap_TreeNode *right_;
  JavaUtilConcurrentConcurrentHashMap_TreeNode *prev_;
  jboolean red_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)hash_
                               withId:(id)key
                               withId:(id)val
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)next
withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)parent;

- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

/*!
 @brief Returns the TreeNode (or null if not found) for the given key
  starting at given root.
 */
- (JavaUtilConcurrentConcurrentHashMap_TreeNode *)findTreeNodeWithInt:(jint)h
                                                               withId:(id)k
                                                         withIOSClass:(IOSClass *)kc;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithInt:(jint)arg0
                               withId:(id)arg1
                               withId:(id)arg2
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_TreeNode)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, parent_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, left_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, right_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, prev_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *self, jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next, JavaUtilConcurrentConcurrentHashMap_TreeNode *parent);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *new_JavaUtilConcurrentConcurrentHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next, JavaUtilConcurrentConcurrentHashMap_TreeNode *parent) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *create_JavaUtilConcurrentConcurrentHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next, JavaUtilConcurrentConcurrentHashMap_TreeNode *parent);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_TreeNode)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_TreeBin_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_TreeBin))
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_

@class JavaLangThread;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@class JavaUtilConcurrentConcurrentHashMap_TreeNode;

/*!
 @brief TreeNodes used at the heads of bins.TreeBins do not hold user
  keys or values, but instead point to list of TreeNodes and
  their root.
 They also maintain a parasitic read-write lock
  forcing writers (who hold bin lock) to wait for readers (who do
  not) to complete before tree restructuring operations.
 */
@interface JavaUtilConcurrentConcurrentHashMap_TreeBin : JavaUtilConcurrentConcurrentHashMap_Node {
 @public
  JavaUtilConcurrentConcurrentHashMap_TreeNode *root_;
  volatile_id first_;
  volatile_id waiter_;
  volatile_jint lockState_;
}
@property (readonly, class) jint WRITER NS_SWIFT_NAME(WRITER);
@property (readonly, class) jint WAITER NS_SWIFT_NAME(WAITER);
@property (readonly, class) jint READER NS_SWIFT_NAME(READER);

+ (jint)WRITER;

+ (jint)WAITER;

+ (jint)READER;

#pragma mark Package-Private

/*!
 @brief Creates bin with initial set of nodes headed by b.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)b;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)balanceDeletionWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                                 withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)x;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)balanceInsertionWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                                  withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)x;

/*!
 @brief Checks invariants recursively for the tree of Nodes rooted at t.
 */
+ (jboolean)checkInvariantsWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)t;

/*!
 @brief Returns matching node or null if none.Tries to search
  using tree comparisons from root, but continues linear
  search when lock not available.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

/*!
 @brief Finds or adds a node.
 @return null if added
 */
- (JavaUtilConcurrentConcurrentHashMap_TreeNode *)putTreeValWithInt:(jint)h
                                                             withId:(id)k
                                                             withId:(id)v;

/*!
 @brief Removes the given node, that must be present before this
  call.This is messier than typical red-black deletion code
  because we cannot swap the contents of an interior node
  with a leaf successor that is pinned by "next" pointers
  that are accessible independently of lock.
 So instead we
  swap the tree linkages.
 @return true if now too small, so should be untreeified
 */
- (jboolean)removeTreeNodeWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)p;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)rotateLeftWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                            withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)p;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)rotateRightWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                             withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)p;

/*!
 @brief Tie-breaking utility for ordering insertions when equal
  hashCodes and non-comparable.We don't require a total
  order, just a consistent insertion rule to maintain
  equivalence across rebalancings.
 Tie-breaking further than
  necessary simplifies testing a bit.
 */
+ (jint)tieBreakOrderWithId:(id)a
                     withId:(id)b;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithInt:(jint)arg0
                               withId:(id)arg1
                               withId:(id)arg2
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_TreeBin)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeBin, root_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeBin, first_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeBin, waiter_, JavaLangThread *)

inline jint JavaUtilConcurrentConcurrentHashMap_TreeBin_get_WRITER(void);
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_WRITER 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap_TreeBin, WRITER, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_TreeBin_get_WAITER(void);
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_WAITER 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap_TreeBin, WAITER, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_TreeBin_get_READER(void);
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_READER 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap_TreeBin, READER, jint)

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_TreeBin_tieBreakOrderWithId_withId_(id a, id b);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_TreeBin_initWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeBin *self, JavaUtilConcurrentConcurrentHashMap_TreeNode *b);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeBin *new_JavaUtilConcurrentConcurrentHashMap_TreeBin_initWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *b) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeBin *create_JavaUtilConcurrentConcurrentHashMap_TreeBin_initWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *b);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_rotateLeftWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *p);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_rotateRightWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *p);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_balanceInsertionWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *x);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_balanceDeletionWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *x);

FOUNDATION_EXPORT jboolean JavaUtilConcurrentConcurrentHashMap_TreeBin_checkInvariantsWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *t);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_TreeBin)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_TableStack_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_TableStack))
#define JavaUtilConcurrentConcurrentHashMap_TableStack_

@class IOSObjectArray;

/*!
 @brief Records the table, its length, and current traversal index for a
  traverser that must process a region of a forwarded table before
  proceeding with current table.
 */
@interface JavaUtilConcurrentConcurrentHashMap_TableStack : NSObject {
 @public
  jint length_;
  jint index_;
  IOSObjectArray *tab_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *next_;
}

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_TableStack)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TableStack, tab_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TableStack, next_, JavaUtilConcurrentConcurrentHashMap_TableStack *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_TableStack_init(JavaUtilConcurrentConcurrentHashMap_TableStack *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TableStack *new_JavaUtilConcurrentConcurrentHashMap_TableStack_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TableStack *create_JavaUtilConcurrentConcurrentHashMap_TableStack_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_TableStack)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_Traverser_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_Traverser))
#define JavaUtilConcurrentConcurrentHashMap_Traverser_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@class JavaUtilConcurrentConcurrentHashMap_TableStack;

/*!
 @brief Encapsulates traversal for methods such as containsValue; also
  serves as a base class for other iterators and spliterators.
 Method advance visits once each still-valid node that was
  reachable upon iterator construction. It might miss some that
  were added to a bin after the bin was visited, which is OK wrt
  consistency guarantees. Maintaining this property in the face
  of possible ongoing resizes requires a fair amount of
  bookkeeping state that is difficult to optimize away amidst
  volatile accesses.  Even so, traversal maintains reasonable
  throughput.
  Normally, iteration proceeds bin-by-bin traversing lists.
  However, if the table has been resized, then all future steps
  must traverse both the bin at the current index as well as at
  (index + baseSize); and so on for further resizings. To
  paranoically cope with potential sharing by users of iterators
  across threads, iteration terminates if a bounds checks fails
  for a table read.
 */
@interface JavaUtilConcurrentConcurrentHashMap_Traverser : NSObject {
 @public
  IOSObjectArray *tab_;
  JavaUtilConcurrentConcurrentHashMap_Node *next_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *stack_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *spare_;
  jint index_;
  jint baseIndex_;
  jint baseLimit_;
  jint baseSize_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)size
                                                                        withInt:(jint)index
                                                                        withInt:(jint)limit;

/*!
 @brief Advances if possible, returning next valid node, or null if none.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)advance;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Traverser)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, tab_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, next_, JavaUtilConcurrentConcurrentHashMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, stack_, JavaUtilConcurrentConcurrentHashMap_TableStack *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, spare_, JavaUtilConcurrentConcurrentHashMap_TableStack *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Traverser_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_(JavaUtilConcurrentConcurrentHashMap_Traverser *self, IOSObjectArray *tab, jint size, jint index, jint limit);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Traverser *new_JavaUtilConcurrentConcurrentHashMap_Traverser_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_(IOSObjectArray *tab, jint size, jint index, jint limit) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Traverser *create_JavaUtilConcurrentConcurrentHashMap_Traverser_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_(IOSObjectArray *tab, jint size, jint index, jint limit);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Traverser)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_BaseIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_BaseIterator))
#define JavaUtilConcurrentConcurrentHashMap_BaseIterator_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief Base of key, value, and entry Iterators.Adds fields to
  Traverser to support iterator.remove.
 */
@interface JavaUtilConcurrentConcurrentHashMap_BaseIterator : JavaUtilConcurrentConcurrentHashMap_Traverser {
 @public
  JavaUtilConcurrentConcurrentHashMap *map_;
  JavaUtilConcurrentConcurrentHashMap_Node *lastReturned_;
}

#pragma mark Public

- (jboolean)hasMoreElements;

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)size
                                                                        withInt:(jint)index
                                                                        withInt:(jint)limit
                                        withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg0
                                                                        withInt:(jint)arg1
                                                                        withInt:(jint)arg2
                                                                        withInt:(jint)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_BaseIterator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BaseIterator, map_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BaseIterator, lastReturned_, JavaUtilConcurrentConcurrentHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_BaseIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_BaseIterator *self, IOSObjectArray *tab, jint size, jint index, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_BaseIterator *new_JavaUtilConcurrentConcurrentHashMap_BaseIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint size, jint index, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_BaseIterator *create_JavaUtilConcurrentConcurrentHashMap_BaseIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint size, jint index, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_BaseIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_KeyIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_KeyIterator))
#define JavaUtilConcurrentConcurrentHashMap_KeyIterator_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

#define RESTRICT_JavaUtilEnumeration 1
#define INCLUDE_JavaUtilEnumeration 1
#include "java/util/Enumeration.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_KeyIterator : JavaUtilConcurrentConcurrentHashMap_BaseIterator < JavaUtilIterator, JavaUtilEnumeration >

#pragma mark Public

- (id)next;

- (id)nextElement;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)index
                                                                        withInt:(jint)size
                                                                        withInt:(jint)limit
                                        withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_KeyIterator *self, IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeyIterator *new_JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeyIterator *create_JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeyIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ValueIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ValueIterator))
#define JavaUtilConcurrentConcurrentHashMap_ValueIterator_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

#define RESTRICT_JavaUtilEnumeration 1
#define INCLUDE_JavaUtilEnumeration 1
#include "java/util/Enumeration.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ValueIterator : JavaUtilConcurrentConcurrentHashMap_BaseIterator < JavaUtilIterator, JavaUtilEnumeration >

#pragma mark Public

- (id)next;

- (id)nextElement;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)index
                                                                        withInt:(jint)size
                                                                        withInt:(jint)limit
                                        withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_ValueIterator *self, IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValueIterator *new_JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValueIterator *create_JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ValueIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_EntryIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_EntryIterator))
#define JavaUtilConcurrentConcurrentHashMap_EntryIterator_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentHashMap_EntryIterator : JavaUtilConcurrentConcurrentHashMap_BaseIterator < JavaUtilIterator >

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)index
                                                                        withInt:(jint)size
                                                                        withInt:(jint)limit
                                        withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntryIterator *self, IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntryIterator *new_JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntryIterator *create_JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntryIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapEntry_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapEntry))
#define JavaUtilConcurrentConcurrentHashMap_MapEntry_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap_Entry 1
#include "java/util/Map.h"

@class JavaUtilConcurrentConcurrentHashMap;

/*!
 @brief Exported Entry for EntryIterator.
 */
@interface JavaUtilConcurrentConcurrentHashMap_MapEntry : NSObject < JavaUtilMap_Entry > {
 @public
  id key_;
  id val_;
  JavaUtilConcurrentConcurrentHashMap *map_;
}

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (id)getKey;

- (id)getValue;

- (NSUInteger)hash;

/*!
 @brief Sets our entry's value and writes through to the map.The
  value to return is somewhat arbitrary here.
 Since we do not
  necessarily track asynchronous changes, the most recent
  "previous" value could be different from what we return (or
  could even have been removed, in which case the put will
  re-establish). We do not and cannot guarantee more.
 */
- (id)setValueWithId:(id)value;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithId:(id)key
                              withId:(id)val
withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapEntry)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapEntry, key_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapEntry, val_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapEntry, map_, JavaUtilConcurrentConcurrentHashMap *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapEntry_initWithId_withId_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_MapEntry *self, id key, id val, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapEntry *new_JavaUtilConcurrentConcurrentHashMap_MapEntry_initWithId_withId_withJavaUtilConcurrentConcurrentHashMap_(id key, id val, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapEntry *create_JavaUtilConcurrentConcurrentHashMap_MapEntry_initWithId_withId_withJavaUtilConcurrentConcurrentHashMap_(id key, id val, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapEntry)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_KeySpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_KeySpliterator))
#define JavaUtilConcurrentConcurrentHashMap_KeySpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class IOSObjectArray;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_KeySpliterator : JavaUtilConcurrentConcurrentHashMap_Traverser < JavaUtilSpliterator > {
 @public
  jlong est_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentConcurrentHashMap_KeySpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)size
                                                                        withInt:(jint)index
                                                                        withInt:(jint)limit
                                                                       withLong:(jlong)est;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg0
                                                                        withInt:(jint)arg1
                                                                        withInt:(jint)arg2
                                                                        withInt:(jint)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeySpliterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeySpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_(JavaUtilConcurrentConcurrentHashMap_KeySpliterator *self, IOSObjectArray *tab, jint size, jint index, jint limit, jlong est);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySpliterator *new_JavaUtilConcurrentConcurrentHashMap_KeySpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_(IOSObjectArray *tab, jint size, jint index, jint limit, jlong est) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySpliterator *create_JavaUtilConcurrentConcurrentHashMap_KeySpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_(IOSObjectArray *tab, jint size, jint index, jint limit, jlong est);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeySpliterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ValueSpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ValueSpliterator))
#define JavaUtilConcurrentConcurrentHashMap_ValueSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class IOSObjectArray;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ValueSpliterator : JavaUtilConcurrentConcurrentHashMap_Traverser < JavaUtilSpliterator > {
 @public
  jlong est_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentConcurrentHashMap_ValueSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)size
                                                                        withInt:(jint)index
                                                                        withInt:(jint)limit
                                                                       withLong:(jlong)est;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg0
                                                                        withInt:(jint)arg1
                                                                        withInt:(jint)arg2
                                                                        withInt:(jint)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ValueSpliterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ValueSpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_(JavaUtilConcurrentConcurrentHashMap_ValueSpliterator *self, IOSObjectArray *tab, jint size, jint index, jint limit, jlong est);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValueSpliterator *new_JavaUtilConcurrentConcurrentHashMap_ValueSpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_(IOSObjectArray *tab, jint size, jint index, jint limit, jlong est) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValueSpliterator *create_JavaUtilConcurrentConcurrentHashMap_ValueSpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_(IOSObjectArray *tab, jint size, jint index, jint limit, jlong est);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ValueSpliterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_EntrySpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_EntrySpliterator))
#define JavaUtilConcurrentConcurrentHashMap_EntrySpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_EntrySpliterator : JavaUtilConcurrentConcurrentHashMap_Traverser < JavaUtilSpliterator > {
 @public
  JavaUtilConcurrentConcurrentHashMap *map_;
  jlong est_;
}

#pragma mark Public

- (jint)characteristics;

- (jlong)estimateSize;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentConcurrentHashMap_EntrySpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                        withInt:(jint)size
                                                                        withInt:(jint)index
                                                                        withInt:(jint)limit
                                                                       withLong:(jlong)est
                                        withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg0
                                                                        withInt:(jint)arg1
                                                                        withInt:(jint)arg2
                                                                        withInt:(jint)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntrySpliterator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_EntrySpliterator, map_, JavaUtilConcurrentConcurrentHashMap *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntrySpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntrySpliterator *self, IOSObjectArray *tab, jint size, jint index, jint limit, jlong est, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntrySpliterator *new_JavaUtilConcurrentConcurrentHashMap_EntrySpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint size, jint index, jint limit, jlong est, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntrySpliterator *create_JavaUtilConcurrentConcurrentHashMap_EntrySpliterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withLong_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint size, jint index, jint limit, jlong est, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntrySpliterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_CollectionView_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_CollectionView))
#define JavaUtilConcurrentConcurrentHashMap_CollectionView_

#define RESTRICT_JavaUtilCollection 1
#define INCLUDE_JavaUtilCollection 1
#include "java/util/Collection.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;
@protocol JavaUtilStreamStream;

/*!
 @brief Base class for views.
 */
@interface JavaUtilConcurrentConcurrentHashMap_CollectionView : NSObject < JavaUtilCollection, JavaIoSerializable > {
 @public
  JavaUtilConcurrentConcurrentHashMap *map_;
}

#pragma mark Public

/*!
 @brief Removes all of the elements from this view, by removing all
  the mappings from the map backing this view.
 */
- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Returns the map backing this view.
 @return the map backing this view
 */
- (JavaUtilConcurrentConcurrentHashMap *)getMap;

- (jboolean)isEmpty;

/*!
 @brief Returns an iterator over the elements in this collection.
 <p>The returned iterator is 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
 @return an iterator over the elements in this collection
 */
- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Returns a string representation of this collection.
 The string representation consists of the string representations
  of the collection's elements in the order they are returned by
  its iterator, enclosed in square brackets (<code>"[]"</code>).
  Adjacent elements are separated by the characters <code>", "</code>
  (comma and space).  Elements are converted to strings as by 
 <code>String.valueOf(Object)</code>.
 @return a string representation of this collection
 */
- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_CollectionView)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_CollectionView, map_, JavaUtilConcurrentConcurrentHashMap *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_CollectionView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_CollectionView *self, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_CollectionView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_KeySetView_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_KeySetView))
#define JavaUtilConcurrentConcurrentHashMap_KeySetView_

#define RESTRICT_JavaUtilSet 1
#define INCLUDE_JavaUtilSet 1
#include "java/util/Set.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

/*!
 @brief A view of a ConcurrentHashMap as a <code>Set</code> of keys, in
  which additions may optionally be enabled by mapping to a
  common value.This class cannot be directly instantiated.
 See <code>keySet(V)</code>,
  <code>newKeySet()</code>,
  <code>newKeySet(int)</code>.
 @since 1.8
 */
@interface JavaUtilConcurrentConcurrentHashMap_KeySetView : JavaUtilConcurrentConcurrentHashMap_CollectionView < JavaUtilSet, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Adds the specified key to this set view by mapping the key to
  the default mapped value in the backing map, if defined.
 @param e key to be added
 @return <code>true</code> if this set changed as a result of the call
 @throw NullPointerExceptionif the specified key is null
 @throw UnsupportedOperationExceptionif no default mapped value
  for additions was provided
 */
- (jboolean)addWithId:(id)e;

/*!
 @brief Adds all of the elements in the specified collection to this set,
  as if by calling <code>add</code> on each one.
 @param c the elements to be inserted into this set
 @return <code>true</code> if this set changed as a result of the call
 @throw NullPointerExceptionif the collection or any of its
  elements are <code>null</code>
 @throw UnsupportedOperationExceptionif no default mapped value
  for additions was provided
 */
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @throw NullPointerExceptionif the specified key is null
 */
- (jboolean)containsWithId:(id)o;

- (jboolean)isEqual:(id)o;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

/*!
 @brief Returns the default mapped value for additions,
  or <code>null</code> if additions are not supported.
 @return the default mapped value for additions, or <code>null</code>
  if not supported
 */
- (id __nullable)getMappedValue;

- (NSUInteger)hash;

/*!
 @return an iterator over the keys of the backing map
 */
- (id<JavaUtilIterator> __nonnull)iterator;

/*!
 @brief Removes the key from this map view, by removing the key (and its
  corresponding value) from the backing map.This method does
  nothing if the key is not in the map.
 @param o the key to be removed from the backing map
 @return <code>true</code> if the backing map contained the specified key
 @throw NullPointerExceptionif the specified key is null
 */
- (jboolean)removeWithId:(id)o;

- (id<JavaUtilSpliterator> __nonnull)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map
                                                               withId:(id)value;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeySetView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeySetView_initWithJavaUtilConcurrentConcurrentHashMap_withId_(JavaUtilConcurrentConcurrentHashMap_KeySetView *self, JavaUtilConcurrentConcurrentHashMap *map, id value);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *new_JavaUtilConcurrentConcurrentHashMap_KeySetView_initWithJavaUtilConcurrentConcurrentHashMap_withId_(JavaUtilConcurrentConcurrentHashMap *map, id value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *create_JavaUtilConcurrentConcurrentHashMap_KeySetView_initWithJavaUtilConcurrentConcurrentHashMap_withId_(JavaUtilConcurrentConcurrentHashMap *map, id value);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeySetView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ValuesView_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ValuesView))
#define JavaUtilConcurrentConcurrentHashMap_ValuesView_

#define RESTRICT_JavaUtilCollection 1
#define INCLUDE_JavaUtilCollection 1
#include "java/util/Collection.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

/*!
 @brief A view of a ConcurrentHashMap as a <code>Collection</code> of
  values, in which additions are disabled.This class cannot be
  directly instantiated.
 See <code>values()</code>.
 */
@interface JavaUtilConcurrentConcurrentHashMap_ValuesView : JavaUtilConcurrentConcurrentHashMap_CollectionView < JavaUtilCollection, JavaIoSerializable >

#pragma mark Public

- (jboolean)addWithId:(id)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)containsWithId:(id)o;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (id<JavaUtilSpliterator>)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ValuesView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ValuesView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_ValuesView *self, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValuesView *new_JavaUtilConcurrentConcurrentHashMap_ValuesView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValuesView *create_JavaUtilConcurrentConcurrentHashMap_ValuesView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ValuesView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_EntrySetView_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_EntrySetView))
#define JavaUtilConcurrentConcurrentHashMap_EntrySetView_

#define RESTRICT_JavaUtilSet 1
#define INCLUDE_JavaUtilSet 1
#include "java/util/Set.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilSpliterator;

/*!
 @brief A view of a ConcurrentHashMap as a <code>Set</code> of (key, value)
  entries.This class cannot be directly instantiated.
 See 
 <code>entrySet()</code>.
 */
@interface JavaUtilConcurrentConcurrentHashMap_EntrySetView : JavaUtilConcurrentConcurrentHashMap_CollectionView < JavaUtilSet, JavaIoSerializable >

#pragma mark Public

- (jboolean)addWithId:(id<JavaUtilMap_Entry>)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEqual:(id)o;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (NSUInteger)hash;

/*!
 @return an iterator over the entries of the backing map
 */
- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (id<JavaUtilSpliterator>)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntrySetView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntrySetView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntrySetView *self, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntrySetView *new_JavaUtilConcurrentConcurrentHashMap_EntrySetView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntrySetView *create_JavaUtilConcurrentConcurrentHashMap_EntrySetView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntrySetView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_BulkTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_BulkTask))
#define JavaUtilConcurrentConcurrentHashMap_BulkTask_

#define RESTRICT_JavaUtilConcurrentCountedCompleter 1
#define INCLUDE_JavaUtilConcurrentCountedCompleter 1
#include "java/util/concurrent/CountedCompleter.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@class JavaUtilConcurrentConcurrentHashMap_TableStack;

/*!
 @brief Base class for bulk tasks.Repeats some fields and code from
  class Traverser, because we need to subclass CountedCompleter.
 */
@interface JavaUtilConcurrentConcurrentHashMap_BulkTask : JavaUtilConcurrentCountedCompleter {
 @public
  IOSObjectArray *tab_;
  JavaUtilConcurrentConcurrentHashMap_Node *next_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *stack_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *spare_;
  jint index_;
  jint baseIndex_;
  jint baseLimit_;
  jint baseSize_;
  jint batch_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)par
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t;

/*!
 @brief Same as Traverser version.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)advance;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)arg0
                                                             withInt:(jint)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_BulkTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BulkTask, tab_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BulkTask, next_, JavaUtilConcurrentConcurrentHashMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BulkTask, stack_, JavaUtilConcurrentConcurrentHashMap_TableStack *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BulkTask, spare_, JavaUtilConcurrentConcurrentHashMap_TableStack *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_BulkTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_(JavaUtilConcurrentConcurrentHashMap_BulkTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *par, jint b, jint i, jint f, IOSObjectArray *t);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_BulkTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachKeyTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachValueTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachValueTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachValueTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachValueTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachValueTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachValueTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachValueTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachValueTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachValueTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachValueTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachValueTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachValueTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachValueTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachEntryTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionBiConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask, action_, id<JavaUtilFunctionBiConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachMappingTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> transformer_;
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask, transformer_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedKeyTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> transformer_;
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask, transformer_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedValueTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> transformer_;
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask, transformer_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedEntryTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask))
#define JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask_

@class IOSObjectArray;
@class JavaLangVoid;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiFunction> transformer_;
  id<JavaUtilFunctionConsumer> action_;
}

#pragma mark Public

- (void)compute;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)transformer
                                                  withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask, transformer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask, action_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiFunction> transformer, id<JavaUtilFunctionConsumer> action);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask *new_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiFunction> transformer, id<JavaUtilFunctionConsumer> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask *create_JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiFunction_withJavaUtilFunctionConsumer_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiFunction> transformer, id<JavaUtilFunctionConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForEachTransformedMappingTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_SearchKeysTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchKeysTask))
#define JavaUtilConcurrentConcurrentHashMap_SearchKeysTask_

@class IOSObjectArray;
@class JavaUtilConcurrentAtomicAtomicReference;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_SearchKeysTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> searchFunction_;
  JavaUtilConcurrentAtomicAtomicReference *result_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)searchFunction
                                   withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)result;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_SearchKeysTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchKeysTask, searchFunction_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchKeysTask, result_, JavaUtilConcurrentAtomicAtomicReference *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_SearchKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_SearchKeysTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchKeysTask *new_JavaUtilConcurrentConcurrentHashMap_SearchKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchKeysTask *create_JavaUtilConcurrentConcurrentHashMap_SearchKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_SearchKeysTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_SearchValuesTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchValuesTask))
#define JavaUtilConcurrentConcurrentHashMap_SearchValuesTask_

@class IOSObjectArray;
@class JavaUtilConcurrentAtomicAtomicReference;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_SearchValuesTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> searchFunction_;
  JavaUtilConcurrentAtomicAtomicReference *result_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)searchFunction
                                   withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)result;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_SearchValuesTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchValuesTask, searchFunction_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchValuesTask, result_, JavaUtilConcurrentAtomicAtomicReference *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_SearchValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_SearchValuesTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchValuesTask *new_JavaUtilConcurrentConcurrentHashMap_SearchValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchValuesTask *create_JavaUtilConcurrentConcurrentHashMap_SearchValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_SearchValuesTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask))
#define JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask_

@class IOSObjectArray;
@class JavaUtilConcurrentAtomicAtomicReference;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> searchFunction_;
  JavaUtilConcurrentAtomicAtomicReference *result_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)searchFunction
                                   withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)result;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask, searchFunction_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask, result_, JavaUtilConcurrentAtomicAtomicReference *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask *new_JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask *create_JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_SearchEntriesTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask))
#define JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask_

@class IOSObjectArray;
@class JavaUtilConcurrentAtomicAtomicReference;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiFunction> searchFunction_;
  JavaUtilConcurrentAtomicAtomicReference *result_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)searchFunction
                                   withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)result;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask, searchFunction_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask, result_, JavaUtilConcurrentAtomicAtomicReference *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask *new_JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask *create_JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilFunctionBiFunction_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, id<JavaUtilFunctionBiFunction> searchFunction, JavaUtilConcurrentAtomicAtomicReference *result);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_SearchMappingsTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask))
#define JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiFunction> reducer_;
  id result_;
  JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                        withJavaUtilConcurrentConcurrentHashMap_ReduceKeysTask:(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *)nextRight
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask, result_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask, rights_, JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *nextRight, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *new_JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *nextRight, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *create_JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceKeysTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask *nextRight, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ReduceKeysTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask))
#define JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiFunction> reducer_;
  id result_;
  JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                      withJavaUtilConcurrentConcurrentHashMap_ReduceValuesTask:(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *)nextRight
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask, result_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask, rights_, JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *nextRight, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *new_JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *nextRight, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *create_JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceValuesTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask *nextRight, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ReduceValuesTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask))
#define JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiFunction> reducer_;
  id<JavaUtilMap_Entry> result_;
  JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id<JavaUtilMap_Entry>)get;

- (id<JavaUtilMap_Entry>)getRawResult;

- (id<JavaUtilMap_Entry>)getWithLong:(jlong)arg0
      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (id<JavaUtilMap_Entry>)invoke;

- (id<JavaUtilMap_Entry>)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                     withJavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask:(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *)nextRight
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask, result_, id<JavaUtilMap_Entry>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask, rights_, JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *nextRight, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *new_JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *nextRight, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *create_JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask *nextRight, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ReduceEntriesTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> transformer_;
  id<JavaUtilFunctionBiFunction> reducer_;
  id result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                     withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *)nextRight
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask, transformer_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask, result_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> transformer_;
  id<JavaUtilFunctionBiFunction> reducer_;
  id result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                   withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *)nextRight
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask, transformer_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask, result_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionFunction> transformer_;
  id<JavaUtilFunctionBiFunction> reducer_;
  id result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                  withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *)nextRight
                                                  withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)transformer
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask, transformer_, id<JavaUtilFunctionFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask, result_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask_withJavaUtilFunctionFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask *nextRight, id<JavaUtilFunctionFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@protocol JavaUtilFunctionBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionBiFunction> transformer_;
  id<JavaUtilFunctionBiFunction> reducer_;
  id result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (id)getRawResult;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                 withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *)nextRight
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)transformer
                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask, transformer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask, reducer_, id<JavaUtilFunctionBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask, result_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_withJavaUtilFunctionBiFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *nextRight, id<JavaUtilFunctionBiFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_withJavaUtilFunctionBiFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *nextRight, id<JavaUtilFunctionBiFunction> transformer, id<JavaUtilFunctionBiFunction> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask_withJavaUtilFunctionBiFunction_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask *nextRight, id<JavaUtilFunctionBiFunction> transformer, id<JavaUtilFunctionBiFunction> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_

@class IOSObjectArray;
@class JavaLangDouble;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionDoubleBinaryOperator;
@protocol JavaUtilFunctionToDoubleFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToDoubleFunction> transformer_;
  id<JavaUtilFunctionDoubleBinaryOperator> reducer_;
  jdouble basis_;
  jdouble result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangDouble *)get;

- (JavaLangDouble *)getRawResult;

- (JavaLangDouble *)getWithLong:(jlong)arg0
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangDouble *)invoke;

- (JavaLangDouble *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
             withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *)nextRight
                                          withJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)transformer
                                                                    withDouble:(jdouble)basis
                                      withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask, transformer_, id<JavaUtilFunctionToDoubleFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask, reducer_, id<JavaUtilFunctionDoubleBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToDoubleTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_

@class IOSObjectArray;
@class JavaLangDouble;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionDoubleBinaryOperator;
@protocol JavaUtilFunctionToDoubleFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToDoubleFunction> transformer_;
  id<JavaUtilFunctionDoubleBinaryOperator> reducer_;
  jdouble basis_;
  jdouble result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangDouble *)get;

- (JavaLangDouble *)getRawResult;

- (JavaLangDouble *)getWithLong:(jlong)arg0
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangDouble *)invoke;

- (JavaLangDouble *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
           withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *)nextRight
                                          withJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)transformer
                                                                    withDouble:(jdouble)basis
                                      withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask, transformer_, id<JavaUtilFunctionToDoubleFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask, reducer_, id<JavaUtilFunctionDoubleBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToDoubleTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_

@class IOSObjectArray;
@class JavaLangDouble;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionDoubleBinaryOperator;
@protocol JavaUtilFunctionToDoubleFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToDoubleFunction> transformer_;
  id<JavaUtilFunctionDoubleBinaryOperator> reducer_;
  jdouble basis_;
  jdouble result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangDouble *)get;

- (JavaLangDouble *)getRawResult;

- (JavaLangDouble *)getWithLong:(jlong)arg0
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangDouble *)invoke;

- (JavaLangDouble *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
          withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *)nextRight
                                          withJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)transformer
                                                                    withDouble:(jdouble)basis
                                      withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask, transformer_, id<JavaUtilFunctionToDoubleFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask, reducer_, id<JavaUtilFunctionDoubleBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask_withJavaUtilFunctionToDoubleFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToDoubleTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_

@class IOSObjectArray;
@class JavaLangDouble;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionDoubleBinaryOperator;
@protocol JavaUtilFunctionToDoubleBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToDoubleBiFunction> transformer_;
  id<JavaUtilFunctionDoubleBinaryOperator> reducer_;
  jdouble basis_;
  jdouble result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangDouble *)get;

- (JavaLangDouble *)getRawResult;

- (JavaLangDouble *)getWithLong:(jlong)arg0
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangDouble *)invoke;

- (JavaLangDouble *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
         withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *)nextRight
                                        withJavaUtilFunctionToDoubleBiFunction:(id<JavaUtilFunctionToDoubleBiFunction>)transformer
                                                                    withDouble:(jdouble)basis
                                      withJavaUtilFunctionDoubleBinaryOperator:(id<JavaUtilFunctionDoubleBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask, transformer_, id<JavaUtilFunctionToDoubleBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask, reducer_, id<JavaUtilFunctionDoubleBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_withJavaUtilFunctionToDoubleBiFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleBiFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_withJavaUtilFunctionToDoubleBiFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleBiFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask_withJavaUtilFunctionToDoubleBiFunction_withDouble_withJavaUtilFunctionDoubleBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask *nextRight, id<JavaUtilFunctionToDoubleBiFunction> transformer, jdouble basis, id<JavaUtilFunctionDoubleBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToDoubleTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_

@class IOSObjectArray;
@class JavaLangLong;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilFunctionToLongFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToLongFunction> transformer_;
  id<JavaUtilFunctionLongBinaryOperator> reducer_;
  jlong basis_;
  jlong result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangLong *)get;

- (JavaLangLong *)getRawResult;

- (JavaLangLong *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangLong *)invoke;

- (JavaLangLong *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
               withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *)nextRight
                                            withJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)transformer
                                                                      withLong:(jlong)basis
                                        withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask, transformer_, id<JavaUtilFunctionToLongFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask, reducer_, id<JavaUtilFunctionLongBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToLongTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_

@class IOSObjectArray;
@class JavaLangLong;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilFunctionToLongFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToLongFunction> transformer_;
  id<JavaUtilFunctionLongBinaryOperator> reducer_;
  jlong basis_;
  jlong result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangLong *)get;

- (JavaLangLong *)getRawResult;

- (JavaLangLong *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangLong *)invoke;

- (JavaLangLong *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
             withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *)nextRight
                                            withJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)transformer
                                                                      withLong:(jlong)basis
                                        withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask, transformer_, id<JavaUtilFunctionToLongFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask, reducer_, id<JavaUtilFunctionLongBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToLongTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_

@class IOSObjectArray;
@class JavaLangLong;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilFunctionToLongFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToLongFunction> transformer_;
  id<JavaUtilFunctionLongBinaryOperator> reducer_;
  jlong basis_;
  jlong result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangLong *)get;

- (JavaLangLong *)getRawResult;

- (JavaLangLong *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangLong *)invoke;

- (JavaLangLong *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
            withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *)nextRight
                                            withJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)transformer
                                                                      withLong:(jlong)basis
                                        withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask, transformer_, id<JavaUtilFunctionToLongFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask, reducer_, id<JavaUtilFunctionLongBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask_withJavaUtilFunctionToLongFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask *nextRight, id<JavaUtilFunctionToLongFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToLongTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_

@class IOSObjectArray;
@class JavaLangLong;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilFunctionToLongBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToLongBiFunction> transformer_;
  id<JavaUtilFunctionLongBinaryOperator> reducer_;
  jlong basis_;
  jlong result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangLong *)get;

- (JavaLangLong *)getRawResult;

- (JavaLangLong *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangLong *)invoke;

- (JavaLangLong *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
           withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *)nextRight
                                          withJavaUtilFunctionToLongBiFunction:(id<JavaUtilFunctionToLongBiFunction>)transformer
                                                                      withLong:(jlong)basis
                                        withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask, transformer_, id<JavaUtilFunctionToLongBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask, reducer_, id<JavaUtilFunctionLongBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_withJavaUtilFunctionToLongBiFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *nextRight, id<JavaUtilFunctionToLongBiFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_withJavaUtilFunctionToLongBiFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *nextRight, id<JavaUtilFunctionToLongBiFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask_withJavaUtilFunctionToLongBiFunction_withLong_withJavaUtilFunctionLongBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask *nextRight, id<JavaUtilFunctionToLongBiFunction> transformer, jlong basis, id<JavaUtilFunctionLongBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToLongTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_

@class IOSObjectArray;
@class JavaLangInteger;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionIntBinaryOperator;
@protocol JavaUtilFunctionToIntFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToIntFunction> transformer_;
  id<JavaUtilFunctionIntBinaryOperator> reducer_;
  jint basis_;
  jint result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangInteger *)get;

- (JavaLangInteger *)getRawResult;

- (JavaLangInteger *)getWithLong:(jlong)arg0
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangInteger *)invoke;

- (JavaLangInteger *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
                withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *)nextRight
                                             withJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)transformer
                                                                       withInt:(jint)basis
                                         withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask, transformer_, id<JavaUtilFunctionToIntFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask, reducer_, id<JavaUtilFunctionIntBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceKeysToIntTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_

@class IOSObjectArray;
@class JavaLangInteger;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionIntBinaryOperator;
@protocol JavaUtilFunctionToIntFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToIntFunction> transformer_;
  id<JavaUtilFunctionIntBinaryOperator> reducer_;
  jint basis_;
  jint result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangInteger *)get;

- (JavaLangInteger *)getRawResult;

- (JavaLangInteger *)getWithLong:(jlong)arg0
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangInteger *)invoke;

- (JavaLangInteger *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
              withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *)nextRight
                                             withJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)transformer
                                                                       withInt:(jint)basis
                                         withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask, transformer_, id<JavaUtilFunctionToIntFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask, reducer_, id<JavaUtilFunctionIntBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceValuesToIntTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_

@class IOSObjectArray;
@class JavaLangInteger;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionIntBinaryOperator;
@protocol JavaUtilFunctionToIntFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToIntFunction> transformer_;
  id<JavaUtilFunctionIntBinaryOperator> reducer_;
  jint basis_;
  jint result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangInteger *)get;

- (JavaLangInteger *)getRawResult;

- (JavaLangInteger *)getWithLong:(jlong)arg0
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangInteger *)invoke;

- (JavaLangInteger *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
             withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *)nextRight
                                             withJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)transformer
                                                                       withInt:(jint)basis
                                         withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask, transformer_, id<JavaUtilFunctionToIntFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask, reducer_, id<JavaUtilFunctionIntBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask_withJavaUtilFunctionToIntFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask *nextRight, id<JavaUtilFunctionToIntFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceEntriesToIntTask)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap || defined(INCLUDE_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask))
#define JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_

@class IOSObjectArray;
@class JavaLangInteger;
@class JavaUtilConcurrentConcurrentHashMap_BulkTask;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionIntBinaryOperator;
@protocol JavaUtilFunctionToIntBiFunction;

@interface JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask : JavaUtilConcurrentConcurrentHashMap_BulkTask {
 @public
  id<JavaUtilFunctionToIntBiFunction> transformer_;
  id<JavaUtilFunctionIntBinaryOperator> reducer_;
  jint basis_;
  jint result_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *rights_;
  JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *nextRight_;
}

#pragma mark Public

- (void)compute;

- (JavaLangInteger *)get;

- (JavaLangInteger *)getRawResult;

- (JavaLangInteger *)getWithLong:(jlong)arg0
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangInteger *)invoke;

- (JavaLangInteger *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)p
                                                                       withInt:(jint)b
                                                                       withInt:(jint)i
                                                                       withInt:(jint)f
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)t
            withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask:(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *)nextRight
                                           withJavaUtilFunctionToIntBiFunction:(id<JavaUtilFunctionToIntBiFunction>)transformer
                                                                       withInt:(jint)basis
                                         withJavaUtilFunctionIntBinaryOperator:(id<JavaUtilFunctionIntBinaryOperator>)reducer;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentHashMap_BulkTask:(JavaUtilConcurrentConcurrentHashMap_BulkTask *)arg0
                                                                       withInt:(jint)arg1
                                                                       withInt:(jint)arg2
                                                                       withInt:(jint)arg3
                             withJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)arg4 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask, transformer_, id<JavaUtilFunctionToIntBiFunction>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask, reducer_, id<JavaUtilFunctionIntBinaryOperator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask, rights_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask, nextRight_, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_withJavaUtilFunctionToIntBiFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *self, JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *nextRight, id<JavaUtilFunctionToIntBiFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *new_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_withJavaUtilFunctionToIntBiFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *nextRight, id<JavaUtilFunctionToIntBiFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *create_JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_initWithJavaUtilConcurrentConcurrentHashMap_BulkTask_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_NodeArray_withJavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask_withJavaUtilFunctionToIntBiFunction_withInt_withJavaUtilFunctionIntBinaryOperator_(JavaUtilConcurrentConcurrentHashMap_BulkTask *p, jint b, jint i, jint f, IOSObjectArray *t, JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask *nextRight, id<JavaUtilFunctionToIntBiFunction> transformer, jint basis, id<JavaUtilFunctionIntBinaryOperator> reducer);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapReduceMappingsToIntTask)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentConcurrentHashMap")
