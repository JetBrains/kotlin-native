//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/ThreadPoolExecutor.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor")
#ifdef RESTRICT_JavaUtilConcurrentThreadPoolExecutor
#define INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor 1
#endif
#undef RESTRICT_JavaUtilConcurrentThreadPoolExecutor

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor))
#define JavaUtilConcurrentThreadPoolExecutor_

#define RESTRICT_JavaUtilConcurrentAbstractExecutorService 1
#define INCLUDE_JavaUtilConcurrentAbstractExecutorService 1
#include "java/util/concurrent/AbstractExecutorService.h"

@class JavaLangThread;
@class JavaLangThrowable;
@class JavaUtilConcurrentThreadPoolExecutor_Worker;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentBlockingQueue;
@protocol JavaUtilConcurrentRejectedExecutionHandler;
@protocol JavaUtilConcurrentThreadFactory;
@protocol JavaUtilList;

/*!
 @brief An <code>ExecutorService</code> that executes each submitted task using
  one of possibly several pooled threads, normally configured
  using <code>Executors</code> factory methods.
 <p>Thread pools address two different problems: they usually
  provide improved performance when executing large numbers of
  asynchronous tasks, due to reduced per-task invocation overhead,
  and they provide a means of bounding and managing the resources,
  including threads, consumed when executing a collection of tasks.
  Each <code>ThreadPoolExecutor</code> also maintains some basic
  statistics, such as the number of completed tasks. 
 <p>To be useful across a wide range of contexts, this class
  provides many adjustable parameters and extensibility
  hooks. However, programmers are urged to use the more convenient 
 <code>Executors</code> factory methods <code>Executors.newCachedThreadPool</code>
  (unbounded thread pool, with
  automatic thread reclamation), <code>Executors.newFixedThreadPool</code>
  (fixed size thread pool) and <code>Executors.newSingleThreadExecutor</code>
  (single background thread), that
  preconfigure settings for the most common usage
  scenarios. Otherwise, use the following guide when manually
  configuring and tuning this class: 
 <dl>
  
 <dt>Core and maximum pool sizes</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  A <code>ThreadPoolExecutor</code> will automatically adjust the
  pool size (see <code>getPoolSize</code>)
  according to the bounds set by
  corePoolSize (see <code>getCorePoolSize</code>) and
  maximumPoolSize (see <code>getMaximumPoolSize</code>).
  When a new task is submitted in method <code>execute(Runnable)</code>,
  and fewer than corePoolSize threads are running, a new thread is
  created to handle the request, even if other worker threads are
  idle.  If there are more than corePoolSize but less than
  maximumPoolSize threads running, a new thread will be created only
  if the queue is full.  By setting corePoolSize and maximumPoolSize
  the same, you create a fixed-size thread pool. By setting
  maximumPoolSize to an essentially unbounded value such as <code>Integer.MAX_VALUE</code>
 , you allow the pool to accommodate an arbitrary
  number of concurrent tasks. Most typically, core and maximum pool
  sizes are set only upon construction, but they may also be changed
  dynamically using <code>setCorePoolSize</code> and <code>setMaximumPoolSize</code>
 . </dd>
  
 <dt>On-demand construction</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  By default, even core threads are initially created and
  started only when new tasks arrive, but this can be overridden
  dynamically using method <code>prestartCoreThread</code> or <code>prestartAllCoreThreads</code>
 .  You probably want to prestart threads if
  you construct the pool with a non-empty queue. </dd>
  
 <dt>Creating new threads</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  New threads are created using a <code>ThreadFactory</code>.  If not
  otherwise specified, a <code>Executors.defaultThreadFactory</code> is
  used, that creates threads to all be in the same <code>ThreadGroup</code>
  and with the same <code>NORM_PRIORITY</code> priority and
  non-daemon status. By supplying a different ThreadFactory, you can
  alter the thread's name, thread group, priority, daemon status,
  etc. If a <code>ThreadFactory</code> fails to create a thread when asked
  by returning null from <code>newThread</code>, the executor will
  continue, but might not be able to execute any tasks. Threads
  should possess the "modifyThread" <code>RuntimePermission</code>. If
  worker threads or other threads using the pool do not possess this
  permission, service may be degraded: configuration changes may not
  take effect in a timely manner, and a shutdown pool may remain in a
  state in which termination is possible but not completed.</dd>
  
 <dt>Keep-alive times</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  If the pool currently has more than corePoolSize threads,
  excess threads will be terminated if they have been idle for more
  than the keepAliveTime (see <code>getKeepAliveTime(TimeUnit)</code>).
  This provides a means of reducing resource consumption when the
  pool is not being actively used. If the pool becomes more active
  later, new threads will be constructed. This parameter can also be
  changed dynamically using method <code>setKeepAliveTime(long,
 TimeUnit)</code>
 .  Using a value of <code>Long.MAX_VALUE</code> <code>TimeUnit.NANOSECONDS</code>
  effectively disables idle threads from ever
  terminating prior to shut down. By default, the keep-alive policy
  applies only when there are more than corePoolSize threads, but
  method <code>allowCoreThreadTimeOut(boolean)</code> can be used to
  apply this time-out policy to core threads as well, so long as the
  keepAliveTime value is non-zero. </dd>
  
 <dt>Queuing</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  Any <code>BlockingQueue</code> may be used to transfer and hold
  submitted tasks.  The use of this queue interacts with pool sizing: 
 <ul>
  
 <li>If fewer than corePoolSize threads are running, the Executor
  always prefers adding a new thread
  rather than queuing. 
 <li>If corePoolSize or more threads are running, the Executor
  always prefers queuing a request rather than adding a new
  thread. 
 <li>If a request cannot be queued, a new thread is created unless
  this would exceed maximumPoolSize, in which case, the task will be
  rejected. 
 </ul>
  There are three general strategies for queuing: 
 <ol>
  
 <li><em> Direct handoffs.</em> A good default choice for a work
  queue is a <code>SynchronousQueue</code> that hands off tasks to threads
  without otherwise holding them. Here, an attempt to queue a task
  will fail if no threads are immediately available to run it, so a
  new thread will be constructed. This policy avoids lockups when
  handling sets of requests that might have internal dependencies.
  Direct handoffs generally require unbounded maximumPoolSizes to
  avoid rejection of new submitted tasks. This in turn admits the
  possibility of unbounded thread growth when commands continue to
  arrive on average faster than they can be processed. 
 <li><em> Unbounded queues.</em> Using an unbounded queue (for
  example a <code>LinkedBlockingQueue</code> without a predefined
  capacity) will cause new tasks to wait in the queue when all
  corePoolSize threads are busy. Thus, no more than corePoolSize
  threads will ever be created. (And the value of the maximumPoolSize
  therefore doesn't have any effect.)  This may be appropriate when
  each task is completely independent of others, so tasks cannot
  affect each others execution; for example, in a web page server.
  While this style of queuing can be useful in smoothing out
  transient bursts of requests, it admits the possibility of
  unbounded work queue growth when commands continue to arrive on
  average faster than they can be processed. 
 <li><em>Bounded queues.</em> A bounded queue (for example, an 
 <code>ArrayBlockingQueue</code>) helps prevent resource exhaustion when
  used with finite maximumPoolSizes, but can be more difficult to
  tune and control.  Queue sizes and maximum pool sizes may be traded
  off for each other: Using large queues and small pools minimizes
  CPU usage, OS resources, and context-switching overhead, but can
  lead to artificially low throughput.  If tasks frequently block (for
  example if they are I/O bound), a system may be able to schedule
  time for more threads than you otherwise allow. Use of small queues
  generally requires larger pool sizes, which keeps CPUs busier but
  may encounter unacceptable scheduling overhead, which also
  decreases throughput. 
 </ol>
  
 </dd>
  
 <dt>Rejected tasks</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  New tasks submitted in method <code>execute(Runnable)</code> will be 
 <em>rejected</em> when the Executor has been shut down, and also when
  the Executor uses finite bounds for both maximum threads and work queue
  capacity, and is saturated.  In either case, the <code>execute</code> method
  invokes the <code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>
  method of its <code>RejectedExecutionHandler</code>.  Four predefined handler
  policies are provided: 
 <ol>
  
 <li>In the default <code>ThreadPoolExecutor.AbortPolicy</code>, the
  handler throws a runtime <code>RejectedExecutionException</code> upon
  rejection. 
 <li>In <code>ThreadPoolExecutor.CallerRunsPolicy</code>, the thread
  that invokes <code>execute</code> itself runs the task. This provides a
  simple feedback control mechanism that will slow down the rate that
  new tasks are submitted. 
 <li>In <code>ThreadPoolExecutor.DiscardPolicy</code>, a task that
  cannot be executed is simply dropped. 
 <li>In <code>ThreadPoolExecutor.DiscardOldestPolicy</code>, if the
  executor is not shut down, the task at the head of the work queue
  is dropped, and then execution is retried (which can fail again,
  causing this to be repeated.) 
 </ol>
  It is possible to define and use other kinds of <code>RejectedExecutionHandler</code>
  classes. Doing so requires some care
  especially when policies are designed to work only under particular
  capacity or queuing policies. </dd>
  
 <dt>Hook methods</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  This class provides <code>protected</code> overridable 
 <code>beforeExecute(Thread, Runnable)</code> and 
 <code>afterExecute(Runnable, Throwable)</code> methods that are called
  before and after execution of each task.  These can be used to
  manipulate the execution environment; for example, reinitializing
  ThreadLocals, gathering statistics, or adding log entries.
  Additionally, method <code>terminated</code> can be overridden to perform
  any special processing that needs to be done once the Executor has
  fully terminated. 
 <p>If hook, callback, or BlockingQueue methods throw exceptions,
  internal worker threads may in turn fail, abruptly terminate, and
  possibly be replaced.</dd>
  
 <dt>Queue maintenance</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  Method <code>getQueue()</code> allows access to the work queue
  for purposes of monitoring and debugging.  Use of this method for
  any other purpose is strongly discouraged.  Two supplied methods, 
 <code>remove(Runnable)</code> and <code>purge</code> are available to
  assist in storage reclamation when large numbers of queued tasks
  become cancelled.</dd>
  
 <dt>Finalization</dt>
  
 <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  A pool that is no longer referenced in a program <em>AND</em>
  has no remaining threads will be <code>shutdown</code> automatically. If
  you would like to ensure that unreferenced pools are reclaimed even
  if users forget to call <code>shutdown</code>, then you must arrange
  that unused threads eventually die, by setting appropriate
  keep-alive times, using a lower bound of zero core threads and/or
  setting <code>allowCoreThreadTimeOut(boolean)</code>.  </dd>
  
 </dl>
  
 <p><b>Extension example</b>. Most extensions of this class
  override one or more of the protected hook methods. For example,
  here is a subclass that adds a simple pause/resume feature: 
 @code
  class PausableThreadPoolExecutor extends ThreadPoolExecutor {
    private boolean isPaused;
    private ReentrantLock pauseLock = new ReentrantLock();
    private Condition unpaused = pauseLock.newCondition();
    public PausableThreadPoolExecutor(...) { super(...); }
    protected void beforeExecute(Thread t, Runnable r) {
      super.beforeExecute(t, r);
      pauseLock.lock();
      try {
        while (isPaused) unpaused.await();
      } catch (InterruptedException ie) {
        t.interrupt();
      } finally {
        pauseLock.unlock();
      }    }
    public void pause() {
      pauseLock.lock();
      try {
        isPaused = true;
      } finally {
        pauseLock.unlock();
      }    }
    public void resume() {
      pauseLock.lock();
      try {
        isPaused = false;
        unpaused.signalAll();
      } finally {
        pauseLock.unlock();
      }    }    }
 
@endcode
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentThreadPoolExecutor : JavaUtilConcurrentAbstractExecutorService

#pragma mark Public

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters and default thread factory and rejected execution handler.
 It may be more convenient to use one of the <code>Executors</code> factory
  methods instead of this general purpose constructor.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue;

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters and default thread factory.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @param handler the handler to use when execution is blocked         because the thread bounds and queue capacities are reached
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code>
          or <code>handler</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue
withJavaUtilConcurrentRejectedExecutionHandler:(id<JavaUtilConcurrentRejectedExecutionHandler>)handler;

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters and default rejected execution handler.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @param threadFactory the factory to use when the executor         creates a new thread
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code>
          or <code>threadFactory</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue
  withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

/*!
 @brief Creates a new <code>ThreadPoolExecutor</code> with the given initial
  parameters.
 @param corePoolSize the number of threads to keep in the pool, even         if they are idle, unless 
 <code>allowCoreThreadTimeOut</code>  is set
 @param maximumPoolSize the maximum number of threads to allow in the         pool
 @param keepAliveTime when the number of threads is greater than         the core, this is the maximum time that excess idle threads
          will wait for new tasks before terminating.
 @param unit the time unit for the <code>keepAliveTime</code>  argument
 @param workQueue the queue to use for holding tasks before they are         executed.  This queue will hold only the 
 <code>Runnable</code>         tasks submitted by the 
 <code>execute</code>  method.
 @param threadFactory the factory to use when the executor         creates a new thread
 @param handler the handler to use when execution is blocked         because the thread bounds and queue capacities are reached
 @throw IllegalArgumentExceptionif one of the following holds:<br>
          <code>corePoolSize < 0</code><br>
          <code>keepAliveTime < 0</code><br>
          <code>maximumPoolSize <= 0</code><br>
          <code>maximumPoolSize < corePoolSize</code>
 @throw NullPointerExceptionif <code>workQueue</code>
          or <code>threadFactory</code> or <code>handler</code> is null
 */
- (instancetype __nonnull)initWithInt:(jint)corePoolSize
                              withInt:(jint)maximumPoolSize
                             withLong:(jlong)keepAliveTime
       withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
  withJavaUtilConcurrentBlockingQueue:(id<JavaUtilConcurrentBlockingQueue>)workQueue
  withJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory
withJavaUtilConcurrentRejectedExecutionHandler:(id<JavaUtilConcurrentRejectedExecutionHandler>)handler;

/*!
 @brief Sets the policy governing whether core threads may time out and
  terminate if no tasks arrive within the keep-alive time, being
  replaced if needed when new tasks arrive.When false, core
  threads are never terminated due to lack of incoming
  tasks.
 When true, the same keep-alive policy applying to
  non-core threads applies also to core threads. To avoid
  continual thread replacement, the keep-alive time must be
  greater than zero when setting <code>true</code>. This method
  should in general be called before the pool is actively used.
 @param value<code>true</code>  if should time out, else <code>false</code>
 @throw IllegalArgumentExceptionif value is <code>true</code>
          and the current keep-alive time is not greater than zero
 @since 1.6
 */
- (void)allowCoreThreadTimeOutWithBoolean:(jboolean)value;

/*!
 @brief Returns true if this pool allows core threads to time out and
  terminate if no tasks arrive within the keepAlive time, being
  replaced if needed when new tasks arrive.When true, the same
  keep-alive policy applying to non-core threads applies also to
  core threads.
 When false (the default), core threads are never
  terminated due to lack of incoming tasks.
 @return <code>true</code> if core threads are allowed to time out,
          else <code>false</code>
 @since 1.6
 */
- (jboolean)allowsCoreThreadTimeOut;

- (jboolean)awaitTerminationWithLong:(jlong)timeout
      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Executes the given task sometime in the future.The task
  may execute in a new thread or in an existing pooled thread.
 If the task cannot be submitted for execution, either because this
  executor has been shutdown or because its capacity has been reached,
  the task is handled by the current <code>RejectedExecutionHandler</code>.
 @param command the task to execute
 @throw RejectedExecutionExceptionat discretion of
          <code>RejectedExecutionHandler</code>, if the task
          cannot be accepted for execution
 @throw NullPointerExceptionif <code>command</code> is null
 */
- (void)executeWithJavaLangRunnable:(id<JavaLangRunnable>)command;

/*!
 @brief Returns the approximate number of threads that are actively
  executing tasks.
 @return the number of threads
 */
- (jint)getActiveCount;

/*!
 @brief Returns the approximate total number of tasks that have
  completed execution.Because the states of tasks and threads
  may change dynamically during computation, the returned value
  is only an approximation, but one that does not ever decrease
  across successive calls.
 @return the number of tasks
 */
- (jlong)getCompletedTaskCount;

/*!
 @brief Returns the core number of threads.
 @return the core number of threads
 - seealso: #setCorePoolSize
 */
- (jint)getCorePoolSize;

/*!
 @brief Returns the thread keep-alive time, which is the amount of time
  that threads may remain idle before being terminated.
 Threads that wait this amount of time without processing a
  task will be terminated if there are more than the core
  number of threads currently in the pool, or if this pool 
 allows core thread timeout.
 @param unit the desired time unit of the result
 @return the time limit
 - seealso: #setKeepAliveTime(long, TimeUnit)
 */
- (jlong)getKeepAliveTimeWithJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns the largest number of threads that have ever
  simultaneously been in the pool.
 @return the number of threads
 */
- (jint)getLargestPoolSize;

/*!
 @brief Returns the maximum allowed number of threads.
 @return the maximum allowed number of threads
 - seealso: #setMaximumPoolSize
 */
- (jint)getMaximumPoolSize;

/*!
 @brief Returns the current number of threads in the pool.
 @return the number of threads
 */
- (jint)getPoolSize;

/*!
 @brief Returns the task queue used by this executor.Access to the
  task queue is intended primarily for debugging and monitoring.
 This queue may be in active use.  Retrieving the task queue
  does not prevent queued tasks from executing.
 @return the task queue
 */
- (id<JavaUtilConcurrentBlockingQueue>)getQueue;

/*!
 @brief Returns the current handler for unexecutable tasks.
 @return the current handler
 - seealso: #setRejectedExecutionHandler(RejectedExecutionHandler)
 */
- (id<JavaUtilConcurrentRejectedExecutionHandler>)getRejectedExecutionHandler;

/*!
 @brief Returns the approximate total number of tasks that have ever been
  scheduled for execution.Because the states of tasks and
  threads may change dynamically during computation, the returned
  value is only an approximation.
 @return the number of tasks
 */
- (jlong)getTaskCount;

/*!
 @brief Returns the thread factory used to create new threads.
 @return the current thread factory
 - seealso: #setThreadFactory(ThreadFactory)
 */
- (id<JavaUtilConcurrentThreadFactory>)getThreadFactory;

- (jboolean)isShutdown;

- (jboolean)isTerminated;

/*!
 @brief Returns true if this executor is in the process of terminating
  after <code>shutdown</code> or <code>shutdownNow</code> but has not
  completely terminated.This method may be useful for
  debugging.
 A return of <code>true</code> reported a sufficient
  period after shutdown may indicate that submitted tasks have
  ignored or suppressed interruption, causing this executor not
  to properly terminate.
 @return <code>true</code> if terminating but not yet terminated
 */
- (jboolean)isTerminating;

/*!
 @brief Starts all core threads, causing them to idly wait for work.This
  overrides the default policy of starting core threads only when
  new tasks are executed.
 @return the number of threads started
 */
- (jint)prestartAllCoreThreads;

/*!
 @brief Starts a core thread, causing it to idly wait for work.This
  overrides the default policy of starting core threads only when
  new tasks are executed.
 This method will return <code>false</code>
  if all core threads have already been started.
 @return <code>true</code> if a thread was started
 */
- (jboolean)prestartCoreThread;

/*!
 @brief Tries to remove from the work queue all <code>Future</code>
  tasks that have been cancelled.This method can be useful as a
  storage reclamation operation, that has no other impact on
  functionality.
 Cancelled tasks are never executed, but may
  accumulate in work queues until worker threads can actively
  remove them. Invoking this method instead tries to remove them now.
  However, this method may fail to remove tasks in
  the presence of interference by other threads.
 */
- (void)purge;

/*!
 @brief Removes this task from the executor's internal queue if it is
  present, thus causing it not to be run if it has not already
  started.
 <p>This method may be useful as one part of a cancellation
  scheme.  It may fail to remove tasks that have been converted
  into other forms before being placed on the internal queue.
  For example, a task entered using <code>submit</code> might be
  converted into a form that maintains <code>Future</code> status.
  However, in such cases, method <code>purge</code> may be used to
  remove those Futures that have been cancelled.
 @param task the task to remove
 @return <code>true</code> if the task was removed
 */
- (jboolean)removeWithJavaLangRunnable:(id<JavaLangRunnable>)task;

/*!
 @brief Sets the core number of threads.This overrides any value set
  in the constructor.
 If the new value is smaller than the
  current value, excess existing threads will be terminated when
  they next become idle.  If larger, new threads will, if needed,
  be started to execute any queued tasks.
 @param corePoolSize the new core size
 @throw IllegalArgumentExceptionif <code>corePoolSize < 0</code>
 - seealso: #getCorePoolSize
 */
- (void)setCorePoolSizeWithInt:(jint)corePoolSize;

/*!
 @brief Sets the thread keep-alive time, which is the amount of time
  that threads may remain idle before being terminated.
 Threads that wait this amount of time without processing a
  task will be terminated if there are more than the core
  number of threads currently in the pool, or if this pool 
 allows core thread timeout.
  This overrides any value set in the constructor.
 @param time the time to wait.  A time value of zero will cause         excess threads to terminate immediately after executing tasks.
 @param unit the time unit of the <code>time</code>  argument
 @throw IllegalArgumentExceptionif <code>time</code> less than zero or
          if <code>time</code> is zero and <code>allowsCoreThreadTimeOut</code>
 - seealso: #getKeepAliveTime(TimeUnit)
 */
- (void)setKeepAliveTimeWithLong:(jlong)time
  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Sets the maximum allowed number of threads.This overrides any
  value set in the constructor.
 If the new value is smaller than
  the current value, excess existing threads will be
  terminated when they next become idle.
 @param maximumPoolSize the new maximum
 @throw IllegalArgumentExceptionif the new maximum is
          less than or equal to zero, or
          less than the core pool size
 - seealso: #getMaximumPoolSize
 */
- (void)setMaximumPoolSizeWithInt:(jint)maximumPoolSize;

/*!
 @brief Sets a new handler for unexecutable tasks.
 @param handler the new handler
 @throw NullPointerExceptionif handler is null
 - seealso: #getRejectedExecutionHandler
 */
- (void)setRejectedExecutionHandlerWithJavaUtilConcurrentRejectedExecutionHandler:(id<JavaUtilConcurrentRejectedExecutionHandler>)handler;

/*!
 @brief Sets the thread factory used to create new threads.
 @param threadFactory the new thread factory
 @throw NullPointerExceptionif threadFactory is null
 - seealso: #getThreadFactory
 */
- (void)setThreadFactoryWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

/*!
 @brief Initiates an orderly shutdown in which previously submitted
  tasks are executed, but no new tasks will be accepted.
 Invocation has no additional effect if already shut down. 
 <p>This method does not wait for previously submitted tasks to
  complete execution.  Use <code>awaitTermination</code>
  to do that.
 */
- (void)shutdown;

/*!
 @brief Attempts to stop all actively executing tasks, halts the
  processing of waiting tasks, and returns a list of the tasks
  that were awaiting execution.These tasks are drained (removed)
  from the task queue upon return from this method.
 <p>This method does not wait for actively executing tasks to
  terminate.  Use <code>awaitTermination</code> to
  do that. 
 <p>There are no guarantees beyond best-effort attempts to stop
  processing actively executing tasks.  This implementation
  interrupts tasks via <code>Thread.interrupt</code>; any task that
  fails to respond to interrupts may never terminate.
 */
- (id<JavaUtilList>)shutdownNow;

/*!
 @brief Returns a string identifying this pool, as well as its state,
  including indications of run state and estimated worker and
  task counts.
 @return a string identifying this pool, as well as its state
 */
- (NSString *)description;

#pragma mark Protected

/*!
 @brief Method invoked upon completion of execution of the given Runnable.
 This method is invoked by the thread that executed the task. If
  non-null, the Throwable is the uncaught <code>RuntimeException</code>
  or <code>Error</code> that caused execution to terminate abruptly. 
 <p>This implementation does nothing, but may be customized in
  subclasses. Note: To properly nest multiple overridings, subclasses
  should generally invoke <code>super.afterExecute</code> at the
  beginning of this method. 
 <p><b>Note:</b> When actions are enclosed in tasks (such as 
 <code>FutureTask</code>) either explicitly or via methods such as 
 <code>submit</code>, these task objects catch and maintain
  computational exceptions, and so they do not cause abrupt
  termination, and the internal exceptions are <em>not</em>
  passed to this method. If you would like to trap both kinds of
  failures in this method, you can further probe for such cases,
  as in this sample subclass that prints either the direct cause
  or the underlying exception if a task has been aborted: 
 @code
  class ExtendedExecutor extends ThreadPoolExecutor {
    // ...
    protected void afterExecute(Runnable r, Throwable t) {
      super.afterExecute(r, t);
      if (t == null
          && r instanceof Future<?>
          && ((Future<?>)r).isDone()) {
        try {
          Object result = ((Future<?>) r).get();
        } catch (CancellationException ce) {
          t = ce;
        } catch (ExecutionException ee) {
          t = ee.getCause();
        } catch (InterruptedException ie) {
          // ignore/reset
          Thread.currentThread().interrupt();
        }      }
      if (t != null)
        System.out.println(t);
    }  }
 
@endcode
 @param r the runnable that has completed
 @param t the exception that caused termination, or null if  execution completed normally
 */
- (void)afterExecuteWithJavaLangRunnable:(id<JavaLangRunnable>)r
                   withJavaLangThrowable:(JavaLangThrowable *)t;

/*!
 @brief Method invoked prior to executing the given Runnable in the
  given thread.This method is invoked by thread <code>t</code> that
  will execute task <code>r</code>, and may be used to re-initialize
  ThreadLocals, or to perform logging.
 <p>This implementation does nothing, but may be customized in
  subclasses. Note: To properly nest multiple overridings, subclasses
  should generally invoke <code>super.beforeExecute</code> at the end of
  this method.
 @param t the thread that will run task <code>r</code>
 @param r the task that will be executed
 */
- (void)beforeExecuteWithJavaLangThread:(JavaLangThread *)t
                   withJavaLangRunnable:(id<JavaLangRunnable>)r;

/*!
 @brief Invokes <code>shutdown</code> when this executor is no longer
  referenced and it has no threads.
 */
- (void)java_finalize;

/*!
 @brief Method invoked when the Executor has terminated.Default
  implementation does nothing.
 Note: To properly nest multiple
  overridings, subclasses should generally invoke 
 <code>super.terminated</code> within this method.
 */
- (void)terminated;

#pragma mark Package-Private

/*!
 @brief Same as prestartCoreThread except arranges that at least one
  thread is started even if corePoolSize is 0.
 */
- (void)ensurePrestart;

/*!
 @brief State check needed by ScheduledThreadPoolExecutor to
  enable running tasks during shutdown.
 @param shutdownOK true if should return true if SHUTDOWN
 */
- (jboolean)isRunningOrShutdownWithBoolean:(jboolean)shutdownOK;

/*!
 @brief Performs any further cleanup following run state transition on
  invocation of shutdown.A no-op here, but used by
  ScheduledThreadPoolExecutor to cancel delayed tasks.
 */
- (void)onShutdown;

/*!
 @brief Invokes the rejected execution handler for the given command.
 Package-protected for use by ScheduledThreadPoolExecutor.
 */
- (void)rejectWithJavaLangRunnable:(id<JavaLangRunnable>)command;

/*!
 @brief Main worker run loop.Repeatedly gets tasks from queue and
  executes them, while coping with a number of issues:
  1.
 We may start out with an initial task, in which case we
  don't need to get the first one. Otherwise, as long as pool is
  running, we get tasks from getTask. If it returns null then the
  worker exits due to changed pool state or configuration
  parameters.  Other exits result from exception throws in
  external code, in which case completedAbruptly holds, which
  usually leads processWorkerExit to replace this thread.
  2. Before running any task, the lock is acquired to prevent
  other pool interrupts while the task is executing, and then we
  ensure that unless pool is stopping, this thread does not have
  its interrupt set.
  3. Each task run is preceded by a call to beforeExecute, which
  might throw an exception, in which case we cause thread to die
  (breaking loop with completedAbruptly true) without processing
  the task.
  4. Assuming beforeExecute completes normally, we run the task,
  gathering any of its thrown exceptions to send to afterExecute.
  We separately handle RuntimeException, Error (both of which the
  specs guarantee that we trap) and arbitrary Throwables.
  Because we cannot rethrow Throwables within Runnable.run, we
  wrap them within Errors on the way out (to the thread's
  UncaughtExceptionHandler).  Any thrown exception also
  conservatively causes thread to die.
  5. After task.run completes, we call afterExecute, which may
  also throw an exception, which will also cause thread to
  die. According to JLS Sec 14.20, this exception is the one that
  will be in effect even if task.run throws.
  The net effect of the exception mechanics is that afterExecute
  and the thread's UncaughtExceptionHandler have as accurate
  information as we can provide about any problems encountered by
  user code.
 @param w the worker
 */
- (void)runWorkerWithJavaUtilConcurrentThreadPoolExecutor_Worker:(JavaUtilConcurrentThreadPoolExecutor_Worker *)w;

/*!
 @brief Transitions to TERMINATED state if either (SHUTDOWN and pool
  and queue empty) or (STOP and pool empty).If otherwise
  eligible to terminate but workerCount is nonzero, interrupts an
  idle worker to ensure that shutdown signals propagate.
 This
  method must be called following any action that might make
  termination possible -- reducing worker count or removing tasks
  from the queue during shutdown. The method is non-private to
  allow access from ScheduledThreadPoolExecutor.
 */
- (void)tryTerminate;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue);

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentRejectedExecutionHandler_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentRejectedExecutionHandler> handler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_withJavaUtilConcurrentRejectedExecutionHandler_(JavaUtilConcurrentThreadPoolExecutor *self, jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *new_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory, id<JavaUtilConcurrentRejectedExecutionHandler> handler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor *create_JavaUtilConcurrentThreadPoolExecutor_initWithInt_withInt_withLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentBlockingQueue_withJavaUtilConcurrentThreadFactory_withJavaUtilConcurrentRejectedExecutionHandler_(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentBlockingQueue> workQueue, id<JavaUtilConcurrentThreadFactory> threadFactory, id<JavaUtilConcurrentRejectedExecutionHandler> handler);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that runs the rejected task
  directly in the calling thread of the <code>execute</code> method,
  unless the executor has been shut down, in which case the task
  is discarded.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates a <code>CallerRunsPolicy</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Executes task r in the caller's thread, unless the executor
  has been shut down, in which case the task is discarded.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_init(JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy *new_JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy *create_JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_CallerRunsPolicy)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_AbortPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that throws a 
 <code>RejectedExecutionException</code>.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_AbortPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates an <code>AbortPolicy</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Always throws RejectedExecutionException.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 @throw RejectedExecutionExceptionalways
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_AbortPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_init(JavaUtilConcurrentThreadPoolExecutor_AbortPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_AbortPolicy *new_JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_AbortPolicy *create_JavaUtilConcurrentThreadPoolExecutor_AbortPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_AbortPolicy)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that silently discards the
  rejected task.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates a <code>DiscardPolicy</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Does nothing, which has the effect of discarding task r.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_init(JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy *new_JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy *create_JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_DiscardPolicy)

#endif

#if !defined (JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_) && (INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor || defined(INCLUDE_JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy))
#define JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_

#define RESTRICT_JavaUtilConcurrentRejectedExecutionHandler 1
#define INCLUDE_JavaUtilConcurrentRejectedExecutionHandler 1
#include "java/util/concurrent/RejectedExecutionHandler.h"

@class JavaUtilConcurrentThreadPoolExecutor;
@protocol JavaLangRunnable;

/*!
 @brief A handler for rejected tasks that discards the oldest unhandled
  request and then retries <code>execute</code>, unless the executor
  is shut down, in which case the task is discarded.
 */
@interface JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy : NSObject < JavaUtilConcurrentRejectedExecutionHandler >

#pragma mark Public

/*!
 @brief Creates a <code>DiscardOldestPolicy</code> for the given executor.
 */
- (instancetype __nonnull)init;

/*!
 @brief Obtains and ignores the next task that the executor
  would otherwise execute, if one is immediately available,
  and then retries execution of task r, unless the executor
  is shut down, in which case task r is instead discarded.
 @param r the runnable task requested to be executed
 @param e the executor attempting to execute this task
 */
- (void)rejectedExecutionWithJavaLangRunnable:(id<JavaLangRunnable>)r
     withJavaUtilConcurrentThreadPoolExecutor:(JavaUtilConcurrentThreadPoolExecutor *)e;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy)

FOUNDATION_EXPORT void JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_init(JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy *self);

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy *new_JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy *create_JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentThreadPoolExecutor_DiscardOldestPolicy)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentThreadPoolExecutor")
