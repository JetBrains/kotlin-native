//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/CompletableFuture.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentCompletableFuture")
#ifdef RESTRICT_JavaUtilConcurrentCompletableFuture
#define INCLUDE_ALL_JavaUtilConcurrentCompletableFuture 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentCompletableFuture 1
#endif
#undef RESTRICT_JavaUtilConcurrentCompletableFuture
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_MinimalStage
#define INCLUDE_JavaUtilConcurrentCompletableFuture 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_Signaller
#define INCLUDE_JavaUtilConcurrentCompletableFuture_Completion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_AsyncRun
#define INCLUDE_JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_AsyncSupply
#define INCLUDE_JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_OrRelay
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_OrRun
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_OrAccept
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_OrApply
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_BiRelay
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_BiRun
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_BiAccept
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_BiApply
#define INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_CoCompletion
#define INCLUDE_JavaUtilConcurrentCompletableFuture_Completion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompose
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniRelay
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniExceptionally
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniHandle
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniWhenComplete
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniRun
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniAccept
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniApply
#define INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion
#define INCLUDE_JavaUtilConcurrentCompletableFuture_Completion 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentCompletableFuture_Completion
#define INCLUDE_JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentCompletableFuture_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture))
#define JavaUtilConcurrentCompletableFuture_

#define RESTRICT_JavaUtilConcurrentFuture 1
#define INCLUDE_JavaUtilConcurrentFuture 1
#include "java/util/concurrent/Future.h"

#define RESTRICT_JavaUtilConcurrentCompletionStage 1
#define INCLUDE_JavaUtilConcurrentCompletionStage 1
#include "java/util/concurrent/CompletionStage.h"

@class IOSObjectArray;
@class JavaLangThrowable;
@class JavaUtilConcurrentCompletableFuture_AltResult;
@class JavaUtilConcurrentCompletableFuture_BiAccept;
@class JavaUtilConcurrentCompletableFuture_BiApply;
@class JavaUtilConcurrentCompletableFuture_BiCompletion;
@class JavaUtilConcurrentCompletableFuture_BiRun;
@class JavaUtilConcurrentCompletableFuture_Completion;
@class JavaUtilConcurrentCompletableFuture_OrAccept;
@class JavaUtilConcurrentCompletableFuture_OrApply;
@class JavaUtilConcurrentCompletableFuture_OrRun;
@class JavaUtilConcurrentCompletableFuture_UniAccept;
@class JavaUtilConcurrentCompletableFuture_UniApply;
@class JavaUtilConcurrentCompletableFuture_UniCompletion;
@class JavaUtilConcurrentCompletableFuture_UniCompose;
@class JavaUtilConcurrentCompletableFuture_UniExceptionally;
@class JavaUtilConcurrentCompletableFuture_UniHandle;
@class JavaUtilConcurrentCompletableFuture_UniRun;
@class JavaUtilConcurrentCompletableFuture_UniWhenComplete;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionSupplier;

/*!
 @brief A <code>Future</code> that may be explicitly completed (setting its
  value and status), and may be used as a <code>CompletionStage</code>,
  supporting dependent functions and actions that trigger upon its
  completion.
 <p>When two or more threads attempt to 
 <code>complete</code>,
  <code>completeExceptionally</code>, or 
 <code>cancel</code>
  a CompletableFuture, only one of them succeeds. 
 <p>In addition to these and related methods for directly
  manipulating status and results, CompletableFuture implements
  interface <code>CompletionStage</code> with the following policies: <ul>
  
 <li>Actions supplied for dependent completions of 
 <em>non-async</em> methods may be performed by the thread that
  completes the current CompletableFuture, or by any other caller of
  a completion method. 
 <li>All <em>async</em> methods without an explicit Executor
  argument are performed using the <code>ForkJoinPool.commonPool()</code>
  (unless it does not support a parallelism level of at least two, in
  which case, a new Thread is created to run each task).
  To simplify monitoring, debugging,
  and tracking, all generated asynchronous tasks are instances of the
  marker interface <code>AsynchronousCompletionTask</code>.  Operations
  with time-delays can use adapter methods defined in this class, for
  example: <code>supplyAsync(supplier, delayedExecutor(timeout,
  timeUnit))</code>
 .  To support methods with delays and timeouts, this
  class maintains at most one daemon thread for triggering and
  cancelling actions, not for running them. 
 <li>All CompletionStage methods are implemented independently of
  other public methods, so the behavior of one method is not impacted
  by overrides of others in subclasses. 
 </ul>
  
 <p>CompletableFuture also implements <code>Future</code> with the following
  policies: <ul>
  
 <li>Since (unlike <code>FutureTask</code>) this class has no direct
  control over the computation that causes it to be completed,
  cancellation is treated as just another form of exceptional
  completion.  Method <code>cancel</code> has the same effect as 
 <code>completeExceptionally(new CancellationException())</code>. Method 
 <code>isCompletedExceptionally</code> can be used to determine if a
  CompletableFuture completed in any exceptional fashion. 
 <li>In case of exceptional completion with a CompletionException,
  methods <code>get()</code> and <code>get(long, TimeUnit)</code> throw an 
 <code>ExecutionException</code> with the same cause as held in the
  corresponding CompletionException.  To simplify usage in most
  contexts, this class also defines methods <code>join()</code> and 
 <code>getNow</code> that instead throw the CompletionException directly
  in these cases. 
 </ul>
  
 <p>Arguments used to pass a completion result (that is, for
  parameters of type <code>T</code>) for methods accepting them may be
  null, but passing a null value for any other parameter will result
  in a <code>NullPointerException</code> being thrown.
 @author Doug Lea
 @since 1.8
 */
@interface JavaUtilConcurrentCompletableFuture : NSObject < JavaUtilConcurrentFuture, JavaUtilConcurrentCompletionStage > {
 @public
  volatile_id result_;
  volatile_id stack_;
}
@property (readonly, class, strong) JavaUtilConcurrentCompletableFuture_AltResult *NIL NS_SWIFT_NAME(NIL);
@property (readonly, class) jint SYNC NS_SWIFT_NAME(SYNC);
@property (readonly, class) jint ASYNC NS_SWIFT_NAME(ASYNC);
@property (readonly, class) jint NESTED NS_SWIFT_NAME(NESTED);
@property (readonly, class) jint SPINS NS_SWIFT_NAME(SPINS);

+ (JavaUtilConcurrentCompletableFuture_AltResult *)NIL;

+ (jint)SYNC;

+ (jint)ASYNC;

+ (jint)NESTED;

+ (jint)SPINS;

#pragma mark Public

/*!
 @brief Creates a new incomplete CompletableFuture.
 */
- (instancetype __nonnull)init;

- (JavaUtilConcurrentCompletableFuture *)acceptEitherWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                              withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)acceptEitherAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                   withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)acceptEitherAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                   withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action
                                                                 withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns a new CompletableFuture that is completed when all of
  the given CompletableFutures complete.If any of the given
  CompletableFutures complete exceptionally, then the returned
  CompletableFuture also does so, with a CompletionException
  holding this exception as its cause.
 Otherwise, the results,
  if any, of the given CompletableFutures are not reflected in
  the returned CompletableFuture, but may be obtained by
  inspecting them individually. If no CompletableFutures are
  provided, returns a CompletableFuture completed with the value 
 <code>null</code>.
  
 <p>Among the applications of this method is to await completion
  of a set of independent CompletableFutures before continuing a
  program, as in: <code>CompletableFuture.allOf(c1, c2,
  c3).join();</code>
 .
 @param cfs the CompletableFutures
 @return a new CompletableFuture that is completed when all of the
  given CompletableFutures complete
 @throw NullPointerExceptionif the array or any of its elements are 
 <code>null</code>
 */
+ (JavaUtilConcurrentCompletableFuture *)allOfWithJavaUtilConcurrentCompletableFutureArray:(IOSObjectArray *)cfs;

/*!
 @brief Returns a new CompletableFuture that is completed when any of
  the given CompletableFutures complete, with the same result.
 Otherwise, if it completed exceptionally, the returned
  CompletableFuture also does so, with a CompletionException
  holding this exception as its cause.  If no CompletableFutures
  are provided, returns an incomplete CompletableFuture.
 @param cfs the CompletableFutures
 @return a new CompletableFuture that is completed with the
  result or exception of any of the given CompletableFutures when
  one completes
 @throw NullPointerExceptionif the array or any of its elements are 
 <code>null</code>
 */
+ (JavaUtilConcurrentCompletableFuture *)anyOfWithJavaUtilConcurrentCompletableFutureArray:(IOSObjectArray *)cfs;

- (JavaUtilConcurrentCompletableFuture *)applyToEitherWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                               withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)applyToEitherAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                    withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)applyToEitherAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                    withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn
                                                                  withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief If not already completed, completes this CompletableFuture with
  a <code>CancellationException</code>.Dependent CompletableFutures
  that have not already completed will also complete
  exceptionally, with a <code>CompletionException</code> caused by
  this <code>CancellationException</code>.
 @param mayInterruptIfRunning this value has no effect in this  implementation because interrupts are not used to control
   processing.
 @return <code>true</code> if this task is now cancelled
 */
- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

/*!
 @brief If not already completed, sets the value returned by <code>get()</code>
  and related methods to the given value.
 @param value the result value
 @return <code>true</code> if this invocation caused this CompletableFuture
  to transition to a completed state, else <code>false</code>
 */
- (jboolean)completeWithId:(id)value;

/*!
 @brief Completes this CompletableFuture with the result of the given
  Supplier function invoked from an asynchronous task using the
  default executor.
 @param supplier a function returning the value to be used  to complete this CompletableFuture
 @return this CompletableFuture
 @since 9
 */
- (JavaUtilConcurrentCompletableFuture *)completeAsyncWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier;

/*!
 @brief Completes this CompletableFuture with the result of
  the given Supplier function invoked from an asynchronous
  task using the given executor.
 @param supplier a function returning the value to be used  to complete this CompletableFuture
 @param executor the executor to use for asynchronous execution
 @return this CompletableFuture
 @since 9
 */
- (JavaUtilConcurrentCompletableFuture *)completeAsyncWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier
                                                    withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns a new CompletableFuture that is already completed with
  the given value.
 @param value the value
 @return the completed CompletableFuture
 */
+ (JavaUtilConcurrentCompletableFuture *)completedFutureWithId:(id)value;

/*!
 @brief Returns a new CompletionStage that is already completed with
  the given value and supports only those methods in
  interface <code>CompletionStage</code>.
 @param value the value
 @return the completed CompletionStage
 @since 9
 */
+ (id<JavaUtilConcurrentCompletionStage>)completedStageWithId:(id)value;

/*!
 @brief If not already completed, causes invocations of <code>get()</code>
  and related methods to throw the given exception.
 @param ex the exception
 @return <code>true</code> if this invocation caused this CompletableFuture
  to transition to a completed state, else <code>false</code>
 */
- (jboolean)completeExceptionallyWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief Completes this CompletableFuture with the given value if not
  otherwise completed before the given timeout.
 @param value the value to use upon timeout
 @param timeout how long to wait before completing normally         with the given value, in units of 
 <code>unit</code>
 @param unit a <code>TimeUnit</code>  determining how to interpret the
          <code>timeout</code>  parameter
 @return this CompletableFuture
 @since 9
 */
- (JavaUtilConcurrentCompletableFuture *)completeOnTimeoutWithId:(id)value
                                                        withLong:(jlong)timeout
                                  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns a new CompletableFuture that is completed normally with
  the same value as this CompletableFuture when it completes
  normally.If this CompletableFuture completes exceptionally,
  then the returned CompletableFuture completes exceptionally
  with a CompletionException with this exception as cause.
 The
  behavior is equivalent to <code>thenApply(x -> x)</code>. This
  method may be useful as a form of "defensive copying", to
  prevent clients from completing, while still being able to
  arrange dependent actions.
 @return the new CompletableFuture
 @since 9
 */
- (JavaUtilConcurrentCompletableFuture *)copy__ OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns the default Executor used for async methods that do not
  specify an Executor.This class uses the <code>ForkJoinPool.commonPool()</code>
  if it supports more than one
  parallel thread, or else an Executor using one thread per async
  task.
 This method may be overridden in subclasses to return
  an Executor that provides at least one independent thread.
 @return the executor
 @since 9
 */
- (id<JavaUtilConcurrentExecutor>)defaultExecutor;

/*!
 @brief Returns a new Executor that submits a task to the default
  executor after the given delay (or no delay if non-positive).
 Each delay commences upon invocation of the returned executor's 
 <code>execute</code> method.
 @param delay how long to delay, in units of <code>unit</code>
 @param unit a <code>TimeUnit</code>  determining how to interpret the
          <code>delay</code>  parameter
 @return the new delayed executor
 @since 9
 */
+ (id<JavaUtilConcurrentExecutor>)delayedExecutorWithLong:(jlong)delay
                           withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns a new Executor that submits a task to the given base
  executor after the given delay (or no delay if non-positive).
 Each delay commences upon invocation of the returned executor's 
 <code>execute</code> method.
 @param delay how long to delay, in units of <code>unit</code>
 @param unit a <code>TimeUnit</code>  determining how to interpret the
          <code>delay</code>  parameter
 @param executor the base executor
 @return the new delayed executor
 @since 9
 */
+ (id<JavaUtilConcurrentExecutor>)delayedExecutorWithLong:(jlong)delay
                           withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                           withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns a new CompletableFuture that is completed when this
  CompletableFuture completes, with the result of the given
  function of the exception triggering this CompletableFuture's
  completion when it completes exceptionally; otherwise, if this
  CompletableFuture completes normally, then the returned
  CompletableFuture also completes normally with the same value.
 Note: More flexible versions of this functionality are
  available using methods <code>whenComplete</code> and <code>handle</code>.
 @param fn the function to use to compute the value of the  returned CompletableFuture if this CompletableFuture completed
   exceptionally
 @return the new CompletableFuture
 */
- (JavaUtilConcurrentCompletableFuture *)exceptionallyWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

/*!
 @brief Returns a new CompletableFuture that is already completed
  exceptionally with the given exception.
 @param ex the exception
 @return the exceptionally completed CompletableFuture
 @since 9
 */
+ (JavaUtilConcurrentCompletableFuture *)failedFutureWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief Returns a new CompletionStage that is already completed
  exceptionally with the given exception and supports only those
  methods in interface <code>CompletionStage</code>.
 @param ex the exception
 @return the exceptionally completed CompletionStage
 @since 9
 */
+ (id<JavaUtilConcurrentCompletionStage>)failedStageWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief Waits if necessary for this future to complete, and then
  returns its result.
 @return the result value
 @throw CancellationExceptionif this future was cancelled
 @throw ExecutionExceptionif this future completed exceptionally
 @throw InterruptedExceptionif the current thread was interrupted
  while waiting
 */
- (id)get;

/*!
 @brief Waits if necessary for at most the given time for this future
  to complete, and then returns its result, if available.
 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @return the result value
 @throw CancellationExceptionif this future was cancelled
 @throw ExecutionExceptionif this future completed exceptionally
 @throw InterruptedExceptionif the current thread was interrupted
  while waiting
 @throw TimeoutExceptionif the wait timed out
 */
- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns the result value (or throws any encountered exception)
  if completed, else returns the given valueIfAbsent.
 @param valueIfAbsent the value to return if not completed
 @return the result value, if completed, else the given valueIfAbsent
 @throw CancellationExceptionif the computation was cancelled
 @throw CompletionExceptionif this future completed
  exceptionally or a completion computation threw an exception
 */
- (id)getNowWithId:(id)valueIfAbsent;

/*!
 @brief Returns the estimated number of CompletableFutures whose
  completions are awaiting completion of this CompletableFuture.
 This method is designed for use in monitoring system state, not
  for synchronization control.
 @return the number of dependent CompletableFutures
 */
- (jint)getNumberOfDependents;

- (JavaUtilConcurrentCompletableFuture *)handleWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)handleAsyncWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)handleAsyncWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn
                                                    withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns <code>true</code> if this CompletableFuture was cancelled
  before it completed normally.
 @return <code>true</code> if this CompletableFuture was cancelled
  before it completed normally
 */
- (jboolean)isCancelled;

/*!
 @brief Returns <code>true</code> if this CompletableFuture completed
  exceptionally, in any way.Possible causes include
  cancellation, explicit invocation of <code>completeExceptionally</code>
 , and abrupt termination of a
  CompletionStage action.
 @return <code>true</code> if this CompletableFuture completed
  exceptionally
 */
- (jboolean)isCompletedExceptionally;

/*!
 @brief Returns <code>true</code> if completed in any fashion: normally,
  exceptionally, or via cancellation.
 @return <code>true</code> if completed
 */
- (jboolean)isDone;

/*!
 @brief Returns the result value when complete, or throws an
  (unchecked) exception if completed exceptionally.To better
  conform with the use of common functional forms, if a
  computation involved in the completion of this
  CompletableFuture threw an exception, this method throws an
  (unchecked) <code>CompletionException</code> with the underlying
  exception as its cause.
 @return the result value
 @throw CancellationExceptionif the computation was cancelled
 @throw CompletionExceptionif this future completed
  exceptionally or a completion computation threw an exception
 */
- (id)join;

/*!
 @brief Returns a new CompletionStage that is completed normally with
  the same value as this CompletableFuture when it completes
  normally, and cannot be independently completed or otherwise
  used in ways not defined by the methods of interface <code>CompletionStage</code>
 .If this CompletableFuture completes
  exceptionally, then the returned CompletionStage completes
  exceptionally with a CompletionException with this exception as
  cause.
 @return the new CompletionStage
 @since 9
 */
- (id<JavaUtilConcurrentCompletionStage>)minimalCompletionStage;

/*!
 @brief Returns a new incomplete CompletableFuture of the type to be
  returned by a CompletionStage method.Subclasses should
  normally override this method to return an instance of the same
  class as this CompletableFuture.
 The default implementation
  returns an instance of class CompletableFuture.
 @return a new CompletableFuture
 @since 9
 */
- (JavaUtilConcurrentCompletableFuture *)newIncompleteFuture OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Forcibly causes subsequent invocations of method <code>get()</code>
  and related methods to throw the given exception, whether or
  not already completed.This method is designed for use only in
  error recovery actions, and even in such situations may result
  in ongoing dependent completions using established versus
  overwritten outcomes.
 @param ex the exception
 @throw NullPointerExceptionif the exception is null
 */
- (void)obtrudeExceptionWithJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief Forcibly sets or resets the value subsequently returned by
  method <code>get()</code> and related methods, whether or not
  already completed.This method is designed for use only in
  error recovery actions, and even in such situations may result
  in ongoing dependent completions using established versus
  overwritten outcomes.
 @param value the completion value
 */
- (void)obtrudeValueWithId:(id)value;

/*!
 @brief Exceptionally completes this CompletableFuture with
  a <code>TimeoutException</code> if not otherwise completed
  before the given timeout.
 @param timeout how long to wait before completing exceptionally         with a TimeoutException, in units of 
 <code>unit</code>
 @param unit a <code>TimeUnit</code>  determining how to interpret the
          <code>timeout</code>  parameter
 @return this CompletableFuture
 @since 9
 */
- (JavaUtilConcurrentCompletableFuture *)orTimeoutWithLong:(jlong)timeout
                            withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (JavaUtilConcurrentCompletableFuture *)runAfterBothWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                      withJavaLangRunnable:(id<JavaLangRunnable>)action;

- (JavaUtilConcurrentCompletableFuture *)runAfterBothAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                           withJavaLangRunnable:(id<JavaLangRunnable>)action;

- (JavaUtilConcurrentCompletableFuture *)runAfterBothAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                           withJavaLangRunnable:(id<JavaLangRunnable>)action
                                                                 withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)runAfterEitherWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                        withJavaLangRunnable:(id<JavaLangRunnable>)action;

- (JavaUtilConcurrentCompletableFuture *)runAfterEitherAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                             withJavaLangRunnable:(id<JavaLangRunnable>)action;

- (JavaUtilConcurrentCompletableFuture *)runAfterEitherAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                             withJavaLangRunnable:(id<JavaLangRunnable>)action
                                                                   withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns a new CompletableFuture that is asynchronously completed
  by a task running in the <code>ForkJoinPool.commonPool()</code> after
  it runs the given action.
 @param runnable the action to run before completing the  returned CompletableFuture
 @return the new CompletableFuture
 */
+ (JavaUtilConcurrentCompletableFuture *)runAsyncWithJavaLangRunnable:(id<JavaLangRunnable>)runnable;

/*!
 @brief Returns a new CompletableFuture that is asynchronously completed
  by a task running in the given executor after it runs the given
  action.
 @param runnable the action to run before completing the  returned CompletableFuture
 @param executor the executor to use for asynchronous execution
 @return the new CompletableFuture
 */
+ (JavaUtilConcurrentCompletableFuture *)runAsyncWithJavaLangRunnable:(id<JavaLangRunnable>)runnable
                                       withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns a new CompletableFuture that is asynchronously completed
  by a task running in the <code>ForkJoinPool.commonPool()</code> with
  the value obtained by calling the given Supplier.
 @param supplier a function returning the value to be used  to complete the returned CompletableFuture
 @return the new CompletableFuture
 */
+ (JavaUtilConcurrentCompletableFuture *)supplyAsyncWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier;

/*!
 @brief Returns a new CompletableFuture that is asynchronously completed
  by a task running in the given executor with the value obtained
  by calling the given Supplier.
 @param supplier a function returning the value to be used  to complete the returned CompletableFuture
 @param executor the executor to use for asynchronous execution
 @return the new CompletableFuture
 */
+ (JavaUtilConcurrentCompletableFuture *)supplyAsyncWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier
                                                  withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)thenAcceptWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)thenAcceptAsyncWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)thenAcceptAsyncWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action
                                                      withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)thenAcceptBothWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                              withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)thenAcceptBothAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                   withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)thenAcceptBothAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                   withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action
                                                                   withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)thenApplyWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)thenApplyAsyncWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)thenApplyAsyncWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn
                                                     withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)thenCombineWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                           withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)thenCombineAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)thenCombineAsyncWithJavaUtilConcurrentCompletionStage:(id<JavaUtilConcurrentCompletionStage>)other
                                                                withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn
                                                                withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)thenComposeWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)thenComposeAsyncWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)thenComposeAsyncWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn
                                                       withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (JavaUtilConcurrentCompletableFuture *)thenRunWithJavaLangRunnable:(id<JavaLangRunnable>)action;

- (JavaUtilConcurrentCompletableFuture *)thenRunAsyncWithJavaLangRunnable:(id<JavaLangRunnable>)action;

- (JavaUtilConcurrentCompletableFuture *)thenRunAsyncWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                           withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Returns this CompletableFuture.
 @return this CompletableFuture
 */
- (JavaUtilConcurrentCompletableFuture *)toCompletableFuture;

/*!
 @brief Returns a string identifying this CompletableFuture, as well as
  its completion state.The state, in brackets, contains the
  String <code>"Completed Normally"</code> or the String <code>"Completed Exceptionally"</code>
 , or the String <code>"Not
  completed"</code>
  followed by the number of CompletableFutures
  dependent upon its completion, if any.
 @return a string identifying this CompletableFuture, as well as its state
 */
- (NSString *)description;

- (JavaUtilConcurrentCompletableFuture *)whenCompleteWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)whenCompleteAsyncWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (JavaUtilConcurrentCompletableFuture *)whenCompleteAsyncWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action
                                                          withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

#pragma mark Package-Private

/*!
 @brief Creates a new complete CompletableFuture with given encoded result.
 */
- (instancetype __nonnull)initWithId:(id)r;

/*!
 @brief Recursively constructs a tree of completions.
 */
+ (JavaUtilConcurrentCompletableFuture *)andTreeWithJavaUtilConcurrentCompletableFutureArray:(IOSObjectArray *)cfs
                                                                                     withInt:(jint)lo
                                                                                     withInt:(jint)hi;

+ (JavaUtilConcurrentCompletableFuture *)asyncRunStageWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)e
                                                                withJavaLangRunnable:(id<JavaLangRunnable>)f;

+ (JavaUtilConcurrentCompletableFuture *)asyncSupplyStageWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)e
                                                           withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)f;

- (jboolean)biAcceptWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                    withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                             withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)f
           withJavaUtilConcurrentCompletableFuture_BiAccept:(JavaUtilConcurrentCompletableFuture_BiAccept *)c;

- (jboolean)biApplyWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                   withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                            withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)f
           withJavaUtilConcurrentCompletableFuture_BiApply:(JavaUtilConcurrentCompletableFuture_BiApply *)c;

/*!
 @brief Pushes completion to this and b unless both done.
 */
- (void)bipushWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
 withJavaUtilConcurrentCompletableFuture_BiCompletion:(JavaUtilConcurrentCompletableFuture_BiCompletion *)c;

- (jboolean)biRelayWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                   withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b;

- (jboolean)biRunWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                 withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                                    withJavaLangRunnable:(id<JavaLangRunnable>)f
           withJavaUtilConcurrentCompletableFuture_BiRun:(JavaUtilConcurrentCompletableFuture_BiRun *)c;

- (jboolean)casStackWithJavaUtilConcurrentCompletableFuture_Completion:(JavaUtilConcurrentCompletableFuture_Completion *)cmp
                    withJavaUtilConcurrentCompletableFuture_Completion:(JavaUtilConcurrentCompletableFuture_Completion *)val;

/*!
 @brief Traverses stack and unlinks dead Completions.
 */
- (void)cleanStack;

/*!
 @brief Completes with the null value, unless already completed.
 */
- (jboolean)completeNull;

/*!
 @brief Completes with r or a copy of r, unless already completed.
 If exceptional, r is first coerced to a CompletionException.
 */
- (jboolean)completeRelayWithId:(id)r;

/*!
 @brief Completes with an exceptional result, unless already completed.
 */
- (jboolean)completeThrowableWithJavaLangThrowable:(JavaLangThrowable *)x;

/*!
 @brief Completes with the given (non-null) exceptional result as a
  wrapped CompletionException unless it is one already, unless
  already completed.May complete with the given Object r
  (which must have been the result of a source future) if it is
  equivalent, i.e. if this is a simple propagation of an
  existing CompletionException.
 */
- (jboolean)completeThrowableWithJavaLangThrowable:(JavaLangThrowable *)x
                                            withId:(id)r;

/*!
 @brief Completes with a non-exceptional result, unless already completed.
 */
- (jboolean)completeValueWithId:(id)t;

/*!
 @brief Returns the encoding of the given arguments: if the exception
  is non-null, encodes as AltResult.Otherwise uses the given
  value, boxed as NIL if null.
 */
- (id)encodeOutcomeWithId:(id)t
    withJavaLangThrowable:(JavaLangThrowable *)x;

/*!
 @brief Returns the encoding of a copied outcome; if exceptional,
  rewraps as a CompletionException, else returns argument.
 */
+ (id)encodeRelayWithId:(id)r;

/*!
 @brief Returns the encoding of the given (non-null) exception as a
  wrapped CompletionException unless it is one already.
 */
+ (JavaUtilConcurrentCompletableFuture_AltResult *)encodeThrowableWithJavaLangThrowable:(JavaLangThrowable *)x;

/*!
 @brief Returns the encoding of the given (non-null) exception as a
  wrapped CompletionException unless it is one already.May
  return the given Object r (which must have been the result of a
  source future) if it is equivalent, i.e. if this is a simple
  relay of an existing CompletionException.
 */
+ (id)encodeThrowableWithJavaLangThrowable:(JavaLangThrowable *)x
                                    withId:(id)r;

/*!
 @brief Returns the encoding of the given non-exceptional value.
 */
- (id)encodeValueWithId:(id)t;

- (jboolean)internalCompleteWithId:(id)r;

+ (void)lazySetNextWithJavaUtilConcurrentCompletableFuture_Completion:(JavaUtilConcurrentCompletableFuture_Completion *)c
                   withJavaUtilConcurrentCompletableFuture_Completion:(JavaUtilConcurrentCompletableFuture_Completion *)next;

- (jboolean)orAcceptWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                    withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                               withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)f
           withJavaUtilConcurrentCompletableFuture_OrAccept:(JavaUtilConcurrentCompletableFuture_OrAccept *)c;

- (jboolean)orApplyWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                   withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                              withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)f
           withJavaUtilConcurrentCompletableFuture_OrApply:(JavaUtilConcurrentCompletableFuture_OrApply *)c;

/*!
 @brief Pushes completion to this and b unless either done.
 */
- (void)orpushWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
 withJavaUtilConcurrentCompletableFuture_BiCompletion:(JavaUtilConcurrentCompletableFuture_BiCompletion *)c;

- (jboolean)orRelayWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                   withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b;

- (jboolean)orRunWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                 withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                                    withJavaLangRunnable:(id<JavaLangRunnable>)f
           withJavaUtilConcurrentCompletableFuture_OrRun:(JavaUtilConcurrentCompletableFuture_OrRun *)c;

/*!
 @brief Recursively constructs a tree of completions.
 */
+ (JavaUtilConcurrentCompletableFuture *)orTreeWithJavaUtilConcurrentCompletableFutureArray:(IOSObjectArray *)cfs
                                                                                    withInt:(jint)lo
                                                                                    withInt:(jint)hi;

/*!
 @brief Pops and tries to trigger all reachable dependents.Call only
  when known to be done.
 */
- (void)postComplete;

/*!
 @brief Post-processing after successful BiCompletion tryFire.
 */
- (JavaUtilConcurrentCompletableFuture *)postFireWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                                 withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)b
                                                                                 withInt:(jint)mode;

/*!
 @brief Post-processing by dependent after successful UniCompletion
  tryFire.Tries to clean stack of source a, and then either runs
  postComplete or returns this to caller, depending on mode.
 */
- (JavaUtilConcurrentCompletableFuture *)postFireWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                                                                 withInt:(jint)mode;

/*!
 @brief Pushes the given completion (if it exists) unless done.
 */
- (void)pushWithJavaUtilConcurrentCompletableFuture_UniCompletion:(JavaUtilConcurrentCompletableFuture_UniCompletion *)c;

/*!
 @brief Unconditionally pushes c onto stack, retrying if necessary.
 */
- (void)pushStackWithJavaUtilConcurrentCompletableFuture_Completion:(JavaUtilConcurrentCompletableFuture_Completion *)c;

/*!
 @brief Null-checks user executor argument, and translates uses of
  commonPool to ASYNC_POOL in case parallelism disabled.
 */
+ (id<JavaUtilConcurrentExecutor>)screenExecutorWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)e;

/*!
 @brief Returns true if successfully pushed c onto stack.
 */
- (jboolean)tryPushStackWithJavaUtilConcurrentCompletableFuture_Completion:(JavaUtilConcurrentCompletableFuture_Completion *)c;

- (jboolean)uniAcceptWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)f
           withJavaUtilConcurrentCompletableFuture_UniAccept:(JavaUtilConcurrentCompletableFuture_UniAccept *)c;

- (jboolean)uniApplyWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                               withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)f
           withJavaUtilConcurrentCompletableFuture_UniApply:(JavaUtilConcurrentCompletableFuture_UniApply *)c;

- (jboolean)uniComposeWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                 withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)f
           withJavaUtilConcurrentCompletableFuture_UniCompose:(JavaUtilConcurrentCompletableFuture_UniCompose *)c;

- (jboolean)uniExceptionallyWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                       withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)f
           withJavaUtilConcurrentCompletableFuture_UniExceptionally:(JavaUtilConcurrentCompletableFuture_UniExceptionally *)c;

- (jboolean)uniHandleWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                              withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)f
           withJavaUtilConcurrentCompletableFuture_UniHandle:(JavaUtilConcurrentCompletableFuture_UniHandle *)c;

- (jboolean)uniRelayWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a;

- (jboolean)uniRunWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                     withJavaLangRunnable:(id<JavaLangRunnable>)f
           withJavaUtilConcurrentCompletableFuture_UniRun:(JavaUtilConcurrentCompletableFuture_UniRun *)c;

- (jboolean)uniWhenCompleteWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)a
                                    withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)f
           withJavaUtilConcurrentCompletableFuture_UniWhenComplete:(JavaUtilConcurrentCompletableFuture_UniWhenComplete *)c;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentCompletableFuture)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture, result_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture, stack_, JavaUtilConcurrentCompletableFuture_Completion *)

/*!
 @brief The encoding of the null value.
 */
inline JavaUtilConcurrentCompletableFuture_AltResult *JavaUtilConcurrentCompletableFuture_get_NIL(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AltResult *JavaUtilConcurrentCompletableFuture_NIL;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentCompletableFuture, NIL, JavaUtilConcurrentCompletableFuture_AltResult *)

inline jint JavaUtilConcurrentCompletableFuture_get_SYNC(void);
#define JavaUtilConcurrentCompletableFuture_SYNC 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentCompletableFuture, SYNC, jint)

inline jint JavaUtilConcurrentCompletableFuture_get_ASYNC(void);
#define JavaUtilConcurrentCompletableFuture_ASYNC 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentCompletableFuture, ASYNC, jint)

inline jint JavaUtilConcurrentCompletableFuture_get_NESTED(void);
#define JavaUtilConcurrentCompletableFuture_NESTED -1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentCompletableFuture, NESTED, jint)

/*!
 @brief Spins before blocking in waitingGet
 */
inline jint JavaUtilConcurrentCompletableFuture_get_SPINS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint JavaUtilConcurrentCompletableFuture_SPINS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentCompletableFuture, SPINS, jint)

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AltResult *JavaUtilConcurrentCompletableFuture_encodeThrowableWithJavaLangThrowable_(JavaLangThrowable *x);

FOUNDATION_EXPORT id JavaUtilConcurrentCompletableFuture_encodeThrowableWithJavaLangThrowable_withId_(JavaLangThrowable *x, id r);

FOUNDATION_EXPORT id JavaUtilConcurrentCompletableFuture_encodeRelayWithId_(id r);

FOUNDATION_EXPORT id<JavaUtilConcurrentExecutor> JavaUtilConcurrentCompletableFuture_screenExecutorWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> e);

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_lazySetNextWithJavaUtilConcurrentCompletableFuture_Completion_withJavaUtilConcurrentCompletableFuture_Completion_(JavaUtilConcurrentCompletableFuture_Completion *c, JavaUtilConcurrentCompletableFuture_Completion *next);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_andTreeWithJavaUtilConcurrentCompletableFutureArray_withInt_withInt_(IOSObjectArray *cfs, jint lo, jint hi);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_orTreeWithJavaUtilConcurrentCompletableFutureArray_withInt_withInt_(IOSObjectArray *cfs, jint lo, jint hi);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_asyncSupplyStageWithJavaUtilConcurrentExecutor_withJavaUtilFunctionSupplier_(id<JavaUtilConcurrentExecutor> e, id<JavaUtilFunctionSupplier> f);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_asyncRunStageWithJavaUtilConcurrentExecutor_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> e, id<JavaLangRunnable> f);

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_init(JavaUtilConcurrentCompletableFuture *self);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *new_JavaUtilConcurrentCompletableFuture_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *create_JavaUtilConcurrentCompletableFuture_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_initWithId_(JavaUtilConcurrentCompletableFuture *self, id r);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *new_JavaUtilConcurrentCompletableFuture_initWithId_(id r) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *create_JavaUtilConcurrentCompletableFuture_initWithId_(id r);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_supplyAsyncWithJavaUtilFunctionSupplier_(id<JavaUtilFunctionSupplier> supplier);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_supplyAsyncWithJavaUtilFunctionSupplier_withJavaUtilConcurrentExecutor_(id<JavaUtilFunctionSupplier> supplier, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_runAsyncWithJavaLangRunnable_(id<JavaLangRunnable> runnable);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_runAsyncWithJavaLangRunnable_withJavaUtilConcurrentExecutor_(id<JavaLangRunnable> runnable, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_completedFutureWithId_(id value);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_allOfWithJavaUtilConcurrentCompletableFutureArray_(IOSObjectArray *cfs);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_anyOfWithJavaUtilConcurrentCompletableFutureArray_(IOSObjectArray *cfs);

FOUNDATION_EXPORT id<JavaUtilConcurrentExecutor> JavaUtilConcurrentCompletableFuture_delayedExecutorWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentExecutor_(jlong delay, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT id<JavaUtilConcurrentExecutor> JavaUtilConcurrentCompletableFuture_delayedExecutorWithLong_withJavaUtilConcurrentTimeUnit_(jlong delay, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT id<JavaUtilConcurrentCompletionStage> JavaUtilConcurrentCompletableFuture_completedStageWithId_(id value);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture *JavaUtilConcurrentCompletableFuture_failedFutureWithJavaLangThrowable_(JavaLangThrowable *ex);

FOUNDATION_EXPORT id<JavaUtilConcurrentCompletionStage> JavaUtilConcurrentCompletableFuture_failedStageWithJavaLangThrowable_(JavaLangThrowable *ex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_AltResult_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_AltResult))
#define JavaUtilConcurrentCompletableFuture_AltResult_

@class JavaLangThrowable;

@interface JavaUtilConcurrentCompletableFuture_AltResult : NSObject {
 @public
  JavaLangThrowable *ex_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaLangThrowable:(JavaLangThrowable *)x;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_AltResult)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_AltResult, ex_, JavaLangThrowable *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_AltResult_initWithJavaLangThrowable_(JavaUtilConcurrentCompletableFuture_AltResult *self, JavaLangThrowable *x);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AltResult *new_JavaUtilConcurrentCompletableFuture_AltResult_initWithJavaLangThrowable_(JavaLangThrowable *x) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AltResult *create_JavaUtilConcurrentCompletableFuture_AltResult_initWithJavaLangThrowable_(JavaLangThrowable *x);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_AltResult)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask))
#define JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask_

/*!
 @brief A marker interface identifying asynchronous tasks produced by 
 <code>async</code> methods.This may be useful for monitoring,
  debugging, and tracking asynchronous activities.
 @since 1.8
 */
@protocol JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask < JavaObject >

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask)

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor))
#define JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor_

#define RESTRICT_JavaUtilConcurrentExecutor 1
#define INCLUDE_JavaUtilConcurrentExecutor 1
#include "java/util/concurrent/Executor.h"

@protocol JavaLangRunnable;

/*!
 @brief Fallback if ForkJoinPool.commonPool() cannot support parallelism
 */
@interface JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor : NSObject < JavaUtilConcurrentExecutor >

#pragma mark Public

- (void)executeWithJavaLangRunnable:(id<JavaLangRunnable>)r;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor_init(JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor *self);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor *new_JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor *create_JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_ThreadPerTaskExecutor)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_Completion_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_Completion))
#define JavaUtilConcurrentCompletableFuture_Completion_

#define RESTRICT_JavaUtilConcurrentForkJoinTask 1
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#include "java/util/concurrent/ForkJoinTask.h"

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;

@interface JavaUtilConcurrentCompletableFuture_Completion : JavaUtilConcurrentForkJoinTask < JavaLangRunnable, JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask > {
 @public
  volatile_id next_;
}

#pragma mark Public

- (jboolean)exec;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

- (void)run;

- (void)setRawResultWithId:(JavaLangVoid *)v;

#pragma mark Package-Private

- (instancetype __nonnull)init;

/*!
 @brief Returns true if possibly still triggerable.Used by cleanStack.
 */
- (jboolean)isLive;

/*!
 @brief Performs completion action if triggered, returning a
  dependent that may need propagation, if one exists.
 @param mode SYNC, ASYNC, or NESTED
 */
- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_Completion)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_Completion, next_, JavaUtilConcurrentCompletableFuture_Completion *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_Completion_init(JavaUtilConcurrentCompletableFuture_Completion *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_Completion)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniCompletion_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompletion))
#define JavaUtilConcurrentCompletableFuture_UniCompletion_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A Completion with a source, dependent, and executor.
 */
@interface JavaUtilConcurrentCompletableFuture_UniCompletion : JavaUtilConcurrentCompletableFuture_Completion {
 @public
  volatile_id executor_;
  volatile_id dep_;
  volatile_id src_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src;

/*!
 @brief Returns true if action can be run.Call only when known to
  be triggerable.
 Uses FJ tag bit to ensure that only one
  thread claims ownership.  If async, starts as task -- a
  later call to tryFire will run action.
 */
- (jboolean)claim;

- (jboolean)isLive;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniCompletion)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniCompletion, executor_, id<JavaUtilConcurrentExecutor>)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniCompletion, dep_, JavaUtilConcurrentCompletableFuture *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniCompletion, src_, JavaUtilConcurrentCompletableFuture *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniCompletion_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture_UniCompletion *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniCompletion)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniApply_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniApply))
#define JavaUtilConcurrentCompletableFuture_UniApply_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentCompletableFuture_UniApply : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                                withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniApply)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniApply, fn_, id<JavaUtilFunctionFunction>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(JavaUtilConcurrentCompletableFuture_UniApply *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniApply *new_JavaUtilConcurrentCompletableFuture_UniApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniApply *create_JavaUtilConcurrentCompletableFuture_UniApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniApply)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniAccept_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniAccept))
#define JavaUtilConcurrentCompletableFuture_UniAccept_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentCompletableFuture_UniAccept : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                                withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniAccept)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniAccept, fn_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionConsumer_(JavaUtilConcurrentCompletableFuture_UniAccept *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionConsumer> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniAccept *new_JavaUtilConcurrentCompletableFuture_UniAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionConsumer> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniAccept *create_JavaUtilConcurrentCompletableFuture_UniAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionConsumer> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniAccept)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniRun_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniRun))
#define JavaUtilConcurrentCompletableFuture_UniRun_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;

@interface JavaUtilConcurrentCompletableFuture_UniRun : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                                        withJavaLangRunnable:(id<JavaLangRunnable>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniRun)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniRun, fn_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture_UniRun *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaLangRunnable> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniRun *new_JavaUtilConcurrentCompletableFuture_UniRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaLangRunnable> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniRun *create_JavaUtilConcurrentCompletableFuture_UniRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaLangRunnable> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniRun)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniWhenComplete_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniWhenComplete))
#define JavaUtilConcurrentCompletableFuture_UniWhenComplete_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionBiConsumer;

@interface JavaUtilConcurrentCompletableFuture_UniWhenComplete : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                              withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniWhenComplete)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniWhenComplete, fn_, id<JavaUtilFunctionBiConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniWhenComplete_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiConsumer_(JavaUtilConcurrentCompletableFuture_UniWhenComplete *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionBiConsumer> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniWhenComplete *new_JavaUtilConcurrentCompletableFuture_UniWhenComplete_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionBiConsumer> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniWhenComplete *create_JavaUtilConcurrentCompletableFuture_UniWhenComplete_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionBiConsumer> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniWhenComplete)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniHandle_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniHandle))
#define JavaUtilConcurrentCompletableFuture_UniHandle_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionBiFunction;

@interface JavaUtilConcurrentCompletableFuture_UniHandle : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                              withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniHandle)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniHandle, fn_, id<JavaUtilFunctionBiFunction>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniHandle_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentCompletableFuture_UniHandle *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionBiFunction> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniHandle *new_JavaUtilConcurrentCompletableFuture_UniHandle_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionBiFunction> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniHandle *create_JavaUtilConcurrentCompletableFuture_UniHandle_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionBiFunction> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniHandle)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniExceptionally_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniExceptionally))
#define JavaUtilConcurrentCompletableFuture_UniExceptionally_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentCompletableFuture_UniExceptionally : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                              withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                                         withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniExceptionally)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniExceptionally, fn_, id<JavaUtilFunctionFunction>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniExceptionally_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(JavaUtilConcurrentCompletableFuture_UniExceptionally *self, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniExceptionally *new_JavaUtilConcurrentCompletableFuture_UniExceptionally_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniExceptionally *create_JavaUtilConcurrentCompletableFuture_UniExceptionally_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniExceptionally)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniRelay_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniRelay))
#define JavaUtilConcurrentCompletableFuture_UniRelay_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;

@interface JavaUtilConcurrentCompletableFuture_UniRelay : JavaUtilConcurrentCompletableFuture_UniCompletion

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                              withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniRelay)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture_UniRelay *self, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniRelay *new_JavaUtilConcurrentCompletableFuture_UniRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniRelay *create_JavaUtilConcurrentCompletableFuture_UniRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniRelay)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_UniCompose_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_UniCompose))
#define JavaUtilConcurrentCompletableFuture_UniCompose_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentCompletableFuture_UniCompose : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                                withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_UniCompose)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_UniCompose, fn_, id<JavaUtilFunctionFunction>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_UniCompose_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(JavaUtilConcurrentCompletableFuture_UniCompose *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniCompose *new_JavaUtilConcurrentCompletableFuture_UniCompose_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_UniCompose *create_JavaUtilConcurrentCompletableFuture_UniCompose_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, id<JavaUtilFunctionFunction> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_UniCompose)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_BiCompletion_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_BiCompletion))
#define JavaUtilConcurrentCompletableFuture_BiCompletion_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A Completion for an action with two sources
 */
@interface JavaUtilConcurrentCompletableFuture_BiCompletion : JavaUtilConcurrentCompletableFuture_UniCompletion {
 @public
  volatile_id snd_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_BiCompletion)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_BiCompletion, snd_, JavaUtilConcurrentCompletableFuture *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_BiCompletion_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture_BiCompletion *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_BiCompletion)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_CoCompletion_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_CoCompletion))
#define JavaUtilConcurrentCompletableFuture_CoCompletion_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentCompletableFuture_BiCompletion;
@class JavaUtilConcurrentTimeUnit;

/*!
 @brief A Completion delegating to a BiCompletion
 */
@interface JavaUtilConcurrentCompletableFuture_CoCompletion : JavaUtilConcurrentCompletableFuture_Completion {
 @public
  volatile_id base_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture_BiCompletion:(JavaUtilConcurrentCompletableFuture_BiCompletion *)base;

- (jboolean)isLive;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_CoCompletion)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_CoCompletion, base_, JavaUtilConcurrentCompletableFuture_BiCompletion *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_CoCompletion_initWithJavaUtilConcurrentCompletableFuture_BiCompletion_(JavaUtilConcurrentCompletableFuture_CoCompletion *self, JavaUtilConcurrentCompletableFuture_BiCompletion *base);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_CoCompletion *new_JavaUtilConcurrentCompletableFuture_CoCompletion_initWithJavaUtilConcurrentCompletableFuture_BiCompletion_(JavaUtilConcurrentCompletableFuture_BiCompletion *base) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_CoCompletion *create_JavaUtilConcurrentCompletableFuture_CoCompletion_initWithJavaUtilConcurrentCompletableFuture_BiCompletion_(JavaUtilConcurrentCompletableFuture_BiCompletion *base);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_CoCompletion)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_BiApply_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_BiApply))
#define JavaUtilConcurrentCompletableFuture_BiApply_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionBiFunction;

@interface JavaUtilConcurrentCompletableFuture_BiApply : JavaUtilConcurrentCompletableFuture_BiCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd
                              withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_BiApply)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_BiApply, fn_, id<JavaUtilFunctionBiFunction>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_BiApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiFunction_(JavaUtilConcurrentCompletableFuture_BiApply *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionBiFunction> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiApply *new_JavaUtilConcurrentCompletableFuture_BiApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionBiFunction> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiApply *create_JavaUtilConcurrentCompletableFuture_BiApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionBiFunction> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_BiApply)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_BiAccept_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_BiAccept))
#define JavaUtilConcurrentCompletableFuture_BiAccept_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionBiConsumer;

@interface JavaUtilConcurrentCompletableFuture_BiAccept : JavaUtilConcurrentCompletableFuture_BiCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd
                              withJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_BiAccept)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_BiAccept, fn_, id<JavaUtilFunctionBiConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_BiAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiConsumer_(JavaUtilConcurrentCompletableFuture_BiAccept *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionBiConsumer> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiAccept *new_JavaUtilConcurrentCompletableFuture_BiAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionBiConsumer> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiAccept *create_JavaUtilConcurrentCompletableFuture_BiAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionBiConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionBiConsumer> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_BiAccept)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_BiRun_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_BiRun))
#define JavaUtilConcurrentCompletableFuture_BiRun_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;

@interface JavaUtilConcurrentCompletableFuture_BiRun : JavaUtilConcurrentCompletableFuture_BiCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd
                                        withJavaLangRunnable:(id<JavaLangRunnable>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_BiRun)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_BiRun, fn_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_BiRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture_BiRun *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaLangRunnable> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiRun *new_JavaUtilConcurrentCompletableFuture_BiRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaLangRunnable> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiRun *create_JavaUtilConcurrentCompletableFuture_BiRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaLangRunnable> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_BiRun)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_BiRelay_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_BiRelay))
#define JavaUtilConcurrentCompletableFuture_BiRelay_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;

@interface JavaUtilConcurrentCompletableFuture_BiRelay : JavaUtilConcurrentCompletableFuture_BiCompletion

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                              withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                              withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_BiRelay)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_BiRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture_BiRelay *self, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiRelay *new_JavaUtilConcurrentCompletableFuture_BiRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_BiRelay *create_JavaUtilConcurrentCompletableFuture_BiRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_BiRelay)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_OrApply_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_OrApply))
#define JavaUtilConcurrentCompletableFuture_OrApply_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionFunction;

@interface JavaUtilConcurrentCompletableFuture_OrApply : JavaUtilConcurrentCompletableFuture_BiCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd
                                withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_OrApply)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_OrApply, fn_, id<JavaUtilFunctionFunction>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_OrApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(JavaUtilConcurrentCompletableFuture_OrApply *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionFunction> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrApply *new_JavaUtilConcurrentCompletableFuture_OrApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionFunction> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrApply *create_JavaUtilConcurrentCompletableFuture_OrApply_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionFunction> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_OrApply)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_OrAccept_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_OrAccept))
#define JavaUtilConcurrentCompletableFuture_OrAccept_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentCompletableFuture_OrAccept : JavaUtilConcurrentCompletableFuture_BiCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd
                                withJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_OrAccept)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_OrAccept, fn_, id<JavaUtilFunctionConsumer>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_OrAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionConsumer_(JavaUtilConcurrentCompletableFuture_OrAccept *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionConsumer> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrAccept *new_JavaUtilConcurrentCompletableFuture_OrAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionConsumer> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrAccept *create_JavaUtilConcurrentCompletableFuture_OrAccept_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionConsumer_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaUtilFunctionConsumer> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_OrAccept)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_OrRun_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_OrRun))
#define JavaUtilConcurrentCompletableFuture_OrRun_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;

@interface JavaUtilConcurrentCompletableFuture_OrRun : JavaUtilConcurrentCompletableFuture_BiCompletion {
 @public
  volatile_id fn_;
}

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd
                                        withJavaLangRunnable:(id<JavaLangRunnable>)fn;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_OrRun)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_OrRun, fn_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_OrRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture_OrRun *self, id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaLangRunnable> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrRun *new_JavaUtilConcurrentCompletableFuture_OrRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaLangRunnable> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrRun *create_JavaUtilConcurrentCompletableFuture_OrRun_initWithJavaUtilConcurrentExecutor_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd, id<JavaLangRunnable> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_OrRun)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_OrRelay_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_OrRelay))
#define JavaUtilConcurrentCompletableFuture_OrRelay_

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;

@interface JavaUtilConcurrentCompletableFuture_OrRelay : JavaUtilConcurrentCompletableFuture_BiCompletion

#pragma mark Public

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                              withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)src
                              withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)snd;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)mode;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)arg0
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg1
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg2
                     withJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)arg3 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_OrRelay)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_OrRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture_OrRelay *self, JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrRelay *new_JavaUtilConcurrentCompletableFuture_OrRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_OrRelay *create_JavaUtilConcurrentCompletableFuture_OrRelay_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_withJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *dep, JavaUtilConcurrentCompletableFuture *src, JavaUtilConcurrentCompletableFuture *snd);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_OrRelay)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_AsyncSupply_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_AsyncSupply))
#define JavaUtilConcurrentCompletableFuture_AsyncSupply_

#define RESTRICT_JavaUtilConcurrentForkJoinTask 1
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#include "java/util/concurrent/ForkJoinTask.h"

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionSupplier;

@interface JavaUtilConcurrentCompletableFuture_AsyncSupply : JavaUtilConcurrentForkJoinTask < JavaLangRunnable, JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask > {
 @public
  volatile_id dep_;
  volatile_id fn_;
}

#pragma mark Public

- (jboolean)exec;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

- (void)run;

- (void)setRawResultWithId:(JavaLangVoid *)v;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                                         withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)fn;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_AsyncSupply)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_AsyncSupply, dep_, JavaUtilConcurrentCompletableFuture *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_AsyncSupply, fn_, id<JavaUtilFunctionSupplier>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_AsyncSupply_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionSupplier_(JavaUtilConcurrentCompletableFuture_AsyncSupply *self, JavaUtilConcurrentCompletableFuture *dep, id<JavaUtilFunctionSupplier> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AsyncSupply *new_JavaUtilConcurrentCompletableFuture_AsyncSupply_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionSupplier_(JavaUtilConcurrentCompletableFuture *dep, id<JavaUtilFunctionSupplier> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AsyncSupply *create_JavaUtilConcurrentCompletableFuture_AsyncSupply_initWithJavaUtilConcurrentCompletableFuture_withJavaUtilFunctionSupplier_(JavaUtilConcurrentCompletableFuture *dep, id<JavaUtilFunctionSupplier> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_AsyncSupply)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_AsyncRun_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_AsyncRun))
#define JavaUtilConcurrentCompletableFuture_AsyncRun_

#define RESTRICT_JavaUtilConcurrentForkJoinTask 1
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#include "java/util/concurrent/ForkJoinTask.h"

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;

@interface JavaUtilConcurrentCompletableFuture_AsyncRun : JavaUtilConcurrentForkJoinTask < JavaLangRunnable, JavaUtilConcurrentCompletableFuture_AsynchronousCompletionTask > {
 @public
  volatile_id dep_;
  volatile_id fn_;
}

#pragma mark Public

- (jboolean)exec;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

- (void)run;

- (void)setRawResultWithId:(JavaLangVoid *)v;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)dep
                                                 withJavaLangRunnable:(id<JavaLangRunnable>)fn;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_AsyncRun)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_AsyncRun, dep_, JavaUtilConcurrentCompletableFuture *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_AsyncRun, fn_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_AsyncRun_initWithJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture_AsyncRun *self, JavaUtilConcurrentCompletableFuture *dep, id<JavaLangRunnable> fn);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AsyncRun *new_JavaUtilConcurrentCompletableFuture_AsyncRun_initWithJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture *dep, id<JavaLangRunnable> fn) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_AsyncRun *create_JavaUtilConcurrentCompletableFuture_AsyncRun_initWithJavaUtilConcurrentCompletableFuture_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture *dep, id<JavaLangRunnable> fn);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_AsyncRun)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_Signaller_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_Signaller))
#define JavaUtilConcurrentCompletableFuture_Signaller_

#define RESTRICT_JavaUtilConcurrentForkJoinPool 1
#define INCLUDE_JavaUtilConcurrentForkJoinPool_ManagedBlocker 1
#include "java/util/concurrent/ForkJoinPool.h"

@class JavaLangThread;
@class JavaLangVoid;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;

/*!
 @brief Completion for recording and releasing a waiting thread.This
  class implements ManagedBlocker to avoid starvation when
  blocking actions pile up in ForkJoinPools.
 */
@interface JavaUtilConcurrentCompletableFuture_Signaller : JavaUtilConcurrentCompletableFuture_Completion < JavaUtilConcurrentForkJoinPool_ManagedBlocker > {
 @public
  jlong nanos_;
  jlong deadline_;
  jboolean interruptible_;
  jboolean interrupted_;
  volatile_id thread_;
}

#pragma mark Public

- (jboolean)block;

- (JavaLangVoid *)get;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (jboolean)isReleasable;

- (JavaLangVoid *)join;

#pragma mark Package-Private

- (instancetype __nonnull)initWithBoolean:(jboolean)interruptible
                                 withLong:(jlong)nanos
                                 withLong:(jlong)deadline;

- (jboolean)isLive;

- (JavaUtilConcurrentCompletableFuture *)tryFireWithInt:(jint)ignore;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_Signaller)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_Signaller, thread_, JavaLangThread *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_Signaller_initWithBoolean_withLong_withLong_(JavaUtilConcurrentCompletableFuture_Signaller *self, jboolean interruptible, jlong nanos, jlong deadline);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Signaller *new_JavaUtilConcurrentCompletableFuture_Signaller_initWithBoolean_withLong_withLong_(jboolean interruptible, jlong nanos, jlong deadline) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Signaller *create_JavaUtilConcurrentCompletableFuture_Signaller_initWithBoolean_withLong_withLong_(jboolean interruptible, jlong nanos, jlong deadline);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_Signaller)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_Delayer_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_Delayer))
#define JavaUtilConcurrentCompletableFuture_Delayer_

@class JavaUtilConcurrentScheduledThreadPoolExecutor;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentScheduledFuture;

/*!
 @brief Singleton delay scheduler, used only for starting and
  cancelling tasks.
 */
@interface JavaUtilConcurrentCompletableFuture_Delayer : NSObject
@property (readonly, class, strong) JavaUtilConcurrentScheduledThreadPoolExecutor *delayer NS_SWIFT_NAME(delayer);

+ (JavaUtilConcurrentScheduledThreadPoolExecutor *)delayer;

#pragma mark Package-Private

- (instancetype __nonnull)init;

+ (id<JavaUtilConcurrentScheduledFuture>)delayWithJavaLangRunnable:(id<JavaLangRunnable>)command
                                                          withLong:(jlong)delay
                                    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentCompletableFuture_Delayer)

inline JavaUtilConcurrentScheduledThreadPoolExecutor *JavaUtilConcurrentCompletableFuture_Delayer_get_delayer(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentScheduledThreadPoolExecutor *JavaUtilConcurrentCompletableFuture_Delayer_delayer;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentCompletableFuture_Delayer, delayer, JavaUtilConcurrentScheduledThreadPoolExecutor *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_Delayer_init(JavaUtilConcurrentCompletableFuture_Delayer *self);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Delayer *new_JavaUtilConcurrentCompletableFuture_Delayer_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Delayer *create_JavaUtilConcurrentCompletableFuture_Delayer_init(void);

FOUNDATION_EXPORT id<JavaUtilConcurrentScheduledFuture> JavaUtilConcurrentCompletableFuture_Delayer_delayWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> command, jlong delay, JavaUtilConcurrentTimeUnit *unit);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_Delayer)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory))
#define JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory_

#define RESTRICT_JavaUtilConcurrentThreadFactory 1
#define INCLUDE_JavaUtilConcurrentThreadFactory 1
#include "java/util/concurrent/ThreadFactory.h"

@class JavaLangThread;
@protocol JavaLangRunnable;

@interface JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory : NSObject < JavaUtilConcurrentThreadFactory >

#pragma mark Public

- (JavaLangThread *)newThreadWithJavaLangRunnable:(id<JavaLangRunnable>)r OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory_init(JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory *self);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory *new_JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory *create_JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_Delayer_DaemonThreadFactory)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_DelayedExecutor_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_DelayedExecutor))
#define JavaUtilConcurrentCompletableFuture_DelayedExecutor_

#define RESTRICT_JavaUtilConcurrentExecutor 1
#define INCLUDE_JavaUtilConcurrentExecutor 1
#include "java/util/concurrent/Executor.h"

@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;

@interface JavaUtilConcurrentCompletableFuture_DelayedExecutor : NSObject < JavaUtilConcurrentExecutor > {
 @public
  jlong delay_;
  JavaUtilConcurrentTimeUnit *unit_;
  id<JavaUtilConcurrentExecutor> executor_;
}

#pragma mark Public

- (void)executeWithJavaLangRunnable:(id<JavaLangRunnable>)r;

#pragma mark Package-Private

- (instancetype __nonnull)initWithLong:(jlong)delay
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
        withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_DelayedExecutor)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_DelayedExecutor, unit_, JavaUtilConcurrentTimeUnit *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_DelayedExecutor, executor_, id<JavaUtilConcurrentExecutor>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_DelayedExecutor_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentExecutor_(JavaUtilConcurrentCompletableFuture_DelayedExecutor *self, jlong delay, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_DelayedExecutor *new_JavaUtilConcurrentCompletableFuture_DelayedExecutor_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentExecutor_(jlong delay, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentExecutor> executor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_DelayedExecutor *create_JavaUtilConcurrentCompletableFuture_DelayedExecutor_initWithLong_withJavaUtilConcurrentTimeUnit_withJavaUtilConcurrentExecutor_(jlong delay, JavaUtilConcurrentTimeUnit *unit, id<JavaUtilConcurrentExecutor> executor);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_DelayedExecutor)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_TaskSubmitter_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_TaskSubmitter))
#define JavaUtilConcurrentCompletableFuture_TaskSubmitter_

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@protocol JavaUtilConcurrentExecutor;

/*!
 @brief Action to submit user task
 */
@interface JavaUtilConcurrentCompletableFuture_TaskSubmitter : NSObject < JavaLangRunnable > {
 @public
  id<JavaUtilConcurrentExecutor> executor_;
  id<JavaLangRunnable> action_;
}

#pragma mark Public

- (void)run;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor
                                        withJavaLangRunnable:(id<JavaLangRunnable>)action;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_TaskSubmitter)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_TaskSubmitter, executor_, id<JavaUtilConcurrentExecutor>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_TaskSubmitter, action_, id<JavaLangRunnable>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_TaskSubmitter_initWithJavaUtilConcurrentExecutor_withJavaLangRunnable_(JavaUtilConcurrentCompletableFuture_TaskSubmitter *self, id<JavaUtilConcurrentExecutor> executor, id<JavaLangRunnable> action);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_TaskSubmitter *new_JavaUtilConcurrentCompletableFuture_TaskSubmitter_initWithJavaUtilConcurrentExecutor_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, id<JavaLangRunnable> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_TaskSubmitter *create_JavaUtilConcurrentCompletableFuture_TaskSubmitter_initWithJavaUtilConcurrentExecutor_withJavaLangRunnable_(id<JavaUtilConcurrentExecutor> executor, id<JavaLangRunnable> action);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_TaskSubmitter)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_Timeout_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_Timeout))
#define JavaUtilConcurrentCompletableFuture_Timeout_

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@class JavaUtilConcurrentCompletableFuture;

/*!
 @brief Action to completeExceptionally on timeout
 */
@interface JavaUtilConcurrentCompletableFuture_Timeout : NSObject < JavaLangRunnable > {
 @public
  JavaUtilConcurrentCompletableFuture *f_;
}

#pragma mark Public

- (void)run;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)f;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_Timeout)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_Timeout, f_, JavaUtilConcurrentCompletableFuture *)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_Timeout_initWithJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture_Timeout *self, JavaUtilConcurrentCompletableFuture *f);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Timeout *new_JavaUtilConcurrentCompletableFuture_Timeout_initWithJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *f) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Timeout *create_JavaUtilConcurrentCompletableFuture_Timeout_initWithJavaUtilConcurrentCompletableFuture_(JavaUtilConcurrentCompletableFuture *f);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_Timeout)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_DelayedCompleter_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_DelayedCompleter))
#define JavaUtilConcurrentCompletableFuture_DelayedCompleter_

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@class JavaUtilConcurrentCompletableFuture;

/*!
 @brief Action to complete on timeout
 */
@interface JavaUtilConcurrentCompletableFuture_DelayedCompleter : NSObject < JavaLangRunnable > {
 @public
  JavaUtilConcurrentCompletableFuture *f_;
  id u_;
}

#pragma mark Public

- (void)run;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentCompletableFuture:(JavaUtilConcurrentCompletableFuture *)f
                                                               withId:(id)u;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_DelayedCompleter)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_DelayedCompleter, f_, JavaUtilConcurrentCompletableFuture *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_DelayedCompleter, u_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_DelayedCompleter_initWithJavaUtilConcurrentCompletableFuture_withId_(JavaUtilConcurrentCompletableFuture_DelayedCompleter *self, JavaUtilConcurrentCompletableFuture *f, id u);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_DelayedCompleter *new_JavaUtilConcurrentCompletableFuture_DelayedCompleter_initWithJavaUtilConcurrentCompletableFuture_withId_(JavaUtilConcurrentCompletableFuture *f, id u) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_DelayedCompleter *create_JavaUtilConcurrentCompletableFuture_DelayedCompleter_initWithJavaUtilConcurrentCompletableFuture_withId_(JavaUtilConcurrentCompletableFuture *f, id u);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_DelayedCompleter)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_Canceller_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_Canceller))
#define JavaUtilConcurrentCompletableFuture_Canceller_

#define RESTRICT_JavaUtilFunctionBiConsumer 1
#define INCLUDE_JavaUtilFunctionBiConsumer 1
#include "java/util/function/BiConsumer.h"

@class JavaLangThrowable;
@protocol JavaUtilConcurrentFuture;

/*!
 @brief Action to cancel unneeded timeouts
 */
@interface JavaUtilConcurrentCompletableFuture_Canceller : NSObject < JavaUtilFunctionBiConsumer > {
 @public
  id<JavaUtilConcurrentFuture> f_;
}

#pragma mark Public

- (void)acceptWithId:(id)ignore
              withId:(JavaLangThrowable *)ex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentFuture:(id<JavaUtilConcurrentFuture>)f;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_Canceller)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentCompletableFuture_Canceller, f_, id<JavaUtilConcurrentFuture>)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_Canceller_initWithJavaUtilConcurrentFuture_(JavaUtilConcurrentCompletableFuture_Canceller *self, id<JavaUtilConcurrentFuture> f);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Canceller *new_JavaUtilConcurrentCompletableFuture_Canceller_initWithJavaUtilConcurrentFuture_(id<JavaUtilConcurrentFuture> f) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_Canceller *create_JavaUtilConcurrentCompletableFuture_Canceller_initWithJavaUtilConcurrentFuture_(id<JavaUtilConcurrentFuture> f);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_Canceller)

#endif

#if !defined (JavaUtilConcurrentCompletableFuture_MinimalStage_) && (INCLUDE_ALL_JavaUtilConcurrentCompletableFuture || defined(INCLUDE_JavaUtilConcurrentCompletableFuture_MinimalStage))
#define JavaUtilConcurrentCompletableFuture_MinimalStage_

@class JavaLangThrowable;
@class JavaUtilConcurrentCompletableFuture;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilFunctionSupplier;

/*!
 @brief A subclass that just throws UOE for most non-CompletionStage methods.
 */
@interface JavaUtilConcurrentCompletableFuture_MinimalStage : JavaUtilConcurrentCompletableFuture

#pragma mark Public

- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

- (jboolean)completeWithId:(id)value;

- (JavaUtilConcurrentCompletableFuture *)completeAsyncWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier;

- (JavaUtilConcurrentCompletableFuture *)completeAsyncWithJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)supplier
                                                    withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

- (jboolean)completeExceptionallyWithJavaLangThrowable:(JavaLangThrowable *)ex;

- (JavaUtilConcurrentCompletableFuture *)completeOnTimeoutWithId:(id)value
                                                        withLong:(jlong)timeout
                                  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id)get;

- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id)getNowWithId:(id)valueIfAbsent;

- (jint)getNumberOfDependents;

- (jboolean)isCancelled;

- (jboolean)isCompletedExceptionally;

- (jboolean)isDone;

- (id)join;

- (JavaUtilConcurrentCompletableFuture *)newIncompleteFuture OBJC_METHOD_FAMILY_NONE;

- (void)obtrudeExceptionWithJavaLangThrowable:(JavaLangThrowable *)ex;

- (void)obtrudeValueWithId:(id)value;

- (JavaUtilConcurrentCompletableFuture *)orTimeoutWithLong:(jlong)timeout
                            withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (instancetype __nonnull)initWithId:(id)r;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentCompletableFuture_MinimalStage)

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_MinimalStage_init(JavaUtilConcurrentCompletableFuture_MinimalStage *self);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_MinimalStage *new_JavaUtilConcurrentCompletableFuture_MinimalStage_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_MinimalStage *create_JavaUtilConcurrentCompletableFuture_MinimalStage_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentCompletableFuture_MinimalStage_initWithId_(JavaUtilConcurrentCompletableFuture_MinimalStage *self, id r);

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_MinimalStage *new_JavaUtilConcurrentCompletableFuture_MinimalStage_initWithId_(id r) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentCompletableFuture_MinimalStage *create_JavaUtilConcurrentCompletableFuture_MinimalStage_initWithId_(id r);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentCompletableFuture_MinimalStage)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentCompletableFuture")
