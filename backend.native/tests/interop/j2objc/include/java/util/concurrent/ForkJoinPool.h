//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/ForkJoinPool.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentForkJoinPool")
#ifdef RESTRICT_JavaUtilConcurrentForkJoinPool
#define INCLUDE_ALL_JavaUtilConcurrentForkJoinPool 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentForkJoinPool 1
#endif
#undef RESTRICT_JavaUtilConcurrentForkJoinPool

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentForkJoinPool_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinPool || defined(INCLUDE_JavaUtilConcurrentForkJoinPool))
#define JavaUtilConcurrentForkJoinPool_

#define RESTRICT_JavaUtilConcurrentAbstractExecutorService 1
#define INCLUDE_JavaUtilConcurrentAbstractExecutorService 1
#include "java/util/concurrent/AbstractExecutorService.h"

@class IOSObjectArray;
@class JavaLangRuntimePermission;
@class JavaLangThrowable;
@class JavaUtilConcurrentCountedCompleter;
@class JavaUtilConcurrentForkJoinPool_AuxState;
@class JavaUtilConcurrentForkJoinPool_WorkQueue;
@class JavaUtilConcurrentForkJoinTask;
@class JavaUtilConcurrentForkJoinWorkerThread;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaLangThread_UncaughtExceptionHandler;
@protocol JavaUtilCollection;
@protocol JavaUtilConcurrentCallable;
@protocol JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory;
@protocol JavaUtilConcurrentForkJoinPool_ManagedBlocker;
@protocol JavaUtilConcurrentRunnableFuture;
@protocol JavaUtilList;

/*!
 @brief An <code>ExecutorService</code> for running <code>ForkJoinTask</code>s.
 A <code>ForkJoinPool</code> provides the entry point for submissions
  from non-<code>ForkJoinTask</code> clients, as well as management and
  monitoring operations. 
 <p>A <code>ForkJoinPool</code> differs from other kinds of <code>ExecutorService</code>
  mainly by virtue of employing 
 <em>work-stealing</em>: all threads in the pool attempt to find and
  execute tasks submitted to the pool and/or created by other active
  tasks (eventually blocking waiting for work if none exist). This
  enables efficient processing when most tasks spawn other subtasks
  (as do most <code>ForkJoinTask</code>s), as well as when many small
  tasks are submitted to the pool from external clients.  Especially
  when setting <em>asyncMode</em> to true in constructors, <code>ForkJoinPool</code>
 s may also be appropriate for use with event-style
  tasks that are never joined. 
 <p>A static <code>commonPool()</code> is available and appropriate for
  most applications. The common pool is used by any ForkJoinTask that
  is not explicitly submitted to a specified pool. Using the common
  pool normally reduces resource usage (its threads are slowly
  reclaimed during periods of non-use, and reinstated upon subsequent
  use). 
 <p>For applications that require separate or custom pools, a <code>ForkJoinPool</code>
  may be constructed with a given target parallelism
  level; by default, equal to the number of available processors.
  The pool attempts to maintain enough active (or available) threads
  by dynamically adding, suspending, or resuming internal worker
  threads, even if some tasks are stalled waiting to join others.
  However, no such adjustments are guaranteed in the face of blocked
  I/O or other unmanaged synchronization. The nested <code>ManagedBlocker</code>
  interface enables extension of the kinds of
  synchronization accommodated. 
 <p>In addition to execution and lifecycle control methods, this
  class provides status check methods (for example 
 <code>getStealCount</code>) that are intended to aid in developing,
  tuning, and monitoring fork/join applications. Also, method 
 <code>toString</code> returns indications of pool state in a
  convenient form for informal monitoring. 
 <p>As is the case with other ExecutorServices, there are three
  main task execution methods summarized in the following table.
  These are designed to be used primarily by clients not already
  engaged in fork/join computations in the current pool.  The main
  forms of these methods accept instances of <code>ForkJoinTask</code>,
  but overloaded forms also allow mixed execution of plain <code>Runnable</code>
 - or <code>Callable</code>- based activities as well.  However,
  tasks that are already executing in a pool should normally instead
  use the within-computation forms listed in the table unless using
  async event-style tasks that are not usually joined, in which case
  there is little difference among choice of methods. 
 <table BORDER CELLPADDING=3 CELLSPACING=1>
  <caption>Summary of task execution methods</caption>
   <tr>
     <td></td>
     <td ALIGN=CENTER> <b>Call from non-fork/join clients</b></td>
     <td ALIGN=CENTER> <b>Call from within fork/join computations</b></td>
   </tr>
   <tr>
     <td> <b>Arrange async execution</b></td>
     <td> <code>execute(ForkJoinTask)</code></td>
     <td> <code>ForkJoinTask.fork</code></td>
   </tr>
   <tr>
     <td> <b>Await and obtain result</b></td>
     <td> <code>invoke(ForkJoinTask)</code></td>
     <td> <code>ForkJoinTask.invoke</code></td>
   </tr>
   <tr>
     <td> <b>Arrange exec and obtain Future</b></td>
     <td> <code>submit(ForkJoinTask)</code></td>
     <td> <code>ForkJoinTask.fork</code> (ForkJoinTasks <em>are</em> Futures)</td>
   </tr>
  </table>
  
 <p>The common pool is by default constructed with default
  parameters, but these may be controlled by setting three 
 system properties:
  <ul>
  <li><code>java.util.concurrent.ForkJoinPool.common.parallelism</code>
  - the parallelism level, a non-negative integer 
 <li><code>java.util.concurrent.ForkJoinPool.common.threadFactory</code>
  - the class name of a <code>ForkJoinWorkerThreadFactory</code>
  <li><code>java.util.concurrent.ForkJoinPool.common.exceptionHandler</code>
  - the class name of a <code>UncaughtExceptionHandler</code>
  <li><code>java.util.concurrent.ForkJoinPool.common.maximumSpares</code>
  - the maximum number of allowed extra threads to maintain target
  parallelism (default 256). 
 </ul>
  If a <code>SecurityManager</code> is present and no factory is
  specified, then the default pool uses a factory supplying
  threads that have no <code>Permissions</code> enabled.
  The system class loader is used to load these classes.
  Upon any error in establishing these settings, default parameters
  are used. It is possible to disable or limit the use of threads in
  the common pool by setting the parallelism property to zero, and/or
  using a factory that may return <code>null</code>. However doing so may
  cause unjoined tasks to never be executed. 
 <p><b>Implementation notes</b>: This implementation restricts the
  maximum number of running threads to 32767. Attempts to create
  pools with greater than the maximum number result in 
 <code>IllegalArgumentException</code>.
  
 <p>This implementation rejects submitted tasks (that is, by throwing 
 <code>RejectedExecutionException</code>) only when the pool is shut down
  or internal resources have been exhausted.
 @since 1.7
 @author Doug Lea
 */
@interface JavaUtilConcurrentForkJoinPool : JavaUtilConcurrentAbstractExecutorService {
 @public
  volatile_jlong ctl_;
  volatile_jint runState_;
  jint config_;
  JavaUtilConcurrentForkJoinPool_AuxState *auxState_;
  volatile_id workQueues_;
  NSString *workerNamePrefix_;
  id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory_;
  id<JavaLangThread_UncaughtExceptionHandler> ueh_;
}
@property (readonly, class) jint SMASK NS_SWIFT_NAME(SMASK);
@property (readonly, class) jint MAX_CAP NS_SWIFT_NAME(MAX_CAP);
@property (readonly, class) jint EVENMASK NS_SWIFT_NAME(EVENMASK);
@property (readonly, class) jint SQMASK NS_SWIFT_NAME(SQMASK);
@property (readonly, class) jint UNSIGNALLED NS_SWIFT_NAME(UNSIGNALLED);
@property (readonly, class) jint SS_SEQ NS_SWIFT_NAME(SS_SEQ);
@property (readonly, class) jint MODE_MASK NS_SWIFT_NAME(MODE_MASK);
@property (readonly, class) jint SPARE_WORKER NS_SWIFT_NAME(SPARE_WORKER);
@property (readonly, class) jint UNREGISTERED NS_SWIFT_NAME(UNREGISTERED);
@property (readonly, class) jint FIFO_QUEUE NS_SWIFT_NAME(FIFO_QUEUE);
@property (readonly, class) jint LIFO_QUEUE NS_SWIFT_NAME(LIFO_QUEUE);
@property (readonly, class) jint IS_OWNED NS_SWIFT_NAME(IS_OWNED);
@property (readonly, class) jint POLL_LIMIT NS_SWIFT_NAME(POLL_LIMIT);
@property (readonly, class, strong) id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> defaultForkJoinWorkerThreadFactory NS_SWIFT_NAME(defaultForkJoinWorkerThreadFactory);
@property (readonly, class, strong) JavaLangRuntimePermission *modifyThreadPermission NS_SWIFT_NAME(modifyThreadPermission);
@property (readonly, class, strong) JavaUtilConcurrentForkJoinPool *common NS_SWIFT_NAME(common);
@property (readonly, class) jint COMMON_PARALLELISM NS_SWIFT_NAME(COMMON_PARALLELISM);

+ (jint)SMASK;

+ (jint)MAX_CAP;

+ (jint)EVENMASK;

+ (jint)SQMASK;

+ (jint)UNSIGNALLED;

+ (jint)SS_SEQ;

+ (jint)MODE_MASK;

+ (jint)SPARE_WORKER;

+ (jint)UNREGISTERED;

+ (jint)FIFO_QUEUE;

+ (jint)LIFO_QUEUE;

+ (jint)IS_OWNED;

+ (jint)POLL_LIMIT;

+ (id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)defaultForkJoinWorkerThreadFactory;

+ (JavaLangRuntimePermission *)modifyThreadPermission;

+ (JavaUtilConcurrentForkJoinPool *)common;

+ (jint)COMMON_PARALLELISM;

#pragma mark Public

/*!
 @brief Creates a <code>ForkJoinPool</code> with parallelism equal to <code>java.lang.Runtime.availableProcessors</code>
 , using the default thread factory
 ,
  no UncaughtExceptionHandler, and non-async LIFO processing mode.
 @throw SecurityExceptionif a security manager exists and
          the caller is not permitted to modify threads
          because it does not hold <code>java.lang.RuntimePermission</code>
 <code>("modifyThread")</code>
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a <code>ForkJoinPool</code> with the indicated parallelism
  level, the default thread factory
 ,
  no UncaughtExceptionHandler, and non-async LIFO processing mode.
 @param parallelism the parallelism level
 @throw IllegalArgumentExceptionif parallelism less than or
          equal to zero, or greater than implementation limit
 @throw SecurityExceptionif a security manager exists and
          the caller is not permitted to modify threads
          because it does not hold <code>java.lang.RuntimePermission</code>
 <code>("modifyThread")</code>
 */
- (instancetype __nonnull)initWithInt:(jint)parallelism;

/*!
 @brief Creates a <code>ForkJoinPool</code> with the given parameters.
 @param parallelism the parallelism level. For default value,  use 
 <code>java.lang.Runtime.availableProcessors</code> .
 @param factory the factory for creating new threads. For default value,  use 
 <code>defaultForkJoinWorkerThreadFactory</code> .
 @param handler the handler for internal worker threads that  terminate due to unrecoverable errors encountered while executing
   tasks. For default value, use 
 <code>null</code> .
 @param asyncMode if true,  establishes local first-in-first-out scheduling mode for forked
   tasks that are never joined. This mode may be more appropriate
   than default locally stack-based mode in applications in which
   worker threads only process event-style asynchronous tasks.
   For default value, use 
 <code>false</code> .
 @throw IllegalArgumentExceptionif parallelism less than or
          equal to zero, or greater than implementation limit
 @throw NullPointerExceptionif the factory is null
 @throw SecurityExceptionif a security manager exists and
          the caller is not permitted to modify threads
          because it does not hold <code>java.lang.RuntimePermission</code>
 <code>("modifyThread")</code>
 */
- (instancetype __nonnull)initWithInt:(jint)parallelism
withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory:(id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)factory
withJavaLangThread_UncaughtExceptionHandler:(id<JavaLangThread_UncaughtExceptionHandler>)handler
                          withBoolean:(jboolean)asyncMode;

/*!
 @brief If called by a ForkJoinTask operating in this pool, equivalent
  in effect to <code>ForkJoinTask.helpQuiesce</code>.Otherwise,
  waits and/or attempts to assist performing tasks until this
  pool <code>isQuiescent</code> or the indicated timeout elapses.
 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @return <code>true</code> if quiescent; <code>false</code> if the
  timeout elapsed.
 */
- (jboolean)awaitQuiescenceWithLong:(jlong)timeout
     withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Blocks until all tasks have completed execution after a
  shutdown request, or the timeout occurs, or the current thread
  is interrupted, whichever happens first.Because the <code>commonPool()</code>
  never terminates until program shutdown, when
  applied to the common pool, this method is equivalent to <code>awaitQuiescence(long, TimeUnit)</code>
  but always returns <code>false</code>.
 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @return <code>true</code> if this executor terminated and
          <code>false</code> if the timeout elapsed before termination
 @throw InterruptedExceptionif interrupted while waiting
 */
- (jboolean)awaitTerminationWithLong:(jlong)timeout
      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns the common pool instance.This pool is statically
  constructed; its run state is unaffected by attempts to <code>shutdown</code>
  or <code>shutdownNow</code>.
 However this pool and any
  ongoing processing are automatically terminated upon program 
 <code>System.exit</code>.  Any program that relies on asynchronous
  task processing to complete before program termination should
  invoke <code>commonPool().</code><code>awaitQuiescence</code>,
  before exit.
 @return the common pool instance
 @since 1.8
 */
+ (JavaUtilConcurrentForkJoinPool *)commonPool;

/*!
 @brief Arranges for (asynchronous) execution of the given task.
 @param task the task
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (void)executeWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (void)executeWithJavaLangRunnable:(id<JavaLangRunnable>)task;

/*!
 @brief Returns an estimate of the number of threads that are currently
  stealing or executing tasks.This method may overestimate the
  number of active threads.
 @return the number of active threads
 */
- (jint)getActiveThreadCount;

/*!
 @brief Returns <code>true</code> if this pool uses local first-in-first-out
  scheduling mode for forked tasks that are never joined.
 @return <code>true</code> if this pool uses async mode
 */
- (jboolean)getAsyncMode;

/*!
 @brief Returns the targeted parallelism level of the common pool.
 @return the targeted parallelism level of the common pool
 @since 1.8
 */
+ (jint)getCommonPoolParallelism;

/*!
 @brief Returns the factory used for constructing new workers.
 @return the factory used for constructing new workers
 */
- (id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)getFactory;

/*!
 @brief Returns the targeted parallelism level of this pool.
 @return the targeted parallelism level of this pool
 */
- (jint)getParallelism;

/*!
 @brief Returns the number of worker threads that have started but not
  yet terminated.The result returned by this method may differ
  from <code>getParallelism</code> when threads are created to
  maintain parallelism when others are cooperatively blocked.
 @return the number of worker threads
 */
- (jint)getPoolSize;

/*!
 @brief Returns an estimate of the number of tasks submitted to this
  pool that have not yet begun executing.This method may take
  time proportional to the number of submissions.
 @return the number of queued submissions
 */
- (jint)getQueuedSubmissionCount;

/*!
 @brief Returns an estimate of the total number of tasks currently held
  in queues by worker threads (but not including tasks submitted
  to the pool that have not begun executing).This value is only
  an approximation, obtained by iterating across all threads in
  the pool.
 This method may be useful for tuning task
  granularities.
 @return the number of queued tasks
 */
- (jlong)getQueuedTaskCount;

/*!
 @brief Returns an estimate of the number of worker threads that are
  not blocked waiting to join tasks or for other managed
  synchronization.This method may overestimate the
  number of running threads.
 @return the number of worker threads
 */
- (jint)getRunningThreadCount;

/*!
 @brief Returns an estimate of the total number of tasks stolen from
  one thread's work queue by another.The reported value
  underestimates the actual total number of steals when the pool
  is not quiescent.
 This value may be useful for monitoring and
  tuning fork/join programs: in general, steal counts should be
  high enough to keep threads busy, but low enough to avoid
  overhead and contention across threads.
 @return the number of steals
 */
- (jlong)getStealCount;

/*!
 @brief Returns the handler for internal worker threads that terminate
  due to unrecoverable errors encountered while executing tasks.
 @return the handler, or <code>null</code> if none
 */
- (id<JavaLangThread_UncaughtExceptionHandler>)getUncaughtExceptionHandler;

/*!
 @brief Returns <code>true</code> if there are any tasks submitted to this
  pool that have not yet begun executing.
 @return <code>true</code> if there are any queued submissions
 */
- (jboolean)hasQueuedSubmissions;

/*!
 @brief Performs the given task, returning its result upon completion.
 If the computation encounters an unchecked Exception or Error,
  it is rethrown as the outcome of this invocation.  Rethrown
  exceptions behave in the same way as regular exceptions, but,
  when possible, contain stack traces (as displayed for example
  using <code>ex.printStackTrace()</code>) of both the current thread
  as well as the thread actually encountering the exception;
  minimally only the latter.
 @param task the task
 @return the task's result
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (id)invokeWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @throw NullPointerException
 @throw RejectedExecutionException
 */
- (id<JavaUtilList>)invokeAllWithJavaUtilCollection:(id<JavaUtilCollection>)tasks;

/*!
 @brief Returns <code>true</code> if all worker threads are currently idle.
 An idle worker is one that cannot obtain a task to execute
  because none are available to steal from other threads, and
  there are no pending submissions to the pool. This method is
  conservative; it might not return <code>true</code> immediately upon
  idleness of all threads, but will eventually become true if
  threads remain inactive.
 @return <code>true</code> if all threads are currently idle
 */
- (jboolean)isQuiescent;

/*!
 @brief Returns <code>true</code> if this pool has been shut down.
 @return <code>true</code> if this pool has been shut down
 */
- (jboolean)isShutdown;

/*!
 @brief Returns <code>true</code> if all tasks have completed following shut down.
 @return <code>true</code> if all tasks have completed following shut down
 */
- (jboolean)isTerminated;

/*!
 @brief Returns <code>true</code> if the process of termination has
  commenced but not yet completed.This method may be useful for
  debugging.
 A return of <code>true</code> reported a sufficient
  period after shutdown may indicate that submitted tasks have
  ignored or suppressed interruption, or are waiting for I/O,
  causing this executor not to properly terminate. (See the
  advisory notes for class <code>ForkJoinTask</code> stating that
  tasks should not normally entail blocking operations.  But if
  they do, they must abort them on interrupt.)
 @return <code>true</code> if terminating but not yet terminated
 */
- (jboolean)isTerminating;

/*!
 @brief Runs the given possibly blocking task.When running in a ForkJoinPool
 , this
  method possibly arranges for a spare thread to be activated if
  necessary to ensure sufficient parallelism while the current
  thread is blocked in <code>blocker.block()</code>.
 <p>This method repeatedly calls <code>blocker.isReleasable()</code> and 
 <code>blocker.block()</code> until either method returns <code>true</code>.
  Every call to <code>blocker.block()</code> is preceded by a call to 
 <code>blocker.isReleasable()</code> that returned <code>false</code>.
  
 <p>If not running in a ForkJoinPool, this method is
  behaviorally equivalent to 
 @code
  while (!blocker.isReleasable())
    if (blocker.block())
      break;
 
@endcode
  If running in a ForkJoinPool, the pool may first be expanded to
  ensure sufficient parallelism available during the call to 
 <code>blocker.block()</code>.
 @param blocker the blocker task
 @throw InterruptedExceptionif <code>blocker.block()</code> did so
 */
+ (void)managedBlockWithJavaUtilConcurrentForkJoinPool_ManagedBlocker:(id<JavaUtilConcurrentForkJoinPool_ManagedBlocker>)blocker;

/*!
 @brief Possibly initiates an orderly shutdown in which previously
  submitted tasks are executed, but no new tasks will be
  accepted.Invocation has no effect on execution state if this
  is the <code>commonPool()</code>, and no additional effect if
  already shut down.
 Tasks that are in the process of being
  submitted concurrently during the course of this method may or
  may not be rejected.
 @throw SecurityExceptionif a security manager exists and
          the caller is not permitted to modify threads
          because it does not hold <code>java.lang.RuntimePermission</code>
 <code>("modifyThread")</code>
 */
- (void)shutdown;

/*!
 @brief Possibly attempts to cancel and/or stop all tasks, and reject
  all subsequently submitted tasks.Invocation has no effect on
  execution state if this is the <code>commonPool()</code>, and no
  additional effect if already shut down.
 Otherwise, tasks that
  are in the process of being submitted or executed concurrently
  during the course of this method may or may not be
  rejected. This method cancels both existing and unexecuted
  tasks, in order to permit termination in the presence of task
  dependencies. So the method always returns an empty list
  (unlike the case for some other Executors).
 @return an empty list
 @throw SecurityExceptionif a security manager exists and
          the caller is not permitted to modify threads
          because it does not hold <code>java.lang.RuntimePermission</code>
 <code>("modifyThread")</code>
 */
- (id<JavaUtilList>)shutdownNow;

/*!
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)task;

/*!
 @brief Submits a ForkJoinTask for execution.
 @param task the task to submit
 @return the task
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaLangRunnable:(id<JavaLangRunnable>)task;

/*!
 @throw NullPointerExceptionif the task is null
 @throw RejectedExecutionExceptionif the task cannot be
          scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaLangRunnable:(id<JavaLangRunnable>)task
                                                        withId:(id)result;

/*!
 @brief Returns a string identifying this pool, as well as its state,
  including indications of run state, parallelism level, and
  worker and task counts.
 @return a string identifying this pool, as well as its state
 */
- (NSString *)description;

#pragma mark Protected

/*!
 @brief Removes all available unexecuted submitted and forked tasks
  from scheduling queues and adds them to the given collection,
  without altering their execution status.These may include
  artificially generated or wrapped tasks.
 This method is
  designed to be invoked only when the pool is known to be
  quiescent. Invocations at other times may not remove all
  tasks. A failure encountered while attempting to add elements
  to collection <code>c</code> may result in elements being in
  neither, either or both collections when the associated
  exception is thrown.  The behavior of this operation is
  undefined if the specified collection is modified while the
  operation is in progress.
 @param c the collection to transfer elements into
 @return the number of elements transferred
 */
- (jint)drainTasksToWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (id<JavaUtilConcurrentRunnableFuture>)newTaskForWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)callable OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilConcurrentRunnableFuture>)newTaskForWithJavaLangRunnable:(id<JavaLangRunnable>)runnable
                                                                withId:(id)value OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Removes and returns the next unexecuted submission if one is
  available.This method may be useful in extensions to this
  class that re-assign work in systems with multiple pools.
 @return the next submission, or <code>null</code> if none
 */
- (JavaUtilConcurrentForkJoinTask *)pollSubmission;

#pragma mark Package-Private

/*!
 @brief Helps and/or blocks until the given task is done or timeout.
 @param w caller
 @param task the task
 @param deadline for timed waits, if nonzero
 @return task status on exit
 */
- (jint)awaitJoinWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w
                           withJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task
                                                     withLong:(jlong)deadline;

/*!
 @brief Returns common pool queue for an external thread.
 */
+ (JavaUtilConcurrentForkJoinPool_WorkQueue *)commonSubmitterQueue;

/*!
 @brief Final callback from terminating worker, as well as upon failure
  to construct or start a worker.Removes record of worker from
  array, and adjusts counts.
 If pool is shutting down, tries to
  complete termination.
 @param wt the worker thread, or null if construction failed
 @param ex the exception causing failure, or null if none
 */
- (void)deregisterWorkerWithJavaUtilConcurrentForkJoinWorkerThread:(JavaUtilConcurrentForkJoinWorkerThread *)wt
                                             withJavaLangThrowable:(JavaLangThrowable *)ex;

/*!
 @brief Performs helpComplete for an external submitter.
 */
- (jint)externalHelpCompleteWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)task
                                                           withInt:(jint)maxTasks;

/*!
 @brief Adds the given task to a submission queue at submitter's
  current queue.Also performs secondary initialization upon the
  first submission of the first task to the pool, and detects
  first submission by an external thread and creates a new shared
  queue if the one at index if empty or contended.
 @param task the task. Caller must ensure non-null.
 */
- (void)externalPushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Returns a cheap heuristic guide for task partitioning when
  programmers, frameworks, tools, or languages have little or no
  idea about task granularity.In essence, by offering this
  method, we ask users only about tradeoffs in overhead vs
  expected throughput and its variance, rather than how finely to
  partition tasks.
 In a steady state strict (tree-structured) computation, each
  thread makes available for stealing enough tasks for other
  threads to remain active. Inductively, if all threads play by
  the same rules, each thread should make available only a
  constant number of tasks.
  The minimum useful constant is just 1. But using a value of 1
  would require immediate replenishment upon each steal to
  maintain enough tasks, which is infeasible.  Further,
  partitionings/granularities of offered tasks should minimize
  steal rates, which in general means that threads nearer the top
  of computation tree should generate more than those nearer the
  bottom. In perfect steady state, each thread is at
  approximately the same level of computation tree. However,
  producing extra tasks amortizes the uncertainty of progress and
  diffusion assumptions.
  So, users will want to use values larger (but not much larger)
  than 1 to both smooth over transient shortages and hedge
  against uneven progress; as traded off against the cost of
  extra task overhead. We leave the user to pick a threshold
  value to compare with the results of this call to guide
  decisions, but recommend values such as 3.
  When all threads are active, it is on average OK to estimate
  surplus strictly locally. In steady-state, if one thread is
  maintaining say 2 surplus tasks, then so are others. So we can
  just use estimated queue length.  However, this strategy alone
  leads to serious mis-estimates in some non-steady-state
  conditions (ramp-up, ramp-down, other stalls). We can detect
  many of these by further considering the number of "idle"
  threads, that are known to have zero queued tasks, so
  compensate by a factor of (#idle/#active) threads.
 */
+ (jint)getSurplusQueuedTaskCount;

/*!
 @brief Tries to steal and run tasks within the target's computation.
 Uses a variant of the top-level algorithm, restricted to tasks
  with the given task as ancestor: It prefers taking and running
  eligible tasks popped from the worker's own queue (via
  popCC). Otherwise it scans others, randomly moving on
  contention or execution, deciding to give up based on a
  checksum (via return codes from pollAndExecCC). The maxTasks
  argument supports external usages; internal calls use zero,
  allowing unbounded steps (external calls trap non-positive
  values).
 @param w caller
 @param maxTasks if non-zero, the maximum number of other tasks to run
 @return task status on exit
 */
- (jint)helpCompleteWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w
                          withJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)task
                                                         withInt:(jint)maxTasks;

/*!
 @brief Runs tasks until <code>isQuiescent()</code>.We piggyback on
  active count ctl maintenance, but rather than blocking
  when tasks cannot be found, we rescan until all others cannot
  find tasks either.
 */
- (void)helpQuiescePoolWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w;

/*!
 @brief Creates and returns the common pool, respecting user settings
  specified via system properties.
 */
+ (JavaUtilConcurrentForkJoinPool *)makeCommonPool;

/*!
 @brief Gets and removes a local or stolen task for the given worker.
 @return a task, if available
 */
- (JavaUtilConcurrentForkJoinTask *)nextTaskForWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w;

/*!
 @brief Waits and/or attempts to assist performing tasks indefinitely
  until the <code>commonPool()</code> <code>isQuiescent</code>.
 */
+ (void)quiesceCommonPool;

/*!
 @brief Callback from ForkJoinWorkerThread constructor to establish and
  record its WorkQueue.
 @param wt the worker thread
 @return the worker's queue
 */
- (JavaUtilConcurrentForkJoinPool_WorkQueue *)registerWorkerWithJavaUtilConcurrentForkJoinWorkerThread:(JavaUtilConcurrentForkJoinWorkerThread *)wt;

/*!
 @brief Top-level runloop for workers, called by ForkJoinWorkerThread.run.
 */
- (void)runWorkerWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w;

/*!
 @brief Tries to create or activate a worker if too few are active.
 */
- (void)signalWork;

/*!
 @brief Performs tryUnpush for an external submitter.
 */
- (jboolean)tryExternalUnpushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentForkJoinPool)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, auxState_, JavaUtilConcurrentForkJoinPool_AuxState *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, workQueues_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, workerNamePrefix_, NSString *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, factory_, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, ueh_, id<JavaLangThread_UncaughtExceptionHandler>)

inline jint JavaUtilConcurrentForkJoinPool_get_SMASK(void);
#define JavaUtilConcurrentForkJoinPool_SMASK 65535
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, SMASK, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_MAX_CAP(void);
#define JavaUtilConcurrentForkJoinPool_MAX_CAP 32767
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, MAX_CAP, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_EVENMASK(void);
#define JavaUtilConcurrentForkJoinPool_EVENMASK 65534
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, EVENMASK, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_SQMASK(void);
#define JavaUtilConcurrentForkJoinPool_SQMASK 126
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, SQMASK, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_UNSIGNALLED(void);
#define JavaUtilConcurrentForkJoinPool_UNSIGNALLED ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, UNSIGNALLED, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_SS_SEQ(void);
#define JavaUtilConcurrentForkJoinPool_SS_SEQ 65536
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, SS_SEQ, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_MODE_MASK(void);
#define JavaUtilConcurrentForkJoinPool_MODE_MASK -65536
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, MODE_MASK, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_SPARE_WORKER(void);
#define JavaUtilConcurrentForkJoinPool_SPARE_WORKER 131072
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, SPARE_WORKER, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_UNREGISTERED(void);
#define JavaUtilConcurrentForkJoinPool_UNREGISTERED 262144
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, UNREGISTERED, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_FIFO_QUEUE(void);
#define JavaUtilConcurrentForkJoinPool_FIFO_QUEUE ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, FIFO_QUEUE, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_LIFO_QUEUE(void);
#define JavaUtilConcurrentForkJoinPool_LIFO_QUEUE 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, LIFO_QUEUE, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_IS_OWNED(void);
#define JavaUtilConcurrentForkJoinPool_IS_OWNED 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, IS_OWNED, jint)

/*!
 @brief The maximum number of task executions from the same queue
  before checking other queues, bounding unfairness and impact of
  infinite user task recursion.Must be a power of two minus 1.
 */
inline jint JavaUtilConcurrentForkJoinPool_get_POLL_LIMIT(void);
#define JavaUtilConcurrentForkJoinPool_POLL_LIMIT 1023
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, POLL_LIMIT, jint)

/*!
 @brief Creates a new ForkJoinWorkerThread.This factory is used unless
  overridden in ForkJoinPool constructors.
 */
inline id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> JavaUtilConcurrentForkJoinPool_get_defaultForkJoinWorkerThreadFactory(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> JavaUtilConcurrentForkJoinPool_defaultForkJoinWorkerThreadFactory;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentForkJoinPool, defaultForkJoinWorkerThreadFactory, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)

/*!
 @brief Permission required for callers of methods that may start or
  kill threads.Also used as a static lock in tryInitialize.
 */
inline JavaLangRuntimePermission *JavaUtilConcurrentForkJoinPool_get_modifyThreadPermission(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaLangRuntimePermission *JavaUtilConcurrentForkJoinPool_modifyThreadPermission;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentForkJoinPool, modifyThreadPermission, JavaLangRuntimePermission *)

/*!
 @brief Common (static) pool.Non-null for public use unless a static
  construction exception, but internal usages null-check on use
  to paranoically avoid potential initialization circularities
  as well as to simplify generated code.
 */
inline JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_get_common(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_common;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentForkJoinPool, common, JavaUtilConcurrentForkJoinPool *)

/*!
 @brief Common pool parallelism.To allow simpler use and management
  when common pool threads are disabled, we allow the underlying
  common.parallelism field to be zero, but in that case still report
  parallelism as 1 to reflect resulting caller-runs mechanics.
 */
inline jint JavaUtilConcurrentForkJoinPool_get_COMMON_PARALLELISM(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinPool_COMMON_PARALLELISM;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentForkJoinPool, COMMON_PARALLELISM, jint)

FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinPool_getSurplusQueuedTaskCount(void);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_WorkQueue *JavaUtilConcurrentForkJoinPool_commonSubmitterQueue(void);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_init(JavaUtilConcurrentForkJoinPool *self);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *new_JavaUtilConcurrentForkJoinPool_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *create_JavaUtilConcurrentForkJoinPool_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_initWithInt_(JavaUtilConcurrentForkJoinPool *self, jint parallelism);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *new_JavaUtilConcurrentForkJoinPool_initWithInt_(jint parallelism) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *create_JavaUtilConcurrentForkJoinPool_initWithInt_(jint parallelism);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_initWithInt_withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_withJavaLangThread_UncaughtExceptionHandler_withBoolean_(JavaUtilConcurrentForkJoinPool *self, jint parallelism, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory, id<JavaLangThread_UncaughtExceptionHandler> handler, jboolean asyncMode);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *new_JavaUtilConcurrentForkJoinPool_initWithInt_withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_withJavaLangThread_UncaughtExceptionHandler_withBoolean_(jint parallelism, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory, id<JavaLangThread_UncaughtExceptionHandler> handler, jboolean asyncMode) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *create_JavaUtilConcurrentForkJoinPool_initWithInt_withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_withJavaLangThread_UncaughtExceptionHandler_withBoolean_(jint parallelism, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory, id<JavaLangThread_UncaughtExceptionHandler> handler, jboolean asyncMode);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_commonPool(void);

FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinPool_getCommonPoolParallelism(void);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_quiesceCommonPool(void);

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_managedBlockWithJavaUtilConcurrentForkJoinPool_ManagedBlocker_(id<JavaUtilConcurrentForkJoinPool_ManagedBlocker> blocker);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_makeCommonPool(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinPool || defined(INCLUDE_JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory))
#define JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_

@class JavaUtilConcurrentForkJoinPool;
@class JavaUtilConcurrentForkJoinWorkerThread;

/*!
 @brief Factory for creating new <code>ForkJoinWorkerThread</code>s.
 A <code>ForkJoinWorkerThreadFactory</code> must be defined and used
  for <code>ForkJoinWorkerThread</code> subclasses that extend base
  functionality or initialize threads with different contexts.
 */
@protocol JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory < JavaObject >

/*!
 @brief Returns a new worker thread operating in the given pool.
 @param pool the pool this thread works in
 @return the new worker thread, or <code>null</code> if the request
          to create a thread is rejected
 @throw NullPointerExceptionif the pool is null
 */
- (JavaUtilConcurrentForkJoinWorkerThread *)newThreadWithJavaUtilConcurrentForkJoinPool:(JavaUtilConcurrentForkJoinPool *)pool OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory)

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_AuxState_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinPool || defined(INCLUDE_JavaUtilConcurrentForkJoinPool_AuxState))
#define JavaUtilConcurrentForkJoinPool_AuxState_

#define RESTRICT_JavaUtilConcurrentLocksReentrantLock 1
#define INCLUDE_JavaUtilConcurrentLocksReentrantLock 1
#include "java/util/concurrent/locks/ReentrantLock.h"

/*!
 @brief Additional fields and lock created upon initialization.
 */
@interface JavaUtilConcurrentForkJoinPool_AuxState : JavaUtilConcurrentLocksReentrantLock {
 @public
  volatile_jlong stealCount_;
  jlong indexSeed_;
}

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_AuxState)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_AuxState_init(JavaUtilConcurrentForkJoinPool_AuxState *self);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_AuxState *new_JavaUtilConcurrentForkJoinPool_AuxState_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_AuxState *create_JavaUtilConcurrentForkJoinPool_AuxState_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_AuxState)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_WorkQueue_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinPool || defined(INCLUDE_JavaUtilConcurrentForkJoinPool_WorkQueue))
#define JavaUtilConcurrentForkJoinPool_WorkQueue_

@class IOSObjectArray;
@class JavaLangThread;
@class JavaUtilConcurrentCountedCompleter;
@class JavaUtilConcurrentForkJoinPool;
@class JavaUtilConcurrentForkJoinTask;
@class JavaUtilConcurrentForkJoinWorkerThread;

/*!
 @brief Queues supporting work-stealing as well as external task
  submission.See above for descriptions and algorithms.
 Performance on most platforms is very sensitive to placement of
  instances of both WorkQueues and their arrays -- we absolutely
  do not want multiple WorkQueue instances or multiple queue
  arrays sharing cache lines. The @@Contended annotation alerts
  JVMs to try to keep instances apart.
 */
@interface JavaUtilConcurrentForkJoinPool_WorkQueue : NSObject {
 @public
  volatile_jint scanState_;
  jint stackPred_;
  jint nsteals_;
  jint hint_;
  jint config_;
  volatile_jint qlock_;
  volatile_jint base_;
  jint top_;
  IOSObjectArray *array_;
  __unsafe_unretained JavaUtilConcurrentForkJoinPool *pool_;
  JavaUtilConcurrentForkJoinWorkerThread *owner_;
  volatile_id parker_;
  volatile_id currentJoin_;
  volatile_id currentSteal_;
}
@property (readonly, class) jint INITIAL_QUEUE_CAPACITY NS_SWIFT_NAME(INITIAL_QUEUE_CAPACITY);
@property (readonly, class) jint MAXIMUM_QUEUE_CAPACITY NS_SWIFT_NAME(MAXIMUM_QUEUE_CAPACITY);

+ (jint)INITIAL_QUEUE_CAPACITY;

+ (jint)MAXIMUM_QUEUE_CAPACITY;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentForkJoinPool:(JavaUtilConcurrentForkJoinPool *)pool
                      withJavaUtilConcurrentForkJoinWorkerThread:(JavaUtilConcurrentForkJoinWorkerThread *)owner;

/*!
 @brief Removes and cancels all known tasks, ignoring any exceptions.
 */
- (void)cancelAll;

/*!
 @brief Returns an exportable index (used by ForkJoinWorkerThread).
 */
- (jint)getPoolIndex;

/*!
 @brief Initializes or doubles the capacity of array.Call either
  by owner or with lock held -- it is OK for base, but not
  top, to move while resizings are in progress.
 */
- (IOSObjectArray *)growArray;

/*!
 @brief Returns true if owned and not known to be blocked.
 */
- (jboolean)isApparentlyUnblocked;

/*!
 @brief Provides a more accurate estimate of whether this queue has
  any tasks than does queueSize, by checking whether a
  near-empty queue has at least one unclaimed task.
 */
- (jboolean)isEmpty;

/*!
 @brief Polls and executes up to POLL_LIMIT tasks or until empty.
 */
- (void)localPollAndExec;

/*!
 @brief Pops and executes up to POLL_LIMIT tasks or until empty.
 */
- (void)localPopAndExec;

/*!
 @brief Takes next task, if one exists, in order specified by mode.
 */
- (JavaUtilConcurrentForkJoinTask *)nextLocalTask;

/*!
 @brief Returns next task, if one exists, in order specified by mode.
 */
- (JavaUtilConcurrentForkJoinTask *)peek;

/*!
 @brief Takes next task, if one exists, in FIFO order.
 */
- (JavaUtilConcurrentForkJoinTask *)poll;

/*!
 @brief Steals and runs a task in the same CC computation as the
  given task if one exists and can be taken without
  contention.Otherwise returns a checksum/control value for
  use by method helpComplete.
 @return 1 if successful, 2 if retryable (lost to another
  stealer), -1 if non-empty but no matching task found, else
  the base index, forced negative.
 */
- (jint)pollAndExecCCWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)task;

/*!
 @brief Takes a task in FIFO order if b is base of queue and a task
  can be claimed without contention.Specialized versions
  appear in ForkJoinPool methods scan and helpStealer.
 */
- (JavaUtilConcurrentForkJoinTask *)pollAtWithInt:(jint)b;

/*!
 @brief Takes next task, if one exists, in LIFO order.Call only
  by owner in unshared queues.
 */
- (JavaUtilConcurrentForkJoinTask *)pop;

/*!
 @brief Pops task if in the same CC computation as the given task,
  in either shared or owned mode.Used only by helpComplete.
 */
- (JavaUtilConcurrentCountedCompleter *)popCCWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)task
                                                                            withInt:(jint)mode;

/*!
 @brief Pushes a task.Call only by owner in unshared queues.
 @param task the task. Caller must ensure non-null.
 @throw RejectedExecutionExceptionif array cannot be resized
 */
- (void)pushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Returns the approximate number of tasks in the queue.
 */
- (jint)queueSize;

/*!
 @brief Executes the given task and (some) remaining local tasks.
 */
- (void)runTaskWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Shared version of push.Fails if already locked.
 @return status: > 0 locked, 0 possibly was empty, < 0 was nonempty
 */
- (jint)sharedPushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Adds steal count to pool steal count if it exists, and resets.
 */
- (void)transferStealCountWithJavaUtilConcurrentForkJoinPool:(JavaUtilConcurrentForkJoinPool *)p;

/*!
 @brief If present, removes from queue and executes the given task,
  or any other cancelled task.Used only by awaitJoin.
 @return true if queue empty and task not known to be done
 */
- (jboolean)tryRemoveAndExecWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Shared version of tryUnpush.
 */
- (jboolean)trySharedUnpushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Pops the given task only if it is at the current top.
 */
- (jboolean)tryUnpushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentForkJoinPool_WorkQueue)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, array_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, owner_, JavaUtilConcurrentForkJoinWorkerThread *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, parker_, JavaLangThread *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, currentJoin_, JavaUtilConcurrentForkJoinTask *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, currentSteal_, JavaUtilConcurrentForkJoinTask *)

/*!
 @brief Capacity of work-stealing queue array upon initialization.
 Must be a power of two; at least 4, but should be larger to
  reduce or eliminate cacheline sharing among queues.
  Currently, it is much larger, as a partial workaround for
  the fact that JVMs often place arrays in locations that
  share GC bookkeeping (especially cardmarks) such that
  per-write accesses encounter serious memory contention.
 */
inline jint JavaUtilConcurrentForkJoinPool_WorkQueue_get_INITIAL_QUEUE_CAPACITY(void);
#define JavaUtilConcurrentForkJoinPool_WorkQueue_INITIAL_QUEUE_CAPACITY 8192
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool_WorkQueue, INITIAL_QUEUE_CAPACITY, jint)

/*!
 @brief Maximum size for queue arrays.Must be a power of two less
  than or equal to 1 << (31 - width of array entry) to ensure
  lack of wraparound of index calculations, but defined to a
  value a bit less than this to help users trap runaway
  programs before saturating systems.
 */
inline jint JavaUtilConcurrentForkJoinPool_WorkQueue_get_MAXIMUM_QUEUE_CAPACITY(void);
#define JavaUtilConcurrentForkJoinPool_WorkQueue_MAXIMUM_QUEUE_CAPACITY 67108864
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool_WorkQueue, MAXIMUM_QUEUE_CAPACITY, jint)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_WorkQueue_initWithJavaUtilConcurrentForkJoinPool_withJavaUtilConcurrentForkJoinWorkerThread_(JavaUtilConcurrentForkJoinPool_WorkQueue *self, JavaUtilConcurrentForkJoinPool *pool, JavaUtilConcurrentForkJoinWorkerThread *owner);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_WorkQueue *new_JavaUtilConcurrentForkJoinPool_WorkQueue_initWithJavaUtilConcurrentForkJoinPool_withJavaUtilConcurrentForkJoinWorkerThread_(JavaUtilConcurrentForkJoinPool *pool, JavaUtilConcurrentForkJoinWorkerThread *owner) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_WorkQueue *create_JavaUtilConcurrentForkJoinPool_WorkQueue_initWithJavaUtilConcurrentForkJoinPool_withJavaUtilConcurrentForkJoinWorkerThread_(JavaUtilConcurrentForkJoinPool *pool, JavaUtilConcurrentForkJoinWorkerThread *owner);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_WorkQueue)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_ManagedBlocker_) && (INCLUDE_ALL_JavaUtilConcurrentForkJoinPool || defined(INCLUDE_JavaUtilConcurrentForkJoinPool_ManagedBlocker))
#define JavaUtilConcurrentForkJoinPool_ManagedBlocker_

/*!
 @brief Interface for extending managed parallelism for tasks running
  in <code>ForkJoinPool</code>s.
 <p>A <code>ManagedBlocker</code> provides two methods.  Method 
 <code>isReleasable</code> must return <code>true</code> if blocking is
  not necessary. Method <code>block</code> blocks the current thread
  if necessary (perhaps internally invoking <code>isReleasable</code>
  before actually blocking). These actions are performed by any
  thread invoking <code>ForkJoinPool.managedBlock(ManagedBlocker)</code>.
  The unusual methods in this API accommodate synchronizers that
  may, but don't usually, block for long periods. Similarly, they
  allow more efficient internal handling of cases in which
  additional workers may be, but usually are not, needed to
  ensure sufficient parallelism.  Toward this end,
  implementations of method <code>isReleasable</code> must be amenable
  to repeated invocation. 
 <p>For example, here is a ManagedBlocker based on a
  ReentrantLock: 
 @code
  class ManagedLocker implements ManagedBlocker {
    final ReentrantLock lock;
    boolean hasLock = false;
    ManagedLocker(ReentrantLock lock) { this.lock = lock; }
    public boolean block() {
      if (!hasLock)
        lock.lock();
      return true;
    }
    public boolean isReleasable() {
      return hasLock || (hasLock = lock.tryLock());
    }  }
 
@endcode
  
 <p>Here is a class that possibly blocks waiting for an
  item on a given queue: 
 @code
  class QueueTaker<E> implements ManagedBlocker {
    final BlockingQueue<E> queue;
    volatile E item = null;
    QueueTaker(BlockingQueue<E> q) { this.queue = q; }
    public boolean block() throws InterruptedException {
      if (item == null)
        item = queue.take();
      return true;
    }
    public boolean isReleasable() {
      return item != null || (item = queue.poll()) != null;
    }
    public E getItem() { // call after pool.managedBlock completes
      return item;
    }  }
 
@endcode
 */
@protocol JavaUtilConcurrentForkJoinPool_ManagedBlocker < JavaObject >

/*!
 @brief Possibly blocks the current thread, for example waiting for
  a lock or condition.
 @return <code>true</code> if no additional blocking is necessary
  (i.e., if isReleasable would return true)
 @throw InterruptedExceptionif interrupted while waiting
  (the method is not required to do so, but is allowed to)
 */
- (jboolean)block;

/*!
 @brief Returns <code>true</code> if blocking is unnecessary.
 @return <code>true</code> if blocking is unnecessary
 */
- (jboolean)isReleasable;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_ManagedBlocker)

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_ManagedBlocker)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentForkJoinPool")
