//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/ConcurrentSkipListMap.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap")
#ifdef RESTRICT_JavaUtilConcurrentConcurrentSkipListMap
#define INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap 1
#endif
#undef RESTRICT_JavaUtilConcurrentConcurrentSkipListMap
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_EntryIterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Iter 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_KeyIterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Iter 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_ValueIterator
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Iter 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_HeadIndex
#define INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Index 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap))
#define JavaUtilConcurrentConcurrentSkipListMap_

#define RESTRICT_JavaUtilAbstractMap 1
#define INCLUDE_JavaUtilAbstractMap 1
#include "java/util/AbstractMap.h"

#define RESTRICT_JavaUtilConcurrentConcurrentNavigableMap 1
#define INCLUDE_JavaUtilConcurrentConcurrentNavigableMap 1
#include "java/util/concurrent/ConcurrentNavigableMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilAbstractMap_SimpleImmutableEntry;
@class JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator;
@class JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@class JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSet;
@protocol JavaUtilSortedMap;

/*!
 @brief A scalable concurrent <code>ConcurrentNavigableMap</code> implementation.
 The map is sorted according to the natural
  ordering
  of its keys, or by a <code>Comparator</code> provided at map
  creation time, depending on which constructor is used. 
 <p>This class implements a concurrent variant of <a href="http://en.wikipedia.org/wiki/Skip_list" target="_top">
 SkipLists</a>
  providing expected average <i>log(n)</i> time cost for the 
 <code>containsKey</code>, <code>get</code>, <code>put</code> and 
 <code>remove</code> operations and their variants.  Insertion, removal,
  update, and access operations safely execute concurrently by
  multiple threads. 
 <p>Iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>Ascending key ordered views and their iterators are faster than
  descending ones. 
 <p>All <code>Map.Entry</code> pairs returned by methods in this class
  and its views represent snapshots of mappings at the time they were
  produced. They do <em>not</em> support the <code>Entry.setValue</code>
  method. (Note however that it is possible to change mappings in the
  associated map using <code>put</code>, <code>putIfAbsent</code>, or 
 <code>replace</code>, depending on exactly which effect you need.) 
 <p>Beware that, unlike in most collections, the <code>size</code>
  method is <em>not</em> a constant-time operation. Because of the
  asynchronous nature of these maps, determining the current number
  of elements requires a traversal of the elements, and so may report
  inaccurate results if this collection is modified during traversal.
  Additionally, the bulk operations <code>putAll</code>, <code>equals</code>,
  <code>toArray</code>, <code>containsValue</code>, and <code>clear</code> are 
 <em>not</em> guaranteed to be performed atomically. For example, an
  iterator operating concurrently with a <code>putAll</code> operation
  might view only some of the added elements. 
 <p>This class and its views and iterators implement all of the 
 <em>optional</em> methods of the <code>Map</code> and <code>Iterator</code>
  interfaces. Like most other concurrent collections, this class does 
 <em>not</em> permit the use of <code>null</code> keys or values because some
  null return values cannot be reliably distinguished from the absence of
  elements.
 @author Doug Lea
 @since 1.6
 */
@interface JavaUtilConcurrentConcurrentSkipListMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentNavigableMap, NSCopying, JavaIoSerializable > {
 @public
  /*!
   @brief The comparator used to maintain order in this map, or null if
  using natural ordering.
   (Non-private to simplify access in
  nested classes.)
   */
  id<JavaUtilComparator> comparator_;
}
@property (readonly, class, strong) id BASE_HEADER NS_SWIFT_NAME(BASE_HEADER);

+ (id)BASE_HEADER;

#pragma mark Public

/*!
 @brief Constructs a new, empty map, sorted according to the 
 natural ordering of the keys.
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs a new, empty map, sorted according to the specified
  comparator.
 @param comparator the comparator that will be used to order this map.         If 
 <code>null</code> , the natural
         ordering
   of the keys will be used.
 */
- (instancetype __nonnull)initWithJavaUtilComparator:(id<JavaUtilComparator>)comparator;

/*!
 @brief Constructs a new map containing the same mappings as the given map,
  sorted according to the natural ordering of
  the keys.
 @param m the map whose mappings are to be placed in this map
 @throw ClassCastExceptionif the keys in <code>m</code> are not
          <code>Comparable</code>, or are not mutually comparable
 @throw NullPointerExceptionif the specified map or any of its keys
          or values are null
 */
- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Constructs a new map containing the same mappings and using the
  same ordering as the specified sorted map.
 @param m the sorted map whose mappings are to be placed in this         map, and whose comparator is to be used to sort this map
 @throw NullPointerExceptionif the specified sorted map or any of
          its keys or values are null
 */
- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m;

/*!
 @brief Returns a key-value mapping associated with the least key
  greater than or equal to the given key, or <code>null</code> if
  there is no such entry.The returned entry does <em>not</em>
  support the <code>Entry.setValue</code> method.
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id)ceilingKeyWithId:(id)key;

/*!
 @brief Removes all of the mappings from this map.
 */
- (void)clear;

/*!
 @brief Returns a shallow copy of this <code>ConcurrentSkipListMap</code>
  instance.
 (The keys and values themselves are not cloned.)
 @return a shallow copy of this map
 */
- (JavaUtilConcurrentConcurrentSkipListMap *)java_clone;

- (id<JavaUtilComparator>)comparator;

/*!
 @brief Attempts to compute a mapping for the specified key and its
  current mapped value (or <code>null</code> if there is no current
  mapping).The function is <em>NOT</em> guaranteed to be applied
  once atomically.
 @param key key with which the specified value is to be associated
 @param remappingFunction the function to compute a value
 @return the new value associated with the specified key, or null if none
 @throw NullPointerExceptionif the specified key is null
          or the remappingFunction is null
 @since 1.8
 */
- (id)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief If the specified key is not already associated with a value,
  attempts to compute its value using the given mapping function
  and enters it into this map unless <code>null</code>.The function
  is <em>NOT</em> guaranteed to be applied once atomically only
  if the value is not present.
 @param key key with which the specified value is to be associated
 @param mappingFunction the function to compute a value
 @return the current (existing or computed) value associated with
          the specified key, or null if the computed value is null
 @throw NullPointerExceptionif the specified key is null
          or the mappingFunction is null
 @since 1.8
 */
- (id)computeIfAbsentWithId:(id)key
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

/*!
 @brief If the value for the specified key is present, attempts to
  compute a new mapping given the key and its current mapped
  value.The function is <em>NOT</em> guaranteed to be applied
  once atomically.
 @param key key with which a value may be associated
 @param remappingFunction the function to compute a value
 @return the new value associated with the specified key, or null if none
 @throw NullPointerExceptionif the specified key is null
          or the remappingFunction is null
 @since 1.8
 */
- (id)computeIfPresentWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @brief Returns <code>true</code> if this map contains a mapping for the specified
  key.
 @param key key whose presence in this map is to be tested
 @return <code>true</code> if this map contains a mapping for the specified key
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key is null
 */
- (jboolean)containsKeyWithId:(id)key;

/*!
 @brief Returns <code>true</code> if this map maps one or more keys to the
  specified value.This operation requires time linear in the
  map size.
 Additionally, it is possible for the map to change
  during execution of this method, in which case the returned
  result may be inaccurate.
 @param value value whose presence in this map is to be tested
 @return <code>true</code> if a mapping to <code>value</code> exists;
          <code>false</code> otherwise
 @throw NullPointerExceptionif the specified value is null
 */
- (jboolean)containsValueWithId:(id)value;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (id<JavaUtilConcurrentConcurrentNavigableMap>)descendingMap;

/*!
 @brief Returns a <code>Set</code> view of the mappings contained in this map.
 <p>The set's iterator returns the entries in ascending key order.  The
  set's spliterator additionally reports <code>Spliterator.CONCURRENT</code>,
  <code>Spliterator.NONNULL</code>, <code>Spliterator.SORTED</code> and 
 <code>Spliterator.ORDERED</code>, with an encounter order that is ascending
  key order. 
 <p>The set is backed by the map, so changes to the map are
  reflected in the set, and vice-versa.  The set supports element
  removal, which removes the corresponding mapping from the map,
  via the <code>Iterator.remove</code>, <code>Set.remove</code>,
  <code>removeAll</code>, <code>retainAll</code> and <code>clear</code>
  operations.  It does not support the <code>add</code> or 
 <code>addAll</code> operations. 
 <p>The view's iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>The <code>Map.Entry</code> elements traversed by the <code>iterator</code>
  or <code>spliterator</code> do <em>not</em> support the <code>setValue</code>
  operation.
 @return a set view of the mappings contained in this map,
          sorted in ascending key order
 */
- (id<JavaUtilSet>)entrySet;

/*!
 @brief Compares the specified object with this map for equality.
 Returns <code>true</code> if the given object is also a map and the
  two maps represent the same mappings.  More formally, two maps 
 <code>m1</code> and <code>m2</code> represent the same mappings if 
 <code>m1.entrySet().equals(m2.entrySet())</code>.  This
  operation may return misleading results if either map is
  concurrently modified during execution of this method.
 @param o object to be compared for equality with this map
 @return <code>true</code> if the specified object is equal to this map
 */
- (jboolean)isEqual:(id)o;

/*!
 @brief Returns a key-value mapping associated with the least
  key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
  the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)firstEntry;

/*!
 @throw NoSuchElementException
 */
- (id)firstKey;

/*!
 @brief Returns a key-value mapping associated with the greatest key
  less than or equal to the given key, or <code>null</code> if there
  is no such key.The returned entry does <em>not</em> support
  the <code>Entry.setValue</code> method.
 @param key the key
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

/*!
 @param key the key
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id)floorKeyWithId:(id)key;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief Returns the value to which the specified key is mapped,
  or <code>null</code> if this map contains no mapping for the key.
 <p>More formally, if this map contains a mapping from a key 
 <code>k</code> to a value <code>v</code> such that <code>key</code> compares
  equal to <code>k</code> according to the map's ordering, then this
  method returns <code>v</code>; otherwise it returns <code>null</code>.
  (There can be at most one such mapping.)
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key is null
 */
- (id)getWithId:(id)key;

/*!
 @brief Returns the value to which the specified key is mapped,
  or the given defaultValue if this map contains no mapping for the key.
 @param key the key
 @param defaultValue the value to return if this map contains  no mapping for the given key
 @return the mapping for the key, if present; else the defaultValue
 @throw NullPointerExceptionif the specified key is null
 @since 1.8
 */
- (id)getOrDefaultWithId:(id)key
                  withId:(id)defaultValue;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif <code>toKey</code> is null
 @throw IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)headMapWithId:(id)toKey;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif <code>toKey</code> is null
 @throw IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)headMapWithId:(id)toKey
                                                  withBoolean:(jboolean)inclusive;

/*!
 @brief Returns a key-value mapping associated with the least key
  strictly greater than the given key, or <code>null</code> if there
  is no such key.The returned entry does <em>not</em> support
  the <code>Entry.setValue</code> method.
 @param key the key
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

/*!
 @param key the key
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id)higherKeyWithId:(id)key;

/*!
 @brief Returns <code>true</code> if this map contains no key-value mappings.
 @return <code>true</code> if this map contains no key-value mappings
 */
- (jboolean)isEmpty;

/*!
 @brief Returns a <code>NavigableSet</code> view of the keys contained in this map.
 <p>The set's iterator returns the keys in ascending order.
  The set's spliterator additionally reports <code>Spliterator.CONCURRENT</code>,
  <code>Spliterator.NONNULL</code>, <code>Spliterator.SORTED</code> and 
 <code>Spliterator.ORDERED</code>, with an encounter order that is ascending
  key order.  The spliterator's comparator (see 
 <code>java.util.Spliterator.getComparator()</code>) is <code>null</code> if
  the map's comparator (see <code>comparator()</code>) is <code>null</code>.
  Otherwise, the spliterator's comparator is the same as or imposes the
  same total ordering as the map's comparator. 
 <p>The set is backed by the map, so changes to the map are
  reflected in the set, and vice-versa.  The set supports element
  removal, which removes the corresponding mapping from the map,
  via the <code>Iterator.remove</code>, <code>Set.remove</code>,
  <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>
  operations.  It does not support the <code>add</code> or <code>addAll</code>
  operations. 
 <p>The view's iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
  
 <p>This method is equivalent to method <code>navigableKeySet</code>.
 @return a navigable set view of the keys in this map
 */
- (id<JavaUtilNavigableSet>)keySet;

/*!
 @brief Returns a key-value mapping associated with the greatest
  key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
  the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)lastEntry;

/*!
 @throw NoSuchElementException
 */
- (id)lastKey;

/*!
 @brief Returns a key-value mapping associated with the greatest key
  strictly less than the given key, or <code>null</code> if there is
  no such key.The returned entry does <em>not</em> support the 
 <code>Entry.setValue</code> method.
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif the specified key is null
 */
- (id)lowerKeyWithId:(id)key;

/*!
 @brief If the specified key is not already associated with a value,
  associates it with the given value.Otherwise, replaces the
  value with the results of the given remapping function, or
  removes if <code>null</code>.
 The function is <em>NOT</em>
  guaranteed to be applied once atomically.
 @param key key with which the specified value is to be associated
 @param value the value to use if absent
 @param remappingFunction the function to recompute a value if present
 @return the new value associated with the specified key, or null if none
 @throw NullPointerExceptionif the specified key or value is null
          or the remappingFunction is null
 @since 1.8
 */
- (id)mergeWithId:(id)key
           withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id<JavaUtilNavigableSet>)navigableKeySet;

/*!
 @brief Removes and returns a key-value mapping associated with
  the least key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
  the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)pollFirstEntry;

/*!
 @brief Removes and returns a key-value mapping associated with
  the greatest key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
  the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)pollLastEntry;

/*!
 @brief Associates the specified value with the specified key in this map.
 If the map previously contained a mapping for the key, the old
  value is replaced.
 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with the specified key, or
          <code>null</code> if there was no mapping for the key
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key or value is null
 */
- (id)putWithId:(id)key
         withId:(id)value;

/*!
 @return the previous value associated with the specified key,
          or <code>null</code> if there was no mapping for the key
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key or value is null
 */
- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

/*!
 @brief Removes the mapping for the specified key from this map if present.
 @param key key for which mapping should be removed
 @return the previous value associated with the specified key, or
          <code>null</code> if there was no mapping for the key
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key is null
 */
- (id)removeWithId:(id)key;

/*!
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key is null
 */
- (jboolean)removeWithId:(id)key
                  withId:(id)value;

/*!
 @return the previous value associated with the specified key,
          or <code>null</code> if there was no mapping for the key
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif the specified key or value is null
 */
- (id)replaceWithId:(id)key
             withId:(id)value;

/*!
 @throw ClassCastExceptionif the specified key cannot be compared
          with the keys currently in the map
 @throw NullPointerExceptionif any of the arguments are null
 */
- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

/*!
 @brief Returns the number of key-value mappings in this map.If this map
  contains more than <code>Integer.MAX_VALUE</code> elements, it
  returns <code>Integer.MAX_VALUE</code>.
 <p>Beware that, unlike in most collections, this method is 
 <em>NOT</em> a constant-time operation. Because of the
  asynchronous nature of these maps, determining the current
  number of elements requires traversing them all to count them.
  Additionally, it is possible for the size to change during
  execution of this method, in which case the returned result
  will be inaccurate. Thus, this method is typically not very
  useful in concurrent applications.
 @return the number of elements in this map
 */
- (jint)size;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif <code>fromKey</code> or <code>toKey</code> is null
 @throw IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)subMapWithId:(id)fromKey
                                                 withBoolean:(jboolean)fromInclusive
                                                      withId:(id)toKey
                                                 withBoolean:(jboolean)toInclusive;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif <code>fromKey</code> or <code>toKey</code> is null
 @throw IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)subMapWithId:(id)fromKey
                                                      withId:(id)toKey;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif <code>fromKey</code> is null
 @throw IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)tailMapWithId:(id)fromKey;

/*!
 @throw ClassCastException
 @throw NullPointerExceptionif <code>fromKey</code> is null
 @throw IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)tailMapWithId:(id)fromKey
                                                  withBoolean:(jboolean)inclusive;

/*!
 @brief Returns a <code>Collection</code> view of the values contained in this map.
 <p>The collection's iterator returns the values in ascending order
  of the corresponding keys. The collections's spliterator additionally
  reports <code>Spliterator.CONCURRENT</code>, <code>Spliterator.NONNULL</code> and 
 <code>Spliterator.ORDERED</code>, with an encounter order that is ascending
  order of the corresponding keys. 
 <p>The collection is backed by the map, so changes to the map are
  reflected in the collection, and vice-versa.  The collection
  supports element removal, which removes the corresponding
  mapping from the map, via the <code>Iterator.remove</code>,
  <code>Collection.remove</code>, <code>removeAll</code>,
  <code>retainAll</code> and <code>clear</code> operations.  It does not
  support the <code>add</code> or <code>addAll</code> operations. 
 <p>The view's iterators and spliterators are 
 <a href="package-summary.html#Weakly"><i>weakly consistent</i></a>.
 */
- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

/*!
 @brief Compares using comparator or natural ordering if null.
 Called only by methods that have performed required type checks.
 */
+ (jint)cprWithJavaUtilComparator:(id<JavaUtilComparator>)c
                           withId:(id)x
                           withId:(id)y;

/*!
 @brief Main deletion method.Locates node, nulls value, appends a
  deletion marker, unlinks predecessor, removes associated index
  nodes, and possibly reduces head index level.
 Index nodes are cleared out simply by calling findPredecessor.
  which unlinks indexes to deleted nodes found along path to key,
  which will include the indexes to this node.  This is done
  unconditionally. We can't check beforehand whether there are
  index nodes because it might be the case that some or all
  indexes hadn't been inserted yet for this node during initial
  search for it, and we'd like to ensure lack of garbage
  retention, so must call to be sure.
 @param key the key
 @param value if non-null, the value that must be  associated with key
 @return the node, or null if not found
 */
- (id)doRemoveWithId:(id)key
              withId:(id)value;

- (JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator *)entrySpliterator;

/*!
 @brief Specialized variant of findNode to get first valid node.
 @return first node or null if empty
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)findFirst;

/*!
 @brief Specialized version of find to get last valid node.
 @return last node or null if empty
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)findLast;

/*!
 @brief Utility for ceiling, floor, lower, higher methods.
 @param key the key
 @param rel the relation -- OR'ed combination of EQ, LT, GT
 @return nearest node fitting relation, or null if no such
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)findNearWithId:(id)key
                                                         withInt:(jint)rel
                                          withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Returns SimpleImmutableEntry for results of findNear.
 @param key the key
 @param rel the relation -- OR'ed combination of EQ, LT, GT
 @return Entry fitting relation, or null if no such
 */
- (JavaUtilAbstractMap_SimpleImmutableEntry *)getNearWithId:(id)key
                                                    withInt:(jint)rel;

- (JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator *)keySpliterator;

/*!
 @brief Helper method for EntrySet.removeIf.
 */
- (jboolean)removeEntryIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)function;

/*!
 @brief Helper method for Values.removeIf.
 */
- (jboolean)removeValueIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)function;

+ (id<JavaUtilList>)toListWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator *)valueSpliterator;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap, comparator_, id<JavaUtilComparator>)

/*!
 @brief Special value used to identify base-level header.
 */
inline id JavaUtilConcurrentConcurrentSkipListMap_get_BASE_HEADER(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id JavaUtilConcurrentConcurrentSkipListMap_BASE_HEADER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentConcurrentSkipListMap, BASE_HEADER, id)

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentSkipListMap_cprWithJavaUtilComparator_withId_withId_(id<JavaUtilComparator> c, id x, id y);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_init(JavaUtilConcurrentConcurrentSkipListMap *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *create_JavaUtilConcurrentConcurrentSkipListMap_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilComparator_(JavaUtilConcurrentConcurrentSkipListMap *self, id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilComparator_(id<JavaUtilComparator> comparator) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *create_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilComparator_(id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilMap_(JavaUtilConcurrentConcurrentSkipListMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *create_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilMap_(id<JavaUtilMap> m);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilSortedMap_(JavaUtilConcurrentConcurrentSkipListMap *self, id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *create_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilConcurrentConcurrentSkipListMap_toListWithJavaUtilCollection_(id<JavaUtilCollection> c);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Node_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Node))
#define JavaUtilConcurrentConcurrentSkipListMap_Node_

@class JavaUtilAbstractMap_SimpleImmutableEntry;

/*!
 @brief Nodes hold keys and values, and are singly linked in sorted
  order, possibly with some intervening marker nodes.The list is
  headed by a dummy node accessible as head.node.
 The value field
  is declared only as Object because it takes special non-V
  values for marker and header nodes.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_Node : NSObject {
 @public
  id key_;
  volatile_id value_;
  volatile_id next_;
}

#pragma mark Package-Private

/*!
 @brief Creates a new regular node.
 */
- (instancetype __nonnull)initWithId:(id)key
                              withId:(id)value
withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)next;

/*!
 @brief Creates a new marker node.A marker is distinguished by
  having its value field point to a sentinel.
 Marker nodes also
  have null keys, a fact that is exploited in a few places,
  but this doesn't distinguish markers from the base-level
  header node (head.node), which also has a null key.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)next;

/*!
 @brief Tries to append a deletion marker to this node.
 @param f the assumed current successor of this node
 @return true if successful
 */
- (jboolean)appendMarkerWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)f;

/*!
 @brief compareAndSet next field.
 */
- (jboolean)casNextWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)cmp
                   withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)val;

/*!
 @brief compareAndSet value field.
 */
- (jboolean)casValueWithId:(id)cmp
                    withId:(id)val;

/*!
 @brief Creates and returns a new SimpleImmutableEntry holding current
  mapping if this node holds a valid value, else null.
 @return new entry or null
 */
- (JavaUtilAbstractMap_SimpleImmutableEntry *)createSnapshot;

/*!
 @brief Returns value if this node contains a valid key-value pair,
  else null.
 @return this node's value if it isn't a marker or header or
  is deleted, else null
 */
- (id)getValidValue;

/*!
 @brief Helps out a deletion by appending marker or unlinking from
  predecessor.This is called during traversals when value
  field seen to be null.
 @param b predecessor
 @param f successor
 */
- (void)helpDeleteWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)b
                  withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)f;

/*!
 @brief Returns true if this node is the header of base-level list.
 @return true if this node is header node
 */
- (jboolean)isBaseHeader;

/*!
 @brief Returns true if this node is a marker.This method isn't
  actually called in any current code checking for markers
  because callers will have already read value field and need
  to use that read (not another done here) and so directly
  test if value points to node.
 @return true if this node is a marker node
 */
- (jboolean)isMarker;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Node)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Node, key_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Node, value_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Node, next_, JavaUtilConcurrentConcurrentSkipListMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Node_initWithId_withId_withJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *self, id key, id value, JavaUtilConcurrentConcurrentSkipListMap_Node *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Node *new_JavaUtilConcurrentConcurrentSkipListMap_Node_initWithId_withId_withJavaUtilConcurrentConcurrentSkipListMap_Node_(id key, id value, JavaUtilConcurrentConcurrentSkipListMap_Node *next) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Node *create_JavaUtilConcurrentConcurrentSkipListMap_Node_initWithId_withId_withJavaUtilConcurrentConcurrentSkipListMap_Node_(id key, id value, JavaUtilConcurrentConcurrentSkipListMap_Node *next);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Node_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *self, JavaUtilConcurrentConcurrentSkipListMap_Node *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Node *new_JavaUtilConcurrentConcurrentSkipListMap_Node_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *next) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Node *create_JavaUtilConcurrentConcurrentSkipListMap_Node_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *next);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Node)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Index_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Index))
#define JavaUtilConcurrentConcurrentSkipListMap_Index_

@class JavaUtilConcurrentConcurrentSkipListMap_Node;

/*!
 @brief Index nodes represent the levels of the skip list.Note that
  even though both Nodes and Indexes have forward-pointing
  fields, they have different types and are handled in different
  ways, that can't nicely be captured by placing field in a
  shared abstract class.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_Index : NSObject {
 @public
  JavaUtilConcurrentConcurrentSkipListMap_Node *node_;
  JavaUtilConcurrentConcurrentSkipListMap_Index *down_;
  volatile_id right_;
}

#pragma mark Package-Private

/*!
 @brief Creates index node with given values.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)node
                             withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)down
                             withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)right;

/*!
 @brief compareAndSet right field.
 */
- (jboolean)casRightWithJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)cmp
                    withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)val;

/*!
 @brief Returns true if the node this indexes has been deleted.
 @return true if indexed node is known to be deleted
 */
- (jboolean)indexesDeletedNode;

/*!
 @brief Tries to CAS newSucc as successor.To minimize races with
  unlink that may lose this index node, if the node being
  indexed is known to be deleted, it doesn't try to link in.
 @param succ the expected current successor
 @param newSucc the new successor
 @return true if successful
 */
- (jboolean)linkWithJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)succ
                withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)newSucc;

/*!
 @brief Tries to CAS right field to skip over apparent successor
  succ.Fails (forcing a retraversal by caller) if this node
  is known to be deleted.
 @param succ the expected current successor
 @return true if successful
 */
- (jboolean)unlinkWithJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)succ;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Index)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Index, node_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Index, down_, JavaUtilConcurrentConcurrentSkipListMap_Index *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Index, right_, JavaUtilConcurrentConcurrentSkipListMap_Index *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Index_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_(JavaUtilConcurrentConcurrentSkipListMap_Index *self, JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Index *new_JavaUtilConcurrentConcurrentSkipListMap_Index_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_(JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Index *create_JavaUtilConcurrentConcurrentSkipListMap_Index_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_(JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Index)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_HeadIndex))
#define JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_

@class JavaUtilConcurrentConcurrentSkipListMap_Index;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;

/*!
 @brief Nodes heading each level keep track of their level.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_HeadIndex : JavaUtilConcurrentConcurrentSkipListMap_Index {
 @public
  jint level_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)node
                             withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)down
                             withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)right
                                                                       withInt:(jint)level;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)arg0
                             withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)arg1
                             withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_withInt_(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex *self, JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right, jint level);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_HeadIndex *new_JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_withInt_(JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right, jint level) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_HeadIndex *create_JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_withInt_(JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right, jint level);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Iter_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Iter))
#define JavaUtilConcurrentConcurrentSkipListMap_Iter_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilFunctionConsumer;

/*!
 @brief Base of iterator classes:
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_Iter : NSObject < JavaUtilIterator > {
 @public
  /*!
   @brief the last node returned by next()
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *lastReturned_;
  /*!
   @brief the next node to return from next();
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *next_;
  /*!
   @brief Cache of next value field to maintain weak consistency
   */
  id nextValue_;
}

#pragma mark Public

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

/*!
 @brief Initializes ascending iterator for entire range.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

/*!
 @brief Advances next to higher entry.
 */
- (void)advance;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Iter)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Iter, lastReturned_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Iter, next_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Iter, nextValue_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Iter_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_Iter *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Iter)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_ValueIterator))
#define JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_

@class JavaUtilConcurrentConcurrentSkipListMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_ValueIterator : JavaUtilConcurrentConcurrentSkipListMap_Iter

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_ValueIterator *new_JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_ValueIterator *create_JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_KeyIterator))
#define JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_

@class JavaUtilConcurrentConcurrentSkipListMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_KeyIterator : JavaUtilConcurrentConcurrentSkipListMap_Iter

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeyIterator *new_JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeyIterator *create_JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_EntryIterator))
#define JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_

@class JavaUtilConcurrentConcurrentSkipListMap;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentSkipListMap_EntryIterator : JavaUtilConcurrentConcurrentSkipListMap_Iter

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntryIterator *new_JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntryIterator *create_JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_KeySet_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_KeySet))
#define JavaUtilConcurrentConcurrentSkipListMap_KeySet_

#define RESTRICT_JavaUtilAbstractSet 1
#define INCLUDE_JavaUtilAbstractSet 1
#include "java/util/AbstractSet.h"

#define RESTRICT_JavaUtilNavigableSet 1
#define INCLUDE_JavaUtilNavigableSet 1
#include "java/util/NavigableSet.h"

@class IOSObjectArray;
@protocol JavaUtilComparator;
@protocol JavaUtilConcurrentConcurrentNavigableMap;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

@interface JavaUtilConcurrentConcurrentSkipListMap_KeySet : JavaUtilAbstractSet < JavaUtilNavigableSet > {
 @public
  id<JavaUtilConcurrentConcurrentNavigableMap> m_;
}

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (void)clear;

- (id<JavaUtilComparator>)comparator;

- (jboolean)containsWithId:(id)o;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (jboolean)isEqual:(id)o;

- (id)first;

- (id)floorWithId:(id)e;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (id)last;

- (id)lowerWithId:(id)e;

- (id)pollFirst;

- (id)pollLast;

- (jboolean)removeWithId:(id)o;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                                  withId:(id)toElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentNavigableMap:(id<JavaUtilConcurrentConcurrentNavigableMap>)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_KeySet)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_KeySet, m_, id<JavaUtilConcurrentConcurrentNavigableMap>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_KeySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(JavaUtilConcurrentConcurrentSkipListMap_KeySet *self, id<JavaUtilConcurrentConcurrentNavigableMap> map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeySet *new_JavaUtilConcurrentConcurrentSkipListMap_KeySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeySet *create_JavaUtilConcurrentConcurrentSkipListMap_KeySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_KeySet)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Values_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_Values))
#define JavaUtilConcurrentConcurrentSkipListMap_Values_

#define RESTRICT_JavaUtilAbstractCollection 1
#define INCLUDE_JavaUtilAbstractCollection 1
#include "java/util/AbstractCollection.h"

@class IOSObjectArray;
@protocol JavaUtilConcurrentConcurrentNavigableMap;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

@interface JavaUtilConcurrentConcurrentSkipListMap_Values : JavaUtilAbstractCollection {
 @public
  id<JavaUtilConcurrentConcurrentNavigableMap> m_;
}

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentNavigableMap:(id<JavaUtilConcurrentConcurrentNavigableMap>)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Values)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Values, m_, id<JavaUtilConcurrentConcurrentNavigableMap>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Values_initWithJavaUtilConcurrentConcurrentNavigableMap_(JavaUtilConcurrentConcurrentSkipListMap_Values *self, id<JavaUtilConcurrentConcurrentNavigableMap> map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Values *new_JavaUtilConcurrentConcurrentSkipListMap_Values_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Values *create_JavaUtilConcurrentConcurrentSkipListMap_Values_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Values)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_EntrySet_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_EntrySet))
#define JavaUtilConcurrentConcurrentSkipListMap_EntrySet_

#define RESTRICT_JavaUtilAbstractSet 1
#define INCLUDE_JavaUtilAbstractSet 1
#include "java/util/AbstractSet.h"

@class IOSObjectArray;
@protocol JavaUtilConcurrentConcurrentNavigableMap;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

@interface JavaUtilConcurrentConcurrentSkipListMap_EntrySet : JavaUtilAbstractSet {
 @public
  id<JavaUtilConcurrentConcurrentNavigableMap> m_;
}

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEqual:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentNavigableMap:(id<JavaUtilConcurrentConcurrentNavigableMap>)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_EntrySet)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_EntrySet, m_, id<JavaUtilConcurrentConcurrentNavigableMap>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_EntrySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(JavaUtilConcurrentConcurrentSkipListMap_EntrySet *self, id<JavaUtilConcurrentConcurrentNavigableMap> map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntrySet *new_JavaUtilConcurrentConcurrentSkipListMap_EntrySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntrySet *create_JavaUtilConcurrentConcurrentSkipListMap_EntrySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_EntrySet)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_

#define RESTRICT_JavaUtilAbstractMap 1
#define INCLUDE_JavaUtilAbstractMap 1
#include "java/util/AbstractMap.h"

#define RESTRICT_JavaUtilConcurrentConcurrentNavigableMap 1
#define INCLUDE_JavaUtilConcurrentConcurrentNavigableMap 1
#include "java/util/concurrent/ConcurrentNavigableMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentSkipListMap;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSet;

/*!
 @brief Submaps returned by <code>ConcurrentSkipListMap</code> submap operations
  represent a subrange of mappings of their underlying maps.
 Instances of this class support all methods of their underlying
  maps, differing in that mappings outside their range are ignored,
  and attempts to add mappings outside their ranges result in <code>IllegalArgumentException</code>
 .  Instances of this class are constructed
  only using the <code>subMap</code>, <code>headMap</code>, and <code>tailMap</code>
  methods of their underlying maps.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentNavigableMap, NSCopying, JavaIoSerializable > {
 @public
  /*!
   @brief Underlying map
   */
  JavaUtilConcurrentConcurrentSkipListMap *m_;
  /*!
   @brief direction
   */
  jboolean isDescending_;
}

#pragma mark Public

- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

- (id)ceilingKeyWithId:(id)key;

- (void)clear;

- (id<JavaUtilComparator>)comparator;

- (jboolean)containsKeyWithId:(id)key;

- (jboolean)containsValueWithId:(id)value;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)descendingMap;

- (id<JavaUtilSet>)entrySet;

- (id<JavaUtilMap_Entry>)firstEntry;

- (id)firstKey;

- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

- (id)floorKeyWithId:(id)key;

- (id)getWithId:(id)key;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)headMapWithId:(id)toKey;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)headMapWithId:(id)toKey
                                                      withBoolean:(jboolean)inclusive;

- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

- (id)higherKeyWithId:(id)key;

- (jboolean)isEmpty;

- (id<JavaUtilNavigableSet>)keySet;

- (id<JavaUtilMap_Entry>)lastEntry;

- (id)lastKey;

- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

- (id)lowerKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)navigableKeySet;

- (id<JavaUtilMap_Entry>)pollFirstEntry;

- (id<JavaUtilMap_Entry>)pollLastEntry;

- (id)putWithId:(id)key
         withId:(id)value;

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (id)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id)replaceWithId:(id)key
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (jint)size;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)subMapWithId:(id)fromKey
                                                     withBoolean:(jboolean)fromInclusive
                                                          withId:(id)toKey
                                                     withBoolean:(jboolean)toInclusive;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)subMapWithId:(id)fromKey
                                                          withId:(id)toKey;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)tailMapWithId:(id)fromKey;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)tailMapWithId:(id)fromKey
                                                      withBoolean:(jboolean)inclusive;

- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

/*!
 @brief Creates a new submap, initializing all fields.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)map
                                                                   withId:(id)fromKey
                                                              withBoolean:(jboolean)fromInclusive
                                                                   withId:(id)toKey
                                                              withBoolean:(jboolean)toInclusive
                                                              withBoolean:(jboolean)isDescending;

- (void)checkKeyBoundsWithId:(id)key
      withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Submap version of ConcurrentSkipListMap.getNearEntry.
 */
- (id<JavaUtilMap_Entry>)getNearEntryWithId:(id)key
                                    withInt:(jint)rel;

- (id)getNearKeyWithId:(id)key
               withInt:(jint)rel;

- (id<JavaUtilMap_Entry>)highestEntry;

/*!
 @brief Returns highest absolute key (ignoring directionality).
 */
- (id)highestKey;

/*!
 @brief Returns highest node.This node might not be in range, so
  most usages need to check bounds.
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)hiNodeWithJavaUtilComparator:(id<JavaUtilComparator>)cmp;

- (jboolean)inBoundsWithId:(id)key
    withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Returns true if node key is less than upper bound of range.
 */
- (jboolean)isBeforeEndWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)n
                                                 withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Returns lowest node.This node might not be in range, so
  most usages need to check bounds.
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)loNodeWithJavaUtilComparator:(id<JavaUtilComparator>)cmp;

- (id<JavaUtilMap_Entry>)lowestEntry;

/*!
 @brief Returns lowest absolute key (ignoring directionality).
 */
- (id)lowestKey;

/*!
 @brief Utility to create submaps, where given bounds override
  unbounded(null) ones and/or are checked against bounded ones.
 */
- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)newSubMapWithId:(id)fromKey
                                                        withBoolean:(jboolean)fromInclusive
                                                             withId:(id)toKey
                                                        withBoolean:(jboolean)toInclusive OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilMap_Entry>)removeHighest;

- (id<JavaUtilMap_Entry>)removeLowest;

- (jboolean)tooHighWithId:(id)key
   withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

- (jboolean)tooLowWithId:(id)key
  withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap, m_, JavaUtilConcurrentConcurrentSkipListMap *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_initWithJavaUtilConcurrentConcurrentSkipListMap_withId_withBoolean_withId_withBoolean_withBoolean_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *self, JavaUtilConcurrentConcurrentSkipListMap *map, id fromKey, jboolean fromInclusive, id toKey, jboolean toInclusive, jboolean isDescending);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_initWithJavaUtilConcurrentConcurrentSkipListMap_withId_withBoolean_withId_withBoolean_withBoolean_(JavaUtilConcurrentConcurrentSkipListMap *map, id fromKey, jboolean fromInclusive, id toKey, jboolean toInclusive, jboolean isDescending) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap *create_JavaUtilConcurrentConcurrentSkipListMap_SubMap_initWithJavaUtilConcurrentConcurrentSkipListMap_withId_withBoolean_withId_withBoolean_withBoolean_(JavaUtilConcurrentConcurrentSkipListMap *map, id fromKey, jboolean fromInclusive, id toKey, jboolean toInclusive, jboolean isDescending);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_

#define RESTRICT_JavaUtilIterator 1
#define INCLUDE_JavaUtilIterator 1
#include "java/util/Iterator.h"

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

/*!
 @brief Variant of main Iter class to traverse through submaps.
 Also serves as back-up Spliterator for views.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter : NSObject < JavaUtilIterator, JavaUtilSpliterator > {
 @public
  /*!
   @brief the last node returned by next()
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *lastReturned_;
  /*!
   @brief the next node to return from next();
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *next_;
  /*!
   @brief Cache of next value field to maintain weak consistency
   */
  id nextValue_;
}

#pragma mark Public

- (jlong)estimateSize;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)hasNext;

- (void)remove;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilSpliterator>)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

- (void)advance;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter, lastReturned_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter, next_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter, nextValue_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_

@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator : JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter

#pragma mark Public

- (jint)characteristics;

- (id)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator *create_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_

@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;
@protocol JavaUtilComparator;

@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator : JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter

#pragma mark Public

- (jint)characteristics;

- (id<JavaUtilComparator>)getComparator;

- (id)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator *create_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_

@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator : JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter

#pragma mark Public

- (jint)characteristics;

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator *create_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator))
#define JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator_

@class JavaUtilConcurrentConcurrentSkipListMap_Index;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilComparator;

/*!
 @brief Base class providing common structure for Spliterators.
 (Although not all that much common functionality; as usual for
  view classes, details annoyingly vary in key, value, and entry
  subclasses in ways that are not worth abstracting out for
  internal classes.)
  The basic split strategy is to recursively descend from top
  level, row by row, descending to next row when either split
  off, or the end of row is encountered. Control of the number of
  splits relies on some statistical estimation: The expected
  remaining number of elements of a skip list when advancing
  either across or down decreases by about 25%. To make this
  observation useful, we need to know initial size, which we
  don't. But we can just use Integer.MAX_VALUE so that we
  don't prematurely zero out while splitting.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator : NSObject {
 @public
  id<JavaUtilComparator> comparator_;
  id fence_;
  JavaUtilConcurrentConcurrentSkipListMap_Index *row_;
  JavaUtilConcurrentConcurrentSkipListMap_Node *current_;
  jint est_;
}

#pragma mark Public

- (jlong)estimateSize;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilComparator:(id<JavaUtilComparator>)comparator
   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)row
    withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)origin
                                              withId:(id)fence
                                             withInt:(jint)est;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator, comparator_, id<JavaUtilComparator>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator, fence_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator, row_, JavaUtilConcurrentConcurrentSkipListMap_Index *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator, current_, JavaUtilConcurrentConcurrentSkipListMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator *self, id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator))
#define JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap_Index;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator : JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilComparator>)getComparator;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilComparator:(id<JavaUtilComparator>)comparator
   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)row
    withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)origin
                                              withId:(id)fence
                                             withInt:(jint)est;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator *self, id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator *new_JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator *create_JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_KeySpliterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator))
#define JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap_Index;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator : JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilComparator:(id<JavaUtilComparator>)comparator
   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)row
    withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)origin
                                              withId:(id)fence
                                             withInt:(jint)est;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator *self, id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator *new_JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator *create_JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_ValueSpliterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap || defined(INCLUDE_JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator))
#define JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator_

#define RESTRICT_JavaUtilSpliterator 1
#define INCLUDE_JavaUtilSpliterator 1
#include "java/util/Spliterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap_Index;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionConsumer;

@interface JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator : JavaUtilConcurrentConcurrentSkipListMap_CSLMSpliterator < JavaUtilSpliterator >

#pragma mark Public

- (jint)characteristics;

- (void)forEachRemainingWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilComparator>)getComparator;

- (jboolean)tryAdvanceWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator *)trySplit;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilComparator:(id<JavaUtilComparator>)comparator
   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)row
    withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)origin
                                              withId:(id)fence
                                             withInt:(jint)est;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator *self, id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator *new_JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator *create_JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator_initWithJavaUtilComparator_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Node_withId_withInt_(id<JavaUtilComparator> comparator, JavaUtilConcurrentConcurrentSkipListMap_Index *row, JavaUtilConcurrentConcurrentSkipListMap_Node *origin, id fence, jint est);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_EntrySpliterator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentConcurrentSkipListMap")
