//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/locks/ReentrantReadWriteLock.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock")
#ifdef RESTRICT_JavaUtilConcurrentLocksReentrantReadWriteLock
#define INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock 1
#endif
#undef RESTRICT_JavaUtilConcurrentLocksReentrantReadWriteLock
#ifdef INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync
#define INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync 1
#endif
#ifdef INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync
#define INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_

#define RESTRICT_JavaUtilConcurrentLocksReadWriteLock 1
#define INCLUDE_JavaUtilConcurrentLocksReadWriteLock 1
#include "java/util/concurrent/locks/ReadWriteLock.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaLangThread;
@class JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock;
@class JavaUtilConcurrentLocksReentrantReadWriteLock_Sync;
@class JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock;
@protocol JavaUtilCollection;
@protocol JavaUtilConcurrentLocksCondition;

/*!
 @brief An implementation of <code>ReadWriteLock</code> supporting similar
  semantics to <code>ReentrantLock</code>.
 <p>This class has the following properties: 
 <ul>
  <li><b>Acquisition order</b>
  
 <p>This class does not impose a reader or writer preference
  ordering for lock access.  However, it does support an optional 
 <em>fairness</em> policy. 
 <dl>
  <dt><b><i>Non-fair mode (default)</i></b>
  <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  When constructed as non-fair (the default), the order of entry
  to the read and write lock is unspecified, subject to reentrancy
  constraints.  A nonfair lock that is continuously contended may
  indefinitely postpone one or more reader or writer threads, but
  will normally have higher throughput than a fair lock. 
 <dt><b><i>Fair mode</i></b>
  <dd style="font-family:'DejaVu Sans', Arial, Helvetica, sans-serif">
  When constructed as fair, threads contend for entry using an
  approximately arrival-order policy. When the currently held lock
  is released, either the longest-waiting single writer thread will
  be assigned the write lock, or if there is a group of reader threads
  waiting longer than all waiting writer threads, that group will be
  assigned the read lock. 
 <p>A thread that tries to acquire a fair read lock (non-reentrantly)
  will block if either the write lock is held, or there is a waiting
  writer thread. The thread will not acquire the read lock until
  after the oldest currently waiting writer thread has acquired and
  released the write lock. Of course, if a waiting writer abandons
  its wait, leaving one or more reader threads as the longest waiters
  in the queue with the write lock free, then those readers will be
  assigned the read lock. 
 <p>A thread that tries to acquire a fair write lock (non-reentrantly)
  will block unless both the read lock and write lock are free (which
  implies there are no waiting threads).  (Note that the non-blocking 
 <code>ReadLock.tryLock()</code> and <code>WriteLock.tryLock()</code> methods
  do not honor this fair setting and will immediately acquire the lock
  if it is possible, regardless of waiting threads.) 
 </dl>
  
 <li><b>Reentrancy</b>
  
 <p>This lock allows both readers and writers to reacquire read or
  write locks in the style of a <code>ReentrantLock</code>. Non-reentrant
  readers are not allowed until all write locks held by the writing
  thread have been released. 
 <p>Additionally, a writer can acquire the read lock, but not
  vice-versa.  Among other applications, reentrancy can be useful
  when write locks are held during calls or callbacks to methods that
  perform reads under read locks.  If a reader tries to acquire the
  write lock it will never succeed. 
 <li><b>Lock downgrading</b>
  <p>Reentrancy also allows downgrading from the write lock to a read lock,
  by acquiring the write lock, then the read lock and then releasing the
  write lock. However, upgrading from a read lock to the write lock is 
 <b>not</b> possible. 
 <li><b>Interruption of lock acquisition</b>
  <p>The read lock and write lock both support interruption during lock
  acquisition. 
 <li><b><code>Condition</code> support</b>
  <p>The write lock provides a <code>Condition</code> implementation that
  behaves in the same way, with respect to the write lock, as the 
 <code>Condition</code> implementation provided by 
 <code>ReentrantLock.newCondition</code> does for <code>ReentrantLock</code>.
  This <code>Condition</code> can, of course, only be used with the write lock. 
 <p>The read lock does not support a <code>Condition</code> and 
 <code>readLock().newCondition()</code> throws 
 <code>UnsupportedOperationException</code>.
  
 <li><b>Instrumentation</b>
  <p>This class supports methods to determine whether locks
  are held or contended. These methods are designed for monitoring
  system state, not for synchronization control. 
 </ul>
  
 <p>Serialization of this class behaves in the same way as built-in
  locks: a deserialized lock is in the unlocked state, regardless of
  its state when serialized. 
 <p><b>Sample usages</b>. Here is a code sketch showing how to perform
  lock downgrading after updating a cache (exception handling is
  particularly tricky when handling multiple locks in a non-nested
  fashion): 
 @code
  class CachedData {
    Object data;
    volatile boolean cacheValid;
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    void processCachedData() {
      rwl.readLock().lock();
      if (!cacheValid) {
        // Must release read lock before acquiring write lock
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        try {
          // Recheck state because another thread might have
          // acquired write lock and changed state before we did.
          if (!cacheValid) {
            data = ...
            cacheValid = true;
          }
          // Downgrade by acquiring read lock before releasing write lock
          rwl.readLock().lock();
        } finally {
          rwl.writeLock().unlock(); // Unlock write, still hold read
        }      }
      try {
        use(data);
      } finally {
        rwl.readLock().unlock();
      }    }    }
 
@endcode
  ReentrantReadWriteLocks can be used to improve concurrency in some
  uses of some kinds of Collections. This is typically worthwhile
  only when the collections are expected to be large, accessed by
  more reader threads than writer threads, and entail operations with
  overhead that outweighs synchronization overhead. For example, here
  is a class using a TreeMap that is expected to be large and
  concurrently accessed. 
 @code
  class RWDictionary {
    private final Map<String, Data> m = new TreeMap<>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();
    public Data get(String key) {
      r.lock();
      try { return m.get(key); }
      finally { r.unlock(); }
    }
    public List<String> allKeys() {
      r.lock();
      try { return new ArrayList<>(m.keySet()); }
      finally { r.unlock(); }
    }
    public Data put(String key, Data value) {
      w.lock();
      try { return m.put(key, value); }
      finally { w.unlock(); }
    }
    public void clear() {
      w.lock();
      try { m.clear(); }
      finally { w.unlock(); }
    }  }
 
@endcode
  
 <h3>Implementation Notes</h3>
  
 <p>This lock supports a maximum of 65535 recursive write locks
  and 65535 read locks. Attempts to exceed these limits result in 
 <code>Error</code> throws from locking methods.
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock : NSObject < JavaUtilConcurrentLocksReadWriteLock, JavaIoSerializable > {
 @public
  /*!
   @brief Performs all synchronization mechanics
   */
  JavaUtilConcurrentLocksReentrantReadWriteLock_Sync *sync_;
}

#pragma mark Public

/*!
 @brief Creates a new <code>ReentrantReadWriteLock</code> with
  default (nonfair) ordering properties.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a new <code>ReentrantReadWriteLock</code> with
  the given fairness policy.
 @param fair<code>true</code>  if this lock should use a fair ordering policy
 */
- (instancetype __nonnull)initWithBoolean:(jboolean)fair;

/*!
 @brief Returns an estimate of the number of threads waiting to acquire
  either the read or write lock.The value is only an estimate
  because the number of threads may change dynamically while this
  method traverses internal data structures.
 This method is
  designed for use in monitoring system state, not for
  synchronization control.
 @return the estimated number of threads waiting for this lock
 */
- (jint)getQueueLength;

/*!
 @brief Queries the number of reentrant read holds on this lock by the
  current thread.A reader thread has a hold on a lock for
  each lock action that is not matched by an unlock action.
 @return the number of holds on the read lock by the current thread,
          or zero if the read lock is not held by the current thread
 @since 1.6
 */
- (jint)getReadHoldCount;

/*!
 @brief Queries the number of read locks held for this lock.This
  method is designed for use in monitoring system state, not for
  synchronization control.
 @return the number of read locks held
 */
- (jint)getReadLockCount;

/*!
 @brief Returns an estimate of the number of threads waiting on the
  given condition associated with the write lock.Note that because
  timeouts and interrupts may occur at any time, the estimate
  serves only as an upper bound on the actual number of waiters.
 This method is designed for use in monitoring of the system
  state, not for synchronization control.
 @param condition the condition
 @return the estimated number of waiting threads
 @throw IllegalMonitorStateExceptionif this lock is not held
 @throw IllegalArgumentExceptionif the given condition is
          not associated with this lock
 @throw NullPointerExceptionif the condition is null
 */
- (jint)getWaitQueueLengthWithJavaUtilConcurrentLocksCondition:(id<JavaUtilConcurrentLocksCondition>)condition;

/*!
 @brief Queries the number of reentrant write holds on this lock by the
  current thread.A writer thread has a hold on a lock for
  each lock action that is not matched by an unlock action.
 @return the number of holds on the write lock by the current thread,
          or zero if the write lock is not held by the current thread
 */
- (jint)getWriteHoldCount;

/*!
 @brief Queries whether the given thread is waiting to acquire either
  the read or write lock.Note that because cancellations may
  occur at any time, a <code>true</code> return does not guarantee
  that this thread will ever acquire a lock.
 This method is
  designed primarily for use in monitoring of the system state.
 @param thread the thread
 @return <code>true</code> if the given thread is queued waiting for this lock
 @throw NullPointerExceptionif the thread is null
 */
- (jboolean)hasQueuedThreadWithJavaLangThread:(JavaLangThread *)thread;

/*!
 @brief Queries whether any threads are waiting to acquire the read or
  write lock.Note that because cancellations may occur at any
  time, a <code>true</code> return does not guarantee that any other
  thread will ever acquire a lock.
 This method is designed
  primarily for use in monitoring of the system state.
 @return <code>true</code> if there may be other threads waiting to
          acquire the lock
 */
- (jboolean)hasQueuedThreads;

/*!
 @brief Queries whether any threads are waiting on the given condition
  associated with the write lock.Note that because timeouts and
  interrupts may occur at any time, a <code>true</code> return does
  not guarantee that a future <code>signal</code> will awaken any
  threads.
 This method is designed primarily for use in
  monitoring of the system state.
 @param condition the condition
 @return <code>true</code> if there are any waiting threads
 @throw IllegalMonitorStateExceptionif this lock is not held
 @throw IllegalArgumentExceptionif the given condition is
          not associated with this lock
 @throw NullPointerExceptionif the condition is null
 */
- (jboolean)hasWaitersWithJavaUtilConcurrentLocksCondition:(id<JavaUtilConcurrentLocksCondition>)condition;

/*!
 @brief Returns <code>true</code> if this lock has fairness set true.
 @return <code>true</code> if this lock has fairness set true
 */
- (jboolean)isFair;

/*!
 @brief Queries if the write lock is held by any thread.This method is
  designed for use in monitoring system state, not for
  synchronization control.
 @return <code>true</code> if any thread holds the write lock and
          <code>false</code> otherwise
 */
- (jboolean)isWriteLocked;

/*!
 @brief Queries if the write lock is held by the current thread.
 @return <code>true</code> if the current thread holds the write lock and
          <code>false</code> otherwise
 */
- (jboolean)isWriteLockedByCurrentThread;

- (JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock *)readLock;

/*!
 @brief Returns a string identifying this lock, as well as its lock state.
 The state, in brackets, includes the String <code>"Write locks ="</code>
  followed by the number of reentrantly held write locks, and the
  String <code>"Read locks ="</code> followed by the number of held
  read locks.
 @return a string identifying this lock, as well as its lock state
 */
- (NSString *)description;

- (JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock *)writeLock;

#pragma mark Protected

/*!
 @brief Returns the thread that currently owns the write lock, or 
 <code>null</code> if not owned.When this method is called by a
  thread that is not the owner, the return value reflects a
  best-effort approximation of current lock status.
 For example,
  the owner may be momentarily <code>null</code> even if there are
  threads trying to acquire the lock but have not yet done so.
  This method is designed to facilitate construction of
  subclasses that provide more extensive lock monitoring
  facilities.
 @return the owner, or <code>null</code> if not owned
 */
- (JavaLangThread *)getOwner;

/*!
 @brief Returns a collection containing threads that may be waiting to
  acquire the read lock.Because the actual set of threads may
  change dynamically while constructing this result, the returned
  collection is only a best-effort estimate.
 The elements of the
  returned collection are in no particular order.  This method is
  designed to facilitate construction of subclasses that provide
  more extensive lock monitoring facilities.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getQueuedReaderThreads;

/*!
 @brief Returns a collection containing threads that may be waiting to
  acquire either the read or write lock.Because the actual set
  of threads may change dynamically while constructing this
  result, the returned collection is only a best-effort estimate.
 The elements of the returned collection are in no particular
  order.  This method is designed to facilitate construction of
  subclasses that provide more extensive monitoring facilities.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getQueuedThreads;

/*!
 @brief Returns a collection containing threads that may be waiting to
  acquire the write lock.Because the actual set of threads may
  change dynamically while constructing this result, the returned
  collection is only a best-effort estimate.
 The elements of the
  returned collection are in no particular order.  This method is
  designed to facilitate construction of subclasses that provide
  more extensive lock monitoring facilities.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getQueuedWriterThreads;

/*!
 @brief Returns a collection containing those threads that may be
  waiting on the given condition associated with the write lock.
 Because the actual set of threads may change dynamically while
  constructing this result, the returned collection is only a
  best-effort estimate. The elements of the returned collection
  are in no particular order.  This method is designed to
  facilitate construction of subclasses that provide more
  extensive condition monitoring facilities.
 @param condition the condition
 @return the collection of threads
 @throw IllegalMonitorStateExceptionif this lock is not held
 @throw IllegalArgumentExceptionif the given condition is
          not associated with this lock
 @throw NullPointerExceptionif the condition is null
 */
- (id<JavaUtilCollection>)getWaitingThreadsWithJavaUtilConcurrentLocksCondition:(id<JavaUtilConcurrentLocksCondition>)condition;

#pragma mark Package-Private

/*!
 @brief Returns the thread id for the given thread.We must access
  this directly rather than via method Thread.getId() because
  getId() is not final, and has been known to be overridden in
  ways that do not preserve unique mappings.
 */
+ (jlong)getThreadIdWithJavaLangThread:(JavaLangThread *)thread;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksReentrantReadWriteLock, sync_, JavaUtilConcurrentLocksReentrantReadWriteLock_Sync *)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_init(JavaUtilConcurrentLocksReentrantReadWriteLock *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock *new_JavaUtilConcurrentLocksReentrantReadWriteLock_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock *create_JavaUtilConcurrentLocksReentrantReadWriteLock_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_initWithBoolean_(JavaUtilConcurrentLocksReentrantReadWriteLock *self, jboolean fair);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock *new_JavaUtilConcurrentLocksReentrantReadWriteLock_initWithBoolean_(jboolean fair) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock *create_JavaUtilConcurrentLocksReentrantReadWriteLock_initWithBoolean_(jboolean fair);

FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksReentrantReadWriteLock_getThreadIdWithJavaLangThread_(JavaLangThread *thread);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_

#define RESTRICT_JavaUtilConcurrentLocksAbstractQueuedSynchronizer 1
#define INCLUDE_JavaUtilConcurrentLocksAbstractQueuedSynchronizer 1
#include "java/util/concurrent/locks/AbstractQueuedSynchronizer.h"

@class JavaLangThread;
@class JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject;

/*!
 @brief Synchronization implementation for ReentrantReadWriteLock.
 Subclassed into fair and nonfair versions.
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_Sync : JavaUtilConcurrentLocksAbstractQueuedSynchronizer
@property (readonly, class) jint SHARED_SHIFT NS_SWIFT_NAME(SHARED_SHIFT);
@property (readonly, class) jint SHARED_UNIT NS_SWIFT_NAME(SHARED_UNIT);
@property (readonly, class) jint MAX_COUNT NS_SWIFT_NAME(MAX_COUNT);
@property (readonly, class) jint EXCLUSIVE_MASK NS_SWIFT_NAME(EXCLUSIVE_MASK);

+ (jint)SHARED_SHIFT;

+ (jint)SHARED_UNIT;

+ (jint)MAX_COUNT;

+ (jint)EXCLUSIVE_MASK;

#pragma mark Protected

- (jboolean)isHeldExclusively;

- (jboolean)tryAcquireWithInt:(jint)acquires;

- (jint)tryAcquireSharedWithInt:(jint)unused;

- (jboolean)tryReleaseWithInt:(jint)releases;

- (jboolean)tryReleaseSharedWithInt:(jint)unused;

#pragma mark Package-Private

- (instancetype __nonnull)init;

/*!
 @brief Returns the number of exclusive holds represented in count.
 */
+ (jint)exclusiveCountWithInt:(jint)c;

/*!
 @brief Full version of acquire for reads, that handles CAS misses
  and reentrant reads not dealt with in tryAcquireShared.
 */
- (jint)fullTryAcquireSharedWithJavaLangThread:(JavaLangThread *)current;

- (jint)getCount;

- (JavaLangThread *)getOwner;

- (jint)getReadHoldCount;

- (jint)getReadLockCount;

- (jint)getWriteHoldCount;

- (jboolean)isWriteLocked;

- (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)newCondition OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns true if the current thread, when trying to acquire
  the read lock, and otherwise eligible to do so, should block
  because of policy for overtaking other waiting threads.
 */
- (jboolean)readerShouldBlock;

/*!
 @brief Returns the number of shared holds represented in count.
 */
+ (jint)sharedCountWithInt:(jint)c;

/*!
 @brief Performs tryLock for read, enabling barging in both modes.
 This is identical in effect to tryAcquireShared except for
  lack of calls to readerShouldBlock.
 */
- (jboolean)tryReadLock;

/*!
 @brief Performs tryLock for write, enabling barging in both modes.
 This is identical in effect to tryAcquire except for lack
  of calls to writerShouldBlock.
 */
- (jboolean)tryWriteLock;

/*!
 @brief Returns true if the current thread, when trying to acquire
  the write lock, and otherwise eligible to do so, should block
  because of policy for overtaking other waiting threads.
 */
- (jboolean)writerShouldBlock;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync)

inline jint JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_get_SHARED_SHIFT(void);
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_SHARED_SHIFT 16
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync, SHARED_SHIFT, jint)

inline jint JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_get_SHARED_UNIT(void);
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_SHARED_UNIT 65536
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync, SHARED_UNIT, jint)

inline jint JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_get_MAX_COUNT(void);
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_MAX_COUNT 65535
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync, MAX_COUNT, jint)

inline jint JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_get_EXCLUSIVE_MASK(void);
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_EXCLUSIVE_MASK 65535
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync, EXCLUSIVE_MASK, jint)

FOUNDATION_EXPORT jint JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_sharedCountWithInt_(jint c);

FOUNDATION_EXPORT jint JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_exclusiveCountWithInt_(jint c);

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_init(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter_

/*!
 @brief A counter for per-thread read hold counts.
 Maintained as a ThreadLocal; cached in cachedHoldCounter.
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter : NSObject {
 @public
  jint count_;
  jlong tid_;
}

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter_init(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *new_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *create_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter_

#define RESTRICT_JavaLangThreadLocal 1
#define INCLUDE_JavaLangThreadLocal 1
#include "java/lang/ThreadLocal.h"

@class JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter;

/*!
 @brief ThreadLocal subclass.Easiest to explicitly define for sake
  of deserialization mechanics.
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter : JavaLangThreadLocal

#pragma mark Public

- (JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *)get;

- (JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *)initialValue OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *)childValueWithId:(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_HoldCounter *)arg0;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter_init(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter *new_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter *create_JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_Sync_ThreadLocalHoldCounter)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync_

/*!
 @brief Nonfair version of Sync
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync : JavaUtilConcurrentLocksReentrantReadWriteLock_Sync

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (jboolean)readerShouldBlock;

- (jboolean)writerShouldBlock;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync_init(JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync *new_JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync *create_JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_NonfairSync)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync_

/*!
 @brief Fair version of Sync
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync : JavaUtilConcurrentLocksReentrantReadWriteLock_Sync

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (jboolean)readerShouldBlock;

- (jboolean)writerShouldBlock;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync_init(JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync *new_JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync *create_JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_FairSync)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock_

#define RESTRICT_JavaUtilConcurrentLocksLock 1
#define INCLUDE_JavaUtilConcurrentLocksLock 1
#include "java/util/concurrent/locks/Lock.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentLocksReentrantReadWriteLock;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentLocksCondition;

/*!
 @brief The lock returned by method <code>ReentrantReadWriteLock.readLock</code>.
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock : NSObject < JavaUtilConcurrentLocksLock, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Acquires the read lock.
 <p>Acquires the read lock if the write lock is not held by
  another thread and returns immediately. 
 <p>If the write lock is held by another thread then
  the current thread becomes disabled for thread scheduling
  purposes and lies dormant until the read lock has been acquired.
 */
- (void)lock;

/*!
 @brief Acquires the read lock unless the current thread is 
 interrupted.
 <p>Acquires the read lock if the write lock is not held
  by another thread and returns immediately. 
 <p>If the write lock is held by another thread then the
  current thread becomes disabled for thread scheduling
  purposes and lies dormant until one of two things happens: 
 <ul>
  
 <li>The read lock is acquired by the current thread; or 
 <li>Some other thread interrupts
  the current thread. 
 </ul>
  
 <p>If the current thread: 
 <ul>
  
 <li>has its interrupted status set on entry to this method; or 
 <li>is interrupted while
  acquiring the read lock, 
 </ul>
  then <code>InterruptedException</code> is thrown and the current
  thread's interrupted status is cleared. 
 <p>In this implementation, as this method is an explicit
  interruption point, preference is given to responding to
  the interrupt over normal or reentrant acquisition of the
  lock.
 @throw InterruptedExceptionif the current thread is interrupted
 */
- (void)lockInterruptibly;

/*!
 @brief Throws <code>UnsupportedOperationException</code> because 
 <code>ReadLocks</code> do not support conditions.
 @throw UnsupportedOperationExceptionalways
 */
- (id<JavaUtilConcurrentLocksCondition>)newCondition OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a string identifying this lock, as well as its lock state.
 The state, in brackets, includes the String <code>"Read locks ="</code>
  followed by the number of held read locks.
 @return a string identifying this lock, as well as its lock state
 */
- (NSString *)description;

/*!
 @brief Acquires the read lock only if the write lock is not held by
  another thread at the time of invocation.
 <p>Acquires the read lock if the write lock is not held by
  another thread and returns immediately with the value 
 <code>true</code>. Even when this lock has been set to use a
  fair ordering policy, a call to <code>tryLock()</code>
  <em>will</em> immediately acquire the read lock if it is
  available, whether or not other threads are currently
  waiting for the read lock.  This &quot;barging&quot; behavior
  can be useful in certain circumstances, even though it
  breaks fairness. If you want to honor the fairness setting
  for this lock, then use <code>tryLock(0, TimeUnit.SECONDS)</code>
  which is almost equivalent
  (it also detects interruption). 
 <p>If the write lock is held by another thread then
  this method will return immediately with the value 
 <code>false</code>.
 @return <code>true</code> if the read lock was acquired
 */
- (jboolean)tryLock;

/*!
 @brief Acquires the read lock if the write lock is not held by
  another thread within the given waiting time and the
  current thread has not been interrupted
 .
 <p>Acquires the read lock if the write lock is not held by
  another thread and returns immediately with the value 
 <code>true</code>. If this lock has been set to use a fair
  ordering policy then an available lock <em>will not</em> be
  acquired if any other threads are waiting for the
  lock. This is in contrast to the <code>tryLock()</code>
  method. If you want a timed <code>tryLock</code> that does
  permit barging on a fair lock then combine the timed and
  un-timed forms together: 
 @code
  if (lock.tryLock() ||
      lock.tryLock(timeout, unit)) {
    ...
  }
 
@endcode
  
 <p>If the write lock is held by another thread then the
  current thread becomes disabled for thread scheduling
  purposes and lies dormant until one of three things happens: 
 <ul>
  
 <li>The read lock is acquired by the current thread; or 
 <li>Some other thread interrupts
  the current thread; or 
 <li>The specified waiting time elapses. 
 </ul>
  
 <p>If the read lock is acquired then the value <code>true</code> is
  returned. 
 <p>If the current thread: 
 <ul>
  
 <li>has its interrupted status set on entry to this method; or 
 <li>is interrupted while
  acquiring the read lock, 
 </ul> then <code>InterruptedException</code> is thrown and the
  current thread's interrupted status is cleared. 
 <p>If the specified waiting time elapses then the value 
 <code>false</code> is returned.  If the time is less than or
  equal to zero, the method will not wait at all. 
 <p>In this implementation, as this method is an explicit
  interruption point, preference is given to responding to
  the interrupt over normal or reentrant acquisition of the
  lock, and over reporting the elapse of the waiting time.
 @param timeout the time to wait for the read lock
 @param unit the time unit of the timeout argument
 @return <code>true</code> if the read lock was acquired
 @throw InterruptedExceptionif the current thread is interrupted
 @throw NullPointerExceptionif the time unit is null
 */
- (jboolean)tryLockWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Attempts to release this lock.
 <p>If the number of readers is now zero then the lock
  is made available for write lock attempts. If the current
  thread does not hold this lock then <code>IllegalMonitorStateException</code>
  is thrown.
 @throw IllegalMonitorStateExceptionif the current thread
  does not hold this lock
 */
- (void)unlock;

#pragma mark Protected

/*!
 @brief Constructor for use by subclasses.
 @param lock the outer lock object
 @throw NullPointerExceptionif the lock is null
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentLocksReentrantReadWriteLock:(JavaUtilConcurrentLocksReentrantReadWriteLock *)lock;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock_initWithJavaUtilConcurrentLocksReentrantReadWriteLock_(JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock *self, JavaUtilConcurrentLocksReentrantReadWriteLock *lock);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock *new_JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock_initWithJavaUtilConcurrentLocksReentrantReadWriteLock_(JavaUtilConcurrentLocksReentrantReadWriteLock *lock) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock *create_JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock_initWithJavaUtilConcurrentLocksReentrantReadWriteLock_(JavaUtilConcurrentLocksReentrantReadWriteLock *lock);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock)

#endif

#if !defined (JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock_) && (INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock || defined(INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock))
#define JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock_

#define RESTRICT_JavaUtilConcurrentLocksLock 1
#define INCLUDE_JavaUtilConcurrentLocksLock 1
#include "java/util/concurrent/locks/Lock.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentLocksReentrantReadWriteLock;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentLocksCondition;

/*!
 @brief The lock returned by method <code>ReentrantReadWriteLock.writeLock</code>.
 */
@interface JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock : NSObject < JavaUtilConcurrentLocksLock, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Queries the number of holds on this write lock by the current
  thread.A thread has a hold on a lock for each lock action
  that is not matched by an unlock action.
 Identical in effect
  to <code>ReentrantReadWriteLock.getWriteHoldCount</code>.
 @return the number of holds on this lock by the current thread,
          or zero if this lock is not held by the current thread
 @since 1.6
 */
- (jint)getHoldCount;

/*!
 @brief Queries if this write lock is held by the current thread.
 Identical in effect to <code>ReentrantReadWriteLock.isWriteLockedByCurrentThread</code>
 .
 @return <code>true</code> if the current thread holds this lock and
          <code>false</code> otherwise
 @since 1.6
 */
- (jboolean)isHeldByCurrentThread;

/*!
 @brief Acquires the write lock.
 <p>Acquires the write lock if neither the read nor write lock
  are held by another thread
  and returns immediately, setting the write lock hold count to
  one. 
 <p>If the current thread already holds the write lock then the
  hold count is incremented by one and the method returns
  immediately. 
 <p>If the lock is held by another thread then the current
  thread becomes disabled for thread scheduling purposes and
  lies dormant until the write lock has been acquired, at which
  time the write lock hold count is set to one.
 */
- (void)lock;

/*!
 @brief Acquires the write lock unless the current thread is 
 interrupted.
 <p>Acquires the write lock if neither the read nor write lock
  are held by another thread
  and returns immediately, setting the write lock hold count to
  one. 
 <p>If the current thread already holds this lock then the
  hold count is incremented by one and the method returns
  immediately. 
 <p>If the lock is held by another thread then the current
  thread becomes disabled for thread scheduling purposes and
  lies dormant until one of two things happens: 
 <ul>
  
 <li>The write lock is acquired by the current thread; or 
 <li>Some other thread interrupts
  the current thread. 
 </ul>
  
 <p>If the write lock is acquired by the current thread then the
  lock hold count is set to one. 
 <p>If the current thread: 
 <ul>
  
 <li>has its interrupted status set on entry to this method;
  or 
 <li>is interrupted while
  acquiring the write lock, 
 </ul>
  then <code>InterruptedException</code> is thrown and the current
  thread's interrupted status is cleared. 
 <p>In this implementation, as this method is an explicit
  interruption point, preference is given to responding to
  the interrupt over normal or reentrant acquisition of the
  lock.
 @throw InterruptedExceptionif the current thread is interrupted
 */
- (void)lockInterruptibly;

/*!
 @brief Returns a <code>Condition</code> instance for use with this 
 <code>Lock</code> instance.
 <p>The returned <code>Condition</code> instance supports the same
  usages as do the <code>Object</code> monitor methods (<code>wait</code>
 , <code>notify</code>, and <code>notifyAll</code>
 ) when used with the built-in
  monitor lock. 
 <ul>
  
 <li>If this write lock is not held when any <code>Condition</code>
  method is called then an <code>IllegalMonitorStateException</code>
  is thrown.  (Read locks are
  held independently of write locks, so are not checked or
  affected. However it is essentially always an error to
  invoke a condition waiting method when the current thread
  has also acquired read locks, since other threads that
  could unblock it will not be able to acquire the write
  lock.) 
 <li>When the condition waiting
  methods are called the write lock is released and, before
  they return, the write lock is reacquired and the lock hold
  count restored to what it was when the method was called. 
 <li>If a thread is interrupted while
  waiting then the wait will terminate, an <code>InterruptedException</code>
  will be thrown, and the thread's
  interrupted status will be cleared. 
 <li>Waiting threads are signalled in FIFO order. 
 <li>The ordering of lock reacquisition for threads returning
  from waiting methods is the same as for threads initially
  acquiring the lock, which is in the default case not specified,
  but for <em>fair</em> locks favors those threads that have been
  waiting the longest. 
 </ul>
 @return the Condition object
 */
- (id<JavaUtilConcurrentLocksCondition>)newCondition OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a string identifying this lock, as well as its lock
  state.The state, in brackets includes either the String 
 <code>"Unlocked"</code> or the String <code>"Locked by"</code>
  followed by the name of the owning thread.
 @return a string identifying this lock, as well as its lock state
 */
- (NSString *)description;

/*!
 @brief Acquires the write lock only if it is not held by another thread
  at the time of invocation.
 <p>Acquires the write lock if neither the read nor write lock
  are held by another thread
  and returns immediately with the value <code>true</code>,
  setting the write lock hold count to one. Even when this lock has
  been set to use a fair ordering policy, a call to 
 <code>tryLock()</code> <em>will</em> immediately acquire the
  lock if it is available, whether or not other threads are
  currently waiting for the write lock.  This &quot;barging&quot;
  behavior can be useful in certain circumstances, even
  though it breaks fairness. If you want to honor the
  fairness setting for this lock, then use <code>tryLock(0, TimeUnit.SECONDS)</code>
  which is almost equivalent (it also detects interruption). 
 <p>If the current thread already holds this lock then the
  hold count is incremented by one and the method returns 
 <code>true</code>.
  
 <p>If the lock is held by another thread then this method
  will return immediately with the value <code>false</code>.
 @return <code>true</code> if the lock was free and was acquired
  by the current thread, or the write lock was already held
  by the current thread; and <code>false</code> otherwise.
 */
- (jboolean)tryLock;

/*!
 @brief Acquires the write lock if it is not held by another thread
  within the given waiting time and the current thread has
  not been interrupted.
 <p>Acquires the write lock if neither the read nor write lock
  are held by another thread
  and returns immediately with the value <code>true</code>,
  setting the write lock hold count to one. If this lock has been
  set to use a fair ordering policy then an available lock 
 <em>will not</em> be acquired if any other threads are
  waiting for the write lock. This is in contrast to the <code>tryLock()</code>
  method. If you want a timed <code>tryLock</code>
  that does permit barging on a fair lock then combine the
  timed and un-timed forms together: 
 @code
  if (lock.tryLock() ||
      lock.tryLock(timeout, unit)) {
    ...
  }
 
@endcode
  
 <p>If the current thread already holds this lock then the
  hold count is incremented by one and the method returns 
 <code>true</code>.
  
 <p>If the lock is held by another thread then the current
  thread becomes disabled for thread scheduling purposes and
  lies dormant until one of three things happens: 
 <ul>
  
 <li>The write lock is acquired by the current thread; or 
 <li>Some other thread interrupts
  the current thread; or 
 <li>The specified waiting time elapses 
 </ul>
  
 <p>If the write lock is acquired then the value <code>true</code> is
  returned and the write lock hold count is set to one. 
 <p>If the current thread: 
 <ul>
  
 <li>has its interrupted status set on entry to this method;
  or 
 <li>is interrupted while
  acquiring the write lock, 
 </ul>
  then <code>InterruptedException</code> is thrown and the current
  thread's interrupted status is cleared. 
 <p>If the specified waiting time elapses then the value 
 <code>false</code> is returned.  If the time is less than or
  equal to zero, the method will not wait at all. 
 <p>In this implementation, as this method is an explicit
  interruption point, preference is given to responding to
  the interrupt over normal or reentrant acquisition of the
  lock, and over reporting the elapse of the waiting time.
 @param timeout the time to wait for the write lock
 @param unit the time unit of the timeout argument
 @return <code>true</code> if the lock was free and was acquired
  by the current thread, or the write lock was already held by the
  current thread; and <code>false</code> if the waiting time
  elapsed before the lock could be acquired.
 @throw InterruptedExceptionif the current thread is interrupted
 @throw NullPointerExceptionif the time unit is null
 */
- (jboolean)tryLockWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Attempts to release this lock.
 <p>If the current thread is the holder of this lock then
  the hold count is decremented. If the hold count is now
  zero then the lock is released.  If the current thread is
  not the holder of this lock then <code>IllegalMonitorStateException</code>
  is thrown.
 @throw IllegalMonitorStateExceptionif the current thread does not
  hold this lock
 */
- (void)unlock;

#pragma mark Protected

/*!
 @brief Constructor for use by subclasses.
 @param lock the outer lock object
 @throw NullPointerExceptionif the lock is null
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentLocksReentrantReadWriteLock:(JavaUtilConcurrentLocksReentrantReadWriteLock *)lock;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock_initWithJavaUtilConcurrentLocksReentrantReadWriteLock_(JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock *self, JavaUtilConcurrentLocksReentrantReadWriteLock *lock);

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock *new_JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock_initWithJavaUtilConcurrentLocksReentrantReadWriteLock_(JavaUtilConcurrentLocksReentrantReadWriteLock *lock) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock *create_JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock_initWithJavaUtilConcurrentLocksReentrantReadWriteLock_(JavaUtilConcurrentLocksReentrantReadWriteLock *lock);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentLocksReentrantReadWriteLock")
