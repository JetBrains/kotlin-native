//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/FutureTask.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentFutureTask")
#ifdef RESTRICT_JavaUtilConcurrentFutureTask
#define INCLUDE_ALL_JavaUtilConcurrentFutureTask 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentFutureTask 1
#endif
#undef RESTRICT_JavaUtilConcurrentFutureTask

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentFutureTask_) && (INCLUDE_ALL_JavaUtilConcurrentFutureTask || defined(INCLUDE_JavaUtilConcurrentFutureTask))
#define JavaUtilConcurrentFutureTask_

#define RESTRICT_JavaUtilConcurrentRunnableFuture 1
#define INCLUDE_JavaUtilConcurrentRunnableFuture 1
#include "java/util/concurrent/RunnableFuture.h"

@class JavaLangThrowable;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentCallable;

/*!
 @brief A cancellable asynchronous computation.This class provides a base
  implementation of <code>Future</code>, with methods to start and cancel
  a computation, query to see if the computation is complete, and
  retrieve the result of the computation.
 The result can only be
  retrieved when the computation has completed; the <code>get</code>
  methods will block if the computation has not yet completed.  Once
  the computation has completed, the computation cannot be restarted
  or cancelled (unless the computation is invoked using 
 <code>runAndReset</code>).
  
 <p>A <code>FutureTask</code> can be used to wrap a <code>Callable</code> or 
 <code>Runnable</code> object.  Because <code>FutureTask</code> implements 
 <code>Runnable</code>, a <code>FutureTask</code> can be submitted to an 
 <code>Executor</code> for execution. 
 <p>In addition to serving as a standalone class, this class provides 
 <code>protected</code> functionality that may be useful when creating
  customized task classes.
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentFutureTask : NSObject < JavaUtilConcurrentRunnableFuture >

#pragma mark Public

/*!
 @brief Creates a <code>FutureTask</code> that will, upon running, execute the
  given <code>Callable</code>.
 @param callable the callable task
 @throw NullPointerExceptionif the callable is null
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)callable;

/*!
 @brief Creates a <code>FutureTask</code> that will, upon running, execute the
  given <code>Runnable</code>, and arrange that <code>get</code> will return the
  given result on successful completion.
 @param runnable the runnable task
 @param result the result to return on successful completion. If  you don't need a particular result, consider using
   constructions of the form:
   <code>Future<?> f = new FutureTask<Void>(runnable, null)</code>
 @throw NullPointerExceptionif the runnable is null
 */
- (instancetype __nonnull)initWithJavaLangRunnable:(id<JavaLangRunnable>)runnable
                                            withId:(id)result;

- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

/*!
 @throw CancellationException
 */
- (id)get;

/*!
 @throw CancellationException
 */
- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (jboolean)isCancelled;

- (jboolean)isDone;

- (void)run;

#pragma mark Protected

/*!
 @brief Protected method invoked when this task transitions to state 
 <code>isDone</code> (whether normally or via cancellation).The
  default implementation does nothing.
 Subclasses may override
  this method to invoke completion callbacks or perform
  bookkeeping. Note that you can query status inside the
  implementation of this method to determine whether this task
  has been cancelled.
 */
- (void)done;

/*!
 @brief Executes the computation without setting its result, and then
  resets this future to initial state, failing to do so if the
  computation encounters an exception or is cancelled.This is
  designed for use with tasks that intrinsically execute more
  than once.
 @return <code>true</code> if successfully run and reset
 */
- (jboolean)runAndReset;

/*!
 @brief Sets the result of this future to the given value unless
  this future has already been set or has been cancelled.
 <p>This method is invoked internally by the <code>run</code> method
  upon successful completion of the computation.
 @param v the value
 */
- (void)setWithId:(id)v;

/*!
 @brief Causes this future to report an <code>ExecutionException</code>
  with the given throwable as its cause, unless this future has
  already been set or has been cancelled.
 <p>This method is invoked internally by the <code>run</code> method
  upon failure of the computation.
 @param t the cause of failure
 */
- (void)setExceptionWithJavaLangThrowable:(JavaLangThrowable *)t;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentFutureTask)

FOUNDATION_EXPORT void JavaUtilConcurrentFutureTask_initWithJavaUtilConcurrentCallable_(JavaUtilConcurrentFutureTask *self, id<JavaUtilConcurrentCallable> callable);

FOUNDATION_EXPORT JavaUtilConcurrentFutureTask *new_JavaUtilConcurrentFutureTask_initWithJavaUtilConcurrentCallable_(id<JavaUtilConcurrentCallable> callable) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentFutureTask *create_JavaUtilConcurrentFutureTask_initWithJavaUtilConcurrentCallable_(id<JavaUtilConcurrentCallable> callable);

FOUNDATION_EXPORT void JavaUtilConcurrentFutureTask_initWithJavaLangRunnable_withId_(JavaUtilConcurrentFutureTask *self, id<JavaLangRunnable> runnable, id result);

FOUNDATION_EXPORT JavaUtilConcurrentFutureTask *new_JavaUtilConcurrentFutureTask_initWithJavaLangRunnable_withId_(id<JavaLangRunnable> runnable, id result) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentFutureTask *create_JavaUtilConcurrentFutureTask_initWithJavaLangRunnable_withId_(id<JavaLangRunnable> runnable, id result);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentFutureTask)

#endif

#if !defined (JavaUtilConcurrentFutureTask_WaitNode_) && (INCLUDE_ALL_JavaUtilConcurrentFutureTask || defined(INCLUDE_JavaUtilConcurrentFutureTask_WaitNode))
#define JavaUtilConcurrentFutureTask_WaitNode_

@class JavaLangThread;

/*!
 @brief Simple linked list nodes to record waiting threads in a Treiber
  stack.See other classes such as Phaser and SynchronousQueue
  for more detailed explanation.
 */
@interface JavaUtilConcurrentFutureTask_WaitNode : NSObject {
 @public
  volatile_id thread_;
  volatile_id next_;
}

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentFutureTask_WaitNode)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentFutureTask_WaitNode, thread_, JavaLangThread *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentFutureTask_WaitNode, next_, JavaUtilConcurrentFutureTask_WaitNode *)

FOUNDATION_EXPORT void JavaUtilConcurrentFutureTask_WaitNode_init(JavaUtilConcurrentFutureTask_WaitNode *self);

FOUNDATION_EXPORT JavaUtilConcurrentFutureTask_WaitNode *new_JavaUtilConcurrentFutureTask_WaitNode_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentFutureTask_WaitNode *create_JavaUtilConcurrentFutureTask_WaitNode_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentFutureTask_WaitNode)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentFutureTask")
