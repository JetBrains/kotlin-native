//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/locks/AbstractQueuedSynchronizer.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer")
#ifdef RESTRICT_JavaUtilConcurrentLocksAbstractQueuedSynchronizer
#define INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer 1
#endif
#undef RESTRICT_JavaUtilConcurrentLocksAbstractQueuedSynchronizer

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_) && (INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer || defined(INCLUDE_JavaUtilConcurrentLocksAbstractQueuedSynchronizer))
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_

#define RESTRICT_JavaUtilConcurrentLocksAbstractOwnableSynchronizer 1
#define INCLUDE_JavaUtilConcurrentLocksAbstractOwnableSynchronizer 1
#include "java/util/concurrent/locks/AbstractOwnableSynchronizer.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaLangThread;
@class JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject;
@class JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node;
@protocol JavaUtilCollection;

/*!
 @brief Provides a framework for implementing blocking locks and related
  synchronizers (semaphores, events, etc) that rely on
  first-in-first-out (FIFO) wait queues.This class is designed to
  be a useful basis for most kinds of synchronizers that rely on a
  single atomic <code>int</code> value to represent state.
 Subclasses
  must define the protected methods that change this state, and which
  define what that state means in terms of this object being acquired
  or released.  Given these, the other methods in this class carry
  out all queuing and blocking mechanics. Subclasses can maintain
  other state fields, but only the atomically updated <code>int</code>
  value manipulated using methods <code>getState</code>, <code>setState</code>
  and <code>compareAndSetState</code> is tracked with respect
  to synchronization. 
 <p>Subclasses should be defined as non-public internal helper
  classes that are used to implement the synchronization properties
  of their enclosing class.  Class 
 <code>AbstractQueuedSynchronizer</code> does not implement any
  synchronization interface.  Instead it defines methods such as 
 <code>acquireInterruptibly</code> that can be invoked as
  appropriate by concrete locks and related synchronizers to
  implement their public methods. 
 <p>This class supports either or both a default <em>exclusive</em>
  mode and a <em>shared</em> mode. When acquired in exclusive mode,
  attempted acquires by other threads cannot succeed. Shared mode
  acquires by multiple threads may (but need not) succeed. This class
  does not &quot;understand&quot; these differences except in the
  mechanical sense that when a shared mode acquire succeeds, the next
  waiting thread (if one exists) must also determine whether it can
  acquire as well. Threads waiting in the different modes share the
  same FIFO queue. Usually, implementation subclasses support only
  one of these modes, but both can come into play for example in a 
 <code>ReadWriteLock</code>. Subclasses that support only exclusive or
  only shared modes need not define the methods supporting the unused mode. 
 <p>This class defines a nested <code>ConditionObject</code> class that
  can be used as a <code>Condition</code> implementation by subclasses
  supporting exclusive mode for which method <code>isHeldExclusively</code>
  reports whether synchronization is exclusively
  held with respect to the current thread, method <code>release</code>
  invoked with the current <code>getState</code> value fully releases
  this object, and <code>acquire</code>, given this saved state value,
  eventually restores this object to its previous acquired state.  No 
 <code>AbstractQueuedSynchronizer</code> method otherwise creates such a
  condition, so if this constraint cannot be met, do not use it.  The
  behavior of <code>ConditionObject</code> depends of course on the
  semantics of its synchronizer implementation. 
 <p>This class provides inspection, instrumentation, and monitoring
  methods for the internal queue, as well as similar methods for
  condition objects. These can be exported as desired into classes
  using an <code>AbstractQueuedSynchronizer</code> for their
  synchronization mechanics. 
 <p>Serialization of this class stores only the underlying atomic
  integer maintaining state, so deserialized objects have empty
  thread queues. Typical subclasses requiring serializability will
  define a <code>readObject</code> method that restores this to a known
  initial state upon deserialization. 
 <h3>Usage</h3>
  
 <p>To use this class as the basis of a synchronizer, redefine the
  following methods, as applicable, by inspecting and/or modifying
  the synchronization state using <code>getState</code>, <code>setState</code>
  and/or <code>compareAndSetState</code>:
  
 <ul>
  <li><code>tryAcquire</code>
  <li><code>tryRelease</code>
  <li><code>tryAcquireShared</code>
  <li><code>tryReleaseShared</code>
  <li><code>isHeldExclusively</code>
  </ul>
  Each of these methods by default throws <code>UnsupportedOperationException</code>
 .  Implementations of these methods
  must be internally thread-safe, and should in general be short and
  not block. Defining these methods is the <em>only</em> supported
  means of using this class. All other methods are declared 
 <code>final</code> because they cannot be independently varied. 
 <p>You may also find the inherited methods from <code>AbstractOwnableSynchronizer</code>
  useful to keep track of the thread
  owning an exclusive synchronizer.  You are encouraged to use them
  -- this enables monitoring and diagnostic tools to assist users in
  determining which threads hold locks. 
 <p>Even though this class is based on an internal FIFO queue, it
  does not automatically enforce FIFO acquisition policies.  The core
  of exclusive synchronization takes the form: 
 @code

  Acquire:
      while (!tryAcquire(arg)) {
                <em>enqueue thread if it is not already queued</em>;
                <em>possibly block current thread</em>;
      }
  Release:
      if (tryRelease(arg))
                <em>unblock the first queued thread</em>;
   
@endcode
  (Shared mode is similar but may involve cascading signals.) 
 <p id="barging">Because checks in acquire are invoked before
  enqueuing, a newly acquiring thread may <em>barge</em> ahead of
  others that are blocked and queued.  However, you can, if desired,
  define <code>tryAcquire</code> and/or <code>tryAcquireShared</code> to
  disable barging by internally invoking one or more of the inspection
  methods, thereby providing a <em>fair</em> FIFO acquisition order.
  In particular, most fair synchronizers can define <code>tryAcquire</code>
  to return <code>false</code> if <code>hasQueuedPredecessors</code> (a method
  specifically designed to be used by fair synchronizers) returns 
 <code>true</code>.  Other variations are possible. 
 <p>Throughput and scalability are generally highest for the
  default barging (also known as <em>greedy</em>,
  <em>renouncement</em>, and <em>convoy-avoidance</em>) strategy.
  While this is not guaranteed to be fair or starvation-free, earlier
  queued threads are allowed to recontend before later queued
  threads, and each recontention has an unbiased chance to succeed
  against incoming threads.  Also, while acquires do not 
 &quot;spin&quot; in the usual sense, they may perform multiple
  invocations of <code>tryAcquire</code> interspersed with other
  computations before blocking.  This gives most of the benefits of
  spins when exclusive synchronization is only briefly held, without
  most of the liabilities when it isn't. If so desired, you can
  augment this by preceding calls to acquire methods with
  "fast-path" checks, possibly prechecking <code>hasContended</code>
  and/or <code>hasQueuedThreads</code> to only do so if the synchronizer
  is likely not to be contended. 
 <p>This class provides an efficient and scalable basis for
  synchronization in part by specializing its range of use to
  synchronizers that can rely on <code>int</code> state, acquire, and
  release parameters, and an internal FIFO wait queue. When this does
  not suffice, you can build synchronizers from a lower level using 
 <code>atomic</code> classes, your own custom 
 <code>java.util.Queue</code> classes, and <code>LockSupport</code> blocking
  support. 
 <h3>Usage Examples</h3>
  
 <p>Here is a non-reentrant mutual exclusion lock class that uses
  the value zero to represent the unlocked state, and one to
  represent the locked state. While a non-reentrant lock
  does not strictly require recording of the current owner
  thread, this class does so anyway to make usage easier to monitor.
  It also supports conditions and exposes
  one of the instrumentation methods: 
 @code
  class Mutex implements Lock, java.io.Serializable {
    // Our internal helper class
    private static class Sync extends AbstractQueuedSynchronizer {
      // Reports whether in locked state
      protected boolean isHeldExclusively() {
        return getState() == 1;
      }
      // Acquires the lock if state is zero
      public boolean tryAcquire(int acquires) {
        assert acquires == 1; // Otherwise unused
        if (compareAndSetState(0, 1)) {
          setExclusiveOwnerThread(Thread.currentThread());
          return true;
        }
        return false;
      }
      // Releases the lock by setting state to zero
      protected boolean tryRelease(int releases) {
        assert releases == 1; // Otherwise unused
        if (getState() == 0) throw new IllegalMonitorStateException();
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
      }
      // Provides a Condition
      Condition newCondition() { return new ConditionObject(); }
      // Deserializes properly
      private void readObject(ObjectInputStream s)
          throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        setState(0); // reset to unlocked state
      }    }
    // The sync object does all the hard work. We just forward to it.
    private final Sync sync = new Sync();
    public void lock()                { sync.acquire(1); }
    public boolean tryLock()          { return sync.tryAcquire(1); }
    public void unlock()              { sync.release(1); }
    public Condition newCondition()   { return sync.newCondition(); }
    public boolean isLocked()         { return sync.isHeldExclusively(); }
    public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
    public void lockInterruptibly() throws InterruptedException {
      sync.acquireInterruptibly(1);
    }
    public boolean tryLock(long timeout, TimeUnit unit)
        throws InterruptedException {
      return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }  }
 
@endcode
  
 <p>Here is a latch class that is like a 
 <code>CountDownLatch</code>
  except that it only requires a single <code>signal</code> to
  fire. Because a latch is non-exclusive, it uses the <code>shared</code>
  acquire and release methods. 
 @code
  class BooleanLatch {
    private static class Sync extends AbstractQueuedSynchronizer {
      boolean isSignalled() { return getState() != 0; }
      protected int tryAcquireShared(int ignore) {
        return isSignalled() ? 1 : -1;
      }
      protected boolean tryReleaseShared(int ignore) {
        setState(1);
        return true;
      }    }
    private final Sync sync = new Sync();
    public boolean isSignalled() { return sync.isSignalled(); }
    public void signal()         { sync.releaseShared(1); }
    public void await() throws InterruptedException {
      sync.acquireSharedInterruptibly(1);
    }  }
 
@endcode
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentLocksAbstractQueuedSynchronizer : JavaUtilConcurrentLocksAbstractOwnableSynchronizer < JavaIoSerializable >
@property (readonly, class) jlong SPIN_FOR_TIMEOUT_THRESHOLD NS_SWIFT_NAME(SPIN_FOR_TIMEOUT_THRESHOLD);

+ (jlong)SPIN_FOR_TIMEOUT_THRESHOLD;

#pragma mark Public

/*!
 @brief Acquires in exclusive mode, ignoring interrupts.Implemented
  by invoking at least once <code>tryAcquire</code>,
  returning on success.
 Otherwise the thread is queued, possibly
  repeatedly blocking and unblocking, invoking <code>tryAcquire</code>
  until success.  This method can be used
  to implement method <code>Lock.lock</code>.
 @param arg the acquire argument.  This value is conveyed to         
 <code>tryAcquire</code>  but is otherwise uninterpreted and         can represent anything you like.
 */
- (void)acquireWithInt:(jint)arg;

/*!
 @brief Acquires in exclusive mode, aborting if interrupted.
 Implemented by first checking interrupt status, then invoking
  at least once <code>tryAcquire</code>, returning on
  success.  Otherwise the thread is queued, possibly repeatedly
  blocking and unblocking, invoking <code>tryAcquire</code>
  until success or the thread is interrupted.  This method can be
  used to implement method <code>Lock.lockInterruptibly</code>.
 @param arg the acquire argument.  This value is conveyed to         
 <code>tryAcquire</code>  but is otherwise uninterpreted and         can represent anything you like.
 @throw InterruptedExceptionif the current thread is interrupted
 */
- (void)acquireInterruptiblyWithInt:(jint)arg;

/*!
 @brief Acquires in shared mode, ignoring interrupts.Implemented by
  first invoking at least once <code>tryAcquireShared</code>,
  returning on success.
 Otherwise the thread is queued, possibly
  repeatedly blocking and unblocking, invoking <code>tryAcquireShared</code>
  until success.
 @param arg the acquire argument.  This value is conveyed to         
 <code>tryAcquireShared</code>  but is otherwise uninterpreted         and can represent anything you like.
 */
- (void)acquireSharedWithInt:(jint)arg;

/*!
 @brief Acquires in shared mode, aborting if interrupted.Implemented
  by first checking interrupt status, then invoking at least once 
 <code>tryAcquireShared</code>, returning on success.
 Otherwise the
  thread is queued, possibly repeatedly blocking and unblocking,
  invoking <code>tryAcquireShared</code> until success or the thread
  is interrupted.
 @param arg the acquire argument.  This value is conveyed to 
 <code>tryAcquireShared</code>  but is  otherwise uninterpreted and can represent anything
   you like.
 @throw InterruptedExceptionif the current thread is interrupted
 */
- (void)acquireSharedInterruptiblyWithInt:(jint)arg;

/*!
 @brief Returns a collection containing threads that may be waiting to
  acquire in exclusive mode.This has the same properties
  as <code>getQueuedThreads</code> except that it only returns
  those threads waiting due to an exclusive acquire.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getExclusiveQueuedThreads;

/*!
 @brief Returns the first (longest-waiting) thread in the queue, or 
 <code>null</code> if no threads are currently queued.
 <p>In this implementation, this operation normally returns in
  constant time, but may iterate upon contention if other threads are
  concurrently modifying the queue.
 @return the first (longest-waiting) thread in the queue, or
          <code>null</code> if no threads are currently queued
 */
- (JavaLangThread *)getFirstQueuedThread;

/*!
 @brief Returns a collection containing threads that may be waiting to
  acquire.Because the actual set of threads may change
  dynamically while constructing this result, the returned
  collection is only a best-effort estimate.
 The elements of the
  returned collection are in no particular order.  This method is
  designed to facilitate construction of subclasses that provide
  more extensive monitoring facilities.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getQueuedThreads;

/*!
 @brief Returns an estimate of the number of threads waiting to
  acquire.The value is only an estimate because the number of
  threads may change dynamically while this method traverses
  internal data structures.
 This method is designed for use in
  monitoring system state, not for synchronization control.
 @return the estimated number of threads waiting to acquire
 */
- (jint)getQueueLength;

/*!
 @brief Returns a collection containing threads that may be waiting to
  acquire in shared mode.This has the same properties
  as <code>getQueuedThreads</code> except that it only returns
  those threads waiting due to a shared acquire.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getSharedQueuedThreads;

/*!
 @brief Returns a collection containing those threads that may be
  waiting on the given condition associated with this
  synchronizer.Because the actual set of threads may change
  dynamically while constructing this result, the returned
  collection is only a best-effort estimate.
 The elements of the
  returned collection are in no particular order.
 @param condition the condition
 @return the collection of threads
 @throw IllegalMonitorStateExceptionif exclusive synchronization
          is not held
 @throw IllegalArgumentExceptionif the given condition is
          not associated with this synchronizer
 @throw NullPointerExceptionif the condition is null
 */
- (id<JavaUtilCollection>)getWaitingThreadsWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

/*!
 @brief Returns an estimate of the number of threads waiting on the
  given condition associated with this synchronizer.Note that
  because timeouts and interrupts may occur at any time, the
  estimate serves only as an upper bound on the actual number of
  waiters.
 This method is designed for use in monitoring system
  state, not for synchronization control.
 @param condition the condition
 @return the estimated number of waiting threads
 @throw IllegalMonitorStateExceptionif exclusive synchronization
          is not held
 @throw IllegalArgumentExceptionif the given condition is
          not associated with this synchronizer
 @throw NullPointerExceptionif the condition is null
 */
- (jint)getWaitQueueLengthWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

/*!
 @brief Queries whether any threads have ever contended to acquire this
  synchronizer; that is, if an acquire method has ever blocked.
 <p>In this implementation, this operation returns in
  constant time.
 @return <code>true</code> if there has ever been contention
 */
- (jboolean)hasContended;

/*!
 @brief Queries whether any threads have been waiting to acquire longer
  than the current thread.
 <p>An invocation of this method is equivalent to (but may be
  more efficient than): 
 @code
  getFirstQueuedThread() != Thread.currentThread()
    && hasQueuedThreads()
 
@endcode
  
 <p>Note that because cancellations due to interrupts and
  timeouts may occur at any time, a <code>true</code> return does not
  guarantee that some other thread will acquire before the current
  thread.  Likewise, it is possible for another thread to win a
  race to enqueue after this method has returned <code>false</code>,
  due to the queue being empty. 
 <p>This method is designed to be used by a fair synchronizer to
  avoid <a href="AbstractQueuedSynchronizer.html#barging">barging</a>.
  Such a synchronizer's <code>tryAcquire</code> method should return 
 <code>false</code>, and its <code>tryAcquireShared</code> method should
  return a negative value, if this method returns <code>true</code>
  (unless this is a reentrant acquire).  For example, the <code>tryAcquire</code>
  method for a fair, reentrant, exclusive mode
  synchronizer might look like this: 
 @code
  protected boolean tryAcquire(int arg) {
    if (isHeldExclusively()) {
      // A reentrant acquire; increment hold count
      return true;
    } else if (hasQueuedPredecessors()) {
      return false;
    } else {
      // try to acquire normally
    }  }
 
@endcode
 @return <code>true</code> if there is a queued thread preceding the
          current thread, and <code>false</code> if the current thread
          is at the head of the queue or the queue is empty
 @since 1.7
 */
- (jboolean)hasQueuedPredecessors;

/*!
 @brief Queries whether any threads are waiting to acquire.Note that
  because cancellations due to interrupts and timeouts may occur
  at any time, a <code>true</code> return does not guarantee that any
  other thread will ever acquire.
 <p>In this implementation, this operation returns in
  constant time.
 @return <code>true</code> if there may be other threads waiting to acquire
 */
- (jboolean)hasQueuedThreads;

/*!
 @brief Queries whether any threads are waiting on the given condition
  associated with this synchronizer.Note that because timeouts
  and interrupts may occur at any time, a <code>true</code> return
  does not guarantee that a future <code>signal</code> will awaken
  any threads.
 This method is designed primarily for use in
  monitoring of the system state.
 @param condition the condition
 @return <code>true</code> if there are any waiting threads
 @throw IllegalMonitorStateExceptionif exclusive synchronization
          is not held
 @throw IllegalArgumentExceptionif the given condition is
          not associated with this synchronizer
 @throw NullPointerExceptionif the condition is null
 */
- (jboolean)hasWaitersWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

/*!
 @brief Returns true if the given thread is currently queued.
 <p>This implementation traverses the queue to determine
  presence of the given thread.
 @param thread the thread
 @return <code>true</code> if the given thread is on the queue
 @throw NullPointerExceptionif the thread is null
 */
- (jboolean)isQueuedWithJavaLangThread:(JavaLangThread *)thread;

/*!
 @brief Queries whether the given ConditionObject
  uses this synchronizer as its lock.
 @param condition the condition
 @return <code>true</code> if owned
 @throw NullPointerExceptionif the condition is null
 */
- (jboolean)ownsWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *)condition;

/*!
 @brief Releases in exclusive mode.Implemented by unblocking one or
  more threads if <code>tryRelease</code> returns true.
 This method can be used to implement method <code>Lock.unlock</code>.
 @param arg the release argument.  This value is conveyed to         
 <code>tryRelease</code>  but is otherwise uninterpreted and         can represent anything you like.
 @return the value returned from <code>tryRelease</code>
 */
- (jboolean)release__WithInt:(jint)arg;

/*!
 @brief Releases in shared mode.Implemented by unblocking one or more
  threads if <code>tryReleaseShared</code> returns true.
 @param arg the release argument.  This value is conveyed to         
 <code>tryReleaseShared</code>  but is otherwise uninterpreted         and can represent anything you like.
 @return the value returned from <code>tryReleaseShared</code>
 */
- (jboolean)releaseSharedWithInt:(jint)arg;

/*!
 @brief Returns a string identifying this synchronizer, as well as its state.
 The state, in brackets, includes the String <code>"State ="</code>
  followed by the current value of <code>getState</code>, and either 
 <code>"nonempty"</code> or <code>"empty"</code> depending on whether the
  queue is empty.
 @return a string identifying this synchronizer, as well as its state
 */
- (NSString *)description;

/*!
 @brief Attempts to acquire in exclusive mode, aborting if interrupted,
  and failing if the given timeout elapses.Implemented by first
  checking interrupt status, then invoking at least once <code>tryAcquire</code>
 , returning on success.
 Otherwise, the thread is
  queued, possibly repeatedly blocking and unblocking, invoking 
 <code>tryAcquire</code> until success or the thread is interrupted
  or the timeout elapses.  This method can be used to implement method 
 <code>Lock.tryLock(long, TimeUnit)</code>.
 @param arg the acquire argument.  This value is conveyed to         
 <code>tryAcquire</code>  but is otherwise uninterpreted and         can represent anything you like.
 @param nanosTimeout the maximum number of nanoseconds to wait
 @return <code>true</code> if acquired; <code>false</code> if timed out
 @throw InterruptedExceptionif the current thread is interrupted
 */
- (jboolean)tryAcquireNanosWithInt:(jint)arg
                          withLong:(jlong)nanosTimeout;

/*!
 @brief Attempts to acquire in shared mode, aborting if interrupted, and
  failing if the given timeout elapses.Implemented by first
  checking interrupt status, then invoking at least once <code>tryAcquireShared</code>
 , returning on success.
 Otherwise, the
  thread is queued, possibly repeatedly blocking and unblocking,
  invoking <code>tryAcquireShared</code> until success or the thread
  is interrupted or the timeout elapses.
 @param arg the acquire argument.  This value is conveyed to         
 <code>tryAcquireShared</code>  but is otherwise uninterpreted         and can represent anything you like.
 @param nanosTimeout the maximum number of nanoseconds to wait
 @return <code>true</code> if acquired; <code>false</code> if timed out
 @throw InterruptedExceptionif the current thread is interrupted
 */
- (jboolean)tryAcquireSharedNanosWithInt:(jint)arg
                                withLong:(jlong)nanosTimeout;

#pragma mark Protected

/*!
 @brief Creates a new <code>AbstractQueuedSynchronizer</code> instance
  with initial synchronization state of zero.
 */
- (instancetype __nonnull)init;

/*!
 @brief Atomically sets synchronization state to the given updated
  value if the current state value equals the expected value.
 This operation has memory semantics of a <code>volatile</code> read
  and write.
 @param expect the expected value
 @param update the new value
 @return <code>true</code> if successful. False return indicates that the actual
          value was not equal to the expected value.
 */
- (jboolean)compareAndSetStateWithInt:(jint)expect
                              withInt:(jint)update;

/*!
 @brief Returns the current value of synchronization state.
 This operation has memory semantics of a <code>volatile</code> read.
 @return current state value
 */
- (jint)getState;

/*!
 @brief Returns <code>true</code> if synchronization is held exclusively with
  respect to the current (calling) thread.This method is invoked
  upon each call to a non-waiting <code>ConditionObject</code> method.
 (Waiting methods instead invoke <code>release</code>.)
  
 <p>The default implementation throws <code>UnsupportedOperationException</code>
 . This method is invoked
  internally only within <code>ConditionObject</code> methods, so need
  not be defined if conditions are not used.
 @return <code>true</code> if synchronization is held exclusively;
          <code>false</code> otherwise
 @throw UnsupportedOperationExceptionif conditions are not supported
 */
- (jboolean)isHeldExclusively;

/*!
 @brief Sets the value of synchronization state.
 This operation has memory semantics of a <code>volatile</code> write.
 @param newState the new state value
 */
- (void)setStateWithInt:(jint)newState;

/*!
 @brief Attempts to acquire in exclusive mode.This method should query
  if the state of the object permits it to be acquired in the
  exclusive mode, and if so to acquire it.
 <p>This method is always invoked by the thread performing
  acquire.  If this method reports failure, the acquire method
  may queue the thread, if it is not already queued, until it is
  signalled by a release from some other thread. This can be used
  to implement method <code>Lock.tryLock()</code>.
  
 <p>The default
  implementation throws <code>UnsupportedOperationException</code>.
 @param arg the acquire argument. This value is always the one         passed to an acquire method, or is the value saved on entry
          to a condition wait.  The value is otherwise uninterpreted
          and can represent anything you like.
 @return <code>true</code> if successful. Upon success, this object has
          been acquired.
 @throw IllegalMonitorStateExceptionif acquiring would place this
          synchronizer in an illegal state. This exception must be
          thrown in a consistent fashion for synchronization to work
          correctly.
 @throw UnsupportedOperationExceptionif exclusive mode is not supported
 */
- (jboolean)tryAcquireWithInt:(jint)arg;

/*!
 @brief Attempts to acquire in shared mode.This method should query if
  the state of the object permits it to be acquired in the shared
  mode, and if so to acquire it.
 <p>This method is always invoked by the thread performing
  acquire.  If this method reports failure, the acquire method
  may queue the thread, if it is not already queued, until it is
  signalled by a release from some other thread. 
 <p>The default implementation throws <code>UnsupportedOperationException</code>
 .
 @param arg the acquire argument. This value is always the one         passed to an acquire method, or is the value saved on entry
          to a condition wait.  The value is otherwise uninterpreted
          and can represent anything you like.
 @return a negative value on failure; zero if acquisition in shared
          mode succeeded but no subsequent shared-mode acquire can
          succeed; and a positive value if acquisition in shared
          mode succeeded and subsequent shared-mode acquires might
          also succeed, in which case a subsequent waiting thread
          must check availability. (Support for three different
          return values enables this method to be used in contexts
          where acquires only sometimes act exclusively.)  Upon
          success, this object has been acquired.
 @throw IllegalMonitorStateExceptionif acquiring would place this
          synchronizer in an illegal state. This exception must be
          thrown in a consistent fashion for synchronization to work
          correctly.
 @throw UnsupportedOperationExceptionif shared mode is not supported
 */
- (jint)tryAcquireSharedWithInt:(jint)arg;

/*!
 @brief Attempts to set the state to reflect a release in exclusive
  mode.
 <p>This method is always invoked by the thread performing release. 
 <p>The default implementation throws 
 <code>UnsupportedOperationException</code>.
 @param arg the release argument. This value is always the one         passed to a release method, or the current state value upon
          entry to a condition wait.  The value is otherwise
          uninterpreted and can represent anything you like.
 @return <code>true</code> if this object is now in a fully released
          state, so that any waiting threads may attempt to acquire;
          and <code>false</code> otherwise.
 @throw IllegalMonitorStateExceptionif releasing would place this
          synchronizer in an illegal state. This exception must be
          thrown in a consistent fashion for synchronization to work
          correctly.
 @throw UnsupportedOperationExceptionif exclusive mode is not supported
 */
- (jboolean)tryReleaseWithInt:(jint)arg;

/*!
 @brief Attempts to set the state to reflect a release in shared mode.
 <p>This method is always invoked by the thread performing release. 
 <p>The default implementation throws 
 <code>UnsupportedOperationException</code>.
 @param arg the release argument. This value is always the one         passed to a release method, or the current state value upon
          entry to a condition wait.  The value is otherwise
          uninterpreted and can represent anything you like.
 @return <code>true</code> if this release of shared mode may permit a
          waiting acquire (shared or exclusive) to succeed; and         
 <code>false</code> otherwise
 @throw IllegalMonitorStateExceptionif releasing would place this
          synchronizer in an illegal state. This exception must be
          thrown in a consistent fashion for synchronization to work
          correctly.
 @throw UnsupportedOperationExceptionif shared mode is not supported
 */
- (jboolean)tryReleaseSharedWithInt:(jint)arg;

#pragma mark Package-Private

/*!
 @brief Acquires in exclusive uninterruptible mode for thread already in
  queue.Used by condition wait methods as well as acquire.
 @param node the node
 @param arg the acquire argument
 @return <code>true</code> if interrupted while waiting
 */
- (jboolean)acquireQueuedWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node
                                                                            withInt:(jint)arg;

/*!
 @brief Returns <code>true</code> if the apparent first queued thread, if one
  exists, is waiting in exclusive mode.If this method returns 
 <code>true</code>, and the current thread is attempting to acquire in
  shared mode (that is, this method is invoked from <code>tryAcquireShared</code>
 ) then it is guaranteed that the current thread
  is not the first queued thread.
 Used only as a heuristic in
  ReentrantReadWriteLock.
 */
- (jboolean)apparentlyFirstQueuedIsExclusive;

/*!
 @brief Invokes release with current state value; returns saved state.
 Cancels node and throws exception on failure.
 @param node the condition node for this wait
 @return previous sync state
 */
- (jint)fullyReleaseWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

/*!
 @brief Returns true if a node, always one that was initially placed on
  a condition queue, is now waiting to reacquire on sync queue.
 @param node the node
 @return true if is reacquiring
 */
- (jboolean)isOnSyncQueueWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

/*!
 @brief Convenience method to interrupt current thread.
 */
+ (void)selfInterrupt;

/*!
 @brief Transfers node, if necessary, to sync queue after a cancelled wait.
 Returns true if thread was cancelled before being signalled.
 @param node the node
 @return true if cancelled before the node was signalled
 */
- (jboolean)transferAfterCancelledWaitWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

/*!
 @brief Transfers a node from a condition queue onto sync queue.
 Returns true if successful.
 @param node the node
 @return true if successfully transferred (else the node was
  cancelled before signal)
 */
- (jboolean)transferForSignalWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)node;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer)

/*!
 @brief The number of nanoseconds for which it is faster to spin
  rather than to use timed park.A rough estimate suffices
  to improve responsiveness with very short timeouts.
 */
inline jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_get_SPIN_FOR_TIMEOUT_THRESHOLD(void);
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_SPIN_FOR_TIMEOUT_THRESHOLD 1000LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer, SPIN_FOR_TIMEOUT_THRESHOLD, jlong)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_init(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *self);

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_selfInterrupt(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer)

#endif

#if !defined (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_) && (INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer || defined(INCLUDE_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node))
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_

@class JavaLangThread;

/*!
 @brief Wait queue node class.
 <p>The wait queue is a variant of a "CLH" (Craig, Landin, and
  Hagersten) lock queue. CLH locks are normally used for
  spinlocks.  We instead use them for blocking synchronizers, but
  use the same basic tactic of holding some of the control
  information about a thread in the predecessor of its node.  A
  "status" field in each node keeps track of whether a thread
  should block.  A node is signalled when its predecessor
  releases.  Each node of the queue otherwise serves as a
  specific-notification-style monitor holding a single waiting
  thread. The status field does NOT control whether threads are
  granted locks etc though.  A thread may try to acquire if it is
  first in the queue. But being first does not guarantee success;
  it only gives the right to contend.  So the currently released
  contender thread may need to rewait. 
 <p>To enqueue into a CLH lock, you atomically splice it in as new
  tail. To dequeue, you just set the head field. 
 @code

       +------+  prev +-----+       +-----+
  head |      | <---- |     | <---- |     |  tail
       +------+       +-----+       +-----+ 
  
@endcode
  
 <p>Insertion into a CLH queue requires only a single atomic
  operation on "tail", so there is a simple atomic point of
  demarcation from unqueued to queued. Similarly, dequeuing
  involves only updating the "head". However, it takes a bit
  more work for nodes to determine who their successors are,
  in part to deal with possible cancellation due to timeouts
  and interrupts. 
 <p>The "prev" links (not used in original CLH locks), are mainly
  needed to handle cancellation. If a node is cancelled, its
  successor is (normally) relinked to a non-cancelled
  predecessor. For explanation of similar mechanics in the case
  of spin locks, see the papers by Scott and Scherer at
  http://www.cs.rochester.edu/u/scott/synchronization/ 
 <p>We also use "next" links to implement blocking mechanics.
  The thread id for each node is kept in its own node, so a
  predecessor signals the next node to wake up by traversing
  next link to determine which thread it is.  Determination of
  successor must avoid races with newly queued nodes to set
  the "next" fields of their predecessors.  This is solved
  when necessary by checking backwards from the atomically
  updated "tail" when a node's successor appears to be null.
  (Or, said differently, the next-links are an optimization
  so that we don't usually need a backward scan.) 
 <p>Cancellation introduces some conservatism to the basic
  algorithms.  Since we must poll for cancellation of other
  nodes, we can miss noticing whether a cancelled node is
  ahead or behind us. This is dealt with by always unparking
  successors upon cancellation, allowing them to stabilize on
  a new predecessor, unless we can identify an uncancelled
  predecessor who will carry this responsibility. 
 <p>CLH queues need a dummy header node to get started. But
  we don't create them on construction, because it would be wasted
  effort if there is never contention. Instead, the node
  is constructed and head and tail pointers are set upon first
  contention. 
 <p>Threads waiting on Conditions use the same nodes, but
  use an additional link. Conditions only need to link nodes
  in simple (non-concurrent) linked queues because they are
  only accessed when exclusively held.  Upon await, a node is
  inserted into a condition queue.  Upon signal, the node is
  transferred to the main queue.  A special value of status
  field is used to mark which queue a node is on. 
 <p>Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill
  Scherer and Michael Scott, along with members of JSR-166
  expert group, for helpful ideas, discussions, and critiques
  on the design of this class.
 */
@interface JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node : NSObject {
 @public
  /*!
   @brief Status field, taking on only the values:
    SIGNAL:     The successor of this node is (or will soon be)
                blocked (via park), so the current node must
                unpark its successor when it releases or
                cancels.To avoid races, acquire methods must
                first indicate they need a signal,
                then retry the atomic acquire, and then,
                on failure, block.
   CANCELLED:  This node is cancelled due to timeout or interrupt.
                Nodes never leave this state. In particular,
                a thread with cancelled node never again blocks.
    CONDITION:  This node is currently on a condition queue.
                It will not be used as a sync queue node
                until transferred, at which time the status
                will be set to 0. (Use of this value here has
                nothing to do with the other uses of the
                field, but simplifies mechanics.)
    PROPAGATE:  A releaseShared should be propagated to other
                nodes. This is set (for head node only) in
                doReleaseShared to ensure propagation
                continues, even if other operations have
                since intervened.
    0:          None of the above
  The values are arranged numerically to simplify use.
  Non-negative values mean that a node doesn't need to
  signal. So, most code doesn't need to check for particular
  values, just for sign.
  The field is initialized to 0 for normal sync nodes, and
  CONDITION for condition nodes.  It is modified using CAS
  (or when possible, unconditional volatile writes).
   */
  volatile_jint waitStatus_;
  /*!
   @brief Link to predecessor node that current node/thread relies on
  for checking waitStatus.Assigned during enqueuing, and nulled
  out (for sake of GC) only upon dequeuing.
   Also, upon
  cancellation of a predecessor, we short-circuit while
  finding a non-cancelled one, which will always exist
  because the head node is never cancelled: A node becomes
  head only as a result of successful acquire. A
  cancelled thread never succeeds in acquiring, and a thread only
  cancels itself, not any other node.
   */
  volatile_id prev_;
  /*!
   @brief Link to the successor node that the current node/thread
  unparks upon release.Assigned during enqueuing, adjusted
  when bypassing cancelled predecessors, and nulled out (for
  sake of GC) when dequeued.
   The enq operation does not
  assign next field of a predecessor until after attachment,
  so seeing a null next field does not necessarily mean that
  node is at end of queue. However, if a next field appears
  to be null, we can scan prev's from the tail to
  double-check.  The next field of cancelled nodes is set to
  point to the node itself instead of null, to make life
  easier for isOnSyncQueue.
   */
  volatile_id next_;
  /*!
   @brief The thread that enqueued this node.Initialized on
  construction and nulled out after use.
   */
  volatile_id thread_;
  /*!
   @brief Link to next node waiting on condition, or the special
  value SHARED.Because condition queues are accessed only
  when holding in exclusive mode, we just need a simple
  linked queue to hold nodes while they are waiting on
  conditions.
   They are then transferred to the queue to
  re-acquire. And because conditions can only be exclusive,
  we save a field by using special value to indicate shared
  mode.
   */
  JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *nextWaiter_;
}
@property (readonly, class, strong) JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *SHARED NS_SWIFT_NAME(SHARED);
@property (readonly, class, strong) JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *EXCLUSIVE NS_SWIFT_NAME(EXCLUSIVE);
@property (readonly, class) jint CANCELLED NS_SWIFT_NAME(CANCELLED);
@property (readonly, class) jint SIGNAL NS_SWIFT_NAME(SIGNAL);
@property (readonly, class) jint CONDITION NS_SWIFT_NAME(CONDITION);
@property (readonly, class) jint PROPAGATE NS_SWIFT_NAME(PROPAGATE);
@property (readonly, class) jlong PREV NS_SWIFT_NAME(PREV);

+ (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)SHARED;

+ (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)EXCLUSIVE;

+ (jint)CANCELLED;

+ (jint)SIGNAL;

+ (jint)CONDITION;

+ (jint)PROPAGATE;

+ (jlong)PREV;

#pragma mark Package-Private

/*!
 @brief Establishes initial head or SHARED marker.
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructor used by addConditionWaiter.
 */
- (instancetype __nonnull)initWithInt:(jint)waitStatus;

/*!
 @brief Constructor used by addWaiter.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)nextWaiter;

/*!
 @brief CASes next field.
 */
- (jboolean)compareAndSetNextWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)expect
                             withJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)update;

/*!
 @brief CASes waitStatus field.
 */
- (jboolean)compareAndSetWaitStatusWithInt:(jint)expect
                                   withInt:(jint)update;

/*!
 @brief Returns true if node is waiting in shared mode.
 */
- (jboolean)isShared;

/*!
 @brief Returns previous node, or throws NullPointerException if null.
 Use when predecessor cannot be null.  The null check could
  be elided, but is present to help the VM.
 @return the predecessor of this node
 */
- (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)predecessor;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, prev_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, next_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, thread_, JavaLangThread *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, nextWaiter_, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)

/*!
 @brief Marker to indicate a node is waiting in shared mode
 */
inline JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_SHARED(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_SHARED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, SHARED, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)

/*!
 @brief Marker to indicate a node is waiting in exclusive mode
 */
inline JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_EXCLUSIVE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_EXCLUSIVE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, EXCLUSIVE, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *)

/*!
 @brief waitStatus value to indicate thread has cancelled.
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_CANCELLED(void);
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_CANCELLED 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, CANCELLED, jint)

/*!
 @brief waitStatus value to indicate successor's thread needs unparking.
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_SIGNAL(void);
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_SIGNAL -1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, SIGNAL, jint)

/*!
 @brief waitStatus value to indicate thread is waiting on condition.
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_CONDITION(void);
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_CONDITION -2
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, CONDITION, jint)

/*!
 @brief waitStatus value to indicate the next acquireShared should
  unconditionally propagate.
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_PROPAGATE(void);
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_PROPAGATE -3
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, PROPAGATE, jint)

inline jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_get_PREV(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jlong JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_PREV;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node, PREV, jlong)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_init(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *new_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *create_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_init(void);

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *self, JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *nextWaiter);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *new_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *nextWaiter) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *create_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *nextWaiter);

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initWithInt_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *self, jint waitStatus);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *new_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initWithInt_(jint waitStatus) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node *create_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node_initWithInt_(jint waitStatus);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_Node)

#endif

#if !defined (JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_) && (INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer || defined(INCLUDE_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject))
#define JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_

#define RESTRICT_JavaUtilConcurrentLocksCondition 1
#define INCLUDE_JavaUtilConcurrentLocksCondition 1
#include "java/util/concurrent/locks/Condition.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaUtilConcurrentLocksAbstractQueuedSynchronizer;
@class JavaUtilConcurrentTimeUnit;
@class JavaUtilDate;
@protocol JavaUtilCollection;

/*!
 @brief Condition implementation for a <code>AbstractQueuedSynchronizer</code>
  serving as the basis of a <code>Lock</code>
  implementation.
 <p>Method documentation for this class describes mechanics,
  not behavioral specifications from the point of view of Lock
  and Condition users. Exported versions of this class will in
  general need to be accompanied by documentation describing
  condition semantics that rely on those of the associated 
 <code>AbstractQueuedSynchronizer</code>.
  
 <p>This class is Serializable, but all fields are transient,
  so deserialized conditions have no waiters.
 */
@interface JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject : NSObject < JavaUtilConcurrentLocksCondition, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a new <code>ConditionObject</code> instance.
 */
- (instancetype __nonnull)initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *)outer$;

/*!
 @brief Implements interruptible condition wait.
 <ol>
  <li>If current thread is interrupted, throw InterruptedException. 
 <li>Save lock state returned by <code>getState</code>.
  <li>Invoke <code>release</code> with saved state as argument,
      throwing IllegalMonitorStateException if it fails. 
 <li>Block until signalled or interrupted. 
 <li>Reacquire by invoking specialized version of
      <code>acquire</code> with saved state as argument. 
 <li>If interrupted while blocked in step 4, throw InterruptedException. 
 </ol>
 */
- (void)await;

/*!
 @brief Implements timed condition wait.
 <ol>
  <li>If current thread is interrupted, throw InterruptedException. 
 <li>Save lock state returned by <code>getState</code>.
  <li>Invoke <code>release</code> with saved state as argument,
      throwing IllegalMonitorStateException if it fails. 
 <li>Block until signalled, interrupted, or timed out. 
 <li>Reacquire by invoking specialized version of
      <code>acquire</code> with saved state as argument. 
 <li>If interrupted while blocked in step 4, throw InterruptedException. 
 <li>If timed out while blocked in step 4, return false, else true. 
 </ol>
 */
- (jboolean)awaitWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Implements timed condition wait.
 <ol>
  <li>If current thread is interrupted, throw InterruptedException. 
 <li>Save lock state returned by <code>getState</code>.
  <li>Invoke <code>release</code> with saved state as argument,
      throwing IllegalMonitorStateException if it fails. 
 <li>Block until signalled, interrupted, or timed out. 
 <li>Reacquire by invoking specialized version of
      <code>acquire</code> with saved state as argument. 
 <li>If interrupted while blocked in step 4, throw InterruptedException. 
 </ol>
 */
- (jlong)awaitNanosWithLong:(jlong)nanosTimeout;

/*!
 @brief Implements uninterruptible condition wait.
 <ol>
  <li>Save lock state returned by <code>getState</code>.
  <li>Invoke <code>release</code> with saved state as argument,
      throwing IllegalMonitorStateException if it fails. 
 <li>Block until signalled. 
 <li>Reacquire by invoking specialized version of
      <code>acquire</code> with saved state as argument. 
 </ol>
 */
- (void)awaitUninterruptibly;

/*!
 @brief Implements absolute timed condition wait.
 <ol>
  <li>If current thread is interrupted, throw InterruptedException. 
 <li>Save lock state returned by <code>getState</code>.
  <li>Invoke <code>release</code> with saved state as argument,
      throwing IllegalMonitorStateException if it fails. 
 <li>Block until signalled, interrupted, or timed out. 
 <li>Reacquire by invoking specialized version of
      <code>acquire</code> with saved state as argument. 
 <li>If interrupted while blocked in step 4, throw InterruptedException. 
 <li>If timed out while blocked in step 4, return false, else true. 
 </ol>
 */
- (jboolean)awaitUntilWithJavaUtilDate:(JavaUtilDate *)deadline;

/*!
 @brief Moves the longest-waiting thread, if one exists, from the
  wait queue for this condition to the wait queue for the
  owning lock.
 @throw IllegalMonitorStateExceptionif <code>isHeldExclusively</code>
          returns <code>false</code>
 */
- (void)signal;

/*!
 @brief Moves all threads from the wait queue for this condition to
  the wait queue for the owning lock.
 @throw IllegalMonitorStateExceptionif <code>isHeldExclusively</code>
          returns <code>false</code>
 */
- (void)signalAll;

#pragma mark Protected

/*!
 @brief Returns a collection containing those threads that may be
  waiting on this Condition.
 Implements <code>AbstractQueuedSynchronizer.getWaitingThreads(ConditionObject)</code>.
 @return the collection of threads
 @throw IllegalMonitorStateExceptionif <code>isHeldExclusively</code>
          returns <code>false</code>
 */
- (id<JavaUtilCollection>)getWaitingThreads;

/*!
 @brief Returns an estimate of the number of threads waiting on
  this condition.
 Implements <code>AbstractQueuedSynchronizer.getWaitQueueLength(ConditionObject)</code>.
 @return the estimated number of waiting threads
 @throw IllegalMonitorStateExceptionif <code>isHeldExclusively</code>
          returns <code>false</code>
 */
- (jint)getWaitQueueLength;

/*!
 @brief Queries whether any threads are waiting on this condition.
 Implements <code>AbstractQueuedSynchronizer.hasWaiters(ConditionObject)</code>.
 @return <code>true</code> if there are any waiting threads
 @throw IllegalMonitorStateExceptionif <code>isHeldExclusively</code>
          returns <code>false</code>
 */
- (jboolean)hasWaiters;

#pragma mark Package-Private

/*!
 @brief Returns true if this condition was created by the given
  synchronization object.
 @return <code>true</code> if owned
 */
- (jboolean)isOwnedByWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer:(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *)sync;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *self, JavaUtilConcurrentLocksAbstractQueuedSynchronizer *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *new_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject *create_JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject_initWithJavaUtilConcurrentLocksAbstractQueuedSynchronizer_(JavaUtilConcurrentLocksAbstractQueuedSynchronizer *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksAbstractQueuedSynchronizer_ConditionObject)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentLocksAbstractQueuedSynchronizer")
