//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/RecursiveAction.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentRecursiveAction")
#ifdef RESTRICT_JavaUtilConcurrentRecursiveAction
#define INCLUDE_ALL_JavaUtilConcurrentRecursiveAction 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentRecursiveAction 1
#endif
#undef RESTRICT_JavaUtilConcurrentRecursiveAction

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentRecursiveAction_) && (INCLUDE_ALL_JavaUtilConcurrentRecursiveAction || defined(INCLUDE_JavaUtilConcurrentRecursiveAction))
#define JavaUtilConcurrentRecursiveAction_

#define RESTRICT_JavaUtilConcurrentForkJoinTask 1
#define INCLUDE_JavaUtilConcurrentForkJoinTask 1
#include "java/util/concurrent/ForkJoinTask.h"

@class JavaLangVoid;
@class JavaUtilConcurrentTimeUnit;

/*!
 @brief A recursive resultless <code>ForkJoinTask</code>.This class
  establishes conventions to parameterize resultless actions as 
 <code>Void</code> <code>ForkJoinTask</code>s.
 Because <code>null</code> is the
  only valid value of type <code>Void</code>, methods such as <code>join</code>
  always return <code>null</code> upon completion. 
 <p><b>Sample Usages.</b> Here is a simple but complete ForkJoin
  sort that sorts a given <code>long[]</code> array: 
 @code
  static class SortTask extends RecursiveAction {
    final long[] array; final int lo, hi;
    SortTask(long[] array, int lo, int hi) {
      this.array = array; this.lo = lo; this.hi = hi;
    }
    SortTask(long[] array) { this(array, 0, array.length); }
    protected void compute() {
      if (hi - lo < THRESHOLD)
        sortSequentially(lo, hi);
      else {
        int mid = (lo + hi) >>> 1;
        invokeAll(new SortTask(array, lo, mid),
                  new SortTask(array, mid, hi));
        merge(lo, mid, hi);
      }    }
    // implementation details follow:
    static final int THRESHOLD = 1000;
    void sortSequentially(int lo, int hi) {
      Arrays.sort(array, lo, hi);
    }
    void merge(int lo, int mid, int hi) {
      long[] buf = Arrays.copyOfRange(array, lo, mid);
      for (int i = 0, j = lo, k = mid; i < buf.length; j++)
        array[j] = (k == hi || buf[i] < array[k]) ?
          buf[i++] : array[k++];
    }  }
 
@endcode
  You could then sort <code>anArray</code> by creating <code>new
  SortTask(anArray)</code>
  and invoking it in a ForkJoinPool.  As a more
  concrete simple example, the following task increments each element
  of an array: 
 @code
  class IncrementTask extends RecursiveAction {
    final long[] array; final int lo, hi;
    IncrementTask(long[] array, int lo, int hi) {
      this.array = array; this.lo = lo; this.hi = hi;
    }
    protected void compute() {
      if (hi - lo < THRESHOLD) {
        for (int i = lo; i < hi; ++i)
          array[i]++;
      }
      else {
        int mid = (lo + hi) >>> 1;
        invokeAll(new IncrementTask(array, lo, mid),
                  new IncrementTask(array, mid, hi));
      }    }    }
 
@endcode
  
 <p>The following example illustrates some refinements and idioms
  that may lead to better performance: RecursiveActions need not be
  fully recursive, so long as they maintain the basic
  divide-and-conquer approach. Here is a class that sums the squares
  of each element of a double array, by subdividing out only the
  right-hand-sides of repeated divisions by two, and keeping track of
  them with a chain of <code>next</code> references. It uses a dynamic
  threshold based on method <code>getSurplusQueuedTaskCount</code>, but
  counterbalances potential excess partitioning by directly
  performing leaf actions on unstolen tasks rather than further
  subdividing. 
 @code
  double sumOfSquares(ForkJoinPool pool, double[] array) {
    int n = array.length;
    Applyer a = new Applyer(array, 0, n, null);
    pool.invoke(a);
    return a.result;
  }
  class Applyer extends RecursiveAction {
    final double[] array;
    final int lo, hi;
    double result;
    Applyer next; // keeps track of right-hand-side tasks
    Applyer(double[] array, int lo, int hi, Applyer next) {
      this.array = array; this.lo = lo; this.hi = hi;
      this.next = next;
    }
    double atLeaf(int l, int h) {
      double sum = 0;
      for (int i = l; i < h; ++i) // perform leftmost base step
        sum += array[i] * array[i];
      return sum;
    }
    protected void compute() {
      int l = lo;
      int h = hi;
      Applyer right = null;
      while (h - l > 1 && getSurplusQueuedTaskCount() <= 3) {
        int mid = (l + h) >>> 1;
        right = new Applyer(array, mid, h, right);
        right.fork();
        h = mid;
      }
      double sum = atLeaf(l, h);
      while (right != null) {
        if (right.tryUnfork()) // directly calculate if not stolen
          sum += right.atLeaf(right.lo, right.hi);
        else {
          right.join();
          sum += right.result;
        }
        right = right.next;
      }
      result = sum;
    }  }
 
@endcode
 @since 1.7
 @author Doug Lea
 */
@interface JavaUtilConcurrentRecursiveAction : JavaUtilConcurrentForkJoinTask

#pragma mark Public

- (instancetype __nonnull)init;

- (JavaLangVoid *)get;

/*!
 @brief Always returns <code>null</code>.
 @return <code>null</code> always
 */
- (JavaLangVoid *)getRawResult;

- (JavaLangVoid *)getWithLong:(jlong)arg0
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)arg1;

- (JavaLangVoid *)invoke;

- (JavaLangVoid *)join;

#pragma mark Protected

/*!
 @brief The main computation performed by this task.
 */
- (void)compute;

/*!
 @brief Implements execution conventions for RecursiveActions.
 */
- (jboolean)exec;

/*!
 @brief Requires null completion value.
 */
- (void)setRawResultWithId:(JavaLangVoid *)mustBeNull;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentRecursiveAction)

FOUNDATION_EXPORT void JavaUtilConcurrentRecursiveAction_init(JavaUtilConcurrentRecursiveAction *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentRecursiveAction)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentRecursiveAction")
