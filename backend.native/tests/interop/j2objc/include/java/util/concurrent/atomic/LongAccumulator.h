//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/atomic/LongAccumulator.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentAtomicLongAccumulator")
#ifdef RESTRICT_JavaUtilConcurrentAtomicLongAccumulator
#define INCLUDE_ALL_JavaUtilConcurrentAtomicLongAccumulator 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentAtomicLongAccumulator 1
#endif
#undef RESTRICT_JavaUtilConcurrentAtomicLongAccumulator

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentAtomicLongAccumulator_) && (INCLUDE_ALL_JavaUtilConcurrentAtomicLongAccumulator || defined(INCLUDE_JavaUtilConcurrentAtomicLongAccumulator))
#define JavaUtilConcurrentAtomicLongAccumulator_

#define RESTRICT_JavaUtilConcurrentAtomicStriped64 1
#define INCLUDE_JavaUtilConcurrentAtomicStriped64 1
#include "java/util/concurrent/atomic/Striped64.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilFunctionLongBinaryOperator;

/*!
 @brief One or more variables that together maintain a running <code>long</code>
  value updated using a supplied function.When updates (method 
 <code>accumulate</code>) are contended across threads, the set of variables
  may grow dynamically to reduce contention.
 Method <code>get</code>
  (or, equivalently, <code>longValue</code>) returns the current value
  across the variables maintaining updates. 
 <p>This class is usually preferable to <code>AtomicLong</code> when
  multiple threads update a common value that is used for purposes such
  as collecting statistics, not for fine-grained synchronization
  control.  Under low update contention, the two classes have similar
  characteristics. But under high contention, expected throughput of
  this class is significantly higher, at the expense of higher space
  consumption. 
 <p>The order of accumulation within or across threads is not
  guaranteed and cannot be depended upon, so this class is only
  applicable to functions for which the order of accumulation does
  not matter. The supplied accumulator function should be
  side-effect-free, since it may be re-applied when attempted updates
  fail due to contention among threads. The function is applied with
  the current value as its first argument, and the given update as
  the second argument.  For example, to maintain a running maximum
  value, you could supply <code>Long::max</code> along with <code>Long.MIN_VALUE</code>
  as the identity. 
 <p>Class <code>LongAdder</code> provides analogs of the functionality of
  this class for the common special case of maintaining counts and
  sums.  The call <code>new LongAdder()</code> is equivalent to <code>new
  LongAccumulator((x, y) -> x + y, 0L</code>
 .
  
 <p>This class extends <code>Number</code>, but does <em>not</em> define
  methods such as <code>equals</code>, <code>hashCode</code> and <code>compareTo</code>
  because instances are expected to be mutated, and so are
  not useful as collection keys.
 @since 1.8
 @author Doug Lea
 */
@interface JavaUtilConcurrentAtomicLongAccumulator : JavaUtilConcurrentAtomicStriped64 < JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a new instance using the given accumulator function
  and identity element.
 @param accumulatorFunction a side-effect-free function of two arguments
 @param identity identity (initial value) for the accumulator function
 */
- (instancetype __nonnull)initWithJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)accumulatorFunction
                                                            withLong:(jlong)identity;

/*!
 @brief Updates with the given value.
 @param x the value
 */
- (void)accumulateWithLong:(jlong)x;

/*!
 @brief Returns the current value as a <code>double</code>
  after a widening primitive conversion.
 */
- (jdouble)doubleValue;

/*!
 @brief Returns the current value as a <code>float</code>
  after a widening primitive conversion.
 */
- (jfloat)floatValue;

/*!
 @brief Returns the current value.The returned value is <em>NOT</em>
  an atomic snapshot; invocation in the absence of concurrent
  updates returns an accurate result, but concurrent updates that
  occur while the value is being calculated might not be
  incorporated.
 @return the current value
 */
- (jlong)get;

/*!
 @brief Equivalent in effect to <code>get</code> followed by <code>reset</code>
 .This method may apply for example during quiescent
  points between multithreaded computations.
 If there are
  updates concurrent with this method, the returned value is 
 <em>not</em> guaranteed to be the final value occurring before
  the reset.
 @return the value before reset
 */
- (jlong)getThenReset;

- (NSUInteger)hash;

/*!
 @brief Returns the current value as an <code>int</code>
  after a narrowing primitive conversion.
 */
- (jint)intValue;

- (jboolean)isEqual:(id)obj;

/*!
 @brief Equivalent to <code>get</code>.
 @return the current value
 */
- (jlong)longLongValue;

/*!
 @brief Resets variables maintaining updates to the identity value.
 This method may be a useful alternative to creating a new
  updater, but is only effective if there are no concurrent
  updates.  Because this method is intrinsically racy, it should
  only be used when it is known that no threads are concurrently
  updating.
 */
- (void)reset;

/*!
 @brief Returns the String representation of the current value.
 @return the String representation of the current value
 */
- (NSString *)description;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initPackagePrivate NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentAtomicLongAccumulator)

FOUNDATION_EXPORT void JavaUtilConcurrentAtomicLongAccumulator_initWithJavaUtilFunctionLongBinaryOperator_withLong_(JavaUtilConcurrentAtomicLongAccumulator *self, id<JavaUtilFunctionLongBinaryOperator> accumulatorFunction, jlong identity);

FOUNDATION_EXPORT JavaUtilConcurrentAtomicLongAccumulator *new_JavaUtilConcurrentAtomicLongAccumulator_initWithJavaUtilFunctionLongBinaryOperator_withLong_(id<JavaUtilFunctionLongBinaryOperator> accumulatorFunction, jlong identity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentAtomicLongAccumulator *create_JavaUtilConcurrentAtomicLongAccumulator_initWithJavaUtilFunctionLongBinaryOperator_withLong_(id<JavaUtilFunctionLongBinaryOperator> accumulatorFunction, jlong identity);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentAtomicLongAccumulator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentAtomicLongAccumulator")
