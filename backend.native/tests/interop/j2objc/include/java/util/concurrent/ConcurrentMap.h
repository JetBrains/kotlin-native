//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/ConcurrentMap.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentConcurrentMap")
#ifdef RESTRICT_JavaUtilConcurrentConcurrentMap
#define INCLUDE_ALL_JavaUtilConcurrentConcurrentMap 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentConcurrentMap 1
#endif
#undef RESTRICT_JavaUtilConcurrentConcurrentMap

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentConcurrentMap_) && (INCLUDE_ALL_JavaUtilConcurrentConcurrentMap || defined(INCLUDE_JavaUtilConcurrentConcurrentMap))
#define JavaUtilConcurrentConcurrentMap_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap 1
#include "java/util/Map.h"

@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;

/*!
 @brief A <code>java.util.Map</code> providing thread safety and atomicity
  guarantees.
 <p>To maintain the specified guarantees, default implementations of
  methods including <code>putIfAbsent</code> inherited from <code>Map</code>
  must be overridden by implementations of this interface. Similarly,
  implementations of the collections returned by methods <code>keySet</code>
 , <code>values</code>, and <code>entrySet</code> must override
  methods such as <code>removeIf</code> when necessary to
  preserve atomicity guarantees. 
 <p>Memory consistency effects: As with other concurrent
  collections, actions in a thread prior to placing an object into a 
 <code>ConcurrentMap</code> as a key or value 
 <a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>
  actions subsequent to the access or removal of that object from the 
 <code>ConcurrentMap</code> in another thread.
 @since 1.5
 @author Doug Lea
 */
@protocol JavaUtilConcurrentConcurrentMap < JavaUtilMap, JavaObject >

/*!
 @throw ClassCastException
 @throw NullPointerException
 @since 1.8
 */
- (id)getOrDefaultWithId:(id)key
                  withId:(id)defaultValue;

/*!
 @throw NullPointerException
 @since 1.8
 */
- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief If the specified key is not already associated
  with a value, associates it with the given value.
 This is equivalent to, for this <code>map</code>:
  @code
  if (!map.containsKey(key))
    return map.put(key, value);
  else
    return map.get(key);
 
@endcode
  except that the action is performed atomically.
 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with the specified key, or
          <code>null</code> if there was no mapping for the key.
          (A <code>null</code> return can also indicate that the map
          previously associated <code>null</code> with the key,
          if the implementation supports null values.)
 @throw UnsupportedOperationExceptionif the <code>put</code> operation
          is not supported by this map
 @throw ClassCastExceptionif the class of the specified key or value
          prevents it from being stored in this map
 @throw NullPointerExceptionif the specified key or value is null,
          and this map does not permit null keys or values
 @throw IllegalArgumentExceptionif some property of the specified key
          or value prevents it from being stored in this map
 */
- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

/*!
 @brief Removes the entry for a key only if currently mapped to a given value.
 This is equivalent to, for this <code>map</code>:
  @code
  if (map.containsKey(key)
      && Objects.equals(map.get(key), value)) {
    map.remove(key);
    return true;
  } else {
    return false;
  }
 
@endcode
  except that the action is performed atomically.
 @param key key with which the specified value is associated
 @param value value expected to be associated with the specified key
 @return <code>true</code> if the value was removed
 @throw UnsupportedOperationExceptionif the <code>remove</code> operation
          is not supported by this map
 @throw ClassCastExceptionif the key or value is of an inappropriate
          type for this map
  (<a href="../Collection.html#optional-restrictions">optional</a>)
 @throw NullPointerExceptionif the specified key or value is null,
          and this map does not permit null keys or values
  (<a href="../Collection.html#optional-restrictions">optional</a>)
 */
- (jboolean)removeWithId:(id)key
                  withId:(id)value;

/*!
 @brief Replaces the entry for a key only if currently mapped to a given value.
 This is equivalent to, for this <code>map</code>:
  @code
  if (map.containsKey(key)
      && Objects.equals(map.get(key), oldValue)) {
    map.put(key, newValue);
    return true;
  } else {
    return false;
  }
 
@endcode
  except that the action is performed atomically.
 @param key key with which the specified value is associated
 @param oldValue value expected to be associated with the specified key
 @param newValue value to be associated with the specified key
 @return <code>true</code> if the value was replaced
 @throw UnsupportedOperationExceptionif the <code>put</code> operation
          is not supported by this map
 @throw ClassCastExceptionif the class of a specified key or value
          prevents it from being stored in this map
 @throw NullPointerExceptionif a specified key or value is null,
          and this map does not permit null keys or values
 @throw IllegalArgumentExceptionif some property of a specified key
          or value prevents it from being stored in this map
 */
- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

/*!
 @brief Replaces the entry for a key only if currently mapped to some value.
 This is equivalent to, for this <code>map</code>:
  @code
  if (map.containsKey(key))
    return map.put(key, value);
  else
    return null;
 
@endcode
  except that the action is performed atomically.
 @param key key with which the specified value is associated
 @param value value to be associated with the specified key
 @return the previous value associated with the specified key, or
          <code>null</code> if there was no mapping for the key.
          (A <code>null</code> return can also indicate that the map
          previously associated <code>null</code> with the key,
          if the implementation supports null values.)
 @throw UnsupportedOperationExceptionif the <code>put</code> operation
          is not supported by this map
 @throw ClassCastExceptionif the class of the specified key or value
          prevents it from being stored in this map
 @throw NullPointerExceptionif the specified key or value is null,
          and this map does not permit null keys or values
 @throw IllegalArgumentExceptionif some property of the specified key
          or value prevents it from being stored in this map
 */
- (id)replaceWithId:(id)key
             withId:(id)value;

/*!
 @throw UnsupportedOperationException
 @throw NullPointerException
 @throw ClassCastException
 @throw IllegalArgumentException
 @since 1.8
 */
- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @since 1.8
 */
- (id)computeIfAbsentWithId:(id)key
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @since 1.8
 */
- (id)computeIfPresentWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @since 1.8
 */
- (id)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

/*!
 @throw UnsupportedOperationException
 @throw ClassCastException
 @throw NullPointerException
 @throw IllegalArgumentException
 @since 1.8
 */
- (id)mergeWithId:(id)key
           withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentMap)

FOUNDATION_EXPORT id JavaUtilConcurrentConcurrentMap_getOrDefaultWithId_withId_(id<JavaUtilConcurrentConcurrentMap> self, id key, id defaultValue);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentMap_forEachWithJavaUtilFunctionBiConsumer_(id<JavaUtilConcurrentConcurrentMap> self, id<JavaUtilFunctionBiConsumer> action);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentMap_replaceAllWithJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentConcurrentMap> self, id<JavaUtilFunctionBiFunction> function);

FOUNDATION_EXPORT id JavaUtilConcurrentConcurrentMap_computeIfAbsentWithId_withJavaUtilFunctionFunction_(id<JavaUtilConcurrentConcurrentMap> self, id key, id<JavaUtilFunctionFunction> mappingFunction);

FOUNDATION_EXPORT id JavaUtilConcurrentConcurrentMap_computeIfPresentWithId_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentConcurrentMap> self, id key, id<JavaUtilFunctionBiFunction> remappingFunction);

FOUNDATION_EXPORT id JavaUtilConcurrentConcurrentMap_computeWithId_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentConcurrentMap> self, id key, id<JavaUtilFunctionBiFunction> remappingFunction);

FOUNDATION_EXPORT id JavaUtilConcurrentConcurrentMap_mergeWithId_withId_withJavaUtilFunctionBiFunction_(id<JavaUtilConcurrentConcurrentMap> self, id key, id value, id<JavaUtilFunctionBiFunction> remappingFunction);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentMap)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentConcurrentMap")
