//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/Collections.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilCollections")
#ifdef RESTRICT_JavaUtilCollections
#define INCLUDE_ALL_JavaUtilCollections 0
#else
#define INCLUDE_ALL_JavaUtilCollections 1
#endif
#undef RESTRICT_JavaUtilCollections
#ifdef INCLUDE_JavaUtilCollections_CheckedNavigableMap
#define INCLUDE_JavaUtilCollections_CheckedSortedMap 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedSortedMap
#define INCLUDE_JavaUtilCollections_CheckedMap 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedRandomAccessList
#define INCLUDE_JavaUtilCollections_CheckedList 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedList
#define INCLUDE_JavaUtilCollections_CheckedCollection 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedNavigableSet
#define INCLUDE_JavaUtilCollections_CheckedSortedSet 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedSortedSet
#define INCLUDE_JavaUtilCollections_CheckedSet 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedSet
#define INCLUDE_JavaUtilCollections_CheckedCollection 1
#endif
#ifdef INCLUDE_JavaUtilCollections_CheckedQueue
#define INCLUDE_JavaUtilCollections_CheckedCollection 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedNavigableMap
#define INCLUDE_JavaUtilCollections_SynchronizedSortedMap 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedSortedMap
#define INCLUDE_JavaUtilCollections_SynchronizedMap 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedRandomAccessList
#define INCLUDE_JavaUtilCollections_SynchronizedList 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedList
#define INCLUDE_JavaUtilCollections_SynchronizedCollection 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedNavigableSet
#define INCLUDE_JavaUtilCollections_SynchronizedSortedSet 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedSortedSet
#define INCLUDE_JavaUtilCollections_SynchronizedSet 1
#endif
#ifdef INCLUDE_JavaUtilCollections_SynchronizedSet
#define INCLUDE_JavaUtilCollections_SynchronizedCollection 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableNavigableMap
#define INCLUDE_JavaUtilCollections_UnmodifiableSortedMap 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableSortedMap
#define INCLUDE_JavaUtilCollections_UnmodifiableMap 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableRandomAccessList
#define INCLUDE_JavaUtilCollections_UnmodifiableList 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableList
#define INCLUDE_JavaUtilCollections_UnmodifiableCollection 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableNavigableSet
#define INCLUDE_JavaUtilCollections_UnmodifiableSortedSet 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableSortedSet
#define INCLUDE_JavaUtilCollections_UnmodifiableSet 1
#endif
#ifdef INCLUDE_JavaUtilCollections_UnmodifiableSet
#define INCLUDE_JavaUtilCollections_UnmodifiableCollection 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilCollections_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections))
#define JavaUtilCollections_

@class IOSClass;
@class IOSObjectArray;
@class JavaUtilArrayList;
@class JavaUtilRandom;
@protocol JavaLangComparable;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilDeque;
@protocol JavaUtilEnumeration;
@protocol JavaUtilIterator;
@protocol JavaUtilList;
@protocol JavaUtilListIterator;
@protocol JavaUtilMap;
@protocol JavaUtilNavigableMap;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilQueue;
@protocol JavaUtilSet;
@protocol JavaUtilSortedMap;
@protocol JavaUtilSortedSet;
@protocol JavaUtilSpliterator;

/*!
 @brief This class consists exclusively of static methods that operate on or return
  collections.It contains polymorphic algorithms that operate on
  collections, "wrappers", which return a new collection backed by a
  specified collection, and a few other odds and ends.
 <p>The methods of this class all throw a <tt>NullPointerException</tt>
  if the collections or class objects provided to them are null. 
 <p>The documentation for the polymorphic algorithms contained in this class
  generally includes a brief description of the <i>implementation</i>.  Such
  descriptions should be regarded as <i>implementation notes</i>, rather than
  parts of the <i>specification</i>.  Implementors should feel free to
  substitute other algorithms, so long as the specification itself is adhered
  to.  (For example, the algorithm used by <tt>sort</tt> does not have to be
  a mergesort, but it does have to be <i>stable</i>.)
  
 <p>The "destructive" algorithms contained in this class, that is, the
  algorithms that modify the collection on which they operate, are specified
  to throw <tt>UnsupportedOperationException</tt> if the collection does not
  support the appropriate mutation primitive(s), such as the <tt>set</tt>
  method.  These algorithms may, but are not required to, throw this
  exception if an invocation would have no effect on the collection.  For
  example, invoking the <tt>sort</tt> method on an unmodifiable list that is
  already sorted may or may not throw <tt>UnsupportedOperationException</tt>.
  
 <p>This class is a member of the 
 <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/collections/index.html">
  Java Collections Framework</a>.
 @author Josh Bloch
 @author Neal Gafter
 - seealso: Collection
 - seealso: Set
 - seealso: List
 - seealso: Map
 @since 1.2
 */
@interface JavaUtilCollections : NSObject
@property (readonly, class, strong) id<JavaUtilSet> EMPTY_SET NS_SWIFT_NAME(EMPTY_SET);
@property (readonly, class, strong) id<JavaUtilList> EMPTY_LIST NS_SWIFT_NAME(EMPTY_LIST);
@property (readonly, class, strong) id<JavaUtilMap> EMPTY_MAP NS_SWIFT_NAME(EMPTY_MAP);

+ (id<JavaUtilSet>)EMPTY_SET;

+ (id<JavaUtilList>)EMPTY_LIST;

+ (id<JavaUtilMap>)EMPTY_MAP;

#pragma mark Public

/*!
 @brief Adds all of the specified elements to the specified collection.
 Elements to be added may be specified individually or as an array.
  The behavior of this convenience method is identical to that of 
 <tt>c.addAll(Arrays.asList(elements))</tt>, but this method is likely
  to run significantly faster under most implementations. 
 <p>When elements are specified individually, this method provides a
  convenient way to add a few elements to an existing collection: 
 @code

      Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 
  
@endcode
 @param c the collection into which  <tt> elements </tt>  are to be inserted
 @param elements the elements to insert into  <tt> c </tt>
 @return <tt>true</tt> if the collection changed as a result of the call
 @throw UnsupportedOperationExceptionif <tt>c</tt> does not support
          the <tt>add</tt> operation
 @throw NullPointerExceptionif <tt>elements</tt> contains one or more
          null values and <tt>c</tt> does not permit null elements, or
          if <tt>c</tt> or <tt>elements</tt> are <tt>null</tt>
 @throw IllegalArgumentExceptionif some property of a value in
          <tt>elements</tt> prevents it from being added to <tt>c</tt>
 - seealso: Collection#addAll(Collection)
 @since 1.5
 */
+ (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c
                       withNSObjectArray:(IOSObjectArray *)elements;

/*!
 @brief Returns a view of a <code>Deque</code> as a Last-in-first-out (Lifo) 
 <code>Queue</code>.Method <tt>add</tt> is mapped to <tt>push</tt>,
  <tt>remove</tt> is mapped to <tt>pop</tt> and so on.
 This
  view can be useful when you would like to use a method
  requiring a <tt>Queue</tt> but you need Lifo ordering. 
 <p>Each method invocation on the queue returned by this method
  results in exactly one method invocation on the backing deque, with
  one exception.  The <code>addAll</code> method is
  implemented as a sequence of <code>addFirst</code>
  invocations on the backing deque.
 @param deque the deque
 @return the queue
 @since 1.6
 */
+ (id<JavaUtilQueue> __nonnull)asLifoQueueWithJavaUtilDeque:(id<JavaUtilDeque>)deque;

/*!
 @brief Searches the specified list for the specified object using the binary
  search algorithm.The list must be sorted into ascending order
  according to the natural ordering of its
  elements (as by the <code>sort(List)</code> method) prior to making this
  call.
 If it is not sorted, the results are undefined.  If the list
  contains multiple elements equal to the specified object, there is no
  guarantee which one will be found. 
 <p>This method runs in log(n) time for a "random access" list (which
  provides near-constant-time positional access).  If the specified list
  does not implement the <code>RandomAccess</code> interface and is large,
  this method will do an iterator-based binary search that performs
  O(n) link traversals and O(log n) element comparisons.
 @param list the list to be searched.
 @param key the key to be searched for.
 @return the index of the search key, if it is contained in the list;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the list: the index of the first
          element greater than the key, or <tt>list.size()</tt> if all
          elements in the list are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw ClassCastExceptionif the list contains elements that are not
          <i>mutually comparable</i> (for example, strings and
          integers), or the search key is not mutually comparable
          with the elements of the list.
 */
+ (jint)binarySearchWithJavaUtilList:(id<JavaUtilList>)list
                              withId:(id)key;

/*!
 @brief Searches the specified list for the specified object using the binary
  search algorithm.The list must be sorted into ascending order
  according to the specified comparator (as by the 
 <code>sort(List, Comparator)</code>
  method), prior to making this call.
 If it is
  not sorted, the results are undefined.  If the list contains multiple
  elements equal to the specified object, there is no guarantee which one
  will be found. 
 <p>This method runs in log(n) time for a "random access" list (which
  provides near-constant-time positional access).  If the specified list
  does not implement the <code>RandomAccess</code> interface and is large,
  this method will do an iterator-based binary search that performs
  O(n) link traversals and O(log n) element comparisons.
 @param list the list to be searched.
 @param key the key to be searched for.
 @param c the comparator by which the list is ordered.          A 
  <tt> null </tt>  value indicates that the elements'          
 natural ordering  should be used.
 @return the index of the search key, if it is contained in the list;
          otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
          <i>insertion point</i> is defined as the point at which the
          key would be inserted into the list: the index of the first
          element greater than the key, or <tt>list.size()</tt> if all
          elements in the list are less than the specified key.  Note
          that this guarantees that the return value will be &gt;= 0 if
          and only if the key is found.
 @throw ClassCastExceptionif the list contains elements that are not
          <i>mutually comparable</i> using the specified comparator,
          or the search key is not mutually comparable with the
          elements of the list using this comparator.
 */
+ (jint)binarySearchWithJavaUtilList:(id<JavaUtilList>)list
                              withId:(id)key
              withJavaUtilComparator:(id<JavaUtilComparator>)c;

/*!
 @brief Returns a dynamically typesafe view of the specified collection.
 Any attempt to insert an element of the wrong type will result in an
  immediate <code>ClassCastException</code>.  Assuming a collection
  contains no incorrectly typed elements prior to the time a
  dynamically typesafe view is generated, and that all subsequent
  access to the collection takes place through the view, it is 
 <i>guaranteed</i> that the collection cannot contain an incorrectly
  typed element. 
 <p>The generics mechanism in the language provides compile-time
  (static) type checking, but it is possible to defeat this mechanism
  with unchecked casts.  Usually this is not a problem, as the compiler
  issues warnings on all such unchecked operations.  There are, however,
  times when static type checking alone is not sufficient.  For example,
  suppose a collection is passed to a third-party library and it is
  imperative that the library code not corrupt the collection by
  inserting an element of the wrong type. 
 <p>Another use of dynamically typesafe views is debugging.  Suppose a
  program fails with a <code>ClassCastException</code>, indicating that an
  incorrectly typed element was put into a parameterized collection.
  Unfortunately, the exception can occur at any time after the erroneous
  element is inserted, so it typically provides little or no information
  as to the real source of the problem.  If the problem is reproducible,
  one can quickly determine its source by temporarily modifying the
  program to wrap the collection with a dynamically typesafe view.
  For example, this declaration:
   @code
     Collection<String> c = new HashSet<>(); 
 
@endcode
  may be replaced temporarily by this one:
   @code
     Collection<String> c = Collections.checkedCollection(
          new HashSet<>(), String.class); 
 
@endcode
  Running the program again will cause it to fail at the point where
  an incorrectly typed element is inserted into the collection, clearly
  identifying the source of the problem.  Once the problem is fixed, the
  modified declaration may be reverted back to the original. 
 <p>The returned collection does <i>not</i> pass the hashCode and equals
  operations through to the backing collection, but relies on 
 <code>Object</code>'s <code>equals</code> and <code>hashCode</code> methods.  This
  is necessary to preserve the contracts of these operations in the case
  that the backing collection is a set or a list. 
 <p>The returned collection will be serializable if the specified
  collection is serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned collection permits insertion of null elements
  whenever the backing collection does.
 @param c the collection for which a dynamically typesafe view is to be           returned
 @param type the type of element that <code>c</code>  is permitted to hold
 @return a dynamically typesafe view of the specified collection
 @since 1.5
 */
+ (id<JavaUtilCollection> __nonnull)checkedCollectionWithJavaUtilCollection:(id<JavaUtilCollection>)c
                                                               withIOSClass:(IOSClass *)type;

/*!
 @brief Returns a dynamically typesafe view of the specified list.
 Any attempt to insert an element of the wrong type will result in
  an immediate <code>ClassCastException</code>.  Assuming a list contains
  no incorrectly typed elements prior to the time a dynamically typesafe
  view is generated, and that all subsequent access to the list
  takes place through the view, it is <i>guaranteed</i> that the
  list cannot contain an incorrectly typed element. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned list will be serializable if the specified list
  is serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned list permits insertion of null elements whenever
  the backing list does.
 @param list the list for which a dynamically typesafe view is to be              returned
 @param type the type of element that <code>list</code>  is permitted to hold
 @return a dynamically typesafe view of the specified list
 @since 1.5
 */
+ (id<JavaUtilList> __nonnull)checkedListWithJavaUtilList:(id<JavaUtilList>)list
                                             withIOSClass:(IOSClass *)type;

/*!
 @brief Returns a dynamically typesafe view of the specified map.
 Any attempt to insert a mapping whose key or value have the wrong
  type will result in an immediate <code>ClassCastException</code>.
  Similarly, any attempt to modify the value currently associated with
  a key will result in an immediate <code>ClassCastException</code>,
  whether the modification is attempted directly through the map
  itself, or through a <code>Map.Entry</code> instance obtained from the
  map's <code>entry set</code> view. 
 <p>Assuming a map contains no incorrectly typed keys or values
  prior to the time a dynamically typesafe view is generated, and
  that all subsequent access to the map takes place through the view
  (or one of its collection views), it is <i>guaranteed</i> that the
  map cannot contain an incorrectly typed key or value. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned map will be serializable if the specified map is
  serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned map permits insertion of null keys or values
  whenever the backing map does.
 @param m the map for which a dynamically typesafe view is to be           returned
 @param keyType the type of key that <code>m</code>  is permitted to hold
 @param valueType the type of value that <code>m</code>  is permitted to hold
 @return a dynamically typesafe view of the specified map
 @since 1.5
 */
+ (id<JavaUtilMap> __nonnull)checkedMapWithJavaUtilMap:(id<JavaUtilMap>)m
                                          withIOSClass:(IOSClass *)keyType
                                          withIOSClass:(IOSClass *)valueType;

/*!
 @brief Returns a dynamically typesafe view of the specified navigable map.
 Any attempt to insert a mapping whose key or value have the wrong
  type will result in an immediate <code>ClassCastException</code>.
  Similarly, any attempt to modify the value currently associated with
  a key will result in an immediate <code>ClassCastException</code>,
  whether the modification is attempted directly through the map
  itself, or through a <code>Map.Entry</code> instance obtained from the
  map's <code>entry set</code> view. 
 <p>Assuming a map contains no incorrectly typed keys or values
  prior to the time a dynamically typesafe view is generated, and
  that all subsequent access to the map takes place through the view
  (or one of its collection views), it is <em>guaranteed</em> that the
  map cannot contain an incorrectly typed key or value. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned map will be serializable if the specified map is
  serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned map permits insertion of null keys or values
  whenever the backing map does.
 @param m the map for which a dynamically typesafe view is to be           returned
 @param keyType the type of key that <code>m</code>  is permitted to hold
 @param valueType the type of value that <code>m</code>  is permitted to hold
 @return a dynamically typesafe view of the specified map
 @since 1.8
 */
+ (id<JavaUtilNavigableMap> __nonnull)checkedNavigableMapWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m
                                                                     withIOSClass:(IOSClass *)keyType
                                                                     withIOSClass:(IOSClass *)valueType;

/*!
 @brief Returns a dynamically typesafe view of the specified navigable set.
 Any attempt to insert an element of the wrong type will result in an
  immediate <code>ClassCastException</code>.  Assuming a navigable set
  contains no incorrectly typed elements prior to the time a
  dynamically typesafe view is generated, and that all subsequent
  access to the navigable set takes place through the view, it is 
 <em>guaranteed</em> that the navigable set cannot contain an incorrectly
  typed element. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned navigable set will be serializable if the specified
  navigable set is serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned navigable set permits insertion of null elements
  whenever the backing sorted set does.
 @param s the navigable set for which a dynamically typesafe view is to be           returned
 @param type the type of element that <code>s</code>  is permitted to hold
 @return a dynamically typesafe view of the specified navigable set
 @since 1.8
 */
+ (id<JavaUtilNavigableSet> __nonnull)checkedNavigableSetWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s
                                                                     withIOSClass:(IOSClass *)type;

/*!
 @brief Returns a dynamically typesafe view of the specified queue.
 Any attempt to insert an element of the wrong type will result in
  an immediate <code>ClassCastException</code>.  Assuming a queue contains
  no incorrectly typed elements prior to the time a dynamically typesafe
  view is generated, and that all subsequent access to the queue
  takes place through the view, it is <i>guaranteed</i> that the
  queue cannot contain an incorrectly typed element. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned queue will be serializable if the specified queue
  is serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned queue permits insertion of <code>null</code> elements
  whenever the backing queue does.
 @param queue the queue for which a dynamically typesafe view is to be              returned
 @param type the type of element that <code>queue</code>  is permitted to hold
 @return a dynamically typesafe view of the specified queue
 @since 1.8
 */
+ (id<JavaUtilQueue> __nonnull)checkedQueueWithJavaUtilQueue:(id<JavaUtilQueue>)queue
                                                withIOSClass:(IOSClass *)type;

/*!
 @brief Returns a dynamically typesafe view of the specified set.
 Any attempt to insert an element of the wrong type will result in
  an immediate <code>ClassCastException</code>.  Assuming a set contains
  no incorrectly typed elements prior to the time a dynamically typesafe
  view is generated, and that all subsequent access to the set
  takes place through the view, it is <i>guaranteed</i> that the
  set cannot contain an incorrectly typed element. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned set will be serializable if the specified set is
  serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned set permits insertion of null elements whenever
  the backing set does.
 @param s the set for which a dynamically typesafe view is to be           returned
 @param type the type of element that <code>s</code>  is permitted to hold
 @return a dynamically typesafe view of the specified set
 @since 1.5
 */
+ (id<JavaUtilSet> __nonnull)checkedSetWithJavaUtilSet:(id<JavaUtilSet>)s
                                          withIOSClass:(IOSClass *)type;

/*!
 @brief Returns a dynamically typesafe view of the specified sorted map.
 Any attempt to insert a mapping whose key or value have the wrong
  type will result in an immediate <code>ClassCastException</code>.
  Similarly, any attempt to modify the value currently associated with
  a key will result in an immediate <code>ClassCastException</code>,
  whether the modification is attempted directly through the map
  itself, or through a <code>Map.Entry</code> instance obtained from the
  map's <code>entry set</code> view. 
 <p>Assuming a map contains no incorrectly typed keys or values
  prior to the time a dynamically typesafe view is generated, and
  that all subsequent access to the map takes place through the view
  (or one of its collection views), it is <i>guaranteed</i> that the
  map cannot contain an incorrectly typed key or value. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned map will be serializable if the specified map is
  serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned map permits insertion of null keys or values
  whenever the backing map does.
 @param m the map for which a dynamically typesafe view is to be           returned
 @param keyType the type of key that <code>m</code>  is permitted to hold
 @param valueType the type of value that <code>m</code>  is permitted to hold
 @return a dynamically typesafe view of the specified map
 @since 1.5
 */
+ (id<JavaUtilSortedMap> __nonnull)checkedSortedMapWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m
                                                            withIOSClass:(IOSClass *)keyType
                                                            withIOSClass:(IOSClass *)valueType;

/*!
 @brief Returns a dynamically typesafe view of the specified sorted set.
 Any attempt to insert an element of the wrong type will result in an
  immediate <code>ClassCastException</code>.  Assuming a sorted set
  contains no incorrectly typed elements prior to the time a
  dynamically typesafe view is generated, and that all subsequent
  access to the sorted set takes place through the view, it is 
 <i>guaranteed</i> that the sorted set cannot contain an incorrectly
  typed element. 
 <p>A discussion of the use of dynamically typesafe views may be
  found in the documentation for the <code>checkedCollection</code>
  method. 
 <p>The returned sorted set will be serializable if the specified sorted
  set is serializable. 
 <p>Since <code>null</code> is considered to be a value of any reference
  type, the returned sorted set permits insertion of null elements
  whenever the backing sorted set does.
 @param s the sorted set for which a dynamically typesafe view is to be           returned
 @param type the type of element that <code>s</code>  is permitted to hold
 @return a dynamically typesafe view of the specified sorted set
 @since 1.5
 */
+ (id<JavaUtilSortedSet> __nonnull)checkedSortedSetWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s
                                                            withIOSClass:(IOSClass *)type;

/*!
 @brief Copies all of the elements from one list into another.After the
  operation, the index of each copied element in the destination list
  will be identical to its index in the source list.
 The destination
  list must be at least as long as the source list.  If it is longer, the
  remaining elements in the destination list are unaffected. <p>
  This method runs in linear time.
 @param dest The destination list.
 @param src The source list.
 @throw IndexOutOfBoundsExceptionif the destination list is too small
          to contain the entire source List.
 @throw UnsupportedOperationExceptionif the destination list's
          list-iterator does not support the <tt>set</tt> operation.
 */
+ (void)copy__WithJavaUtilList:(id<JavaUtilList>)dest
              withJavaUtilList:(id<JavaUtilList>)src OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns <code>true</code> if the two specified collections have no
  elements in common.
 <p>Care must be exercised if this method is used on collections that
  do not comply with the general contract for <code>Collection</code>.
  Implementations may elect to iterate over either collection and test
  for containment in the other collection (or to perform any equivalent
  computation).  If either collection uses a nonstandard equality test
  (as does a <code>SortedSet</code> whose ordering is not <em>compatible with
  equals</em>, or the key set of an <code>IdentityHashMap</code>), both
  collections must use the same nonstandard equality test, or the
  result of this method is undefined. 
 <p>Care must also be exercised when using collections that have
  restrictions on the elements that they may contain. Collection
  implementations are allowed to throw exceptions for any operation
  involving elements they deem ineligible. For absolute safety the
  specified collections should contain only elements which are
  eligible elements for both collections. 
 <p>Note that it is permissible to pass the same collection in both
  parameters, in which case the method will return <code>true</code> if and
  only if the collection is empty.
 @param c1 a collection
 @param c2 a collection
 @return <code>true</code> if the two specified collections have no
  elements in common.
 @throw NullPointerExceptionif either collection is <code>null</code>.
 @throw NullPointerExceptionif one collection contains a <code>null</code>
  element and <code>null</code> is not an eligible element for the other collection.
  (<a href="Collection.html#optional-restrictions">optional</a>)
 @throw ClassCastExceptionif one collection contains an element that is
  of a type which is ineligible for the other collection.
  (<a href="Collection.html#optional-restrictions">optional</a>)
 @since 1.5
 */
+ (jboolean)disjointWithJavaUtilCollection:(id<JavaUtilCollection>)c1
                    withJavaUtilCollection:(id<JavaUtilCollection>)c2;

/*!
 @brief Returns an enumeration that has no elements.More precisely, 
 <ul>
  <li><code>hasMoreElements</code> always
  returns <code>false</code>.
 </li>
  <li> <code>nextElement</code> always throws 
 <code>NoSuchElementException</code>.</li>
  </ul>
  
 <p>Implementations of this method are permitted, but not
  required, to return the same object from multiple invocations.
 @return an empty enumeration
 @since 1.7
 */
+ (id<JavaUtilEnumeration> __nonnull)emptyEnumeration;

/*!
 @brief Returns an iterator that has no elements.More precisely, 
 <ul>
  <li><code>hasNext</code> always returns <code>false</code>
 .
 </li>
  <li><code>next</code> always throws <code>NoSuchElementException</code>
 .</li>
  <li><code>remove</code> always throws <code>IllegalStateException</code>
 .</li>
  </ul>
  
 <p>Implementations of this method are permitted, but not
  required, to return the same object from multiple invocations.
 @return an empty iterator
 @since 1.7
 */
+ (id<JavaUtilIterator> __nonnull)emptyIterator;

/*!
 @brief Returns an empty list (immutable).This list is serializable.
 <p>This example illustrates the type-safe way to obtain an empty list: 
 @code

      List&lt;String&gt; s = Collections.emptyList(); 
  
@endcode
 @return an empty immutable list
 - seealso: #EMPTY_LIST
 @since 1.5
 */
+ (id<JavaUtilList> __nonnull)emptyList;

/*!
 @brief Returns a list iterator that has no elements.More precisely, 
 <ul>
  <li><code>hasNext</code> and <code>hasPrevious</code>
  always return <code>false</code>
 .
 </li>
  <li><code>next</code> and <code>previous</code>
  always throw <code>NoSuchElementException</code>.</li>
  <li><code>remove</code> and <code>set</code>
  always throw <code>IllegalStateException</code>.</li>
  <li><code>add</code> always throws <code>UnsupportedOperationException</code>
 .</li>
  <li><code>nextIndex</code> always returns 
 <code>0</code>.</li>
  <li><code>previousIndex</code> always
  returns <code>-1</code>.</li>
  </ul>
  
 <p>Implementations of this method are permitted, but not
  required, to return the same object from multiple invocations.
 @return an empty list iterator
 @since 1.7
 */
+ (id<JavaUtilListIterator> __nonnull)emptyListIterator;

/*!
 @brief Returns an empty map (immutable).This map is serializable.
 <p>This example illustrates the type-safe way to obtain an empty map: 
 @code

      Map&lt;String, Date&gt; s = Collections.emptyMap(); 
  
@endcode
 @return an empty map
 - seealso: #EMPTY_MAP
 @since 1.5
 */
+ (id<JavaUtilMap> __nonnull)emptyMap;

/*!
 @brief Returns an empty navigable map (immutable).This map is serializable.
 <p>This example illustrates the type-safe way to obtain an empty map: 
 @code
     NavigableMap<String, Date> s = Collections.emptyNavigableMap(); 
 
@endcode
 @return an empty navigable map
 @since 1.8
 */
+ (id<JavaUtilNavigableMap> __nonnull)emptyNavigableMap;

/*!
 @brief Returns an empty navigable set (immutable).This set is serializable.
 <p>This example illustrates the type-safe way to obtain an empty
  navigable set: 
 @code
     NavigableSet<String> s = Collections.emptyNavigableSet(); 
 
@endcode
 @return the empty navigable set
 @since 1.8
 */
+ (id<JavaUtilNavigableSet> __nonnull)emptyNavigableSet;

/*!
 @brief Returns an empty set (immutable).This set is serializable.
 Unlike the like-named field, this method is parameterized. 
 <p>This example illustrates the type-safe way to obtain an empty set: 
 @code

      Set&lt;String&gt; s = Collections.emptySet(); 
  
@endcode
 @return the empty set
 - seealso: #EMPTY_SET
 @since 1.5
 */
+ (id<JavaUtilSet> __nonnull)emptySet;

/*!
 @brief Returns an empty sorted map (immutable).This map is serializable.
 <p>This example illustrates the type-safe way to obtain an empty map: 
 @code
     SortedMap<String, Date> s = Collections.emptySortedMap(); 
 
@endcode
 @return an empty sorted map
 @since 1.8
 */
+ (id<JavaUtilSortedMap> __nonnull)emptySortedMap;

/*!
 @brief Returns an empty sorted set (immutable).This set is serializable.
 <p>This example illustrates the type-safe way to obtain an empty
  sorted set: 
 @code
     SortedSet<String> s = Collections.emptySortedSet(); 
 
@endcode
 @return the empty sorted set
 @since 1.8
 */
+ (id<JavaUtilSortedSet> __nonnull)emptySortedSet;

/*!
 @brief Returns an enumeration over the specified collection.This provides
  interoperability with legacy APIs that require an enumeration
  as input.
 @param c the collection for which an enumeration is to be returned.
 @return an enumeration over the specified collection.
 - seealso: Enumeration
 */
+ (id<JavaUtilEnumeration> __nonnull)enumerationWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Replaces all of the elements of the specified list with the specified
  element.
 <p>
  This method runs in linear time.
 @param list the list to be filled with the specified element.
 @param obj The element with which to fill the specified list.
 @throw UnsupportedOperationExceptionif the specified list or its
          list-iterator does not support the <tt>set</tt> operation.
 */
+ (void)fillWithJavaUtilList:(id<JavaUtilList>)list
                      withId:(id)obj;

/*!
 @brief Returns the number of elements in the specified collection equal to the
  specified object.More formally, returns the number of elements 
 <tt>e</tt> in the collection such that 
 <tt>(o == null ?
 e == null : o.equals(e))</tt>.
 @param c the collection in which to determine the frequency      of 
  <tt> o </tt>
 @param o the object whose frequency is to be determined
 @return the number of elements in <code>c</code> equal to <code>o</code>
 @throw NullPointerExceptionif <tt>c</tt> is null
 @since 1.5
 */
+ (jint)frequencyWithJavaUtilCollection:(id<JavaUtilCollection>)c
                                 withId:(id)o;

/*!
 @brief Returns the starting position of the first occurrence of the specified
  target list within the specified source list, or -1 if there is no
  such occurrence.More formally, returns the lowest index <tt>i</tt>
  such that <code>source.subList(i, i+target.size()).equals(target)</code>,
  or -1 if there is no such index.
 (Returns -1 if 
 <code>target.size() > source.size()</code>)
  
 <p>This implementation uses the "brute force" technique of scanning
  over the source list, looking for a match with the target at each
  location in turn.
 @param source the list in which to search for the first occurrence         of 
  <tt> target </tt> .
 @param target the list to search for as a subList of  <tt> source </tt>
  .
 @return the starting position of the first occurrence of the specified
          target list within the specified source list, or -1 if there
          is no such occurrence.
 @since 1.4
 */
+ (jint)indexOfSubListWithJavaUtilList:(id<JavaUtilList>)source
                      withJavaUtilList:(id<JavaUtilList>)target;

/*!
 @brief Returns the starting position of the last occurrence of the specified
  target list within the specified source list, or -1 if there is no such
  occurrence.More formally, returns the highest index <tt>i</tt>
  such that <code>source.subList(i, i+target.size()).equals(target)</code>,
  or -1 if there is no such index.
 (Returns -1 if 
 <code>target.size() > source.size()</code>)
  
 <p>This implementation uses the "brute force" technique of iterating
  over the source list, looking for a match with the target at each
  location in turn.
 @param source the list in which to search for the last occurrence         of 
  <tt> target </tt> .
 @param target the list to search for as a subList of  <tt> source </tt>
  .
 @return the starting position of the last occurrence of the specified
          target list within the specified source list, or -1 if there
          is no such occurrence.
 @since 1.4
 */
+ (jint)lastIndexOfSubListWithJavaUtilList:(id<JavaUtilList>)source
                          withJavaUtilList:(id<JavaUtilList>)target;

/*!
 @brief Returns an array list containing the elements returned by the
  specified enumeration in the order they are returned by the
  enumeration.This method provides interoperability between
  legacy APIs that return enumerations and new APIs that require
  collections.
 @param e enumeration providing elements for the returned           array list
 @return an array list containing the elements returned
          by the specified enumeration.
 @since 1.4
 - seealso: Enumeration
 - seealso: ArrayList
 */
+ (JavaUtilArrayList * __nonnull)listWithJavaUtilEnumeration:(id<JavaUtilEnumeration>)e;

/*!
 @brief Returns the maximum element of the given collection, according to the 
 <i>natural ordering</i> of its elements.All elements in the
  collection must implement the <tt>Comparable</tt> interface.
 Furthermore, all elements in the collection must be <i>mutually
  comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a 
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and 
 <tt>e2</tt> in the collection).<p>
  This method iterates over the entire collection, hence it requires
  time proportional to the size of the collection.
 @param coll the collection whose maximum element is to be determined.
 @return the maximum element of the given collection, according
          to the <i>natural ordering</i> of its elements.
 @throw ClassCastExceptionif the collection contains elements that are
          not <i>mutually comparable</i> (for example, strings and
          integers).
 @throw NoSuchElementExceptionif the collection is empty.
 - seealso: Comparable
 */
+ (id<JavaLangComparable> __nonnull)maxWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

/*!
 @brief Returns the maximum element of the given collection, according to the
  order induced by the specified comparator.All elements in the
  collection must be <i>mutually comparable</i> by the specified
  comparator (that is, <tt>comp.compare(e1, e2)</tt> must not throw a 
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and 
 <tt>e2</tt> in the collection).
 <p>
  This method iterates over the entire collection, hence it requires
  time proportional to the size of the collection.
 @param coll the collection whose maximum element is to be determined.
 @param comp the comparator with which to determine the maximum element.          A 
  <tt> null </tt>  value indicates that the elements'  <i> natural         ordering
  </i>  should be used.
 @return the maximum element of the given collection, according
          to the specified comparator.
 @throw ClassCastExceptionif the collection contains elements that are
          not <i>mutually comparable</i> using the specified comparator.
 @throw NoSuchElementExceptionif the collection is empty.
 - seealso: Comparable
 */
+ (id)maxWithJavaUtilCollection:(id<JavaUtilCollection>)coll
         withJavaUtilComparator:(id<JavaUtilComparator>)comp;

/*!
 @brief Returns the minimum element of the given collection, according to the 
 <i>natural ordering</i> of its elements.All elements in the
  collection must implement the <tt>Comparable</tt> interface.
 Furthermore, all elements in the collection must be <i>mutually
  comparable</i> (that is, <tt>e1.compareTo(e2)</tt> must not throw a 
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and 
 <tt>e2</tt> in the collection).<p>
  This method iterates over the entire collection, hence it requires
  time proportional to the size of the collection.
 @param coll the collection whose minimum element is to be determined.
 @return the minimum element of the given collection, according
          to the <i>natural ordering</i> of its elements.
 @throw ClassCastExceptionif the collection contains elements that are
          not <i>mutually comparable</i> (for example, strings and
          integers).
 @throw NoSuchElementExceptionif the collection is empty.
 - seealso: Comparable
 */
+ (id<JavaLangComparable> __nonnull)minWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

/*!
 @brief Returns the minimum element of the given collection, according to the
  order induced by the specified comparator.All elements in the
  collection must be <i>mutually comparable</i> by the specified
  comparator (that is, <tt>comp.compare(e1, e2)</tt> must not throw a 
 <tt>ClassCastException</tt> for any elements <tt>e1</tt> and 
 <tt>e2</tt> in the collection).
 <p>
  This method iterates over the entire collection, hence it requires
  time proportional to the size of the collection.
 @param coll the collection whose minimum element is to be determined.
 @param comp the comparator with which to determine the minimum element.          A 
  <tt> null </tt>  value indicates that the elements'  <i> natural          ordering
  </i>  should be used.
 @return the minimum element of the given collection, according
          to the specified comparator.
 @throw ClassCastExceptionif the collection contains elements that are
          not <i>mutually comparable</i> using the specified comparator.
 @throw NoSuchElementExceptionif the collection is empty.
 - seealso: Comparable
 */
+ (id)minWithJavaUtilCollection:(id<JavaUtilCollection>)coll
         withJavaUtilComparator:(id<JavaUtilComparator>)comp;

/*!
 @brief Returns an immutable list consisting of <tt>n</tt> copies of the
  specified object.The newly allocated data object is tiny (it contains
  a single reference to the data object).
 This method is useful in
  combination with the <tt>List.addAll</tt> method to grow lists.
  The returned list is serializable.
 @param n the number of elements in the returned list.
 @param o the element to appear repeatedly in the returned list.
 @return an immutable list consisting of <tt>n</tt> copies of the
          specified object.
 @throw IllegalArgumentExceptionif <code>n < 0</code>
 - seealso: List#addAll(Collection)
 - seealso: List#addAll(int, Collection)
 */
+ (id<JavaUtilList> __nonnull)nCopiesWithInt:(jint)n
                                      withId:(id)o;

/*!
 @brief Returns a set backed by the specified map.The resulting set displays
  the same ordering, concurrency, and performance characteristics as the
  backing map.
 In essence, this factory method provides a <code>Set</code>
  implementation corresponding to any <code>Map</code> implementation.  There
  is no need to use this method on a <code>Map</code> implementation that
  already has a corresponding <code>Set</code> implementation (such as <code>HashMap</code>
  or <code>TreeMap</code>).
  
 <p>Each method invocation on the set returned by this method results in
  exactly one method invocation on the backing map or its <tt>keySet</tt>
  view, with one exception.  The <tt>addAll</tt> method is implemented
  as a sequence of <tt>put</tt> invocations on the backing map. 
 <p>The specified map must be empty at the time this method is invoked,
  and should not be accessed directly after this method returns.  These
  conditions are ensured if the map is created empty, passed directly
  to this method, and no reference to the map is retained, as illustrated
  in the following code fragment: 
 @code

     Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(
         new WeakHashMap&lt;Object, Boolean&gt;());
   
@endcode
 @param map the backing map
 @return the set backed by the map
 @throw IllegalArgumentExceptionif <tt>map</tt> is not empty
 @since 1.6
 */
+ (id<JavaUtilSet> __nonnull)newSetFromMapWithJavaUtilMap:(id<JavaUtilMap>)map OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Replaces all occurrences of one specified value in a list with another.
 More formally, replaces with <tt>newVal</tt> each element <tt>e</tt>
  in <tt>list</tt> such that 
 <tt>(oldVal==null ? e==null : oldVal.equals(e))</tt>.
  (This method has no effect on the size of the list.)
 @param list the list in which replacement is to occur.
 @param oldVal the old value to be replaced.
 @param newVal the new value with which  <tt> oldVal </tt>  is to be
          replaced.
 @return <tt>true</tt> if <tt>list</tt> contained one or more elements
          <tt>e</tt> such that
          <tt>(oldVal==null ?  e==null : oldVal.equals(e))</tt>.
 @throw UnsupportedOperationExceptionif the specified list or
          its list-iterator does not support the <tt>set</tt> operation.
 @since 1.4
 */
+ (jboolean)replaceAllWithJavaUtilList:(id<JavaUtilList>)list
                                withId:(id)oldVal
                                withId:(id)newVal;

/*!
 @brief Reverses the order of the elements in the specified list.
 <p>
  This method runs in linear time.
 @param list the list whose elements are to be reversed.
 @throw UnsupportedOperationExceptionif the specified list or
          its list-iterator does not support the <tt>set</tt> operation.
 */
+ (void)reverseWithJavaUtilList:(id<JavaUtilList>)list;

/*!
 @brief Returns a comparator that imposes the reverse of the <em>natural
  ordering</em> on a collection of objects that implement the 
 <code>Comparable</code> interface.
 (The natural ordering is the ordering
  imposed by the objects' own <code>compareTo</code> method.)  This enables a
  simple idiom for sorting (or maintaining) collections (or arrays) of
  objects that implement the <code>Comparable</code> interface in
  reverse-natural-order.  For example, suppose <code>a</code> is an array of
  strings. Then: @code

           Arrays.sort(a, Collections.reverseOrder()); 
  
@endcode sorts the array in reverse-lexicographic (alphabetical) order.<p>
  The returned comparator is serializable.
 @return A comparator that imposes the reverse of the <i>natural
          ordering</i> on a collection of objects that implement
          the <tt>Comparable</tt> interface.
 - seealso: Comparable
 */
+ (id<JavaUtilComparator> __nonnull)reverseOrder;

/*!
 @brief Returns a comparator that imposes the reverse ordering of the specified
  comparator.If the specified comparator is <code>null</code>, this method is
  equivalent to <code>reverseOrder()</code> (in other words, it returns a
  comparator that imposes the reverse of the <em>natural ordering</em> on
  a collection of objects that implement the Comparable interface).
 <p>The returned comparator is serializable (assuming the specified
  comparator is also serializable or <code>null</code>).
 @param cmp a comparator who's ordering is to be reversed by the returned  comparator or 
 <code>null</code>
 @return A comparator that imposes the reverse ordering of the
          specified comparator.
 @since 1.5
 */
+ (id<JavaUtilComparator> __nonnull)reverseOrderWithJavaUtilComparator:(id<JavaUtilComparator>)cmp;

/*!
 @brief Rotates the elements in the specified list by the specified distance.
 After calling this method, the element at index <tt>i</tt> will be
  the element previously at index <tt>(i - distance)</tt> mod 
 <tt>list.size()</tt>, for all values of <tt>i</tt> between <tt>0</tt>
  and <tt>list.size()-1</tt>, inclusive.  (This method has no effect on
  the size of the list.) 
 <p>For example, suppose <tt>list</tt> comprises<tt> [t, a, n, k, s]</tt>.
  After invoking <tt>Collections.rotate(list, 1)</tt> (or 
 <tt>Collections.rotate(list, -4)</tt>), <tt>list</tt> will comprise 
 <tt>[s, t, a, n, k]</tt>.
  
 <p>Note that this method can usefully be applied to sublists to
  move one or more elements within a list while preserving the
  order of the remaining elements.  For example, the following idiom
  moves the element at index <tt>j</tt> forward to position 
 <tt>k</tt> (which must be greater than or equal to <tt>j</tt>):
  @code

      Collections.rotate(list.subList(j, k+1), -1); 
  
@endcode
  To make this concrete, suppose <tt>list</tt> comprises 
 <tt>[a, b, c, d, e]</tt>.  To move the element at index <tt>1</tt>
  (<tt>b</tt>) forward two positions, perform the following invocation: 
 @code

      Collections.rotate(l.subList(1, 4), -1); 
  
@endcode
  The resulting list is <tt>[a, c, d, b, e]</tt>.
  
 <p>To move more than one element forward, increase the absolute value
  of the rotation distance.  To move elements backward, use a positive
  shift distance. 
 <p>If the specified list is small or implements the <code>RandomAccess</code>
  interface, this implementation exchanges the first
  element into the location it should go, and then repeatedly exchanges
  the displaced element into the location it should go until a displaced
  element is swapped into the first element.  If necessary, the process
  is repeated on the second and successive elements, until the rotation
  is complete.  If the specified list is large and doesn't implement the 
 <tt>RandomAccess</tt> interface, this implementation breaks the
  list into two sublist views around index <tt>-distance mod size</tt>.
  Then the <code>reverse(List)</code> method is invoked on each sublist view,
  and finally it is invoked on the entire list.  For a more complete
  description of both algorithms, see Section 2.3 of Jon Bentley's 
 <i>Programming Pearls</i> (Addison-Wesley, 1986).
 @param list the list to be rotated.
 @param distance the distance to rotate the list.  There are no         constraints on this value; it may be zero, negative, or
          greater than 
  <tt> list.size() </tt> .
 @throw UnsupportedOperationExceptionif the specified list or
          its list-iterator does not support the <tt>set</tt> operation.
 @since 1.4
 */
+ (void)rotateWithJavaUtilList:(id<JavaUtilList>)list
                       withInt:(jint)distance;

/*!
 @brief Randomly permutes the specified list using a default source of
  randomness.All permutations occur with approximately equal
  likelihood.
 <p>The hedge "approximately" is used in the foregoing description because
  default source of randomness is only approximately an unbiased source
  of independently chosen bits. If it were a perfect source of randomly
  chosen bits, then the algorithm would choose permutations with perfect
  uniformity. 
 <p>This implementation traverses the list backwards, from the last
  element up to the second, repeatedly swapping a randomly selected element
  into the "current position".  Elements are randomly selected from the
  portion of the list that runs from the first element to the current
  position, inclusive. 
 <p>This method runs in linear time.  If the specified list does not
  implement the <code>RandomAccess</code> interface and is large, this
  implementation dumps the specified list into an array before shuffling
  it, and dumps the shuffled array back into the list.  This avoids the
  quadratic behavior that would result from shuffling a "sequential
  access" list in place.
 @param list the list to be shuffled.
 @throw UnsupportedOperationExceptionif the specified list or
          its list-iterator does not support the <tt>set</tt> operation.
 */
+ (void)shuffleWithJavaUtilList:(id<JavaUtilList>)list;

/*!
 @brief Randomly permute the specified list using the specified source of
  randomness.All permutations occur with equal likelihood
  assuming that the source of randomness is fair.
 <p>
  This implementation traverses the list backwards, from the last element
  up to the second, repeatedly swapping a randomly selected element into
  the "current position".  Elements are randomly selected from the
  portion of the list that runs from the first element to the current
  position, inclusive.<p>
  This method runs in linear time.  If the specified list does not
  implement the <code>RandomAccess</code> interface and is large, this
  implementation dumps the specified list into an array before shuffling
  it, and dumps the shuffled array back into the list.  This avoids the
  quadratic behavior that would result from shuffling a "sequential
  access" list in place.
 @param list the list to be shuffled.
 @param rnd the source of randomness to use to shuffle the list.
 @throw UnsupportedOperationExceptionif the specified list or its
          list-iterator does not support the <tt>set</tt> operation.
 */
+ (void)shuffleWithJavaUtilList:(id<JavaUtilList>)list
             withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Returns an immutable set containing only the specified object.
 The returned set is serializable.
 @param o the sole object to be stored in the returned set.
 @return an immutable set containing only the specified object.
 */
+ (id<JavaUtilSet> __nonnull)singletonWithId:(id)o;

/*!
 @brief Returns an immutable list containing only the specified object.
 The returned list is serializable.
 @param o the sole object to be stored in the returned list.
 @return an immutable list containing only the specified object.
 @since 1.3
 */
+ (id<JavaUtilList> __nonnull)singletonListWithId:(id)o;

/*!
 @brief Returns an immutable map, mapping only the specified key to the
  specified value.The returned map is serializable.
 @param key the sole key to be stored in the returned map.
 @param value the value to which the returned map maps  <tt> key </tt>
  .
 @return an immutable map containing only the specified key-value
          mapping.
 @since 1.3
 */
+ (id<JavaUtilMap> __nonnull)singletonMapWithId:(id)key
                                         withId:(id)value;

/*!
 @brief Sorts the specified list into ascending order, according to the 
 natural ordering of its elements.
 All elements in the list must implement the <code>Comparable</code>
  interface.  Furthermore, all elements in the list must be 
 <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code>
  must not throw a <code>ClassCastException</code> for any elements 
 <code>e1</code> and <code>e2</code> in the list). 
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort. 
 <p>The specified list must be modifiable, but need not be resizable.
 @param list the list to be sorted.
 @throw ClassCastExceptionif the list contains elements that are not
          <i>mutually comparable</i> (for example, strings and integers).
 @throw UnsupportedOperationExceptionif the specified list's
          list-iterator does not support the <code>set</code> operation.
 @throw IllegalArgumentException(optional) if the implementation
          detects that the natural ordering of the list elements is
          found to violate the <code>Comparable</code> contract
 - seealso: List#sort(Comparator)
 */
+ (void)sortWithJavaUtilList:(id<JavaUtilList>)list;

/*!
 @brief Sorts the specified list according to the order induced by the
  specified comparator.All elements in the list must be <i>mutually
  comparable</i> using the specified comparator (that is, 
 <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code>
  for any elements <code>e1</code> and <code>e2</code> in the list).
 <p>This sort is guaranteed to be <i>stable</i>:  equal elements will
  not be reordered as a result of the sort. 
 <p>The specified list must be modifiable, but need not be resizable.
 @param list the list to be sorted.
 @param c the comparator to determine the order of the list.  A         
 <code>null</code>  value indicates that the elements'  <i> natural         ordering
  </i>  should be used.
 @throw ClassCastExceptionif the list contains elements that are not
          <i>mutually comparable</i> using the specified comparator.
 @throw UnsupportedOperationExceptionif the specified list's
          list-iterator does not support the <code>set</code> operation.
 @throw IllegalArgumentException(optional) if the comparator is
          found to violate the <code>Comparator</code> contract
 - seealso: List#sort(Comparator)
 */
+ (void)sortWithJavaUtilList:(id<JavaUtilList>)list
      withJavaUtilComparator:(id<JavaUtilComparator>)c;

/*!
 @brief Swaps the elements at the specified positions in the specified list.
 (If the specified positions are equal, invoking this method leaves
  the list unchanged.)
 @param list The list in which to swap elements.
 @param i the index of one element to be swapped.
 @param j the index of the other element to be swapped.
 @throw IndexOutOfBoundsExceptionif either <tt>i</tt> or <tt>j</tt>
          is out of range (i &lt; 0 || i &gt;= list.size()
          || j &lt; 0 || j &gt;= list.size()).
 @since 1.4
 */
+ (void)swapWithJavaUtilList:(id<JavaUtilList>)list
                     withInt:(jint)i
                     withInt:(jint)j;

/*!
 @brief Returns a synchronized (thread-safe) collection backed by the specified
  collection.In order to guarantee serial access, it is critical that 
 <strong>all</strong> access to the backing collection is accomplished
  through the returned collection.
 <p>
  It is imperative that the user manually synchronize on the returned
  collection when traversing it via <code>Iterator</code>, <code>Spliterator</code>
  or <code>Stream</code>:
  @code

   Collection c = Collections.synchronizedCollection(myCollection);
      ...
   synchronized (c) {
       Iterator i = c.iterator(); // Must be in the synchronized block
       while (i.hasNext())
          foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned collection does <i>not</i> pass the <code>hashCode</code>
  and <code>equals</code> operations through to the backing collection, but
  relies on <code>Object</code>'s equals and hashCode methods.  This is
  necessary to preserve the contracts of these operations in the case
  that the backing collection is a set or a list.<p>
  The returned collection will be serializable if the specified collection
  is serializable.
 @param c the collection to be "wrapped" in a synchronized collection.
 @return a synchronized view of the specified collection.
 */
+ (id<JavaUtilCollection> __nonnull)synchronizedCollectionWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Returns a synchronized (thread-safe) list backed by the specified
  list.In order to guarantee serial access, it is critical that 
 <strong>all</strong> access to the backing list is accomplished
  through the returned list.
 <p>
  It is imperative that the user manually synchronize on the returned
  list when iterating over it: 
 @code

   List list = Collections.synchronizedList(new ArrayList());
       ...
   synchronized (list) {
       Iterator i = list.iterator(); // Must be in synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned list will be serializable if the specified list is
  serializable.
 @param list the list to be "wrapped" in a synchronized list.
 @return a synchronized view of the specified list.
 */
+ (id<JavaUtilList> __nonnull)synchronizedListWithJavaUtilList:(id<JavaUtilList>)list;

/*!
 @brief Returns a synchronized (thread-safe) map backed by the specified
  map.In order to guarantee serial access, it is critical that 
 <strong>all</strong> access to the backing map is accomplished
  through the returned map.
 <p>
  It is imperative that the user manually synchronize on the returned
  map when iterating over any of its collection views: 
 @code

   Map m = Collections.synchronizedMap(new HashMap());
       ...
   Set s = m.keySet();  // Needn't be in synchronized block
       ...
   synchronized (m) {  // Synchronizing on m, not s!
       Iterator i = s.iterator(); // Must be in synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned map will be serializable if the specified map is
  serializable.
 @param m the map to be "wrapped" in a synchronized map.
 @return a synchronized view of the specified map.
 */
+ (id<JavaUtilMap> __nonnull)synchronizedMapWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Returns a synchronized (thread-safe) navigable map backed by the
  specified navigable map.In order to guarantee serial access, it is
  critical that <strong>all</strong> access to the backing navigable map is
  accomplished through the returned navigable map (or its views).
 <p>
  It is imperative that the user manually synchronize on the returned
  navigable map when iterating over any of its collection views, or the
  collections views of any of its <code>subMap</code>, <code>headMap</code> or 
 <code>tailMap</code> views. 
 @code

   NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
       ...
   Set s = m.keySet();  // Needn't be in synchronized block
       ...
   synchronized (m) {  // Synchronizing on m, not s!
       Iterator i = s.iterator(); // Must be in synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  or: 
 @code

   NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap());
   NavigableMap m2 = m.subMap(foo, true, bar, false);
       ...
   Set s2 = m2.keySet();  // Needn't be in synchronized block
       ...
   synchronized (m) {  // Synchronizing on m, not m2 or s2!
       Iterator i = s.iterator(); // Must be in synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned navigable map will be serializable if the specified
  navigable map is serializable.
 @param m the navigable map to be "wrapped" in a synchronized navigable               map
 @return a synchronized view of the specified navigable map.
 @since 1.8
 */
+ (id<JavaUtilNavigableMap> __nonnull)synchronizedNavigableMapWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m;

/*!
 @brief Returns a synchronized (thread-safe) navigable set backed by the
  specified navigable set.In order to guarantee serial access, it is
  critical that <strong>all</strong> access to the backing navigable set is
  accomplished through the returned navigable set (or its views).
 <p>
  It is imperative that the user manually synchronize on the returned
  navigable set when iterating over it or any of its <code>subSet</code>,
  <code>headSet</code>, or <code>tailSet</code> views. 
 @code

   NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
       ...
   synchronized (s) {
       Iterator i = s.iterator(); // Must be in the synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  or: 
 @code

   NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet());
   NavigableSet s2 = s.headSet(foo, true);
       ...
   synchronized (s) {  // Note: s, not s2!!!
       Iterator i = s2.iterator(); // Must be in the synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned navigable set will be serializable if the specified
  navigable set is serializable.
 @param s the navigable set to be "wrapped" in a synchronized navigable  set
 @return a synchronized view of the specified navigable set
 @since 1.8
 */
+ (id<JavaUtilNavigableSet> __nonnull)synchronizedNavigableSetWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s;

/*!
 @brief Returns a synchronized (thread-safe) set backed by the specified
  set.In order to guarantee serial access, it is critical that 
 <strong>all</strong> access to the backing set is accomplished
  through the returned set.
 <p>
  It is imperative that the user manually synchronize on the returned
  set when iterating over it: 
 @code

   Set s = Collections.synchronizedSet(new HashSet());
       ...
   synchronized (s) {
       Iterator i = s.iterator(); // Must be in the synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned set will be serializable if the specified set is
  serializable.
 @param s the set to be "wrapped" in a synchronized set.
 @return a synchronized view of the specified set.
 */
+ (id<JavaUtilSet> __nonnull)synchronizedSetWithJavaUtilSet:(id<JavaUtilSet>)s;

/*!
 @brief Returns a synchronized (thread-safe) sorted map backed by the specified
  sorted map.In order to guarantee serial access, it is critical that 
 <strong>all</strong> access to the backing sorted map is accomplished
  through the returned sorted map (or its views).
 <p>
  It is imperative that the user manually synchronize on the returned
  sorted map when iterating over any of its collection views, or the
  collections views of any of its <tt>subMap</tt>, <tt>headMap</tt> or 
 <tt>tailMap</tt> views. 
 @code

   SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
       ...
   Set s = m.keySet();  // Needn't be in synchronized block
       ...
   synchronized (m) {  // Synchronizing on m, not s!
       Iterator i = s.iterator(); // Must be in synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  or: 
 @code

   SortedMap m = Collections.synchronizedSortedMap(new TreeMap());
   SortedMap m2 = m.subMap(foo, bar);
       ...
   Set s2 = m2.keySet();  // Needn't be in synchronized block
       ...
   synchronized (m) {  // Synchronizing on m, not m2 or s2!
       Iterator i = s.iterator(); // Must be in synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned sorted map will be serializable if the specified
  sorted map is serializable.
 @param m the sorted map to be "wrapped" in a synchronized sorted map.
 @return a synchronized view of the specified sorted map.
 */
+ (id<JavaUtilSortedMap> __nonnull)synchronizedSortedMapWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m;

/*!
 @brief Returns a synchronized (thread-safe) sorted set backed by the specified
  sorted set.In order to guarantee serial access, it is critical that 
 <strong>all</strong> access to the backing sorted set is accomplished
  through the returned sorted set (or its views).
 <p>
  It is imperative that the user manually synchronize on the returned
  sorted set when iterating over it or any of its <tt>subSet</tt>,
  <tt>headSet</tt>, or <tt>tailSet</tt> views. 
 @code

   SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
       ...
   synchronized (s) {
       Iterator i = s.iterator(); // Must be in the synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  or: 
 @code

   SortedSet s = Collections.synchronizedSortedSet(new TreeSet());
   SortedSet s2 = s.headSet(foo);
       ...
   synchronized (s) {  // Note: s, not s2!!!
       Iterator i = s2.iterator(); // Must be in the synchronized block
       while (i.hasNext())
           foo(i.next());
   } 
  
@endcode
  Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned sorted set will be serializable if the specified
  sorted set is serializable.
 @param s the sorted set to be "wrapped" in a synchronized sorted set.
 @return a synchronized view of the specified sorted set.
 */
+ (id<JavaUtilSortedSet> __nonnull)synchronizedSortedSetWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s;

/*!
 @brief Returns an unmodifiable view of the specified collection.This method
  allows modules to provide users with "read-only" access to internal
  collections.
 Query operations on the returned collection "read through"
  to the specified collection, and attempts to modify the returned
  collection, whether direct or via its iterator, result in an 
 <tt>UnsupportedOperationException</tt>.<p>
  The returned collection does <i>not</i> pass the hashCode and equals
  operations through to the backing collection, but relies on 
 <tt>Object</tt>'s <tt>equals</tt> and <tt>hashCode</tt> methods.  This
  is necessary to preserve the contracts of these operations in the case
  that the backing collection is a set or a list.<p>
  The returned collection will be serializable if the specified collection
  is serializable.
 @param c the collection for which an unmodifiable view is to be          returned.
 @return an unmodifiable view of the specified collection.
 */
+ (id<JavaUtilCollection> __nonnull)unmodifiableCollectionWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Returns an unmodifiable view of the specified list.This method allows
  modules to provide users with "read-only" access to internal
  lists.
 Query operations on the returned list "read through" to the
  specified list, and attempts to modify the returned list, whether
  direct or via its iterator, result in an 
 <tt>UnsupportedOperationException</tt>.<p>
  The returned list will be serializable if the specified list
  is serializable. Similarly, the returned list will implement 
 <code>RandomAccess</code> if the specified list does.
 @param list the list for which an unmodifiable view is to be returned.
 @return an unmodifiable view of the specified list.
 */
+ (id<JavaUtilList> __nonnull)unmodifiableListWithJavaUtilList:(id<JavaUtilList>)list;

/*!
 @brief Returns an unmodifiable view of the specified map.This method
  allows modules to provide users with "read-only" access to internal
  maps.
 Query operations on the returned map "read through"
  to the specified map, and attempts to modify the returned
  map, whether direct or via its collection views, result in an 
 <tt>UnsupportedOperationException</tt>.<p>
  The returned map will be serializable if the specified map
  is serializable.
 @param m the map for which an unmodifiable view is to be returned.
 @return an unmodifiable view of the specified map.
 */
+ (id<JavaUtilMap> __nonnull)unmodifiableMapWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Returns an unmodifiable view of the specified navigable map.This method
  allows modules to provide users with "read-only" access to internal
  navigable maps.
 Query operations on the returned navigable map "read
  through" to the specified navigable map.  Attempts to modify the returned
  navigable map, whether direct, via its collection views, or via its 
 <code>subMap</code>, <code>headMap</code>, or <code>tailMap</code> views, result in
  an <code>UnsupportedOperationException</code>.<p>
  The returned navigable map will be serializable if the specified
  navigable map is serializable.
 @param m the navigable map for which an unmodifiable view is to be         returned
 @return an unmodifiable view of the specified navigable map
 @since 1.8
 */
+ (id<JavaUtilNavigableMap> __nonnull)unmodifiableNavigableMapWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m;

/*!
 @brief Returns an unmodifiable view of the specified navigable set.This method
  allows modules to provide users with "read-only" access to internal
  navigable sets.
 Query operations on the returned navigable set "read
  through" to the specified navigable set.  Attempts to modify the returned
  navigable set, whether direct, via its iterator, or via its 
 <code>subSet</code>, <code>headSet</code>, or <code>tailSet</code> views, result in
  an <code>UnsupportedOperationException</code>.<p>
  The returned navigable set will be serializable if the specified
  navigable set is serializable.
 @param s the navigable set for which an unmodifiable view is to be         returned
 @return an unmodifiable view of the specified navigable set
 @since 1.8
 */
+ (id<JavaUtilNavigableSet> __nonnull)unmodifiableNavigableSetWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s;

/*!
 @brief Returns an unmodifiable view of the specified set.This method allows
  modules to provide users with "read-only" access to internal sets.
 Query operations on the returned set "read through" to the specified
  set, and attempts to modify the returned set, whether direct or via its
  iterator, result in an <tt>UnsupportedOperationException</tt>.<p>
  The returned set will be serializable if the specified set
  is serializable.
 @param s the set for which an unmodifiable view is to be returned.
 @return an unmodifiable view of the specified set.
 */
+ (id<JavaUtilSet> __nonnull)unmodifiableSetWithJavaUtilSet:(id<JavaUtilSet>)s;

/*!
 @brief Returns an unmodifiable view of the specified sorted map.This method
  allows modules to provide users with "read-only" access to internal
  sorted maps.
 Query operations on the returned sorted map "read through"
  to the specified sorted map.  Attempts to modify the returned
  sorted map, whether direct, via its collection views, or via its 
 <tt>subMap</tt>, <tt>headMap</tt>, or <tt>tailMap</tt> views, result in
  an <tt>UnsupportedOperationException</tt>.<p>
  The returned sorted map will be serializable if the specified sorted map
  is serializable.
 @param m the sorted map for which an unmodifiable view is to be         returned.
 @return an unmodifiable view of the specified sorted map.
 */
+ (id<JavaUtilSortedMap> __nonnull)unmodifiableSortedMapWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m;

/*!
 @brief Returns an unmodifiable view of the specified sorted set.This method
  allows modules to provide users with "read-only" access to internal
  sorted sets.
 Query operations on the returned sorted set "read
  through" to the specified sorted set.  Attempts to modify the returned
  sorted set, whether direct, via its iterator, or via its 
 <tt>subSet</tt>, <tt>headSet</tt>, or <tt>tailSet</tt> views, result in
  an <tt>UnsupportedOperationException</tt>.<p>
  The returned sorted set will be serializable if the specified sorted set
  is serializable.
 @param s the sorted set for which an unmodifiable view is to be         returned.
 @return an unmodifiable view of the specified sorted set.
 */
+ (id<JavaUtilSortedSet> __nonnull)unmodifiableSortedSetWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s;

#pragma mark Package-Private

/*!
 @brief Returns true if the specified arguments are equal, or both null.
 NB: Do not replace with Object.equals until JDK-8015417 is resolved.
 */
+ (jboolean)eqWithId:(id)o1
              withId:(id)o2;

+ (id<JavaUtilIterator>)singletonIteratorWithId:(id)e;

/*!
 @brief Creates a <code>Spliterator</code> with only the specified element
 @return A singleton <code>Spliterator</code>
 */
+ (id<JavaUtilSpliterator>)singletonSpliteratorWithId:(id)element;

+ (id<JavaUtilCollection>)synchronizedCollectionWithJavaUtilCollection:(id<JavaUtilCollection>)c
                                                                withId:(id)mutex;

+ (id<JavaUtilList>)synchronizedListWithJavaUtilList:(id<JavaUtilList>)list
                                              withId:(id)mutex;

+ (id<JavaUtilSet>)synchronizedSetWithJavaUtilSet:(id<JavaUtilSet>)s
                                           withId:(id)mutex;

+ (IOSObjectArray *)zeroLengthArrayWithIOSClass:(IOSClass *)type;

@end

J2OBJC_STATIC_INIT(JavaUtilCollections)

/*!
 @brief The empty set (immutable).This set is serializable.
 - seealso: #emptySet()
 */
inline id<JavaUtilSet> JavaUtilCollections_get_EMPTY_SET(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_EMPTY_SET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilCollections, EMPTY_SET, id<JavaUtilSet>)

/*!
 @brief The empty list (immutable).This list is serializable.
 - seealso: #emptyList()
 */
inline id<JavaUtilList> JavaUtilCollections_get_EMPTY_LIST(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_EMPTY_LIST;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilCollections, EMPTY_LIST, id<JavaUtilList>)

/*!
 @brief The empty map (immutable).This map is serializable.
 - seealso: #emptyMap()
 @since 1.3
 */
inline id<JavaUtilMap> JavaUtilCollections_get_EMPTY_MAP(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilMap> JavaUtilCollections_EMPTY_MAP;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilCollections, EMPTY_MAP, id<JavaUtilMap>)

FOUNDATION_EXPORT void JavaUtilCollections_sortWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT void JavaUtilCollections_sortWithJavaUtilList_withJavaUtilComparator_(id<JavaUtilList> list, id<JavaUtilComparator> c);

FOUNDATION_EXPORT jint JavaUtilCollections_binarySearchWithJavaUtilList_withId_(id<JavaUtilList> list, id key);

FOUNDATION_EXPORT jint JavaUtilCollections_binarySearchWithJavaUtilList_withId_withJavaUtilComparator_(id<JavaUtilList> list, id key, id<JavaUtilComparator> c);

FOUNDATION_EXPORT void JavaUtilCollections_reverseWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT void JavaUtilCollections_shuffleWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT void JavaUtilCollections_shuffleWithJavaUtilList_withJavaUtilRandom_(id<JavaUtilList> list, JavaUtilRandom *rnd);

FOUNDATION_EXPORT void JavaUtilCollections_swapWithJavaUtilList_withInt_withInt_(id<JavaUtilList> list, jint i, jint j);

FOUNDATION_EXPORT void JavaUtilCollections_fillWithJavaUtilList_withId_(id<JavaUtilList> list, id obj);

FOUNDATION_EXPORT void JavaUtilCollections_copy__WithJavaUtilList_withJavaUtilList_(id<JavaUtilList> dest, id<JavaUtilList> src);

FOUNDATION_EXPORT id<JavaLangComparable> JavaUtilCollections_minWithJavaUtilCollection_(id<JavaUtilCollection> coll);

FOUNDATION_EXPORT id JavaUtilCollections_minWithJavaUtilCollection_withJavaUtilComparator_(id<JavaUtilCollection> coll, id<JavaUtilComparator> comp);

FOUNDATION_EXPORT id<JavaLangComparable> JavaUtilCollections_maxWithJavaUtilCollection_(id<JavaUtilCollection> coll);

FOUNDATION_EXPORT id JavaUtilCollections_maxWithJavaUtilCollection_withJavaUtilComparator_(id<JavaUtilCollection> coll, id<JavaUtilComparator> comp);

FOUNDATION_EXPORT void JavaUtilCollections_rotateWithJavaUtilList_withInt_(id<JavaUtilList> list, jint distance);

FOUNDATION_EXPORT jboolean JavaUtilCollections_replaceAllWithJavaUtilList_withId_withId_(id<JavaUtilList> list, id oldVal, id newVal);

FOUNDATION_EXPORT jint JavaUtilCollections_indexOfSubListWithJavaUtilList_withJavaUtilList_(id<JavaUtilList> source, id<JavaUtilList> target);

FOUNDATION_EXPORT jint JavaUtilCollections_lastIndexOfSubListWithJavaUtilList_withJavaUtilList_(id<JavaUtilList> source, id<JavaUtilList> target);

FOUNDATION_EXPORT id<JavaUtilCollection> JavaUtilCollections_unmodifiableCollectionWithJavaUtilCollection_(id<JavaUtilCollection> c);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_unmodifiableSetWithJavaUtilSet_(id<JavaUtilSet> s);

FOUNDATION_EXPORT id<JavaUtilSortedSet> JavaUtilCollections_unmodifiableSortedSetWithJavaUtilSortedSet_(id<JavaUtilSortedSet> s);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> JavaUtilCollections_unmodifiableNavigableSetWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> s);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_unmodifiableListWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT id<JavaUtilMap> JavaUtilCollections_unmodifiableMapWithJavaUtilMap_(id<JavaUtilMap> m);

FOUNDATION_EXPORT id<JavaUtilSortedMap> JavaUtilCollections_unmodifiableSortedMapWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT id<JavaUtilNavigableMap> JavaUtilCollections_unmodifiableNavigableMapWithJavaUtilNavigableMap_(id<JavaUtilNavigableMap> m);

FOUNDATION_EXPORT id<JavaUtilCollection> JavaUtilCollections_synchronizedCollectionWithJavaUtilCollection_(id<JavaUtilCollection> c);

FOUNDATION_EXPORT id<JavaUtilCollection> JavaUtilCollections_synchronizedCollectionWithJavaUtilCollection_withId_(id<JavaUtilCollection> c, id mutex);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_synchronizedSetWithJavaUtilSet_(id<JavaUtilSet> s);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_synchronizedSetWithJavaUtilSet_withId_(id<JavaUtilSet> s, id mutex);

FOUNDATION_EXPORT id<JavaUtilSortedSet> JavaUtilCollections_synchronizedSortedSetWithJavaUtilSortedSet_(id<JavaUtilSortedSet> s);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> JavaUtilCollections_synchronizedNavigableSetWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> s);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_synchronizedListWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_synchronizedListWithJavaUtilList_withId_(id<JavaUtilList> list, id mutex);

FOUNDATION_EXPORT id<JavaUtilMap> JavaUtilCollections_synchronizedMapWithJavaUtilMap_(id<JavaUtilMap> m);

FOUNDATION_EXPORT id<JavaUtilSortedMap> JavaUtilCollections_synchronizedSortedMapWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT id<JavaUtilNavigableMap> JavaUtilCollections_synchronizedNavigableMapWithJavaUtilNavigableMap_(id<JavaUtilNavigableMap> m);

FOUNDATION_EXPORT id<JavaUtilCollection> JavaUtilCollections_checkedCollectionWithJavaUtilCollection_withIOSClass_(id<JavaUtilCollection> c, IOSClass *type);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilCollections_zeroLengthArrayWithIOSClass_(IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilQueue> JavaUtilCollections_checkedQueueWithJavaUtilQueue_withIOSClass_(id<JavaUtilQueue> queue, IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_checkedSetWithJavaUtilSet_withIOSClass_(id<JavaUtilSet> s, IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilSortedSet> JavaUtilCollections_checkedSortedSetWithJavaUtilSortedSet_withIOSClass_(id<JavaUtilSortedSet> s, IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> JavaUtilCollections_checkedNavigableSetWithJavaUtilNavigableSet_withIOSClass_(id<JavaUtilNavigableSet> s, IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_checkedListWithJavaUtilList_withIOSClass_(id<JavaUtilList> list, IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilMap> JavaUtilCollections_checkedMapWithJavaUtilMap_withIOSClass_withIOSClass_(id<JavaUtilMap> m, IOSClass *keyType, IOSClass *valueType);

FOUNDATION_EXPORT id<JavaUtilSortedMap> JavaUtilCollections_checkedSortedMapWithJavaUtilSortedMap_withIOSClass_withIOSClass_(id<JavaUtilSortedMap> m, IOSClass *keyType, IOSClass *valueType);

FOUNDATION_EXPORT id<JavaUtilNavigableMap> JavaUtilCollections_checkedNavigableMapWithJavaUtilNavigableMap_withIOSClass_withIOSClass_(id<JavaUtilNavigableMap> m, IOSClass *keyType, IOSClass *valueType);

FOUNDATION_EXPORT id<JavaUtilIterator> JavaUtilCollections_emptyIterator(void);

FOUNDATION_EXPORT id<JavaUtilListIterator> JavaUtilCollections_emptyListIterator(void);

FOUNDATION_EXPORT id<JavaUtilEnumeration> JavaUtilCollections_emptyEnumeration(void);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_emptySet(void);

FOUNDATION_EXPORT id<JavaUtilSortedSet> JavaUtilCollections_emptySortedSet(void);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> JavaUtilCollections_emptyNavigableSet(void);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_emptyList(void);

FOUNDATION_EXPORT id<JavaUtilMap> JavaUtilCollections_emptyMap(void);

FOUNDATION_EXPORT id<JavaUtilSortedMap> JavaUtilCollections_emptySortedMap(void);

FOUNDATION_EXPORT id<JavaUtilNavigableMap> JavaUtilCollections_emptyNavigableMap(void);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_singletonWithId_(id o);

FOUNDATION_EXPORT id<JavaUtilIterator> JavaUtilCollections_singletonIteratorWithId_(id e);

FOUNDATION_EXPORT id<JavaUtilSpliterator> JavaUtilCollections_singletonSpliteratorWithId_(id element);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_singletonListWithId_(id o);

FOUNDATION_EXPORT id<JavaUtilMap> JavaUtilCollections_singletonMapWithId_withId_(id key, id value);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilCollections_nCopiesWithInt_withId_(jint n, id o);

FOUNDATION_EXPORT id<JavaUtilComparator> JavaUtilCollections_reverseOrder(void);

FOUNDATION_EXPORT id<JavaUtilComparator> JavaUtilCollections_reverseOrderWithJavaUtilComparator_(id<JavaUtilComparator> cmp);

FOUNDATION_EXPORT id<JavaUtilEnumeration> JavaUtilCollections_enumerationWithJavaUtilCollection_(id<JavaUtilCollection> c);

FOUNDATION_EXPORT JavaUtilArrayList *JavaUtilCollections_listWithJavaUtilEnumeration_(id<JavaUtilEnumeration> e);

FOUNDATION_EXPORT jboolean JavaUtilCollections_eqWithId_withId_(id o1, id o2);

FOUNDATION_EXPORT jint JavaUtilCollections_frequencyWithJavaUtilCollection_withId_(id<JavaUtilCollection> c, id o);

FOUNDATION_EXPORT jboolean JavaUtilCollections_disjointWithJavaUtilCollection_withJavaUtilCollection_(id<JavaUtilCollection> c1, id<JavaUtilCollection> c2);

FOUNDATION_EXPORT jboolean JavaUtilCollections_addAllWithJavaUtilCollection_withNSObjectArray_(id<JavaUtilCollection> c, IOSObjectArray *elements);

FOUNDATION_EXPORT id<JavaUtilSet> JavaUtilCollections_newSetFromMapWithJavaUtilMap_(id<JavaUtilMap> map);

FOUNDATION_EXPORT id<JavaUtilQueue> JavaUtilCollections_asLifoQueueWithJavaUtilDeque_(id<JavaUtilDeque> deque);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections)

#endif

#if !defined (JavaUtilCollections_UnmodifiableCollection_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableCollection))
#define JavaUtilCollections_UnmodifiableCollection_

#define RESTRICT_JavaUtilCollection 1
#define INCLUDE_JavaUtilCollection 1
#include "java/util/Collection.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;
@protocol JavaUtilStreamStream;

/*!
 */
@interface JavaUtilCollections_UnmodifiableCollection : NSObject < JavaUtilCollection, JavaIoSerializable > {
 @public
  id<JavaUtilCollection> c_;
}

#pragma mark Public

- (jboolean)addWithId:(id)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (id<JavaUtilStreamStream>)parallelStream;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (id<JavaUtilStreamStream>)stream;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)c;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableCollection)

J2OBJC_FIELD_SETTER(JavaUtilCollections_UnmodifiableCollection, c_, id<JavaUtilCollection>)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableCollection_initWithJavaUtilCollection_(JavaUtilCollections_UnmodifiableCollection *self, id<JavaUtilCollection> c);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableCollection *new_JavaUtilCollections_UnmodifiableCollection_initWithJavaUtilCollection_(id<JavaUtilCollection> c) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableCollection *create_JavaUtilCollections_UnmodifiableCollection_initWithJavaUtilCollection_(id<JavaUtilCollection> c);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableCollection)

#endif

#if !defined (JavaUtilCollections_UnmodifiableSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableSet))
#define JavaUtilCollections_UnmodifiableSet_

#define RESTRICT_JavaUtilSet 1
#define INCLUDE_JavaUtilSet 1
#include "java/util/Set.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilCollection;

/*!
 */
@interface JavaUtilCollections_UnmodifiableSet : JavaUtilCollections_UnmodifiableCollection < JavaUtilSet, JavaIoSerializable >

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (NSUInteger)hash;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)s;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableSet)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableSet_initWithJavaUtilSet_(JavaUtilCollections_UnmodifiableSet *self, id<JavaUtilSet> s);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableSet *new_JavaUtilCollections_UnmodifiableSet_initWithJavaUtilSet_(id<JavaUtilSet> s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableSet *create_JavaUtilCollections_UnmodifiableSet_initWithJavaUtilSet_(id<JavaUtilSet> s);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableSet)

#endif

#if !defined (JavaUtilCollections_UnmodifiableSortedSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableSortedSet))
#define JavaUtilCollections_UnmodifiableSortedSet_

#define RESTRICT_JavaUtilSortedSet 1
#define INCLUDE_JavaUtilSortedSet 1
#include "java/util/SortedSet.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilComparator;
@protocol JavaUtilSet;

/*!
 */
@interface JavaUtilCollections_UnmodifiableSortedSet : JavaUtilCollections_UnmodifiableSet < JavaUtilSortedSet, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilComparator>)comparator;

- (id)first;

- (id<JavaUtilSortedSet>)headSetWithId:(id)toElement;

- (id)last;

- (id<JavaUtilSortedSet>)subSetWithId:(id)fromElement
                               withId:(id)toElement;

- (id<JavaUtilSortedSet>)tailSetWithId:(id)fromElement;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableSortedSet)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableSortedSet_initWithJavaUtilSortedSet_(JavaUtilCollections_UnmodifiableSortedSet *self, id<JavaUtilSortedSet> s);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableSortedSet *new_JavaUtilCollections_UnmodifiableSortedSet_initWithJavaUtilSortedSet_(id<JavaUtilSortedSet> s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableSortedSet *create_JavaUtilCollections_UnmodifiableSortedSet_initWithJavaUtilSortedSet_(id<JavaUtilSortedSet> s);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableSortedSet)

#endif

#if !defined (JavaUtilCollections_UnmodifiableNavigableSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableNavigableSet))
#define JavaUtilCollections_UnmodifiableNavigableSet_

#define RESTRICT_JavaUtilNavigableSet 1
#define INCLUDE_JavaUtilNavigableSet 1
#include "java/util/NavigableSet.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilIterator;
@protocol JavaUtilSortedSet;

/*!
 @brief Wraps a navigable set and disables all of the mutative operations.
 */
@interface JavaUtilCollections_UnmodifiableNavigableSet : JavaUtilCollections_UnmodifiableSortedSet < JavaUtilNavigableSet, JavaIoSerializable >

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (id)floorWithId:(id)e;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (id)lowerWithId:(id)e;

- (id)pollFirst;

- (id)pollLast;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)arg0 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilCollections_UnmodifiableNavigableSet)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableNavigableSet_initWithJavaUtilNavigableSet_(JavaUtilCollections_UnmodifiableNavigableSet *self, id<JavaUtilNavigableSet> s);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableNavigableSet *new_JavaUtilCollections_UnmodifiableNavigableSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableNavigableSet *create_JavaUtilCollections_UnmodifiableNavigableSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> s);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableNavigableSet)

#endif

#if !defined (JavaUtilCollections_UnmodifiableList_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableList))
#define JavaUtilCollections_UnmodifiableList_

#define RESTRICT_JavaUtilList 1
#define INCLUDE_JavaUtilList 1
#include "java/util/List.h"

@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionUnaryOperator;
@protocol JavaUtilListIterator;

/*!
 */
@interface JavaUtilCollections_UnmodifiableList : JavaUtilCollections_UnmodifiableCollection < JavaUtilList > {
 @public
  id<JavaUtilList> list_;
}

#pragma mark Public

- (void)addWithInt:(jint)index
            withId:(id)element;

- (jboolean)addAllWithInt:(jint)index
   withJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)isEqual:(id)o;

- (id)getWithInt:(jint)index;

- (NSUInteger)hash;

- (jint)indexOfWithId:(id)o;

- (jint)lastIndexOfWithId:(id)o;

- (id<JavaUtilListIterator>)listIterator;

- (id<JavaUtilListIterator>)listIteratorWithInt:(jint)index;

- (id)removeWithInt:(jint)index;

- (void)replaceAllWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)operator_;

- (id)setWithInt:(jint)index
          withId:(id)element;

- (void)sortWithJavaUtilComparator:(id<JavaUtilComparator>)c;

- (id<JavaUtilList>)subListWithInt:(jint)fromIndex
                           withInt:(jint)toIndex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableList)

J2OBJC_FIELD_SETTER(JavaUtilCollections_UnmodifiableList, list_, id<JavaUtilList>)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableList_initWithJavaUtilList_(JavaUtilCollections_UnmodifiableList *self, id<JavaUtilList> list);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableList *new_JavaUtilCollections_UnmodifiableList_initWithJavaUtilList_(id<JavaUtilList> list) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableList *create_JavaUtilCollections_UnmodifiableList_initWithJavaUtilList_(id<JavaUtilList> list);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableList)

#endif

#if !defined (JavaUtilCollections_UnmodifiableRandomAccessList_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableRandomAccessList))
#define JavaUtilCollections_UnmodifiableRandomAccessList_

#define RESTRICT_JavaUtilRandomAccess 1
#define INCLUDE_JavaUtilRandomAccess 1
#include "java/util/RandomAccess.h"

@protocol JavaUtilList;

/*!
 */
@interface JavaUtilCollections_UnmodifiableRandomAccessList : JavaUtilCollections_UnmodifiableList < JavaUtilRandomAccess >

#pragma mark Public

- (id<JavaUtilList>)subListWithInt:(jint)fromIndex
                           withInt:(jint)toIndex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableRandomAccessList)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableRandomAccessList_initWithJavaUtilList_(JavaUtilCollections_UnmodifiableRandomAccessList *self, id<JavaUtilList> list);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableRandomAccessList *new_JavaUtilCollections_UnmodifiableRandomAccessList_initWithJavaUtilList_(id<JavaUtilList> list) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableRandomAccessList *create_JavaUtilCollections_UnmodifiableRandomAccessList_initWithJavaUtilList_(id<JavaUtilList> list);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableRandomAccessList)

#endif

#if !defined (JavaUtilCollections_UnmodifiableMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableMap))
#define JavaUtilCollections_UnmodifiableMap_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap 1
#include "java/util/Map.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilCollection;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilSet;

/*!
 */
@interface JavaUtilCollections_UnmodifiableMap : NSObject < JavaUtilMap, JavaIoSerializable >

#pragma mark Public

- (void)clear;

- (id)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id)computeIfAbsentWithId:(id)key
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

- (id)computeIfPresentWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (jboolean)containsKeyWithId:(id)key;

- (jboolean)containsValueWithId:(id)val;

- (id<JavaUtilSet>)entrySet;

- (jboolean)isEqual:(id)o;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (id)getWithId:(id)key;

- (id)getOrDefaultWithId:(id)k
                  withId:(id)defaultValue;

- (NSUInteger)hash;

- (jboolean)isEmpty;

- (id<JavaUtilSet>)keySet;

- (id)mergeWithId:(id)key
           withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id)putWithId:(id)key
         withId:(id)value;

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)m;

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (id)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id)replaceWithId:(id)key
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

- (jint)size;

- (NSString *)description;

- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableMap)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableMap_initWithJavaUtilMap_(JavaUtilCollections_UnmodifiableMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableMap *new_JavaUtilCollections_UnmodifiableMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableMap *create_JavaUtilCollections_UnmodifiableMap_initWithJavaUtilMap_(id<JavaUtilMap> m);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableMap)

#endif

#if !defined (JavaUtilCollections_UnmodifiableSortedMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableSortedMap))
#define JavaUtilCollections_UnmodifiableSortedMap_

#define RESTRICT_JavaUtilSortedMap 1
#define INCLUDE_JavaUtilSortedMap 1
#include "java/util/SortedMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilComparator;
@protocol JavaUtilMap;

/*!
 */
@interface JavaUtilCollections_UnmodifiableSortedMap : JavaUtilCollections_UnmodifiableMap < JavaUtilSortedMap, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilComparator>)comparator;

- (id)firstKey;

- (id<JavaUtilSortedMap>)headMapWithId:(id)toKey;

- (id)lastKey;

- (id<JavaUtilSortedMap>)subMapWithId:(id)fromKey
                               withId:(id)toKey;

- (id<JavaUtilSortedMap>)tailMapWithId:(id)fromKey;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_UnmodifiableSortedMap)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableSortedMap_initWithJavaUtilSortedMap_(JavaUtilCollections_UnmodifiableSortedMap *self, id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableSortedMap *new_JavaUtilCollections_UnmodifiableSortedMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableSortedMap *create_JavaUtilCollections_UnmodifiableSortedMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableSortedMap)

#endif

#if !defined (JavaUtilCollections_UnmodifiableNavigableMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_UnmodifiableNavigableMap))
#define JavaUtilCollections_UnmodifiableNavigableMap_

#define RESTRICT_JavaUtilNavigableMap 1
#define INCLUDE_JavaUtilNavigableMap 1
#include "java/util/NavigableMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSortedMap;

/*!
 */
@interface JavaUtilCollections_UnmodifiableNavigableMap : JavaUtilCollections_UnmodifiableSortedMap < JavaUtilNavigableMap, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

- (id)ceilingKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (id<JavaUtilNavigableMap>)descendingMap;

- (id<JavaUtilMap_Entry>)firstEntry;

- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

- (id)floorKeyWithId:(id)key;

- (id<JavaUtilNavigableMap>)headMapWithId:(id)toKey
                              withBoolean:(jboolean)inclusive;

- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

- (id)higherKeyWithId:(id)key;

- (id<JavaUtilMap_Entry>)lastEntry;

- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

- (id)lowerKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)navigableKeySet;

- (id<JavaUtilMap_Entry>)pollFirstEntry;

- (id<JavaUtilMap_Entry>)pollLastEntry;

- (id<JavaUtilNavigableMap>)subMapWithId:(id)fromKey
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toKey
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableMap>)tailMapWithId:(id)fromKey
                              withBoolean:(jboolean)inclusive;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)arg0 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilCollections_UnmodifiableNavigableMap)

FOUNDATION_EXPORT void JavaUtilCollections_UnmodifiableNavigableMap_initWithJavaUtilNavigableMap_(JavaUtilCollections_UnmodifiableNavigableMap *self, id<JavaUtilNavigableMap> m);

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableNavigableMap *new_JavaUtilCollections_UnmodifiableNavigableMap_initWithJavaUtilNavigableMap_(id<JavaUtilNavigableMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_UnmodifiableNavigableMap *create_JavaUtilCollections_UnmodifiableNavigableMap_initWithJavaUtilNavigableMap_(id<JavaUtilNavigableMap> m);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_UnmodifiableNavigableMap)

#endif

#if !defined (JavaUtilCollections_SynchronizedCollection_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedCollection))
#define JavaUtilCollections_SynchronizedCollection_

#define RESTRICT_JavaUtilCollection 1
#define INCLUDE_JavaUtilCollection 1
#include "java/util/Collection.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;
@protocol JavaUtilStreamStream;

/*!
 */
@interface JavaUtilCollections_SynchronizedCollection : NSObject < JavaUtilCollection, JavaIoSerializable > {
 @public
  id<JavaUtilCollection> c_;
  id mutex_;
}

#pragma mark Public

- (jboolean)addWithId:(id)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)consumer;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (id<JavaUtilStreamStream>)parallelStream;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (id<JavaUtilStreamStream>)stream;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)c
                                              withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedCollection)

J2OBJC_FIELD_SETTER(JavaUtilCollections_SynchronizedCollection, c_, id<JavaUtilCollection>)
J2OBJC_FIELD_SETTER(JavaUtilCollections_SynchronizedCollection, mutex_, id)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedCollection_initWithJavaUtilCollection_(JavaUtilCollections_SynchronizedCollection *self, id<JavaUtilCollection> c);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedCollection *new_JavaUtilCollections_SynchronizedCollection_initWithJavaUtilCollection_(id<JavaUtilCollection> c) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedCollection *create_JavaUtilCollections_SynchronizedCollection_initWithJavaUtilCollection_(id<JavaUtilCollection> c);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedCollection_initWithJavaUtilCollection_withId_(JavaUtilCollections_SynchronizedCollection *self, id<JavaUtilCollection> c, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedCollection *new_JavaUtilCollections_SynchronizedCollection_initWithJavaUtilCollection_withId_(id<JavaUtilCollection> c, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedCollection *create_JavaUtilCollections_SynchronizedCollection_initWithJavaUtilCollection_withId_(id<JavaUtilCollection> c, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedCollection)

#endif

#if !defined (JavaUtilCollections_SynchronizedSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedSet))
#define JavaUtilCollections_SynchronizedSet_

#define RESTRICT_JavaUtilSet 1
#define INCLUDE_JavaUtilSet 1
#include "java/util/Set.h"

@protocol JavaUtilCollection;

/*!
 */
@interface JavaUtilCollections_SynchronizedSet : JavaUtilCollections_SynchronizedCollection < JavaUtilSet >

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (NSUInteger)hash;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)s;

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)s
                                       withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0
                                              withId:(id)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedSet)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedSet_initWithJavaUtilSet_(JavaUtilCollections_SynchronizedSet *self, id<JavaUtilSet> s);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSet *new_JavaUtilCollections_SynchronizedSet_initWithJavaUtilSet_(id<JavaUtilSet> s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSet *create_JavaUtilCollections_SynchronizedSet_initWithJavaUtilSet_(id<JavaUtilSet> s);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedSet_initWithJavaUtilSet_withId_(JavaUtilCollections_SynchronizedSet *self, id<JavaUtilSet> s, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSet *new_JavaUtilCollections_SynchronizedSet_initWithJavaUtilSet_withId_(id<JavaUtilSet> s, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSet *create_JavaUtilCollections_SynchronizedSet_initWithJavaUtilSet_withId_(id<JavaUtilSet> s, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedSet)

#endif

#if !defined (JavaUtilCollections_SynchronizedSortedSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedSortedSet))
#define JavaUtilCollections_SynchronizedSortedSet_

#define RESTRICT_JavaUtilSortedSet 1
#define INCLUDE_JavaUtilSortedSet 1
#include "java/util/SortedSet.h"

@protocol JavaUtilComparator;
@protocol JavaUtilSet;

/*!
 */
@interface JavaUtilCollections_SynchronizedSortedSet : JavaUtilCollections_SynchronizedSet < JavaUtilSortedSet >

#pragma mark Public

- (id<JavaUtilComparator>)comparator;

- (id)first;

- (id<JavaUtilSortedSet>)headSetWithId:(id)toElement;

- (id)last;

- (id<JavaUtilSortedSet>)subSetWithId:(id)fromElement
                               withId:(id)toElement;

- (id<JavaUtilSortedSet>)tailSetWithId:(id)fromElement;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s;

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s
                                             withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)arg0
                                       withId:(id)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedSortedSet)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedSortedSet_initWithJavaUtilSortedSet_(JavaUtilCollections_SynchronizedSortedSet *self, id<JavaUtilSortedSet> s);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedSet *new_JavaUtilCollections_SynchronizedSortedSet_initWithJavaUtilSortedSet_(id<JavaUtilSortedSet> s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedSet *create_JavaUtilCollections_SynchronizedSortedSet_initWithJavaUtilSortedSet_(id<JavaUtilSortedSet> s);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedSortedSet_initWithJavaUtilSortedSet_withId_(JavaUtilCollections_SynchronizedSortedSet *self, id<JavaUtilSortedSet> s, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedSet *new_JavaUtilCollections_SynchronizedSortedSet_initWithJavaUtilSortedSet_withId_(id<JavaUtilSortedSet> s, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedSet *create_JavaUtilCollections_SynchronizedSortedSet_initWithJavaUtilSortedSet_withId_(id<JavaUtilSortedSet> s, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedSortedSet)

#endif

#if !defined (JavaUtilCollections_SynchronizedNavigableSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedNavigableSet))
#define JavaUtilCollections_SynchronizedNavigableSet_

#define RESTRICT_JavaUtilNavigableSet 1
#define INCLUDE_JavaUtilNavigableSet 1
#include "java/util/NavigableSet.h"

@protocol JavaUtilIterator;
@protocol JavaUtilSortedSet;

/*!
 */
@interface JavaUtilCollections_SynchronizedNavigableSet : JavaUtilCollections_SynchronizedSortedSet < JavaUtilNavigableSet >

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (id)floorWithId:(id)e;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (id)lowerWithId:(id)e;

- (id)pollFirst;

- (id)pollLast;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                                  withId:(id)toElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s;

- (instancetype __nonnull)initWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s
                                                withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)arg0
                                             withId:(id)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedNavigableSet)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedNavigableSet_initWithJavaUtilNavigableSet_(JavaUtilCollections_SynchronizedNavigableSet *self, id<JavaUtilNavigableSet> s);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableSet *new_JavaUtilCollections_SynchronizedNavigableSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> s) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableSet *create_JavaUtilCollections_SynchronizedNavigableSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> s);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedNavigableSet_initWithJavaUtilNavigableSet_withId_(JavaUtilCollections_SynchronizedNavigableSet *self, id<JavaUtilNavigableSet> s, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableSet *new_JavaUtilCollections_SynchronizedNavigableSet_initWithJavaUtilNavigableSet_withId_(id<JavaUtilNavigableSet> s, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableSet *create_JavaUtilCollections_SynchronizedNavigableSet_initWithJavaUtilNavigableSet_withId_(id<JavaUtilNavigableSet> s, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedNavigableSet)

#endif

#if !defined (JavaUtilCollections_SynchronizedList_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedList))
#define JavaUtilCollections_SynchronizedList_

#define RESTRICT_JavaUtilList 1
#define INCLUDE_JavaUtilList 1
#include "java/util/List.h"

@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionUnaryOperator;
@protocol JavaUtilListIterator;

/*!
 */
@interface JavaUtilCollections_SynchronizedList : JavaUtilCollections_SynchronizedCollection < JavaUtilList > {
 @public
  id<JavaUtilList> list_;
}

#pragma mark Public

- (void)addWithInt:(jint)index
            withId:(id)element;

- (jboolean)addAllWithInt:(jint)index
   withJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)isEqual:(id)o;

- (id)getWithInt:(jint)index;

- (NSUInteger)hash;

- (jint)indexOfWithId:(id)o;

- (jint)lastIndexOfWithId:(id)o;

- (id<JavaUtilListIterator>)listIterator;

- (id<JavaUtilListIterator>)listIteratorWithInt:(jint)index;

- (id)removeWithInt:(jint)index;

- (void)replaceAllWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)operator_;

- (id)setWithInt:(jint)index
          withId:(id)element;

- (void)sortWithJavaUtilComparator:(id<JavaUtilComparator>)c;

- (id<JavaUtilList>)subListWithInt:(jint)fromIndex
                           withInt:(jint)toIndex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list;

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list
                                        withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0
                                              withId:(id)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedList)

J2OBJC_FIELD_SETTER(JavaUtilCollections_SynchronizedList, list_, id<JavaUtilList>)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedList_initWithJavaUtilList_(JavaUtilCollections_SynchronizedList *self, id<JavaUtilList> list);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedList *new_JavaUtilCollections_SynchronizedList_initWithJavaUtilList_(id<JavaUtilList> list) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedList *create_JavaUtilCollections_SynchronizedList_initWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedList_initWithJavaUtilList_withId_(JavaUtilCollections_SynchronizedList *self, id<JavaUtilList> list, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedList *new_JavaUtilCollections_SynchronizedList_initWithJavaUtilList_withId_(id<JavaUtilList> list, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedList *create_JavaUtilCollections_SynchronizedList_initWithJavaUtilList_withId_(id<JavaUtilList> list, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedList)

#endif

#if !defined (JavaUtilCollections_SynchronizedRandomAccessList_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedRandomAccessList))
#define JavaUtilCollections_SynchronizedRandomAccessList_

#define RESTRICT_JavaUtilRandomAccess 1
#define INCLUDE_JavaUtilRandomAccess 1
#include "java/util/RandomAccess.h"

@protocol JavaUtilList;

/*!
 */
@interface JavaUtilCollections_SynchronizedRandomAccessList : JavaUtilCollections_SynchronizedList < JavaUtilRandomAccess >

#pragma mark Public

- (id<JavaUtilList>)subListWithInt:(jint)fromIndex
                           withInt:(jint)toIndex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list;

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list
                                        withId:(id)mutex;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedRandomAccessList)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedRandomAccessList_initWithJavaUtilList_(JavaUtilCollections_SynchronizedRandomAccessList *self, id<JavaUtilList> list);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedRandomAccessList *new_JavaUtilCollections_SynchronizedRandomAccessList_initWithJavaUtilList_(id<JavaUtilList> list) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedRandomAccessList *create_JavaUtilCollections_SynchronizedRandomAccessList_initWithJavaUtilList_(id<JavaUtilList> list);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedRandomAccessList_initWithJavaUtilList_withId_(JavaUtilCollections_SynchronizedRandomAccessList *self, id<JavaUtilList> list, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedRandomAccessList *new_JavaUtilCollections_SynchronizedRandomAccessList_initWithJavaUtilList_withId_(id<JavaUtilList> list, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedRandomAccessList *create_JavaUtilCollections_SynchronizedRandomAccessList_initWithJavaUtilList_withId_(id<JavaUtilList> list, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedRandomAccessList)

#endif

#if !defined (JavaUtilCollections_SynchronizedMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedMap))
#define JavaUtilCollections_SynchronizedMap_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap 1
#include "java/util/Map.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilCollection;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilSet;

/*!
 */
@interface JavaUtilCollections_SynchronizedMap : NSObject < JavaUtilMap, JavaIoSerializable > {
 @public
  id mutex_;
}

#pragma mark Public

- (void)clear;

- (id)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id)computeIfAbsentWithId:(id)key
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

- (id)computeIfPresentWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (jboolean)containsKeyWithId:(id)key;

- (jboolean)containsValueWithId:(id)value;

- (id<JavaUtilSet>)entrySet;

- (jboolean)isEqual:(id)o;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (id)getWithId:(id)key;

- (id)getOrDefaultWithId:(id)k
                  withId:(id)defaultValue;

- (NSUInteger)hash;

- (jboolean)isEmpty;

- (id<JavaUtilSet>)keySet;

- (id)mergeWithId:(id)key
           withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id)putWithId:(id)key
         withId:(id)value;

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map;

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (id)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id)replaceWithId:(id)key
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

- (jint)size;

- (NSString *)description;

- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m;

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m
                                       withId:(id)mutex;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedMap)

J2OBJC_FIELD_SETTER(JavaUtilCollections_SynchronizedMap, mutex_, id)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedMap_initWithJavaUtilMap_(JavaUtilCollections_SynchronizedMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedMap *new_JavaUtilCollections_SynchronizedMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedMap *create_JavaUtilCollections_SynchronizedMap_initWithJavaUtilMap_(id<JavaUtilMap> m);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedMap_initWithJavaUtilMap_withId_(JavaUtilCollections_SynchronizedMap *self, id<JavaUtilMap> m, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedMap *new_JavaUtilCollections_SynchronizedMap_initWithJavaUtilMap_withId_(id<JavaUtilMap> m, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedMap *create_JavaUtilCollections_SynchronizedMap_initWithJavaUtilMap_withId_(id<JavaUtilMap> m, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedMap)

#endif

#if !defined (JavaUtilCollections_SynchronizedSortedMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedSortedMap))
#define JavaUtilCollections_SynchronizedSortedMap_

#define RESTRICT_JavaUtilSortedMap 1
#define INCLUDE_JavaUtilSortedMap 1
#include "java/util/SortedMap.h"

@protocol JavaUtilComparator;
@protocol JavaUtilMap;

/*!
 */
@interface JavaUtilCollections_SynchronizedSortedMap : JavaUtilCollections_SynchronizedMap < JavaUtilSortedMap >

#pragma mark Public

- (id<JavaUtilComparator>)comparator;

- (id)firstKey;

- (id<JavaUtilSortedMap>)headMapWithId:(id)toKey;

- (id)lastKey;

- (id<JavaUtilSortedMap>)subMapWithId:(id)fromKey
                               withId:(id)toKey;

- (id<JavaUtilSortedMap>)tailMapWithId:(id)fromKey;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m;

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m
                                             withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)arg0
                                       withId:(id)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedSortedMap)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedSortedMap_initWithJavaUtilSortedMap_(JavaUtilCollections_SynchronizedSortedMap *self, id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedMap *new_JavaUtilCollections_SynchronizedSortedMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedMap *create_JavaUtilCollections_SynchronizedSortedMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedSortedMap_initWithJavaUtilSortedMap_withId_(JavaUtilCollections_SynchronizedSortedMap *self, id<JavaUtilSortedMap> m, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedMap *new_JavaUtilCollections_SynchronizedSortedMap_initWithJavaUtilSortedMap_withId_(id<JavaUtilSortedMap> m, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedSortedMap *create_JavaUtilCollections_SynchronizedSortedMap_initWithJavaUtilSortedMap_withId_(id<JavaUtilSortedMap> m, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedSortedMap)

#endif

#if !defined (JavaUtilCollections_SynchronizedNavigableMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_SynchronizedNavigableMap))
#define JavaUtilCollections_SynchronizedNavigableMap_

#define RESTRICT_JavaUtilNavigableMap 1
#define INCLUDE_JavaUtilNavigableMap 1
#include "java/util/NavigableMap.h"

@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSortedMap;

/*!
 @brief A synchronized NavigableMap.
 */
@interface JavaUtilCollections_SynchronizedNavigableMap : JavaUtilCollections_SynchronizedSortedMap < JavaUtilNavigableMap >

#pragma mark Public

- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

- (id)ceilingKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (id<JavaUtilNavigableMap>)descendingMap;

- (id<JavaUtilMap_Entry>)firstEntry;

- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

- (id)floorKeyWithId:(id)key;

- (id<JavaUtilSortedMap>)headMapWithId:(id)toKey;

- (id<JavaUtilNavigableMap>)headMapWithId:(id)toKey
                              withBoolean:(jboolean)inclusive;

- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

- (id)higherKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)keySet;

- (id<JavaUtilMap_Entry>)lastEntry;

- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

- (id)lowerKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)navigableKeySet;

- (id<JavaUtilMap_Entry>)pollFirstEntry;

- (id<JavaUtilMap_Entry>)pollLastEntry;

- (id<JavaUtilNavigableMap>)subMapWithId:(id)fromKey
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toKey
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilSortedMap>)subMapWithId:(id)fromKey
                               withId:(id)toKey;

- (id<JavaUtilSortedMap>)tailMapWithId:(id)fromKey;

- (id<JavaUtilNavigableMap>)tailMapWithId:(id)fromKey
                              withBoolean:(jboolean)inclusive;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m;

- (instancetype __nonnull)initWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m
                                                withId:(id)mutex;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)arg0 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)arg0
                                             withId:(id)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_SynchronizedNavigableMap)

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedNavigableMap_initWithJavaUtilNavigableMap_(JavaUtilCollections_SynchronizedNavigableMap *self, id<JavaUtilNavigableMap> m);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableMap *new_JavaUtilCollections_SynchronizedNavigableMap_initWithJavaUtilNavigableMap_(id<JavaUtilNavigableMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableMap *create_JavaUtilCollections_SynchronizedNavigableMap_initWithJavaUtilNavigableMap_(id<JavaUtilNavigableMap> m);

FOUNDATION_EXPORT void JavaUtilCollections_SynchronizedNavigableMap_initWithJavaUtilNavigableMap_withId_(JavaUtilCollections_SynchronizedNavigableMap *self, id<JavaUtilNavigableMap> m, id mutex);

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableMap *new_JavaUtilCollections_SynchronizedNavigableMap_initWithJavaUtilNavigableMap_withId_(id<JavaUtilNavigableMap> m, id mutex) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_SynchronizedNavigableMap *create_JavaUtilCollections_SynchronizedNavigableMap_initWithJavaUtilNavigableMap_withId_(id<JavaUtilNavigableMap> m, id mutex);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_SynchronizedNavigableMap)

#endif

#if !defined (JavaUtilCollections_CheckedCollection_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedCollection))
#define JavaUtilCollections_CheckedCollection_

#define RESTRICT_JavaUtilCollection 1
#define INCLUDE_JavaUtilCollection 1
#include "java/util/Collection.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@class IOSObjectArray;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;
@protocol JavaUtilStreamStream;

/*!
 */
@interface JavaUtilCollections_CheckedCollection : NSObject < JavaUtilCollection, JavaIoSerializable > {
 @public
  id<JavaUtilCollection> c_;
  IOSClass *type_;
}

#pragma mark Public

- (jboolean)addWithId:(id)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (id<JavaUtilStreamStream>)parallelStream;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (id<JavaUtilStreamStream>)stream;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)c
                                        withIOSClass:(IOSClass *)type;

- (id<JavaUtilCollection>)checkedCopyOfWithJavaUtilCollection:(id<JavaUtilCollection>)coll;

- (id)typeCheckWithId:(id)o;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedCollection)

J2OBJC_FIELD_SETTER(JavaUtilCollections_CheckedCollection, c_, id<JavaUtilCollection>)
J2OBJC_FIELD_SETTER(JavaUtilCollections_CheckedCollection, type_, IOSClass *)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedCollection_initWithJavaUtilCollection_withIOSClass_(JavaUtilCollections_CheckedCollection *self, id<JavaUtilCollection> c, IOSClass *type);

FOUNDATION_EXPORT JavaUtilCollections_CheckedCollection *new_JavaUtilCollections_CheckedCollection_initWithJavaUtilCollection_withIOSClass_(id<JavaUtilCollection> c, IOSClass *type) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedCollection *create_JavaUtilCollections_CheckedCollection_initWithJavaUtilCollection_withIOSClass_(id<JavaUtilCollection> c, IOSClass *type);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedCollection)

#endif

#if !defined (JavaUtilCollections_CheckedQueue_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedQueue))
#define JavaUtilCollections_CheckedQueue_

#define RESTRICT_JavaUtilQueue 1
#define INCLUDE_JavaUtilQueue 1
#include "java/util/Queue.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilCollection;

/*!
 */
@interface JavaUtilCollections_CheckedQueue : JavaUtilCollections_CheckedCollection < JavaUtilQueue, JavaIoSerializable > {
 @public
  id<JavaUtilQueue> queue_;
}

#pragma mark Public

- (id)element;

- (jboolean)isEqual:(id)o;

- (NSUInteger)hash;

- (jboolean)offerWithId:(id)e;

- (id)peek;

- (id)poll;

- (id)remove;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilQueue:(id<JavaUtilQueue>)queue
                                   withIOSClass:(IOSClass *)elementType;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0
                                        withIOSClass:(IOSClass *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedQueue)

J2OBJC_FIELD_SETTER(JavaUtilCollections_CheckedQueue, queue_, id<JavaUtilQueue>)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedQueue_initWithJavaUtilQueue_withIOSClass_(JavaUtilCollections_CheckedQueue *self, id<JavaUtilQueue> queue, IOSClass *elementType);

FOUNDATION_EXPORT JavaUtilCollections_CheckedQueue *new_JavaUtilCollections_CheckedQueue_initWithJavaUtilQueue_withIOSClass_(id<JavaUtilQueue> queue, IOSClass *elementType) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedQueue *create_JavaUtilCollections_CheckedQueue_initWithJavaUtilQueue_withIOSClass_(id<JavaUtilQueue> queue, IOSClass *elementType);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedQueue)

#endif

#if !defined (JavaUtilCollections_CheckedSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedSet))
#define JavaUtilCollections_CheckedSet_

#define RESTRICT_JavaUtilSet 1
#define INCLUDE_JavaUtilSet 1
#include "java/util/Set.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilCollection;

/*!
 */
@interface JavaUtilCollections_CheckedSet : JavaUtilCollections_CheckedCollection < JavaUtilSet, JavaIoSerializable >

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (NSUInteger)hash;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)s
                                 withIOSClass:(IOSClass *)elementType;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0
                                        withIOSClass:(IOSClass *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedSet)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedSet_initWithJavaUtilSet_withIOSClass_(JavaUtilCollections_CheckedSet *self, id<JavaUtilSet> s, IOSClass *elementType);

FOUNDATION_EXPORT JavaUtilCollections_CheckedSet *new_JavaUtilCollections_CheckedSet_initWithJavaUtilSet_withIOSClass_(id<JavaUtilSet> s, IOSClass *elementType) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedSet *create_JavaUtilCollections_CheckedSet_initWithJavaUtilSet_withIOSClass_(id<JavaUtilSet> s, IOSClass *elementType);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedSet)

#endif

#if !defined (JavaUtilCollections_CheckedSortedSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedSortedSet))
#define JavaUtilCollections_CheckedSortedSet_

#define RESTRICT_JavaUtilSortedSet 1
#define INCLUDE_JavaUtilSortedSet 1
#include "java/util/SortedSet.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilComparator;
@protocol JavaUtilSet;

/*!
 */
@interface JavaUtilCollections_CheckedSortedSet : JavaUtilCollections_CheckedSet < JavaUtilSortedSet, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilComparator>)comparator;

- (id)first;

- (id<JavaUtilSortedSet>)headSetWithId:(id)toElement;

- (id)last;

- (id<JavaUtilSortedSet>)subSetWithId:(id)fromElement
                               withId:(id)toElement;

- (id<JavaUtilSortedSet>)tailSetWithId:(id)fromElement;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)s
                                       withIOSClass:(IOSClass *)type;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSet:(id<JavaUtilSet>)arg0
                                 withIOSClass:(IOSClass *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedSortedSet)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedSortedSet_initWithJavaUtilSortedSet_withIOSClass_(JavaUtilCollections_CheckedSortedSet *self, id<JavaUtilSortedSet> s, IOSClass *type);

FOUNDATION_EXPORT JavaUtilCollections_CheckedSortedSet *new_JavaUtilCollections_CheckedSortedSet_initWithJavaUtilSortedSet_withIOSClass_(id<JavaUtilSortedSet> s, IOSClass *type) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedSortedSet *create_JavaUtilCollections_CheckedSortedSet_initWithJavaUtilSortedSet_withIOSClass_(id<JavaUtilSortedSet> s, IOSClass *type);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedSortedSet)

#endif

#if !defined (JavaUtilCollections_CheckedNavigableSet_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedNavigableSet))
#define JavaUtilCollections_CheckedNavigableSet_

#define RESTRICT_JavaUtilNavigableSet 1
#define INCLUDE_JavaUtilNavigableSet 1
#include "java/util/NavigableSet.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilIterator;
@protocol JavaUtilSortedSet;

/*!
 */
@interface JavaUtilCollections_CheckedNavigableSet : JavaUtilCollections_CheckedSortedSet < JavaUtilNavigableSet, JavaIoSerializable >

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (id)floorWithId:(id)e;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (id)lowerWithId:(id)e;

- (id)pollFirst;

- (id)pollLast;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                                  withId:(id)toElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)s
                                          withIOSClass:(IOSClass *)type;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)arg0
                                       withIOSClass:(IOSClass *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedNavigableSet)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedNavigableSet_initWithJavaUtilNavigableSet_withIOSClass_(JavaUtilCollections_CheckedNavigableSet *self, id<JavaUtilNavigableSet> s, IOSClass *type);

FOUNDATION_EXPORT JavaUtilCollections_CheckedNavigableSet *new_JavaUtilCollections_CheckedNavigableSet_initWithJavaUtilNavigableSet_withIOSClass_(id<JavaUtilNavigableSet> s, IOSClass *type) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedNavigableSet *create_JavaUtilCollections_CheckedNavigableSet_initWithJavaUtilNavigableSet_withIOSClass_(id<JavaUtilNavigableSet> s, IOSClass *type);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedNavigableSet)

#endif

#if !defined (JavaUtilCollections_CheckedList_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedList))
#define JavaUtilCollections_CheckedList_

#define RESTRICT_JavaUtilList 1
#define INCLUDE_JavaUtilList 1
#include "java/util/List.h"

@class IOSClass;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilFunctionUnaryOperator;
@protocol JavaUtilListIterator;

/*!
 */
@interface JavaUtilCollections_CheckedList : JavaUtilCollections_CheckedCollection < JavaUtilList > {
 @public
  id<JavaUtilList> list_;
}

#pragma mark Public

- (void)addWithInt:(jint)index
            withId:(id)element;

- (jboolean)addAllWithInt:(jint)index
   withJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)isEqual:(id)o;

- (id)getWithInt:(jint)index;

- (NSUInteger)hash;

- (jint)indexOfWithId:(id)o;

- (jint)lastIndexOfWithId:(id)o;

- (id<JavaUtilListIterator>)listIterator;

- (id<JavaUtilListIterator>)listIteratorWithInt:(jint)index;

- (id)removeWithInt:(jint)index;

/*!
 @throw ClassCastExceptionif the class of an element returned by the
          operator prevents it from being added to this collection. The
          exception may be thrown after some elements of the list have
          already been replaced.
 */
- (void)replaceAllWithJavaUtilFunctionUnaryOperator:(id<JavaUtilFunctionUnaryOperator>)operator_;

- (id)setWithInt:(jint)index
          withId:(id)element;

- (void)sortWithJavaUtilComparator:(id<JavaUtilComparator>)c;

- (id<JavaUtilList>)subListWithInt:(jint)fromIndex
                           withInt:(jint)toIndex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list
                                  withIOSClass:(IOSClass *)type;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilCollection:(id<JavaUtilCollection>)arg0
                                        withIOSClass:(IOSClass *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedList)

J2OBJC_FIELD_SETTER(JavaUtilCollections_CheckedList, list_, id<JavaUtilList>)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedList_initWithJavaUtilList_withIOSClass_(JavaUtilCollections_CheckedList *self, id<JavaUtilList> list, IOSClass *type);

FOUNDATION_EXPORT JavaUtilCollections_CheckedList *new_JavaUtilCollections_CheckedList_initWithJavaUtilList_withIOSClass_(id<JavaUtilList> list, IOSClass *type) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedList *create_JavaUtilCollections_CheckedList_initWithJavaUtilList_withIOSClass_(id<JavaUtilList> list, IOSClass *type);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedList)

#endif

#if !defined (JavaUtilCollections_CheckedRandomAccessList_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedRandomAccessList))
#define JavaUtilCollections_CheckedRandomAccessList_

#define RESTRICT_JavaUtilRandomAccess 1
#define INCLUDE_JavaUtilRandomAccess 1
#include "java/util/RandomAccess.h"

@class IOSClass;
@protocol JavaUtilList;

/*!
 */
@interface JavaUtilCollections_CheckedRandomAccessList : JavaUtilCollections_CheckedList < JavaUtilRandomAccess >

#pragma mark Public

- (id<JavaUtilList>)subListWithInt:(jint)fromIndex
                           withInt:(jint)toIndex;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilList:(id<JavaUtilList>)list
                                  withIOSClass:(IOSClass *)type;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedRandomAccessList)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedRandomAccessList_initWithJavaUtilList_withIOSClass_(JavaUtilCollections_CheckedRandomAccessList *self, id<JavaUtilList> list, IOSClass *type);

FOUNDATION_EXPORT JavaUtilCollections_CheckedRandomAccessList *new_JavaUtilCollections_CheckedRandomAccessList_initWithJavaUtilList_withIOSClass_(id<JavaUtilList> list, IOSClass *type) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedRandomAccessList *create_JavaUtilCollections_CheckedRandomAccessList_initWithJavaUtilList_withIOSClass_(id<JavaUtilList> list, IOSClass *type);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedRandomAccessList)

#endif

#if !defined (JavaUtilCollections_CheckedMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedMap))
#define JavaUtilCollections_CheckedMap_

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap 1
#include "java/util/Map.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilSet;

/*!
 */
@interface JavaUtilCollections_CheckedMap : NSObject < JavaUtilMap, JavaIoSerializable > {
 @public
  IOSClass *keyType_;
  IOSClass *valueType_;
}

#pragma mark Public

- (void)clear;

- (id)computeWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id)computeIfAbsentWithId:(id)key
withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)mappingFunction;

- (id)computeIfPresentWithId:(id)key
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (jboolean)containsKeyWithId:(id)key;

- (jboolean)containsValueWithId:(id)v;

- (id<JavaUtilSet>)entrySet;

- (jboolean)isEqual:(id)o;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

- (id)getWithId:(id)key;

- (NSUInteger)hash;

- (jboolean)isEmpty;

- (id<JavaUtilSet>)keySet;

- (id)mergeWithId:(id)key
           withId:(id)value
withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)remappingFunction;

- (id)putWithId:(id)key
         withId:(id)value;

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)t;

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (id)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id)replaceWithId:(id)key
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

- (jint)size;

- (NSString *)description;

- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)m
                                 withIOSClass:(IOSClass *)keyType
                                 withIOSClass:(IOSClass *)valueType;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedMap)

J2OBJC_FIELD_SETTER(JavaUtilCollections_CheckedMap, keyType_, IOSClass *)
J2OBJC_FIELD_SETTER(JavaUtilCollections_CheckedMap, valueType_, IOSClass *)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedMap_initWithJavaUtilMap_withIOSClass_withIOSClass_(JavaUtilCollections_CheckedMap *self, id<JavaUtilMap> m, IOSClass *keyType, IOSClass *valueType);

FOUNDATION_EXPORT JavaUtilCollections_CheckedMap *new_JavaUtilCollections_CheckedMap_initWithJavaUtilMap_withIOSClass_withIOSClass_(id<JavaUtilMap> m, IOSClass *keyType, IOSClass *valueType) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedMap *create_JavaUtilCollections_CheckedMap_initWithJavaUtilMap_withIOSClass_withIOSClass_(id<JavaUtilMap> m, IOSClass *keyType, IOSClass *valueType);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedMap)

#endif

#if !defined (JavaUtilCollections_CheckedSortedMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedSortedMap))
#define JavaUtilCollections_CheckedSortedMap_

#define RESTRICT_JavaUtilSortedMap 1
#define INCLUDE_JavaUtilSortedMap 1
#include "java/util/SortedMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilComparator;
@protocol JavaUtilMap;

/*!
 */
@interface JavaUtilCollections_CheckedSortedMap : JavaUtilCollections_CheckedMap < JavaUtilSortedMap, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilComparator>)comparator;

- (id)firstKey;

- (id<JavaUtilSortedMap>)headMapWithId:(id)toKey;

- (id)lastKey;

- (id<JavaUtilSortedMap>)subMapWithId:(id)fromKey
                               withId:(id)toKey;

- (id<JavaUtilSortedMap>)tailMapWithId:(id)fromKey;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m
                                       withIOSClass:(IOSClass *)keyType
                                       withIOSClass:(IOSClass *)valueType;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilMap:(id<JavaUtilMap>)arg0
                                 withIOSClass:(IOSClass *)arg1
                                 withIOSClass:(IOSClass *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedSortedMap)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedSortedMap_initWithJavaUtilSortedMap_withIOSClass_withIOSClass_(JavaUtilCollections_CheckedSortedMap *self, id<JavaUtilSortedMap> m, IOSClass *keyType, IOSClass *valueType);

FOUNDATION_EXPORT JavaUtilCollections_CheckedSortedMap *new_JavaUtilCollections_CheckedSortedMap_initWithJavaUtilSortedMap_withIOSClass_withIOSClass_(id<JavaUtilSortedMap> m, IOSClass *keyType, IOSClass *valueType) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedSortedMap *create_JavaUtilCollections_CheckedSortedMap_initWithJavaUtilSortedMap_withIOSClass_withIOSClass_(id<JavaUtilSortedMap> m, IOSClass *keyType, IOSClass *valueType);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedSortedMap)

#endif

#if !defined (JavaUtilCollections_CheckedNavigableMap_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_CheckedNavigableMap))
#define JavaUtilCollections_CheckedNavigableMap_

#define RESTRICT_JavaUtilNavigableMap 1
#define INCLUDE_JavaUtilNavigableMap 1
#include "java/util/NavigableMap.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSClass;
@protocol JavaUtilComparator;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSortedMap;

/*!
 */
@interface JavaUtilCollections_CheckedNavigableMap : JavaUtilCollections_CheckedSortedMap < JavaUtilNavigableMap, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

- (id)ceilingKeyWithId:(id)key;

- (id<JavaUtilComparator>)comparator;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (id<JavaUtilNavigableMap>)descendingMap;

- (id<JavaUtilMap_Entry>)firstEntry;

- (id)firstKey;

- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

- (id)floorKeyWithId:(id)key;

- (id<JavaUtilNavigableMap>)headMapWithId:(id)toKey;

- (id<JavaUtilNavigableMap>)headMapWithId:(id)toKey
                              withBoolean:(jboolean)inclusive;

- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

- (id)higherKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)keySet;

- (id<JavaUtilMap_Entry>)lastEntry;

- (id)lastKey;

- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

- (id)lowerKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)navigableKeySet;

- (id<JavaUtilMap_Entry>)pollFirstEntry;

- (id<JavaUtilMap_Entry>)pollLastEntry;

- (id<JavaUtilNavigableMap>)subMapWithId:(id)fromKey
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toKey
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableMap>)subMapWithId:(id)fromKey
                                  withId:(id)toKey;

- (id<JavaUtilNavigableMap>)tailMapWithId:(id)fromKey;

- (id<JavaUtilNavigableMap>)tailMapWithId:(id)fromKey
                              withBoolean:(jboolean)inclusive;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableMap:(id<JavaUtilNavigableMap>)m
                                          withIOSClass:(IOSClass *)keyType
                                          withIOSClass:(IOSClass *)valueType;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)arg0
                                       withIOSClass:(IOSClass *)arg1
                                       withIOSClass:(IOSClass *)arg2 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_CheckedNavigableMap)

FOUNDATION_EXPORT void JavaUtilCollections_CheckedNavigableMap_initWithJavaUtilNavigableMap_withIOSClass_withIOSClass_(JavaUtilCollections_CheckedNavigableMap *self, id<JavaUtilNavigableMap> m, IOSClass *keyType, IOSClass *valueType);

FOUNDATION_EXPORT JavaUtilCollections_CheckedNavigableMap *new_JavaUtilCollections_CheckedNavigableMap_initWithJavaUtilNavigableMap_withIOSClass_withIOSClass_(id<JavaUtilNavigableMap> m, IOSClass *keyType, IOSClass *valueType) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_CheckedNavigableMap *create_JavaUtilCollections_CheckedNavigableMap_initWithJavaUtilNavigableMap_withIOSClass_withIOSClass_(id<JavaUtilNavigableMap> m, IOSClass *keyType, IOSClass *valueType);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_CheckedNavigableMap)

#endif

#if !defined (JavaUtilCollections_AsLIFOQueue_) && (INCLUDE_ALL_JavaUtilCollections || defined(INCLUDE_JavaUtilCollections_AsLIFOQueue))
#define JavaUtilCollections_AsLIFOQueue_

#define RESTRICT_JavaUtilAbstractQueue 1
#define INCLUDE_JavaUtilAbstractQueue 1
#include "java/util/AbstractQueue.h"

#define RESTRICT_JavaUtilQueue 1
#define INCLUDE_JavaUtilQueue 1
#include "java/util/Queue.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@protocol JavaUtilCollection;
@protocol JavaUtilDeque;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;
@protocol JavaUtilStreamStream;

/*!
 */
@interface JavaUtilCollections_AsLIFOQueue : JavaUtilAbstractQueue < JavaUtilQueue, JavaIoSerializable >

#pragma mark Public

- (jboolean)addWithId:(id)e;

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (id)element;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jboolean)offerWithId:(id)e;

- (id<JavaUtilStreamStream>)parallelStream;

- (id)peek;

- (id)poll;

- (id)remove;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

- (id<JavaUtilStreamStream>)stream;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilDeque:(id<JavaUtilDeque>)q;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilCollections_AsLIFOQueue)

FOUNDATION_EXPORT void JavaUtilCollections_AsLIFOQueue_initWithJavaUtilDeque_(JavaUtilCollections_AsLIFOQueue *self, id<JavaUtilDeque> q);

FOUNDATION_EXPORT JavaUtilCollections_AsLIFOQueue *new_JavaUtilCollections_AsLIFOQueue_initWithJavaUtilDeque_(id<JavaUtilDeque> q) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilCollections_AsLIFOQueue *create_JavaUtilCollections_AsLIFOQueue_initWithJavaUtilDeque_(id<JavaUtilDeque> q);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilCollections_AsLIFOQueue)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilCollections")
