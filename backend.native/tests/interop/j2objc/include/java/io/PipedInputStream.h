//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/io/PipedInputStream.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaIoPipedInputStream")
#ifdef RESTRICT_JavaIoPipedInputStream
#define INCLUDE_ALL_JavaIoPipedInputStream 0
#else
#define INCLUDE_ALL_JavaIoPipedInputStream 1
#endif
#undef RESTRICT_JavaIoPipedInputStream

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaIoPipedInputStream_) && (INCLUDE_ALL_JavaIoPipedInputStream || defined(INCLUDE_JavaIoPipedInputStream))
#define JavaIoPipedInputStream_

#define RESTRICT_JavaIoInputStream 1
#define INCLUDE_JavaIoInputStream 1
#include "java/io/InputStream.h"

@class IOSByteArray;
@class JavaIoPipedOutputStream;

/*!
 @brief Receives information from a communications pipe.When two threads want to
  pass data back and forth, one creates a piped output stream and the other one
  creates a piped input stream.
 - seealso: PipedOutputStream
 */
@interface JavaIoPipedInputStream : JavaIoInputStream {
 @public
  /*!
   @brief The circular buffer through which data is passed.Data is read from the
  range <code>[out, in)</code> and written to the range <code>[in, out)</code>.
   Data in the buffer is either sequential: @code

      { - - - X X X X X X X - - - - - }
              ^             ^
              |             |
             out           in
@endcode
  ...or wrapped around the buffer's end: @code

      { X X X X - - - - - - - - X X X }
                ^               ^
                |               |
               in              out
@endcode
  When the buffer is empty, <code>in == -1</code>. Reading when the buffer is
  empty will block until data is available. When the buffer is full, 
 <code>in == out</code>. Writing when the buffer is full will block until free
  space is available.
   */
  IOSByteArray *buffer_;
  /*!
   @brief The index in <code>buffer</code> where the next byte will be written.
   */
  jint in_;
  /*!
   @brief The index in <code>buffer</code> where the next byte will be read.
   */
  jint out_;
  /*!
   @brief Indicates if this pipe is connected.
   */
  jboolean isConnected_;
}
@property (readonly, class) jint PIPE_SIZE NS_SWIFT_NAME(PIPE_SIZE);

+ (jint)PIPE_SIZE;

#pragma mark Public

/*!
 @brief Constructs a new unconnected <code>PipedInputStream</code>.The resulting
  stream must be connected to a <code>PipedOutputStream</code> before data may
  be read from it.
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs a new unconnected <code>PipedInputStream</code> with the given
  buffer size.The resulting stream must be connected to a 
 <code>PipedOutputStream</code> before data may be read from it.
 @param pipeSize the size of the buffer in bytes.
 @throw IllegalArgumentExceptionif pipeSize is less than or equal to zero.
 @since 1.6
 */
- (instancetype __nonnull)initWithInt:(jint)pipeSize;

/*!
 @brief Constructs a new <code>PipedInputStream</code> connected to the 
 <code>PipedOutputStream</code> <code>out</code>.Any data written to the output
  stream can be read from the this input stream.
 @param outArg the piped output stream to connect to.
 @throw IOException
 if this stream or <code>out</code> are already connected.
 */
- (instancetype __nonnull)initWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)outArg;

/*!
 @brief Constructs a new <code>PipedInputStream</code> connected to the given <code>PipedOutputStream</code>,
  with the given buffer size.Any data written to the output stream can be read from this
  input stream.
 @param outArg the <code>PipedOutputStream</code>  to connect to.
 @param pipeSize the size of the buffer in bytes.
 @throw IOExceptionif an I/O error occurs.
 @throw IllegalArgumentExceptionif pipeSize is less than or equal to zero.
 @since 1.6
 */
- (instancetype __nonnull)initWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)outArg
                                                  withInt:(jint)pipeSize;

/*!
 @brief <p>Unlike most streams, <code>PipedInputStream</code> returns 0 rather than throwing 
 <code>IOException</code> if the stream has been closed.
 Unconnected and broken pipes also
  return 0.
 @throw IOExceptionif an I/O error occurs
 */
- (jint)available;

/*!
 @brief Closes this stream.This implementation releases the buffer used for the
  pipe and notifies all threads waiting to read or write.
 @throw IOException
 if an error occurs while closing this stream.
 */
- (void)close;

/*!
 @brief Connects this <code>PipedInputStream</code> to a <code>PipedOutputStream</code>.
 Any data written to the output stream becomes readable in this input
  stream.
 @param src the source output stream.
 @throw IOException
 if either stream is already connected.
 */
- (void)connectWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)src;

/*!
 @brief Reads a single byte from this stream and returns it as an integer in the
  range from 0 to 255.Returns -1 if the end of this stream has been
  reached.
 If there is no data in the pipe, this method blocks until data
  is available, the end of the stream is detected or an exception is
  thrown. 
 <p>
  Separate threads should be used to read from a <code>PipedInputStream</code>
  and to write to the connected <code>PipedOutputStream</code>. If the same
  thread is used, a deadlock may occur.
 @return the byte read or -1 if the end of the source stream has been
          reached.
 @throw IOException
 if this stream is closed or not connected to an output
              stream, or if the thread writing to the connected output
              stream is no longer alive.
 */
- (jint)read;

/*!
 @brief Reads at most <code>byteCount</code> bytes from this stream and stores them in the
  byte array <code>bytes</code> starting at <code>offset</code>.Blocks until at
  least one byte has been read, the end of the stream is detected or an
  exception is thrown.
 <p>
  Separate threads should be used to read from a <code>PipedInputStream</code>
  and to write to the connected <code>PipedOutputStream</code>. If the same
  thread is used, a deadlock may occur.
 @return the number of bytes actually read or -1 if the end of the stream
          has been reached.
 @throw IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>byteCount < 0</code>, or if <code>offset + byteCount</code>
  is greater than the size of <code>bytes</code>.
 @throw InterruptedIOException
 if the thread reading from this stream is interrupted.
 @throw IOException
 if this stream is closed or not connected to an output
              stream, or if the thread writing to the connected output
              stream is no longer alive.
 @throw NullPointerException
 if <code>bytes</code> is <code>null</code>.
 */
- (jint)readWithByteArray:(IOSByteArray *)bytes
                  withInt:(jint)offset
                  withInt:(jint)byteCount;

#pragma mark Protected

/*!
 @brief Receives a byte and stores it in this stream's <code>buffer</code>.This
  method is called by <code>PipedOutputStream.write(int)</code>.
 The least
  significant byte of the integer <code>oneByte</code> is stored at index 
 <code>in</code> in the <code>buffer</code>.
  <p>
  This method blocks as long as <code>buffer</code> is full.
 @param oneByte the byte to store in this pipe.
 @throw InterruptedIOException
 if the <code>buffer</code> is full and the thread that has called
              this method is interrupted.
 @throw IOException
 if this stream is closed or the thread that has last read
              from this stream is no longer alive.
 */
- (void)receiveWithInt:(jint)oneByte;

#pragma mark Package-Private

- (void)done;

/*!
 @brief Establishes the connection to the PipedOutputStream.
 @throw IOException
 If this Reader is already connected.
 */
- (void)establishConnection;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoPipedInputStream)

J2OBJC_FIELD_SETTER(JavaIoPipedInputStream, buffer_, IOSByteArray *)

/*!
 @brief The size of the default pipe in bytes.
 */
inline jint JavaIoPipedInputStream_get_PIPE_SIZE(void);
#define JavaIoPipedInputStream_PIPE_SIZE 1024
J2OBJC_STATIC_FIELD_CONSTANT(JavaIoPipedInputStream, PIPE_SIZE, jint)

FOUNDATION_EXPORT void JavaIoPipedInputStream_init(JavaIoPipedInputStream *self);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_init(void);

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedInputStream *self, JavaIoPipedOutputStream *outArg);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedOutputStream *outArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedOutputStream *outArg);

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithInt_(JavaIoPipedInputStream *self, jint pipeSize);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithInt_(jint pipeSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_initWithInt_(jint pipeSize);

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedInputStream *self, JavaIoPipedOutputStream *outArg, jint pipeSize);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedOutputStream *outArg, jint pipeSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedOutputStream *outArg, jint pipeSize);

J2OBJC_TYPE_LITERAL_HEADER(JavaIoPipedInputStream)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaIoPipedInputStream")
