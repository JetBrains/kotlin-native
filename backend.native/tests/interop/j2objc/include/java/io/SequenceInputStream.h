//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/io/SequenceInputStream.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaIoSequenceInputStream")
#ifdef RESTRICT_JavaIoSequenceInputStream
#define INCLUDE_ALL_JavaIoSequenceInputStream 0
#else
#define INCLUDE_ALL_JavaIoSequenceInputStream 1
#endif
#undef RESTRICT_JavaIoSequenceInputStream

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaIoSequenceInputStream_) && (INCLUDE_ALL_JavaIoSequenceInputStream || defined(INCLUDE_JavaIoSequenceInputStream))
#define JavaIoSequenceInputStream_

#define RESTRICT_JavaIoInputStream 1
#define INCLUDE_JavaIoInputStream 1
#include "java/io/InputStream.h"

@class IOSByteArray;
@protocol JavaUtilEnumeration;

/*!
 @brief A <code>SequenceInputStream</code> represents
  the logical concatenation of other input
  streams.It starts out with an ordered
  collection of input streams and reads from
  the first one until end of file is reached,
  whereupon it reads from the second one,
  and so on, until end of file is reached
  on the last of the contained input streams.
 @author Author van Hoff
 @since JDK1.0
 */
@interface JavaIoSequenceInputStream : JavaIoInputStream {
 @public
  id<JavaUtilEnumeration> e_;
  JavaIoInputStream *in_;
}

#pragma mark Public

/*!
 @brief Initializes a newly created <code>SequenceInputStream</code>
  by remembering the argument, which must
  be an <code>Enumeration</code>  that produces
  objects whose run-time type is <code>InputStream</code>.
 The input streams that are  produced by
  the enumeration will be read, in order,
  to provide the bytes to be read  from this 
 <code>SequenceInputStream</code>. After
  each input stream from the enumeration
  is exhausted, it is closed by calling its 
 <code>close</code> method.
 @param e an enumeration of input streams.
 - seealso: java.util.Enumeration
 */
- (instancetype __nonnull)initWithJavaUtilEnumeration:(id<JavaUtilEnumeration>)e;

/*!
 @brief Initializes a newly
  created <code>SequenceInputStream</code>
  by remembering the two arguments, which
  will be read in order, first <code>s1</code>
  and then <code>s2</code>, to provide the
  bytes to be read from this <code>SequenceInputStream</code>.
 @param s1 the first input stream to read.
 @param s2 the second input stream to read.
 */
- (instancetype __nonnull)initWithJavaIoInputStream:(JavaIoInputStream *)s1
                              withJavaIoInputStream:(JavaIoInputStream *)s2;

/*!
 @brief Returns an estimate of the number of bytes that can be read (or
  skipped over) from the current underlying input stream without
  blocking by the next invocation of a method for the current
  underlying input stream.The next invocation might be
  the same thread or another thread.
 A single read or skip of this
  many bytes will not block, but may read or skip fewer bytes. 
 <p>
  This method simply calls <code>available</code> of the current underlying
  input stream and returns the result.
 @return an estimate of the number of bytes that can be read (or
          skipped over) from the current underlying input stream
          without blocking or <code>0</code> if this input stream
          has been closed by invoking its <code>close()</code> method
 @throw IOExceptionif an I/O error occurs.
 @since JDK1.1
 */
- (jint)available;

/*!
 @brief Closes this input stream and releases any system resources
  associated with the stream.
 A closed <code>SequenceInputStream</code>
  cannot  perform input operations and cannot
  be reopened. 
 <p>
  If this stream was created
  from an enumeration, all remaining elements
  are requested from the enumeration and closed
  before the <code>close</code> method returns.
 @throw IOExceptionif an I/O error occurs.
 */
- (void)close;

/*!
 @brief Reads the next byte of data from this input stream.The byte is
  returned as an <code>int</code> in the range <code>0</code> to 
 <code>255</code>.
 If no byte is available because the end of the
  stream has been reached, the value <code>-1</code> is returned.
  This method blocks until input data is available, the end of the
  stream is detected, or an exception is thrown. 
 <p>
  This method
  tries to read one character from the current substream. If it
  reaches the end of the stream, it calls the <code>close</code>
  method of the current substream and begins reading from the next
  substream.
 @return the next byte of data, or <code>-1</code> if the end of the
              stream is reached.
 @throw IOExceptionif an I/O error occurs.
 */
- (jint)read;

/*!
 @brief Reads up to <code>len</code> bytes of data from this input stream
  into an array of bytes.If <code>len</code> is not zero, the method
  blocks until at least 1 byte of input is available; otherwise, no
  bytes are read and <code>0</code> is returned.
 <p>
  The <code>read</code> method of <code>SequenceInputStream</code>
  tries to read the data from the current substream. If it fails to
  read any characters because the substream has reached the end of
  the stream, it calls the <code>close</code> method of the current
  substream and begins reading from the next substream.
 @param b the buffer into which the data is read.
 @param off the start offset in array  <code> b </code>
                     at which the data is written.
 @param len the maximum number of bytes read.
 @return int   the number of bytes read.
 @throw NullPointerExceptionIf <code>b</code> is <code>null</code>.
 @throw IndexOutOfBoundsExceptionIf <code>off</code> is negative, 
 <code>len</code> is negative, or <code>len</code> is greater than 
 <code>b.length - off</code>
 @throw IOExceptionif an I/O error occurs.
 */
- (jint)readWithByteArray:(IOSByteArray *)b
                  withInt:(jint)off
                  withInt:(jint)len;

#pragma mark Package-Private

/*!
 @brief Continues reading in the next stream if an EOF is reached.
 */
- (void)nextStream;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoSequenceInputStream)

J2OBJC_FIELD_SETTER(JavaIoSequenceInputStream, e_, id<JavaUtilEnumeration>)
J2OBJC_FIELD_SETTER(JavaIoSequenceInputStream, in_, JavaIoInputStream *)

FOUNDATION_EXPORT void JavaIoSequenceInputStream_initWithJavaUtilEnumeration_(JavaIoSequenceInputStream *self, id<JavaUtilEnumeration> e);

FOUNDATION_EXPORT JavaIoSequenceInputStream *new_JavaIoSequenceInputStream_initWithJavaUtilEnumeration_(id<JavaUtilEnumeration> e) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoSequenceInputStream *create_JavaIoSequenceInputStream_initWithJavaUtilEnumeration_(id<JavaUtilEnumeration> e);

FOUNDATION_EXPORT void JavaIoSequenceInputStream_initWithJavaIoInputStream_withJavaIoInputStream_(JavaIoSequenceInputStream *self, JavaIoInputStream *s1, JavaIoInputStream *s2);

FOUNDATION_EXPORT JavaIoSequenceInputStream *new_JavaIoSequenceInputStream_initWithJavaIoInputStream_withJavaIoInputStream_(JavaIoInputStream *s1, JavaIoInputStream *s2) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoSequenceInputStream *create_JavaIoSequenceInputStream_initWithJavaIoInputStream_withJavaIoInputStream_(JavaIoInputStream *s1, JavaIoInputStream *s2);

J2OBJC_TYPE_LITERAL_HEADER(JavaIoSequenceInputStream)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaIoSequenceInputStream")
