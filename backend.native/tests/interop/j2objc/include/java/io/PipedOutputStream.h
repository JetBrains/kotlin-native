//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/io/PipedOutputStream.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaIoPipedOutputStream")
#ifdef RESTRICT_JavaIoPipedOutputStream
#define INCLUDE_ALL_JavaIoPipedOutputStream 0
#else
#define INCLUDE_ALL_JavaIoPipedOutputStream 1
#endif
#undef RESTRICT_JavaIoPipedOutputStream

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaIoPipedOutputStream_) && (INCLUDE_ALL_JavaIoPipedOutputStream || defined(INCLUDE_JavaIoPipedOutputStream))
#define JavaIoPipedOutputStream_

#define RESTRICT_JavaIoOutputStream 1
#define INCLUDE_JavaIoOutputStream 1
#include "java/io/OutputStream.h"

@class IOSByteArray;
@class JavaIoPipedInputStream;

/*!
 @brief Places information on a communications pipe.When two threads want to pass
  data back and forth, one creates a piped output stream and the other one
  creates a piped input stream.
 - seealso: PipedInputStream
 */
@interface JavaIoPipedOutputStream : JavaIoOutputStream

#pragma mark Public

/*!
 @brief Constructs a new unconnected <code>PipedOutputStream</code>.The resulting
  stream must be connected to a <code>PipedInputStream</code> before data can be
  written to it.
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs a new <code>PipedOutputStream</code> connected to the 
 <code>PipedInputStream</code> <code>target</code>.Any data written to this stream
  can be read from the target stream.
 @param target the piped input stream to connect to.
 @throw IOException
 if this stream or <code>target</code> are already connected.
 */
- (instancetype __nonnull)initWithJavaIoPipedInputStream:(JavaIoPipedInputStream *)target;

/*!
 @brief Closes this stream.If this stream is connected to an input stream, the
  input stream is closed and the pipe is disconnected.
 @throw IOException
 if an error occurs while closing this stream.
 */
- (void)close;

/*!
 @brief Connects this stream to a <code>PipedInputStream</code>.Any data written to
  this output stream becomes readable in the input stream.
 @param stream the piped input stream to connect to.
 @throw IOException
 if either stream is already connected.
 */
- (void)connectWithJavaIoPipedInputStream:(JavaIoPipedInputStream *)stream;

/*!
 @brief Notifies the readers of this <code>PipedInputStream</code> that bytes can be
  read.This method does nothing if this stream is not connected.
 @throw IOException
 if an I/O error occurs while flushing this stream.
 */
- (void)flush;

/*!
 @brief Writes <code>count</code> bytes from the byte array <code>buffer</code> starting at 
 <code>offset</code> to this stream.The written data can then be read from the
  connected input stream.
 <p>
  Separate threads should be used to write to a <code>PipedOutputStream</code>
  and to read from the connected <code>PipedInputStream</code>. If the same
  thread is used, a deadlock may occur.
 @param buffer the buffer to write.
 @param offset the index of the first byte in 
 <code>buffer</code>  to write.
 @param count the number of bytes from 
 <code>buffer</code>  to write to this             stream.
 @throw IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>count < 0</code>, or if <code>offset + count</code>
  is bigger than the length of <code>buffer</code>.
 @throw InterruptedIOException
 if the pipe is full and the current thread is interrupted
              waiting for space to write data. This case is not currently
              handled correctly.
 @throw IOException
 if this stream is not connected, if the target stream is
              closed or if the thread reading from the target stream is no
              longer alive. This case is currently not handled correctly.
 */
- (void)writeWithByteArray:(IOSByteArray *)buffer
                   withInt:(jint)offset
                   withInt:(jint)count;

/*!
 @brief Writes a single byte to this stream.Only the least significant byte of
  the integer <code>oneByte</code> is written.
 The written byte can then be read
  from the connected input stream. 
 <p>
  Separate threads should be used to write to a <code>PipedOutputStream</code>
  and to read from the connected <code>PipedInputStream</code>. If the same
  thread is used, a deadlock may occur.
 @param oneByte the byte to write.
 @throw InterruptedIOException
 if the pipe is full and the current thread is interrupted
              waiting for space to write data. This case is not currently
              handled correctly.
 @throw IOException
 if this stream is not connected, if the target stream is
              closed or if the thread reading from the target stream is no
              longer alive. This case is currently not handled correctly.
 */
- (void)writeWithInt:(jint)oneByte;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoPipedOutputStream)

FOUNDATION_EXPORT void JavaIoPipedOutputStream_init(JavaIoPipedOutputStream *self);

FOUNDATION_EXPORT JavaIoPipedOutputStream *new_JavaIoPipedOutputStream_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedOutputStream *create_JavaIoPipedOutputStream_init(void);

FOUNDATION_EXPORT void JavaIoPipedOutputStream_initWithJavaIoPipedInputStream_(JavaIoPipedOutputStream *self, JavaIoPipedInputStream *target);

FOUNDATION_EXPORT JavaIoPipedOutputStream *new_JavaIoPipedOutputStream_initWithJavaIoPipedInputStream_(JavaIoPipedInputStream *target) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedOutputStream *create_JavaIoPipedOutputStream_initWithJavaIoPipedInputStream_(JavaIoPipedInputStream *target);

J2OBJC_TYPE_LITERAL_HEADER(JavaIoPipedOutputStream)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaIoPipedOutputStream")
