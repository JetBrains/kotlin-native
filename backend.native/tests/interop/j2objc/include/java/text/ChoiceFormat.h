//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/text/ChoiceFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTextChoiceFormat")
#ifdef RESTRICT_JavaTextChoiceFormat
#define INCLUDE_ALL_JavaTextChoiceFormat 0
#else
#define INCLUDE_ALL_JavaTextChoiceFormat 1
#endif
#undef RESTRICT_JavaTextChoiceFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTextChoiceFormat_) && (INCLUDE_ALL_JavaTextChoiceFormat || defined(INCLUDE_JavaTextChoiceFormat))
#define JavaTextChoiceFormat_

#define RESTRICT_JavaTextNumberFormat 1
#define INCLUDE_JavaTextNumberFormat 1
#include "java/text/NumberFormat.h"

@class IOSDoubleArray;
@class IOSObjectArray;
@class JavaLangStringBuffer;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;

/*!
 @brief A <code>ChoiceFormat</code> allows you to attach a format to a range of numbers.
 It is generally used in a <code>MessageFormat</code> for handling plurals.
  The choice is specified with an ascending list of doubles, where each item
  specifies a half-open interval up to the next item: 
 <blockquote>
  @code

  X matches j if and only if limit[j] &lt;= X &lt; limit[j+1] 
  
@endcode
  </blockquote>
  If there is no match, then either the first or last index is used, depending
  on whether the number (X) is too low or too high.  If the limit array is not
  in ascending order, the results of formatting will be incorrect.  ChoiceFormat
  also accepts <code>&#92;u221E</code> as equivalent to infinity(INF). 
 <p>
  <strong>Note:</strong>
  <code>ChoiceFormat</code> differs from the other <code>Format</code>
  classes in that you create a <code>ChoiceFormat</code> object with a
  constructor (not with a <code>getInstance</code> style factory
  method). The factory methods aren't necessary because <code>ChoiceFormat</code>
  doesn't require any complex setup for a given locale. In fact, 
 <code>ChoiceFormat</code> doesn't implement any locale specific behavior. 
 <p>
  When creating a <code>ChoiceFormat</code>, you must specify an array of formats
  and an array of limits. The length of these arrays must be the same.
  For example, 
 <ul>
  <li>
      <em>limits</em> = {1,2,3,4,5,6,7}<br>
      <em>formats</em> = {"Sun","Mon","Tue","Wed","Thur","Fri","Sat"} 
 <li>
      <em>limits</em> = {0, 1, ChoiceFormat.nextDouble(1)}<br>
      <em>formats</em> = {"no files", "one file", "many files"}<br>
      (<code>nextDouble</code> can be used to get the next higher double, to
      make the half-open interval.) 
 </ul>
  
 <p>
  Here is a simple example that shows formatting and parsing: 
 <blockquote>
  @code

  double[] limits = {1,2,3,4,5,6,7};
  String[] dayOfWeekNames = {"Sun","Mon","Tue","Wed","Thur","Fri","Sat"};
  ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
  ParsePosition status = new ParsePosition(0);
  for (double i = 0.0; i &lt;= 8.0; ++i) {
      status.setIndex(0);
      System.out.println(i + " -&gt; " + form.format(i) + " -&gt; "
                               + form.parse(form.format(i),status));
  } 
  
@endcode
  </blockquote>
  Here is a more complex example, with a pattern format: 
 <blockquote>
  @code

  double[] filelimits = {0,1,2};
  String[] filepart = {"are no files","is one file","are {2} files"};
  ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
  Format[] testFormats = {fileform, null, NumberFormat.getInstance()};
  MessageFormat pattform = new MessageFormat("There {0} on {1}");
  pattform.setFormats(testFormats);
  Object[] testArgs = {null, "ADisk", null};
  for (int i = 0; i &lt; 4; ++i) {
      testArgs[0] = new Integer(i);
      testArgs[2] = testArgs[0];
      System.out.println(pattform.format(testArgs));
  } 
  
@endcode
  </blockquote>
  <p>
  Specifying a pattern for ChoiceFormat objects is fairly straightforward.
  For example: 
 <blockquote>
  @code

  ChoiceFormat fmt = new ChoiceFormat(
       "-1#is negative| 0#is zero or fraction | 1#is one |1.0&lt;is 1+ |2#is two |2&lt;is more than 2.");
  System.out.println("Formatter Pattern : " + fmt.toPattern());
  System.out.println("Format with -INF : " + fmt.format(Double.NEGATIVE_INFINITY));
  System.out.println("Format with -1.0 : " + fmt.format(-1.0));
  System.out.println("Format with 0 : " + fmt.format(0));
  System.out.println("Format with 0.9 : " + fmt.format(0.9));
  System.out.println("Format with 1.0 : " + fmt.format(1));
  System.out.println("Format with 1.5 : " + fmt.format(1.5));
  System.out.println("Format with 2 : " + fmt.format(2));
  System.out.println("Format with 2.1 : " + fmt.format(2.1));
  System.out.println("Format with NaN : " + fmt.format(Double.NaN));
  System.out.println("Format with +INF : " + fmt.format(Double.POSITIVE_INFINITY)); 
  
@endcode
  </blockquote>
  And the output result would be like the following: 
 <blockquote>
  @code

    Format with -INF : is negative
    Format with -1.0 : is negative
    Format with 0 : is zero or fraction
    Format with 0.9 : is zero or fraction
    Format with 1.0 : is one
    Format with 1.5 : is 1+
    Format with 2 : is two
    Format with 2.1 : is more than 2.
    Format with NaN : is negative
    Format with +INF : is more than 2. 
  
@endcode
  </blockquote>
  
 <h4><a name="synchronization">Synchronization</a></h4>
  
 <p>
  Choice formats are not synchronized.
  It is recommended to create separate format instances for each thread.
  If multiple threads access a format concurrently, it must be synchronized
  externally.
 - seealso: DecimalFormat
 - seealso: MessageFormat
 @author Mark Davis
 */
@interface JavaTextChoiceFormat : JavaTextNumberFormat
@property (readonly, class) jlong SIGN NS_SWIFT_NAME(SIGN);
@property (readonly, class) jlong EXPONENT NS_SWIFT_NAME(EXPONENT);
@property (readonly, class) jlong POSITIVEINFINITY NS_SWIFT_NAME(POSITIVEINFINITY);

+ (jlong)SIGN;

+ (jlong)EXPONENT;

+ (jlong)POSITIVEINFINITY;

#pragma mark Public

/*!
 @brief Constructs with the limits and the corresponding formats.
 - seealso: #setChoices
 */
- (instancetype __nonnull)initWithDoubleArray:(IOSDoubleArray *)limits
                            withNSStringArray:(IOSObjectArray *)formats;

/*!
 @brief Constructs with limits and corresponding formats based on the pattern.
 - seealso: #applyPattern
 */
- (instancetype __nonnull)initWithNSString:(NSString *)newPattern;

/*!
 @brief Sets the pattern.
 @param newPattern See the class description.
 */
- (void)applyPatternWithNSString:(NSString *)newPattern;

/*!
 @brief Overrides Cloneable
 */
- (id)java_clone;

/*!
 @brief Equality comparision between two
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns pattern with formatted double.
 @param number number to be formatted  &  substituted.
 @param toAppendTo where text is appended.
 @param status ignore no useful status is returned.
 */
- (JavaLangStringBuffer *)formatWithDouble:(jdouble)number
                  withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                 withJavaTextFieldPosition:(JavaTextFieldPosition *)status;

/*!
 @brief Specialization of format.This method really calls 
 <code>format(double, StringBuffer, FieldPosition)</code>
  thus the range of longs that are supported is only equal to
  the range that can be stored by double.
 This will never be
  a practical limitation.
 */
- (JavaLangStringBuffer *)formatWithLong:(jlong)number
                withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
               withJavaTextFieldPosition:(JavaTextFieldPosition *)status;

/*!
 @brief Get the formats passed in the constructor.
 @return the formats.
 */
- (IOSObjectArray *)getFormats;

/*!
 @brief Get the limits passed in the constructor.
 @return the limits.
 */
- (IOSDoubleArray *)getLimits;

/*!
 @brief Generates a hash code for the message format object.
 */
- (NSUInteger)hash;

/*!
 @brief Finds the least double greater than d.
 If NaN, returns same value. 
 <p>Used to make half-open intervals.
 - seealso: #previousDouble
 */
+ (jdouble)nextDoubleWithDouble:(jdouble)d;

/*!
 @brief Finds the least double greater than d (if positive == true),
  or the greatest double less than d (if positive == false).
 If NaN, returns same value.
  Does not affect floating-point flags,
  provided these member functions do not:
           Double.longBitsToDouble(long)
           Double.doubleToLongBits(double)
           Double.isNaN(double)
 */
+ (jdouble)nextDoubleWithDouble:(jdouble)d
                    withBoolean:(jboolean)positive;

/*!
 @brief Parses a Number from the input text.
 @param text the source text.
 @param status an input-output parameter.  On input, the  status.index field indicates the first character of the
   source text that should be parsed.  On exit, if no error
   occured, status.index is set to the first unparsed character
   in the source text.  On exit, if an error did occur,
   status.index is unchanged and status.errorIndex is set to the
   first index of the character that caused the parse to fail.
 @return A Number representing the value of the number parsed.
 */
- (NSNumber *)parseWithNSString:(NSString *)text
      withJavaTextParsePosition:(JavaTextParsePosition *)status;

/*!
 @brief Finds the greatest double less than d.
 If NaN, returns same value.
 - seealso: #nextDouble
 */
+ (jdouble)previousDoubleWithDouble:(jdouble)d;

/*!
 @brief Set the choices to be used in formatting.
 @param limits contains the top value that you want  parsed with that format,and should be in ascending sorted order. When
   formatting X, the choice will be the i, where
   limit[i]  &lt; = X  &lt;  limit[i+1].  If the limit array is not in ascending order, the results of formatting  will be incorrect.
 @param formats are the formats you want to use for each limit.  They can be either Format objects or Strings.
   When formatting with object Y,
   if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
   is called. Otherwise Y.toString() is called.
 */
- (void)setChoicesWithDoubleArray:(IOSDoubleArray *)limits
                withNSStringArray:(IOSObjectArray *)formats;

/*!
 @brief Gets the pattern.
 */
- (NSString *)toPattern;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextChoiceFormat)

inline jlong JavaTextChoiceFormat_get_SIGN(void);
#define JavaTextChoiceFormat_SIGN ((jlong) 0x8000000000000000LL)
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextChoiceFormat, SIGN, jlong)

inline jlong JavaTextChoiceFormat_get_EXPONENT(void);
#define JavaTextChoiceFormat_EXPONENT 9218868437227405312LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextChoiceFormat, EXPONENT, jlong)

inline jlong JavaTextChoiceFormat_get_POSITIVEINFINITY(void);
#define JavaTextChoiceFormat_POSITIVEINFINITY 9218868437227405312LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextChoiceFormat, POSITIVEINFINITY, jlong)

FOUNDATION_EXPORT void JavaTextChoiceFormat_initWithNSString_(JavaTextChoiceFormat *self, NSString *newPattern);

FOUNDATION_EXPORT JavaTextChoiceFormat *new_JavaTextChoiceFormat_initWithNSString_(NSString *newPattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextChoiceFormat *create_JavaTextChoiceFormat_initWithNSString_(NSString *newPattern);

FOUNDATION_EXPORT void JavaTextChoiceFormat_initWithDoubleArray_withNSStringArray_(JavaTextChoiceFormat *self, IOSDoubleArray *limits, IOSObjectArray *formats);

FOUNDATION_EXPORT JavaTextChoiceFormat *new_JavaTextChoiceFormat_initWithDoubleArray_withNSStringArray_(IOSDoubleArray *limits, IOSObjectArray *formats) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextChoiceFormat *create_JavaTextChoiceFormat_initWithDoubleArray_withNSStringArray_(IOSDoubleArray *limits, IOSObjectArray *formats);

FOUNDATION_EXPORT jdouble JavaTextChoiceFormat_nextDoubleWithDouble_(jdouble d);

FOUNDATION_EXPORT jdouble JavaTextChoiceFormat_previousDoubleWithDouble_(jdouble d);

FOUNDATION_EXPORT jdouble JavaTextChoiceFormat_nextDoubleWithDouble_withBoolean_(jdouble d, jboolean positive);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextChoiceFormat)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTextChoiceFormat")
