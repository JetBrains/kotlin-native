//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/text/Format.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTextFormat")
#ifdef RESTRICT_JavaTextFormat
#define INCLUDE_ALL_JavaTextFormat 0
#else
#define INCLUDE_ALL_JavaTextFormat 1
#endif
#undef RESTRICT_JavaTextFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTextFormat_) && (INCLUDE_ALL_JavaTextFormat || defined(INCLUDE_JavaTextFormat))
#define JavaTextFormat_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@class JavaLangStringBuffer;
@class JavaTextAttributedCharacterIterator_Attribute;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@protocol JavaTextAttributedCharacterIterator;

/*!
 @brief <code>Format</code> is an abstract base class for formatting locale-sensitive
  information such as dates, messages, and numbers.
 <p>
  <code>Format</code> defines the programming interface for formatting
  locale-sensitive objects into <code>String</code>s (the 
 <code>format</code> method) and for parsing <code>String</code>s back
  into objects (the <code>parseObject</code> method). 
 <p>
  Generally, a format's <code>parseObject</code> method must be able to parse
  any string formatted by its <code>format</code> method. However, there may
  be exceptional cases where this is not possible. For example, a 
 <code>format</code> method might create two adjacent integer numbers with
  no separator in between, and in this case the <code>parseObject</code> could
  not tell which digits belong to which number. 
 <h4>Subclassing</h4>
  
 <p>
  The Java Platform provides three specialized subclasses of <code>Format</code>--
  <code>DateFormat</code>, <code>MessageFormat</code>, and 
 <code>NumberFormat</code>--for formatting dates, messages, and numbers,
  respectively. 
 <p>
  Concrete subclasses must implement three methods: 
 <ol>
  <li> <code>format(Object obj, StringBuffer toAppendTo, FieldPosition pos)</code>
  <li> <code>formatToCharacterIterator(Object obj)</code>
  <li> <code>parseObject(String source, ParsePosition pos)</code>
  </ol>
  These general methods allow polymorphic parsing and formatting of objects
  and are used, for example, by <code>MessageFormat</code>.
  Subclasses often also provide additional <code>format</code> methods for
  specific input types as well as <code>parse</code> methods for specific
  result types. Any <code>parse</code> method that does not take a 
 <code>ParsePosition</code> argument should throw <code>ParseException</code>
  when no text in the required format is at the beginning of the input text. 
 <p>
  Most subclasses will also implement the following factory methods: 
 <ol>
  <li>
  <code>getInstance</code> for getting a useful format object appropriate
  for the current locale 
 <li>
  <code>getInstance(Locale)</code> for getting a useful format
  object appropriate for the specified locale 
 </ol>
  In addition, some subclasses may also implement other 
 <code>getXxxxInstance</code> methods for more specialized control. For
  example, the <code>NumberFormat</code> class provides 
 <code>getPercentInstance</code> and <code>getCurrencyInstance</code>
  methods for getting specialized number formatters. 
 <p>
  Subclasses of <code>Format</code> that allow programmers to create objects
  for locales (with <code>getInstance(Locale)</code> for example)
  must also implement the following class method: 
 <blockquote>
  @code

  public static Locale[] getAvailableLocales() 
  
@endcode
  </blockquote>
  
 <p>
  And finally subclasses may define a set of constants to identify the various
  fields in the formatted output. These constants are used to create a FieldPosition
  object which identifies what information is contained in the field and its
  position in the formatted result. These constants should be named 
 <code><em>item</em>_FIELD</code> where <code><em>item</em></code> identifies
  the field. For examples of these constants, see <code>ERA_FIELD</code> and its
  friends in <code>DateFormat</code>.
  
 <h4><a name="synchronization">Synchronization</a></h4>
  
 <p>
  Formats are generally not synchronized.
  It is recommended to create separate format instances for each thread.
  If multiple threads access a format concurrently, it must be synchronized
  externally.
 - seealso: java.text.ParsePosition
 - seealso: java.text.FieldPosition
 - seealso: java.text.NumberFormat
 - seealso: java.text.DateFormat
 - seealso: java.text.MessageFormat
 @author Mark Davis
 */
@interface JavaTextFormat : NSObject < JavaIoSerializable, NSCopying >

#pragma mark Public

/*!
 @brief Creates and returns a copy of this object.
 @return a clone of this instance.
 */
- (id)java_clone;

/*!
 @brief Formats an object to produce a string.This is equivalent to 
 <blockquote>
  <code>format</code><code>(obj,
          new StringBuffer(), new FieldPosition(0)).toString();</code>
  </blockquote>
 @param obj The object to format
 @return Formatted string.
 @throw IllegalArgumentExceptionif the Format cannot format the given
             object
 */
- (NSString *)formatWithId:(id)obj;

/*!
 @brief Formats an object and appends the resulting text to a given string
  buffer.
 If the <code>pos</code> argument identifies a field used by the format,
  then its indices are set to the beginning and end of the first such
  field encountered.
 @param obj The object to format
 @param toAppendTo where the text is to be appended
 @param pos A  <code> FieldPosition </code>  identifying a field
                 in the formatted text
 @return the string buffer passed in as <code>toAppendTo</code>,
                with formatted text appended
 @throw NullPointerExceptionif <code>toAppendTo</code> or
             <code>pos</code> is null
 @throw IllegalArgumentExceptionif the Format cannot format the given
             object
 */
- (JavaLangStringBuffer *)formatWithId:(id)obj
              withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Formats an Object producing an <code>AttributedCharacterIterator</code>.
 You can use the returned <code>AttributedCharacterIterator</code>
  to build the resulting String, as well as to determine information
  about the resulting String. 
 <p>
  Each attribute key of the AttributedCharacterIterator will be of type 
 <code>Field</code>. It is up to each <code>Format</code> implementation
  to define what the legal values are for each attribute in the 
 <code>AttributedCharacterIterator</code>, but typically the attribute
  key is also used as the attribute value. 
 <p>The default implementation creates an 
 <code>AttributedCharacterIterator</code> with no attributes. Subclasses
  that support fields should override this and create an 
 <code>AttributedCharacterIterator</code> with meaningful attributes.
 @throw NullPointerExceptionif obj is null.
 @throw IllegalArgumentExceptionwhen the Format cannot format the
             given object.
 @param obj The object to format
 @return AttributedCharacterIterator describing the formatted value.
 @since 1.4
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)obj;

/*!
 @brief Parses text from the beginning of the given string to produce an object.
 The method may not use the entire text of the given string.
 @param source A  <code> String </code>  whose beginning should be parsed.
 @return An <code>Object</code> parsed from the string.
 @throw ParseExceptionif the beginning of the specified string
             cannot be parsed.
 */
- (id)parseObjectWithNSString:(NSString *)source;

/*!
 @brief Parses text from a string to produce an object.
 <p>
  The method attempts to parse text starting at the index given by 
 <code>pos</code>.
  If parsing succeeds, then the index of <code>pos</code> is updated
  to the index after the last character used (parsing does not necessarily
  use all characters up to the end of the string), and the parsed
  object is returned. The updated <code>pos</code> can be used to
  indicate the starting point for the next call to this method.
  If an error occurs, then the index of <code>pos</code> is not
  changed, the error index of <code>pos</code> is set to the index of
  the character where the error occurred, and null is returned.
 @param source A  <code> String </code> , part of which should be parsed.
 @param pos A  <code> ParsePosition </code>  object with index and error
              index information as described above.
 @return An <code>Object</code> parsed from the string. In case of
          error, returns null.
 @throw NullPointerExceptionif <code>pos</code> is null.
 */
- (id)parseObjectWithNSString:(NSString *)source
    withJavaTextParsePosition:(JavaTextParsePosition *)pos;

#pragma mark Protected

/*!
 @brief Sole constructor.
 (For invocation by subclass constructors, typically
  implicit.)
 */
- (instancetype __nonnull)init;

#pragma mark Package-Private

/*!
 @brief Creates an AttributedCharacterIterator with the contents of 
 <code>iterator</code> and the additional attribute <code>key</code>
  <code>value</code>.
 @param iterator Initial AttributedCharacterIterator to add arg to
 @param key Key for AttributedCharacterIterator
 @param value Value associated with key in AttributedCharacterIterator
 @return AttributedCharacterIterator wrapping args
 */
- (id<JavaTextAttributedCharacterIterator>)createAttributedCharacterIteratorWithJavaTextAttributedCharacterIterator:(id<JavaTextAttributedCharacterIterator>)iterator
                                                                  withJavaTextAttributedCharacterIterator_Attribute:(JavaTextAttributedCharacterIterator_Attribute *)key
                                                                                                             withId:(id)value;

/*!
 @brief Creates an <code>AttributedCharacterIterator</code> containg the
  concatenated contents of the passed in 
 <code>AttributedCharacterIterator</code>s.
 @param iterators AttributedCharacterIterators used to create resulting                   AttributedCharacterIterators
 @return AttributedCharacterIterator wrapping passed in
          AttributedCharacterIterators
 */
- (id<JavaTextAttributedCharacterIterator>)createAttributedCharacterIteratorWithJavaTextAttributedCharacterIteratorArray:(IOSObjectArray *)iterators;

/*!
 @brief Creates an <code>AttributedCharacterIterator</code> for the String 
 <code>s</code>.
 @param s String to create AttributedCharacterIterator from
 @return AttributedCharacterIterator wrapping s
 */
- (id<JavaTextAttributedCharacterIterator>)createAttributedCharacterIteratorWithNSString:(NSString *)s;

/*!
 @brief Returns an AttributedCharacterIterator with the String 
 <code>string</code> and additional key/value pair <code>key</code>,
  <code>value</code>.
 @param string String to create AttributedCharacterIterator from
 @param key Key for AttributedCharacterIterator
 @param value Value associated with key in AttributedCharacterIterator
 @return AttributedCharacterIterator wrapping args
 */
- (id<JavaTextAttributedCharacterIterator>)createAttributedCharacterIteratorWithNSString:(NSString *)string
                                       withJavaTextAttributedCharacterIterator_Attribute:(JavaTextAttributedCharacterIterator_Attribute *)key
                                                                                  withId:(id)value;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextFormat)

FOUNDATION_EXPORT void JavaTextFormat_init(JavaTextFormat *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextFormat)

#endif

#if !defined (JavaTextFormat_Field_) && (INCLUDE_ALL_JavaTextFormat || defined(INCLUDE_JavaTextFormat_Field))
#define JavaTextFormat_Field_

#define RESTRICT_JavaTextAttributedCharacterIterator 1
#define INCLUDE_JavaTextAttributedCharacterIterator_Attribute 1
#include "java/text/AttributedCharacterIterator.h"

/*!
 @brief Defines constants that are used as attribute keys in the 
 <code>AttributedCharacterIterator</code> returned
  from <code>Format.formatToCharacterIterator</code> and as
  field identifiers in <code>FieldPosition</code>.
 @since 1.4
 */
@interface JavaTextFormat_Field : JavaTextAttributedCharacterIterator_Attribute

#pragma mark Protected

/*!
 @brief Creates a Field with the specified name.
 @param name Name of the attribute
 */
- (instancetype __nonnull)initWithNSString:(NSString *)name;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextFormat_Field)

FOUNDATION_EXPORT void JavaTextFormat_Field_initWithNSString_(JavaTextFormat_Field *self, NSString *name);

FOUNDATION_EXPORT JavaTextFormat_Field *new_JavaTextFormat_Field_initWithNSString_(NSString *name) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextFormat_Field *create_JavaTextFormat_Field_initWithNSString_(NSString *name);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextFormat_Field)

#endif

#if !defined (JavaTextFormat_FieldDelegate_) && (INCLUDE_ALL_JavaTextFormat || defined(INCLUDE_JavaTextFormat_FieldDelegate))
#define JavaTextFormat_FieldDelegate_

@class JavaLangStringBuffer;
@class JavaTextFormat_Field;

/*!
 @brief FieldDelegate is notified by the various <code>Format</code>
  implementations as they are formatting the Objects.This allows for
  storage of the individual sections of the formatted String for
  later use, such as in a <code>FieldPosition</code> or for an 
 <code>AttributedCharacterIterator</code>.
 <p>
  Delegates should NOT assume that the <code>Format</code> will notify
  the delegate of fields in any particular order.
 - seealso: FieldPosition.Delegate
 - seealso: CharacterIteratorFieldDelegate
 */
@protocol JavaTextFormat_FieldDelegate < JavaObject >

/*!
 @brief Notified when a particular region of the String is formatted.This
  method will be invoked if there is no corresponding integer field id
  matching <code>attr</code>.
 @param attr Identifies the field matched
 @param value Value associated with the field
 @param start Beginning location of the field, will be  > = 0
 @param end End of the field, will be  > = start and  < = buffer.length()
 @param buffer Contains current formatted value, receiver should         NOT modify it.
 */
- (void)formattedWithJavaTextFormat_Field:(JavaTextFormat_Field *)attr
                                   withId:(id)value
                                  withInt:(jint)start
                                  withInt:(jint)end
                 withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer;

/*!
 @brief Notified when a particular region of the String is formatted.
 @param fieldID Identifies the field by integer
 @param attr Identifies the field matched
 @param value Value associated with the field
 @param start Beginning location of the field, will be  > = 0
 @param end End of the field, will be  > = start and  < = buffer.length()
 @param buffer Contains current formatted value, receiver should         NOT modify it.
 */
- (void)formattedWithInt:(jint)fieldID
withJavaTextFormat_Field:(JavaTextFormat_Field *)attr
                  withId:(id)value
                 withInt:(jint)start
                 withInt:(jint)end
withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextFormat_FieldDelegate)

J2OBJC_TYPE_LITERAL_HEADER(JavaTextFormat_FieldDelegate)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTextFormat")
