//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/text/MessageFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTextMessageFormat")
#ifdef RESTRICT_JavaTextMessageFormat
#define INCLUDE_ALL_JavaTextMessageFormat 0
#else
#define INCLUDE_ALL_JavaTextMessageFormat 1
#endif
#undef RESTRICT_JavaTextMessageFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTextMessageFormat_) && (INCLUDE_ALL_JavaTextMessageFormat || defined(INCLUDE_JavaTextMessageFormat))
#define JavaTextMessageFormat_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat 1
#include "java/text/Format.h"

@class IOSObjectArray;
@class JavaLangStringBuffer;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@class JavaUtilLocale;
@protocol JavaTextAttributedCharacterIterator;

/*!
 @brief <code>MessageFormat</code> provides a means to produce concatenated
  messages in a language-neutral way.Use this to construct messages
  displayed for end users.
 <p>
  <code>MessageFormat</code> takes a set of objects, formats them, then
  inserts the formatted strings into the pattern at the appropriate places. 
 <p>
  <strong>Note:</strong>
  <code>MessageFormat</code> differs from the other <code>Format</code>
  classes in that you create a <code>MessageFormat</code> object with one
  of its constructors (not with a <code>getInstance</code> style factory
  method). The factory methods aren't necessary because <code>MessageFormat</code>
  itself doesn't implement locale specific behavior. Any locale specific
  behavior is defined by the pattern that you provide as well as the
  subformats used for inserted arguments. 
 <h4><a name="patterns">Patterns and Their Interpretation</a></h4>
  
 <code>MessageFormat</code> uses patterns of the following form: 
 <blockquote>@code

   <i>MessageFormatPattern:</i>
                  <i>String</i>
                  <i>MessageFormatPattern</i> <i>FormatElement</i> <i>String</i>
  
  <i>FormatElement:</i>
          { <i>ArgumentIndex</i> }
          { <i>ArgumentIndex</i> , <i>FormatType</i> }
          { <i>ArgumentIndex</i> , <i>FormatType</i> , <i>FormatStyle</i> } 
  <i>FormatType: one of </i>
          number date time choice 
  <i>FormatStyle:</i>
          short
          medium
          long
          full
          integer
          currency
          percent         
         <i>SubformatPattern</i>
   
@endcode</blockquote>
  
 <p>Within a <i>String</i>, a pair of single quotes can be used to
  quote any arbitrary characters except single quotes. For example,
  pattern string <code>"'{0}'"</code> represents string 
 <code>"{0}"</code>, not a <i>FormatElement</i>. A single quote itself
  must be represented by doubled single quotes <code>''</code> throughout a 
 <i>String</i>.  For example, pattern string <code>"'{''}'"</code> is
  interpreted as a sequence of <code>'{</code> (start of quoting and a
  left curly brace), <code>''</code> (a single quote), and 
 <code>}'</code> (a right curly brace and end of quoting), 
 <em>not</em> <code>'{'</code> and <code>'}'</code> (quoted left and
  right curly braces): representing string <code>"{'}"</code>,
  <em>not</em> <code>"{}"</code>.
  
 <p>A <i>SubformatPattern</i> is interpreted by its corresponding
  subformat, and subformat-dependent pattern rules apply. For example,
  pattern string <code>"{1,number,<u>$'#',##</u>}"</code>
  (<i>SubformatPattern</i> with underline) will produce a number format
  with the pound-sign quoted, with a result such as: <code>"$#31,45"</code>
 . Refer to each <code>Format</code> subclass documentation for
  details. 
 <p>Any unmatched quote is treated as closed at the end of the given
  pattern. For example, pattern string <code>"'{0}"</code> is treated as
  pattern <code>"'{0}'"</code>.
  
 <p>Any curly braces within an unquoted pattern must be balanced. For
  example, <code>"ab {0} de"</code> and <code>"ab '}' de"</code> are
  valid patterns, but <code>"ab {0'}' de"</code>, <code>"ab } de"</code>
  and <code>"''{''"</code> are not. 
 <p>
  <dl><dt><b>Warning:</b><dd>The rules for using quotes within message
  format patterns unfortunately have shown to be somewhat confusing.
  In particular, it isn't always obvious to localizers whether single
  quotes need to be doubled or not. Make sure to inform localizers about
  the rules, and tell them (for example, by using comments in resource
  bundle source files) which strings will be processed by <code>MessageFormat</code>.
  Note that localizers may need to use single quotes in translated
  strings where the original version doesn't have them. 
 </dl>
  <p>
  The <i>ArgumentIndex</i> value is a non-negative integer written
  using the digits <code>'0'</code> through <code>'9'</code>, and represents an index into the 
 <code>arguments</code> array passed to the <code>format</code> methods
  or the result array returned by the <code>parse</code> methods. 
 <p>
  The <i>FormatType</i> and <i>FormatStyle</i> values are used to create
  a <code>Format</code> instance for the format element. The following
  table shows how the values map to <code>Format</code> instances. Combinations not
  shown in the table are illegal. A <i>SubformatPattern</i> must
  be a valid pattern string for the <code>Format</code> subclass used. 
 <p>
  <table border=1 summary="Shows how FormatType and FormatStyle values map to Format instances">
     <tr>
        <th id="ft" class="TableHeadingColor">FormatType
        <th id="fs" class="TableHeadingColor">FormatStyle
        <th id="sc" class="TableHeadingColor">Subformat Created
     <tr>
        <td headers="ft"><i>(none)</i>
        <td headers="fs"><i>(none)</i>
        <td headers="sc"><code>null</code>
     <tr>
        <td headers="ft" rowspan=5><code>number</code>
        <td headers="fs"><i>(none)</i>
        <td headers="sc"><code>NumberFormat.getInstance</code><code>(getLocale())</code>
     <tr>
        <td headers="fs"><code>integer</code>
        <td headers="sc"><code>NumberFormat.getIntegerInstance</code><code>(getLocale())</code>
     <tr>
        <td headers="fs"><code>currency</code>
        <td headers="sc"><code>NumberFormat.getCurrencyInstance</code><code>(getLocale())</code>
     <tr>
        <td headers="fs"><code>percent</code>
        <td headers="sc"><code>NumberFormat.getPercentInstance</code><code>(getLocale())</code>
     <tr>
        <td headers="fs"><i>SubformatPattern</i>
        <td headers="sc"><code>new</code> <code>DecimalFormat</code><code>(subformatPattern,</code> <code>DecimalFormatSymbols.getInstance</code><code>(getLocale()))</code>
     <tr>
        <td headers="ft" rowspan=6><code>date</code>
        <td headers="fs"><i>(none)</i>
        <td headers="sc"><code>DateFormat.getDateInstance</code><code>(</code><code>DateFormat.DEFAULT</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>short</code>
        <td headers="sc"><code>DateFormat.getDateInstance</code><code>(</code><code>DateFormat.SHORT</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>medium</code>
        <td headers="sc"><code>DateFormat.getDateInstance</code><code>(</code><code>DateFormat.DEFAULT</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>long</code>
        <td headers="sc"><code>DateFormat.getDateInstance</code><code>(</code><code>DateFormat.LONG</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>full</code>
        <td headers="sc"><code>DateFormat.getDateInstance</code><code>(</code><code>DateFormat.FULL</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><i>SubformatPattern</i>
        <td headers="sc"><code>new</code> <code>SimpleDateFormat</code><code>(subformatPattern, getLocale())</code>
     <tr>
        <td headers="ft" rowspan=6><code>time</code>
        <td headers="fs"><i>(none)</i>
        <td headers="sc"><code>DateFormat.getTimeInstance</code><code>(</code><code>DateFormat.DEFAULT</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>short</code>
        <td headers="sc"><code>DateFormat.getTimeInstance</code><code>(</code><code>DateFormat.SHORT</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>medium</code>
        <td headers="sc"><code>DateFormat.getTimeInstance</code><code>(</code><code>DateFormat.DEFAULT</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>long</code>
        <td headers="sc"><code>DateFormat.getTimeInstance</code><code>(</code><code>DateFormat.LONG</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><code>full</code>
        <td headers="sc"><code>DateFormat.getTimeInstance</code><code>(</code><code>DateFormat.FULL</code><code>, getLocale())</code>
     <tr>
        <td headers="fs"><i>SubformatPattern</i>
        <td headers="sc"><code>new</code> <code>SimpleDateFormat</code><code>(subformatPattern, getLocale())</code>
     <tr>
        <td headers="ft"><code>choice</code>
        <td headers="fs"><i>SubformatPattern</i>
        <td headers="sc"><code>new</code> <code>ChoiceFormat</code><code>(subformatPattern)</code>
  </table>
  <p>
  
 <h4>Usage Information</h4>
  
 <p>
  Here are some examples of usage.
  In real internationalized programs, the message format pattern and other
  static strings will, of course, be obtained from resource bundles.
  Other parameters will be dynamically determined at runtime. 
 <p>
  The first example uses the static method <code>MessageFormat.format</code>,
  which internally creates a <code>MessageFormat</code> for one-time use: 
 <blockquote>@code

  int planet = 7;
  String event = "a disturbance in the Force";
  String result = MessageFormat.format(
      "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
      planet, new Date(), event); 
  
@endcode</blockquote>
  The output is: 
 <blockquote>@code

  At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7. 
  
@endcode</blockquote>
  
 <p>
  The following example creates a <code>MessageFormat</code> instance that
  can be used repeatedly: 
 <blockquote>@code

  int fileCount = 1273;
  String diskName = "MyDisk";
  Object[] testArgs = {new Long(fileCount), diskName};
  MessageFormat form = new MessageFormat(
      "The disk \"{1}\" contains {0} file(s).");
  System.out.println(form.format(testArgs)); 
  
@endcode</blockquote>
  The output with different values for <code>fileCount</code>:
  <blockquote>@code

  The disk "MyDisk" contains 0 file(s).
  The disk "MyDisk" contains 1 file(s).
  The disk "MyDisk" contains 1,273 file(s). 
  
@endcode</blockquote>
  
 <p>
  For more sophisticated patterns, you can use a <code>ChoiceFormat</code>
  to produce correct forms for singular and plural: 
 <blockquote>@code

  MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
  double[] filelimits = {0,1,2};
  String[] filepart = {"no files","one file","{0,number} files"};
  ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
  form.setFormatByArgumentIndex(0, fileform);
  int fileCount = 1273;
  String diskName = "MyDisk";
  Object[] testArgs = {new Long(fileCount), diskName};
  System.out.println(form.format(testArgs)); 
  
@endcode</blockquote>
  The output with different values for <code>fileCount</code>:
  <blockquote>@code

  The disk "MyDisk" contains no files.
  The disk "MyDisk" contains one file.
  The disk "MyDisk" contains 1,273 files. 
  
@endcode</blockquote>
  
 <p>
  You can create the <code>ChoiceFormat</code> programmatically, as in the
  above example, or by using a pattern. See <code>ChoiceFormat</code>
  for more information. 
 <blockquote>@code

  form.applyPattern(
     "There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}."); 
  
@endcode</blockquote>
  
 <p>
  <strong>Note:</strong> As we see above, the string produced
  by a <code>ChoiceFormat</code> in <code>MessageFormat</code> is treated as special;
  occurrences of '{' are used to indicate subformats, and cause recursion.
  If you create both a <code>MessageFormat</code> and <code>ChoiceFormat</code>
  programmatically (instead of using the string patterns), then be careful not to
  produce a format that recurses on itself, which will cause an infinite loop. 
 <p>
  When a single argument is parsed more than once in the string, the last match
  will be the final result of the parsing.  For example, 
 <blockquote>@code

  MessageFormat mf = new MessageFormat("{0,number,#.##}, {0,number,#.#}");
  Object[] objs = {new Double(3.1415)};
  String result = mf.format( objs );
  // result now equals "3.14, 3.1"
  objs = null;
  objs = mf.parse(result, new ParsePosition(0));
  // objs now equals {new Double(3.1)} 
  
@endcode</blockquote>
  
 <p>
  Likewise, parsing with a <code>MessageFormat</code> object using patterns containing
  multiple occurrences of the same argument would return the last match.  For
  example, 
 <blockquote>@code

  MessageFormat mf = new MessageFormat("{0}, {0}, {0}");
  String forParsing = "x, y, z";
  Object[] objs = mf.parse(forParsing, new ParsePosition(0));
  // result now equals {new String("z")} 
  
@endcode</blockquote>
  
 <h4><a name="synchronization">Synchronization</a></h4>
  
 <p>
  Message formats are not synchronized.
  It is recommended to create separate format instances for each thread.
  If multiple threads access a format concurrently, it must be synchronized
  externally.
 - seealso: java.util.Locale
 - seealso: Format
 - seealso: NumberFormat
 - seealso: DecimalFormat
 - seealso: DecimalFormatSymbols
 - seealso: ChoiceFormat
 - seealso: DateFormat
 - seealso: SimpleDateFormat
 @author Mark Davis
 */
@interface JavaTextMessageFormat : JavaTextFormat

#pragma mark Public

/*!
 @brief Constructs a MessageFormat for the default locale and the
  specified pattern.
 The constructor first sets the locale, then parses the pattern and
  creates a list of subformats for the format elements contained in it.
  Patterns and their interpretation are specified in the 
 <a href="#patterns">class description</a>.
 @param pattern the pattern for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern;

/*!
 @brief Constructs a MessageFormat for the specified locale and
  pattern.
 The constructor first sets the locale, then parses the pattern and
  creates a list of subformats for the format elements contained in it.
  Patterns and their interpretation are specified in the 
 <a href="#patterns">class description</a>.
 @param pattern the pattern for this message format
 @param locale the locale for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 @since 1.4
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                        withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Sets the pattern used by this message format.
 The method parses the pattern and creates a list of subformats
  for the format elements contained in it.
  Patterns and their interpretation are specified in the 
 <a href="#patterns">class description</a>.
 @param pattern the pattern for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 */
- (void)applyPatternWithNSString:(NSString *)pattern;

/*!
 @brief Creates and returns a copy of this object.
 @return a clone of this instance.
 */
- (id)java_clone;

/*!
 @brief Equality comparison between two message format objects
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Formats an array of objects and appends the <code>MessageFormat</code>'s
  pattern, with format elements replaced by the formatted objects, to the
  provided <code>StringBuffer</code>.
 This is equivalent to 
 <blockquote>
      <code><code>format</code>((Object[]) arguments, result, pos)</code>
  </blockquote>
 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired.             On output: the offsets of the alignment field.
 @throw IllegalArgumentExceptionif an argument in the
             <code>arguments</code> array is not of the type
             expected by the format element(s) that use it.
 */
- (JavaLangStringBuffer *)formatWithId:(id)arguments
              withJavaLangStringBuffer:(JavaLangStringBuffer *)result
             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Formats an array of objects and appends the <code>MessageFormat</code>'s
  pattern, with format elements replaced by the formatted objects, to the
  provided <code>StringBuffer</code>.
 <p>
  The text substituted for the individual format elements is derived from
  the current subformat of the format element and the 
 <code>arguments</code> element at the format element's argument index
  as indicated by the first matching line of the following table. An
  argument is <i>unavailable</i> if <code>arguments</code> is 
 <code>null</code> or has fewer than argumentIndex+1 elements. 
 <p>
  <table border=1 summary="Examples of subformat,argument,and formatted text">
     <tr>
        <th>Subformat
        <th>Argument
        <th>Formatted Text
     <tr>
        <td><i>any</i>
        <td><i>unavailable</i>
        <td><code>"{" + argumentIndex + "}"</code>
     <tr>
        <td><i>any</i>
        <td><code>null</code>
        <td><code>"null"</code>
     <tr>
        <td><code>instanceof ChoiceFormat</code>
        <td><i>any</i>
        <td><code>subformat.format(argument).indexOf('{') >= 0 ?<br>
            (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
            subformat.format(argument)</code>
     <tr>
        <td><code>!= null</code>
        <td><i>any</i>
        <td><code>subformat.format(argument)</code>
     <tr>
        <td><code>null</code>
        <td><code>instanceof Number</code>
        <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>
     <tr>
        <td><code>null</code>
        <td><code>instanceof Date</code>
        <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)</code>
     <tr>
        <td><code>null</code>
        <td><code>instanceof String</code>
        <td><code>argument</code>
     <tr>
        <td><code>null</code>
        <td><i>any</i>
        <td><code>argument.toString()</code>
  </table>
  <p>
  If <code>pos</code> is non-null, and refers to 
 <code>Field.ARGUMENT</code>, the location of the first formatted
  string will be returned.
 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired.             On output: the offsets of the alignment field.
 @throw IllegalArgumentExceptionif an argument in the
             <code>arguments</code> array is not of the type
             expected by the format element(s) that use it.
 */
- (JavaLangStringBuffer *)formatWithNSObjectArray:(IOSObjectArray *)arguments
                         withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                        withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Creates a MessageFormat with the given pattern and uses it
  to format the given arguments.This is equivalent to 
 <blockquote>
      <code>(new <code>MessageFormat</code>(pattern)).
 <code>format</code>(arguments, new StringBuffer(), null).toString()</code>
  </blockquote>
 @throw IllegalArgumentExceptionif the pattern is invalid,
             or if an argument in the <code>arguments</code> array
             is not of the type expected by the format element(s)
             that use it.
 */
+ (NSString *)formatWithNSString:(NSString *)pattern
               withNSObjectArray:(IOSObjectArray *)arguments;

/*!
 @brief Formats an array of objects and inserts them into the 
 <code>MessageFormat</code>'s pattern, producing an 
 <code>AttributedCharacterIterator</code>.
 You can use the returned <code>AttributedCharacterIterator</code>
  to build the resulting String, as well as to determine information
  about the resulting String. 
 <p>
  The text of the returned <code>AttributedCharacterIterator</code> is
  the same that would be returned by 
 <blockquote>
      <code><code>format</code>(arguments, new StringBuffer(), null).toString()</code>
  </blockquote>
  <p>
  In addition, the <code>AttributedCharacterIterator</code> contains at
  least attributes indicating where text was generated from an
  argument in the <code>arguments</code> array. The keys of these attributes are of
  type <code>MessageFormat.Field</code>, their values are 
 <code>Integer</code> objects indicating the index in the <code>arguments</code>
  array of the argument from which the text was generated. 
 <p>
  The attributes/value from the underlying <code>Format</code>
  instances that <code>MessageFormat</code> uses will also be
  placed in the resulting <code>AttributedCharacterIterator</code>.
  This allows you to not only find where an argument is placed in the
  resulting String, but also which fields it contains in turn.
 @param arguments an array of objects to be formatted and substituted.
 @return AttributedCharacterIterator describing the formatted value.
 @throw NullPointerExceptionif <code>arguments</code> is null.
 @throw IllegalArgumentExceptionif an argument in the
             <code>arguments</code> array is not of the type
             expected by the format element(s) that use it.
 @since 1.4
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)arguments;

/*!
 @brief Gets the formats used for the format elements in the
  previously set pattern string.
 The order of formats in the returned array corresponds to
  the order of format elements in the pattern string. 
 <p>
  Since the order of format elements in a pattern string often
  changes during localization, it's generally better to use the 
 <code>getFormatsByArgumentIndex</code>
  method, which assumes an order of formats corresponding to the
  order of elements in the <code>arguments</code> array passed to
  the <code>format</code> methods or the result array returned by the 
 <code>parse</code> methods.
 @return the formats used for the format elements in the pattern
 */
- (IOSObjectArray *)getFormats;

/*!
 @brief Gets the formats used for the values passed into 
 <code>format</code> methods or returned from <code>parse</code>
  methods.The indices of elements in the returned array
  correspond to the argument indices used in the previously set
  pattern string.
 The order of formats in the returned array thus corresponds to
  the order of elements in the <code>arguments</code> array passed
  to the <code>format</code> methods or the result array returned
  by the <code>parse</code> methods. 
 <p>
  If an argument index is used for more than one format element
  in the pattern string, then the format used for the last such
  format element is returned in the array. If an argument index
  is not used for any format element in the pattern string, then
  null is returned in the array.
 @return the formats used for the arguments within the pattern
 @since 1.4
 */
- (IOSObjectArray *)getFormatsByArgumentIndex;

/*!
 @brief Gets the locale that's used when creating or comparing subformats.
 @return the locale used when creating or comparing subformats
 */
- (JavaUtilLocale *)getLocale;

/*!
 @brief Generates a hash code for the message format object.
 */
- (NSUInteger)hash;

/*!
 @brief Parses text from the beginning of the given string to produce an object
  array.
 The method may not use the entire text of the given string. 
 <p>
  See the <code>parse(String, ParsePosition)</code> method for more information
  on message parsing.
 @param source A  <code> String </code>  whose beginning should be parsed.
 @return An <code>Object</code> array parsed from the string.
 @throw ParseExceptionif the beginning of the specified string
             cannot be parsed.
 */
- (IOSObjectArray *)parseWithNSString:(NSString *)source;

/*!
 @brief Parses the string.
 <p>Caveats: The parse may fail in a number of circumstances.
  For example: 
 <ul>
  <li>If one of the arguments does not occur in the pattern. 
 <li>If the format of an argument loses information, such as
      with a choice format where a large number formats to "many". 
 <li>Does not yet handle recursion (where
      the substituted strings contain {n} references.) 
 <li>Will not always find a match (or the correct match)
      if some part of the parse is ambiguous.
      For example, if the pattern "{1},{2}" is used with the
      string arguments {"a,b", "c"}, it will format as "a,b,c".
      When the result is parsed, it will return {"a", "b,c"}. 
 <li>If a single argument is parsed more than once in the string,
      then the later parse wins. 
 </ul>
  When the parse fails, use ParsePosition.getErrorIndex() to find out
  where in the string the parsing failed.  The returned error
  index is the starting offset of the sub-patterns that the string
  is comparing with.  For example, if the parsing string "AAA {0} BBB"
  is comparing against the pattern "AAD {0} BBB", the error index is
  0. When an error occurs, the call to this method will return null.
  If the source is null, return an empty array.
 */
- (IOSObjectArray *)parseWithNSString:(NSString *)source
            withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Parses text from a string to produce an object array.
 <p>
  The method attempts to parse text starting at the index given by 
 <code>pos</code>.
  If parsing succeeds, then the index of <code>pos</code> is updated
  to the index after the last character used (parsing does not necessarily
  use all characters up to the end of the string), and the parsed
  object array is returned. The updated <code>pos</code> can be used to
  indicate the starting point for the next call to this method.
  If an error occurs, then the index of <code>pos</code> is not
  changed, the error index of <code>pos</code> is set to the index of
  the character where the error occurred, and null is returned. 
 <p>
  See the <code>parse(String, ParsePosition)</code> method for more information
  on message parsing.
 @param source A  <code> String </code> , part of which should be parsed.
 @param pos A  <code> ParsePosition </code>  object with index and error
              index information as described above.
 @return An <code>Object</code> array parsed from the string. In case of
          error, returns null.
 @throw NullPointerExceptionif <code>pos</code> is null.
 */
- (id)parseObjectWithNSString:(NSString *)source
    withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Sets the format to use for the format element with the given
  format element index within the previously set pattern string.
 The format element index is the zero-based number of the format
  element counting from the start of the pattern string. 
 <p>
  Since the order of format elements in a pattern string often
  changes during localization, it is generally better to use the 
 <code>setFormatByArgumentIndex</code>
  method, which accesses format elements based on the argument
  index they specify.
 @param formatElementIndex the index of a format element within the pattern
 @param newFormat the format to use for the specified format element
 @throw ArrayIndexOutOfBoundsExceptionif <code>formatElementIndex</code> is equal to or
             larger than the number of format elements in the pattern string
 */
- (void)setFormatWithInt:(jint)formatElementIndex
      withJavaTextFormat:(JavaTextFormat *)newFormat;

/*!
 @brief Sets the format to use for the format elements within the
  previously set pattern string that use the given argument
  index.
 The argument index is part of the format element definition and
  represents an index into the <code>arguments</code> array passed
  to the <code>format</code> methods or the result array returned
  by the <code>parse</code> methods. 
 <p>
  If the argument index is used for more than one format element
  in the pattern string, then the new format is used for all such
  format elements. If the argument index is not used for any format
  element in the pattern string, then the new format is ignored.
 @param argumentIndex the argument index for which to use the new format
 @param newFormat the new format to use
 @since 1.4
 */
- (void)setFormatByArgumentIndexWithInt:(jint)argumentIndex
                     withJavaTextFormat:(JavaTextFormat *)newFormat;

/*!
 @brief Sets the formats to use for the format elements in the
  previously set pattern string.
 The order of formats in <code>newFormats</code> corresponds to
  the order of format elements in the pattern string. 
 <p>
  If more formats are provided than needed by the pattern string,
  the remaining ones are ignored. If fewer formats are provided
  than needed, then only the first <code>newFormats.length</code>
  formats are replaced. 
 <p>
  Since the order of format elements in a pattern string often
  changes during localization, it is generally better to use the 
 <code>setFormatsByArgumentIndex</code>
  method, which assumes an order of formats corresponding to the
  order of elements in the <code>arguments</code> array passed to
  the <code>format</code> methods or the result array returned by the 
 <code>parse</code> methods.
 @param newFormats the new formats to use
 @throw NullPointerExceptionif <code>newFormats</code> is null
 */
- (void)setFormatsWithJavaTextFormatArray:(IOSObjectArray *)newFormats;

/*!
 @brief Sets the formats to use for the values passed into 
 <code>format</code> methods or returned from <code>parse</code>
  methods.The indices of elements in <code>newFormats</code>
  correspond to the argument indices used in the previously set
  pattern string.
 The order of formats in <code>newFormats</code> thus corresponds to
  the order of elements in the <code>arguments</code> array passed
  to the <code>format</code> methods or the result array returned
  by the <code>parse</code> methods. 
 <p>
  If an argument index is used for more than one format element
  in the pattern string, then the corresponding new format is used
  for all such format elements. If an argument index is not used
  for any format element in the pattern string, then the
  corresponding new format is ignored. If fewer formats are provided
  than needed, then only the formats for argument indices less than 
 <code>newFormats.length</code> are replaced.
 @param newFormats the new formats to use
 @throw NullPointerExceptionif <code>newFormats</code> is null
 @since 1.4
 */
- (void)setFormatsByArgumentIndexWithJavaTextFormatArray:(IOSObjectArray *)newFormats;

/*!
 @brief Sets the locale to be used when creating or comparing subformats.
 This affects subsequent calls 
 <ul>
  <li>to the <code>applyPattern</code>
      and <code>toPattern</code> methods if format elements specify
      a format type and therefore have the subformats created in the     
 <code>applyPattern</code> method, as well as 
 <li>to the <code>format</code> and
      <code>formatToCharacterIterator</code> methods
      if format elements do not specify a format type and therefore have
      the subformats created in the formatting methods. 
 </ul>
  Subformats that have already been created are not affected.
 @param locale the locale to be used when creating or comparing subformats
 */
- (void)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns a pattern representing the current state of the message format.
 The string is constructed from internal information and therefore
  does not necessarily equal the previously applied pattern.
 @return a pattern representing the current state of the message format
 */
- (NSString *)toPattern;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTextMessageFormat)

FOUNDATION_EXPORT void JavaTextMessageFormat_initWithNSString_(JavaTextMessageFormat *self, NSString *pattern);

FOUNDATION_EXPORT JavaTextMessageFormat *new_JavaTextMessageFormat_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextMessageFormat *create_JavaTextMessageFormat_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT void JavaTextMessageFormat_initWithNSString_withJavaUtilLocale_(JavaTextMessageFormat *self, NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT JavaTextMessageFormat *new_JavaTextMessageFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextMessageFormat *create_JavaTextMessageFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT NSString *JavaTextMessageFormat_formatWithNSString_withNSObjectArray_(NSString *pattern, IOSObjectArray *arguments);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextMessageFormat)

#endif

#if !defined (JavaTextMessageFormat_Field_) && (INCLUDE_ALL_JavaTextMessageFormat || defined(INCLUDE_JavaTextMessageFormat_Field))
#define JavaTextMessageFormat_Field_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat_Field 1
#include "java/text/Format.h"

/*!
 @brief Defines constants that are used as attribute keys in the 
 <code>AttributedCharacterIterator</code> returned
  from <code>MessageFormat.formatToCharacterIterator</code>.
 @since 1.4
 */
@interface JavaTextMessageFormat_Field : JavaTextFormat_Field
@property (readonly, class, strong) JavaTextMessageFormat_Field *ARGUMENT NS_SWIFT_NAME(ARGUMENT);

+ (JavaTextMessageFormat_Field *)ARGUMENT;

#pragma mark Protected

/*!
 @brief Creates a Field with the specified name.
 @param name Name of the attribute
 */
- (instancetype __nonnull)initWithNSString:(NSString *)name;

/*!
 @brief Resolves instances being deserialized to the predefined constants.
 @throw InvalidObjectExceptionif the constant could not be
          resolved.
 @return resolved MessageFormat.Field constant
 */
- (id)readResolve;

@end

J2OBJC_STATIC_INIT(JavaTextMessageFormat_Field)

/*!
 @brief Constant identifying a portion of a message that was generated
  from an argument passed into <code>formatToCharacterIterator</code>.
 The value associated with the key will be an <code>Integer</code>
  indicating the index in the <code>arguments</code> array of the
  argument from which the text was generated.
 */
inline JavaTextMessageFormat_Field *JavaTextMessageFormat_Field_get_ARGUMENT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextMessageFormat_Field *JavaTextMessageFormat_Field_ARGUMENT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextMessageFormat_Field, ARGUMENT, JavaTextMessageFormat_Field *)

FOUNDATION_EXPORT void JavaTextMessageFormat_Field_initWithNSString_(JavaTextMessageFormat_Field *self, NSString *name);

FOUNDATION_EXPORT JavaTextMessageFormat_Field *new_JavaTextMessageFormat_Field_initWithNSString_(NSString *name) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextMessageFormat_Field *create_JavaTextMessageFormat_Field_initWithNSString_(NSString *name);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextMessageFormat_Field)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTextMessageFormat")
