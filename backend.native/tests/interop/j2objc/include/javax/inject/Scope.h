//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/inject/javax_inject/build_result/java/javax/inject/Scope.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxInjectScope")
#ifdef RESTRICT_JavaxInjectScope
#define INCLUDE_ALL_JavaxInjectScope 0
#else
#define INCLUDE_ALL_JavaxInjectScope 1
#endif
#undef RESTRICT_JavaxInjectScope

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxInjectScope_) && (INCLUDE_ALL_JavaxInjectScope || defined(INCLUDE_JavaxInjectScope))
#define JavaxInjectScope_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;

/*!
 @brief Identifies scope annotations.A scope annotation applies to a class
  containing an injectable constructor and governs how the injector reuses
  instances of the type.
 By default, if no scope annotation is present, the
  injector creates an instance (by injecting the type's constructor), uses
  the instance for one injection, and then forgets it. If a scope annotation
  is present, the injector may retain the instance for possible reuse in a
  later injection. If multiple threads can access a scoped instance, its
  implementation should be thread safe. The implementation of the scope
  itself is left up to the injector. 
 <p>In the following example, the scope annotation <code>@@Singleton</code> ensures
  that we only have one Log instance: 
 @code

      &#064;Singleton
    class Log {
      void log(String message) { ... }
    }
@endcode
   
 <p>The injector generates an error if it encounters more than one scope
  annotation on the same class or a scope annotation it doesn't support. 
 <p>A scope annotation: 
 <ul>
    <li>is annotated with <code>@@Scope</code>, <code>@@Retention(RUNTIME)</code>,
       and typically <code>@@Documented</code>.</li>
    <li>should not have attributes.</li>
    <li>is typically not <code>@@Inherited</code>, so scoping is orthogonal to
       implementation inheritance.</li>
    <li>may have restricted usage if annotated with <code>@@Target</code>. While
       this specification covers applying scopes to classes only, some 
       injector configurations might use scope annotations
       in other places (on factory method results for example).</li>
  </ul>
  
 <p>For example: 
 @code

      &#064;java.lang.annotation.Documented
      &#064;java.lang.annotation.Retention(RUNTIME)
      &#064;javax.inject.Scope
    public @@interface RequestScoped {}
@endcode
  
 <p>Annotating scope annotations with <code>@@Scope</code> helps the injector
  detect the case where a programmer used the scope annotation on a class but
  forgot to configure the scope in the injector. A conservative injector
  would generate an error rather than not apply a scope.
 - seealso: javax.inject.Singleton@@Singleton
 */
@protocol JavaxInjectScope < JavaLangAnnotationAnnotation >

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface JavaxInjectScope : NSObject < JavaxInjectScope >

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxInjectScope)

FOUNDATION_EXPORT id<JavaxInjectScope> create_JavaxInjectScope(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaxInjectScope)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaxInjectScope")
