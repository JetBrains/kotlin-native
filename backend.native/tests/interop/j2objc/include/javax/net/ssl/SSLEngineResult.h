//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/javax/net/ssl/SSLEngineResult.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxNetSslSSLEngineResult")
#ifdef RESTRICT_JavaxNetSslSSLEngineResult
#define INCLUDE_ALL_JavaxNetSslSSLEngineResult 0
#else
#define INCLUDE_ALL_JavaxNetSslSSLEngineResult 1
#endif
#undef RESTRICT_JavaxNetSslSSLEngineResult

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxNetSslSSLEngineResult_) && (INCLUDE_ALL_JavaxNetSslSSLEngineResult || defined(INCLUDE_JavaxNetSslSSLEngineResult))
#define JavaxNetSslSSLEngineResult_

@class JavaxNetSslSSLEngineResult_HandshakeStatus;
@class JavaxNetSslSSLEngineResult_Status;

/*!
 @brief An encapsulation of the result state produced by 
 <code>SSLEngine</code> I/O calls.
 <p> A <code>SSLEngine</code> provides a means for establishing
  secure communication sessions between two peers.  <code>SSLEngine</code>
  operations typically consume bytes from an input buffer and produce
  bytes in an output buffer.  This class provides operational result
  values describing the state of the <code>SSLEngine</code>, including
  indications of what operations are needed to finish an
  ongoing handshake.  Lastly, it reports the number of bytes consumed
  and produced as a result of this operation.
 - seealso: SSLEngine
 - seealso: SSLEngine#wrap(ByteBuffer, ByteBuffer)
 - seealso: SSLEngine#unwrap(ByteBuffer, ByteBuffer)
 @author Brad R. Wetmore
 @since 1.5
 */
@interface JavaxNetSslSSLEngineResult : NSObject

#pragma mark Public

/*!
 @brief Initializes a new instance of this class.
 @param status the return value of the operation.
 @param handshakeStatus the current handshaking status.
 @param bytesConsumed the number of bytes consumed from the source ByteBuffer
 @param bytesProduced the number of bytes placed into the destination ByteBuffer
 @throw IllegalArgumentException
 if the <code>status</code> or <code>handshakeStatus</code>
           arguments are null, or if <code>bytesConsumed</code> or
           <code>bytesProduced</code> is negative.
 */
- (instancetype __nonnull)initWithJavaxNetSslSSLEngineResult_Status:(JavaxNetSslSSLEngineResult_Status *)status
                     withJavaxNetSslSSLEngineResult_HandshakeStatus:(JavaxNetSslSSLEngineResult_HandshakeStatus *)handshakeStatus
                                                            withInt:(jint)bytesConsumed
                                                            withInt:(jint)bytesProduced;

/*!
 @brief Returns the number of bytes consumed from the input buffer.
 @return the number of bytes consumed.
 */
- (jint)bytesConsumed;

/*!
 @brief Returns the number of bytes written to the output buffer.
 @return the number of bytes produced
 */
- (jint)bytesProduced;

/*!
 @brief Gets the handshake status of this <code>SSLEngine</code>
  operation.
 @return the handshake status
 */
- (JavaxNetSslSSLEngineResult_HandshakeStatus *)getHandshakeStatus;

/*!
 @brief Gets the return value of this <code>SSLEngine</code> operation.
 @return the return value
 */
- (JavaxNetSslSSLEngineResult_Status *)getStatus;

/*!
 @brief Returns a String representation of this object.
 */
- (NSString *)description;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxNetSslSSLEngineResult)

FOUNDATION_EXPORT void JavaxNetSslSSLEngineResult_initWithJavaxNetSslSSLEngineResult_Status_withJavaxNetSslSSLEngineResult_HandshakeStatus_withInt_withInt_(JavaxNetSslSSLEngineResult *self, JavaxNetSslSSLEngineResult_Status *status, JavaxNetSslSSLEngineResult_HandshakeStatus *handshakeStatus, jint bytesConsumed, jint bytesProduced);

FOUNDATION_EXPORT JavaxNetSslSSLEngineResult *new_JavaxNetSslSSLEngineResult_initWithJavaxNetSslSSLEngineResult_Status_withJavaxNetSslSSLEngineResult_HandshakeStatus_withInt_withInt_(JavaxNetSslSSLEngineResult_Status *status, JavaxNetSslSSLEngineResult_HandshakeStatus *handshakeStatus, jint bytesConsumed, jint bytesProduced) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxNetSslSSLEngineResult *create_JavaxNetSslSSLEngineResult_initWithJavaxNetSslSSLEngineResult_Status_withJavaxNetSslSSLEngineResult_HandshakeStatus_withInt_withInt_(JavaxNetSslSSLEngineResult_Status *status, JavaxNetSslSSLEngineResult_HandshakeStatus *handshakeStatus, jint bytesConsumed, jint bytesProduced);

J2OBJC_TYPE_LITERAL_HEADER(JavaxNetSslSSLEngineResult)

#endif

#if !defined (JavaxNetSslSSLEngineResult_Status_) && (INCLUDE_ALL_JavaxNetSslSSLEngineResult || defined(INCLUDE_JavaxNetSslSSLEngineResult_Status))
#define JavaxNetSslSSLEngineResult_Status_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, JavaxNetSslSSLEngineResult_Status_Enum) {
  JavaxNetSslSSLEngineResult_Status_Enum_BUFFER_UNDERFLOW = 0,
  JavaxNetSslSSLEngineResult_Status_Enum_BUFFER_OVERFLOW = 1,
  JavaxNetSslSSLEngineResult_Status_Enum_OK = 2,
  JavaxNetSslSSLEngineResult_Status_Enum_CLOSED = 3,
};

/*!
 @brief An <code>SSLEngineResult</code> enum describing the overall result
  of the <code>SSLEngine</code> operation.
 The <code>Status</code> value does not reflect the
  state of a <code>SSLEngine</code> handshake currently
  in progress.  The <code>SSLEngineResult's HandshakeStatus</code>
  should be consulted for that information.
 @author Brad R. Wetmore
 @since 1.5
 */
@interface JavaxNetSslSSLEngineResult_Status : JavaLangEnum

@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_Status *BUFFER_UNDERFLOW NS_SWIFT_NAME(BUFFER_UNDERFLOW);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_Status *BUFFER_OVERFLOW NS_SWIFT_NAME(BUFFER_OVERFLOW);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_Status *OK NS_SWIFT_NAME(OK);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_Status *CLOSED NS_SWIFT_NAME(CLOSED);
+ (JavaxNetSslSSLEngineResult_Status * __nonnull)BUFFER_UNDERFLOW;

+ (JavaxNetSslSSLEngineResult_Status * __nonnull)BUFFER_OVERFLOW;

+ (JavaxNetSslSSLEngineResult_Status * __nonnull)OK;

+ (JavaxNetSslSSLEngineResult_Status * __nonnull)CLOSED;

#pragma mark Public

+ (JavaxNetSslSSLEngineResult_Status *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaxNetSslSSLEngineResult_Status_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(JavaxNetSslSSLEngineResult_Status)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_values_[];

/*!
 @brief The <code>SSLEngine</code> was not able to unwrap the
  incoming data because there were not enough source bytes
  available to make a complete packet.
 <P>
  Repeat the call once more bytes are available.
 */
inline JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_get_BUFFER_UNDERFLOW(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_Status, BUFFER_UNDERFLOW)

/*!
 @brief The <code>SSLEngine</code> was not able to process the
  operation because there are not enough bytes available in the
  destination buffer to hold the result.
 <P>
  Repeat the call once more bytes are available.
 - seealso: SSLSession#getPacketBufferSize()
 - seealso: SSLSession#getApplicationBufferSize()
 */
inline JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_get_BUFFER_OVERFLOW(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_Status, BUFFER_OVERFLOW)

/*!
 @brief The <code>SSLEngine</code> completed the operation, and
  is available to process similar calls.
 */
inline JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_get_OK(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_Status, OK)

/*!
 @brief The operation just closed this side of the 
 <code>SSLEngine</code>, or the operation
  could not be completed because it was already closed.
 */
inline JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_get_CLOSED(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_Status, CLOSED)

FOUNDATION_EXPORT IOSObjectArray *JavaxNetSslSSLEngineResult_Status_values(void);

FOUNDATION_EXPORT JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaxNetSslSSLEngineResult_Status *JavaxNetSslSSLEngineResult_Status_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaxNetSslSSLEngineResult_Status)

#endif

#if !defined (JavaxNetSslSSLEngineResult_HandshakeStatus_) && (INCLUDE_ALL_JavaxNetSslSSLEngineResult || defined(INCLUDE_JavaxNetSslSSLEngineResult_HandshakeStatus))
#define JavaxNetSslSSLEngineResult_HandshakeStatus_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, JavaxNetSslSSLEngineResult_HandshakeStatus_Enum) {
  JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NOT_HANDSHAKING = 0,
  JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_FINISHED = 1,
  JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NEED_TASK = 2,
  JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NEED_WRAP = 3,
  JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NEED_UNWRAP = 4,
};

/*!
 @brief An <code>SSLEngineResult</code> enum describing the current
  handshaking state of this <code>SSLEngine</code>.
 @author Brad R. Wetmore
 @since 1.5
 */
@interface JavaxNetSslSSLEngineResult_HandshakeStatus : JavaLangEnum

@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_HandshakeStatus *NOT_HANDSHAKING NS_SWIFT_NAME(NOT_HANDSHAKING);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_HandshakeStatus *FINISHED NS_SWIFT_NAME(FINISHED);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_HandshakeStatus *NEED_TASK NS_SWIFT_NAME(NEED_TASK);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_HandshakeStatus *NEED_WRAP NS_SWIFT_NAME(NEED_WRAP);
@property (readonly, class, nonnull) JavaxNetSslSSLEngineResult_HandshakeStatus *NEED_UNWRAP NS_SWIFT_NAME(NEED_UNWRAP);
+ (JavaxNetSslSSLEngineResult_HandshakeStatus * __nonnull)NOT_HANDSHAKING;

+ (JavaxNetSslSSLEngineResult_HandshakeStatus * __nonnull)FINISHED;

+ (JavaxNetSslSSLEngineResult_HandshakeStatus * __nonnull)NEED_TASK;

+ (JavaxNetSslSSLEngineResult_HandshakeStatus * __nonnull)NEED_WRAP;

+ (JavaxNetSslSSLEngineResult_HandshakeStatus * __nonnull)NEED_UNWRAP;

#pragma mark Public

+ (JavaxNetSslSSLEngineResult_HandshakeStatus *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaxNetSslSSLEngineResult_HandshakeStatus_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(JavaxNetSslSSLEngineResult_HandshakeStatus)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_values_[];

/*!
 @brief The <code>SSLEngine</code> is not currently handshaking.
 */
inline JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_get_NOT_HANDSHAKING(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_HandshakeStatus, NOT_HANDSHAKING)

/*!
 @brief The <code>SSLEngine</code> has just finished handshaking.
 <P>
  This value is only generated by a call to 
 <code>SSLEngine.wrap()/unwrap()</code> when that call
  finishes a handshake.  It is never generated by 
 <code>SSLEngine.getHandshakeStatus()</code>.
 - seealso: SSLEngine#wrap(ByteBuffer, ByteBuffer)
 - seealso: SSLEngine#unwrap(ByteBuffer, ByteBuffer)
 - seealso: SSLEngine#getHandshakeStatus()
 */
inline JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_get_FINISHED(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_HandshakeStatus, FINISHED)

/*!
 @brief The <code>SSLEngine</code> needs the results of one (or more)
  delegated tasks before handshaking can continue.
 - seealso: SSLEngine#getDelegatedTask()
 */
inline JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_get_NEED_TASK(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_HandshakeStatus, NEED_TASK)

/*!
 @brief The <code>SSLEngine</code> must send data to the remote side
  before handshaking can continue, so <code>SSLEngine.wrap()</code>
  should be called.
 - seealso: SSLEngine#wrap(ByteBuffer, ByteBuffer)
 */
inline JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_get_NEED_WRAP(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_HandshakeStatus, NEED_WRAP)

/*!
 @brief The <code>SSLEngine</code> needs to receive data from the
  remote side before handshaking can continue.
 */
inline JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_get_NEED_UNWRAP(void);
J2OBJC_ENUM_CONSTANT(JavaxNetSslSSLEngineResult_HandshakeStatus, NEED_UNWRAP)

FOUNDATION_EXPORT IOSObjectArray *JavaxNetSslSSLEngineResult_HandshakeStatus_values(void);

FOUNDATION_EXPORT JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaxNetSslSSLEngineResult_HandshakeStatus *JavaxNetSslSSLEngineResult_HandshakeStatus_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaxNetSslSSLEngineResult_HandshakeStatus)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaxNetSslSSLEngineResult")
