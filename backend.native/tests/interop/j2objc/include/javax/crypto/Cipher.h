//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/javax/crypto/Cipher.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxCryptoCipher")
#ifdef RESTRICT_JavaxCryptoCipher
#define INCLUDE_ALL_JavaxCryptoCipher 0
#else
#define INCLUDE_ALL_JavaxCryptoCipher 1
#endif
#undef RESTRICT_JavaxCryptoCipher

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxCryptoCipher_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher))
#define JavaxCryptoCipher_

@class IOSByteArray;
@class IOSObjectArray;
@class JavaNioByteBuffer;
@class JavaSecurityAlgorithmParameters;
@class JavaSecurityCertCertificate;
@class JavaSecurityProvider;
@class JavaSecurityProvider_Service;
@class JavaSecuritySecureRandom;
@class JavaxCryptoCipherSpi;
@class JavaxCryptoCipher_CipherSpiAndProvider;
@class JavaxCryptoCipher_InitParams;
@class JavaxCryptoCipher_NeedToSet;
@class JavaxCryptoExemptionMechanism;
@protocol JavaSecurityKey;
@protocol JavaSecuritySpecAlgorithmParameterSpec;

/*!
 @brief This class provides the functionality of a cryptographic cipher for
  encryption and decryption.It forms the core of the Java Cryptographic
  Extension (JCE) framework.
 <p>In order to create a Cipher object, the application calls the
  Cipher's <code>getInstance</code> method, and passes the name of the
  requested <i>transformation</i> to it. Optionally, the name of a provider
  may be specified. 
 <p>A <i>transformation</i> is a string that describes the operation (or
  set of operations) to be performed on the given input, to produce some
  output. A transformation always includes the name of a cryptographic
  algorithm (e.g., <i>DES</i>), and may be followed by a feedback mode and
  padding scheme. 
 <p> A transformation is of the form:<p>
  
 <ul>
  <li>"<i>algorithm/mode/padding</i>" or 
 <p>
  <li>"<i>algorithm</i>"
  </ul>
  
 <P> (in the latter case,
  provider-specific default values for the mode and padding scheme are used).
  For example, the following is a valid transformation:<p>
  
 @code

      Cipher c = Cipher.getInstance("<i>DES/CBC/PKCS5Padding</i>");
   
@endcode
  Using modes such as <code>CFB</code> and <code>OFB</code>, block
  ciphers can encrypt data in units smaller than the cipher's actual
  block size.  When requesting such a mode, you may optionally specify
  the number of bits to be processed at a time by appending this number
  to the mode name as shown in the "<code>DES/CFB8/NoPadding</code>" and
  "<code>DES/OFB32/PKCS5Padding</code>" transformations. If no such
  number is specified, a provider-specific default is used. (For
  example, the SunJCE provider uses a default of 64 bits for DES.)
  Thus, block ciphers can be turned into byte-oriented stream ciphers by
  using an 8 bit mode such as CFB8 or OFB8. 
 <p>
  Modes such as Authenticated Encryption with Associated Data (AEAD)
  provide authenticity assurances for both confidential data and
  Additional Associated Data (AAD) that is not encrypted.  (Please see 
 <a href="http://www.ietf.org/rfc/rfc5116.txt"> RFC 5116 </a> for more
  information on AEAD and AEAD algorithms such as GCM/CCM.) Both
  confidential and AAD data can be used when calculating the
  authentication tag (similar to a <code>Mac</code>).  This tag is appended
  to the ciphertext during encryption, and is verified on decryption. 
 <p>
  AEAD modes such as GCM/CCM perform all AAD authenticity calculations
  before starting the ciphertext authenticity calculations.  To avoid
  implementations having to internally buffer ciphertext, all AAD data
  must be supplied to GCM/CCM implementations (via the <code>updateAAD</code>
  methods) <b>before</b> the ciphertext is processed (via the 
 <code>update</code> and <code>doFinal</code> methods). 
 @code

      GCMParameterSpec s = new GCMParameterSpec(...);
      cipher.init(..., s);
      // If the GCMParameterSpec is needed again
      cipher.getParameters().getParameterSpec(GCMParameterSpec.class));
      cipher.updateAAD(...);  // AAD
      cipher.update(...);     // Multi-part update
      cipher.doFinal(...);    // conclusion of operation 
  
@endcode
  <p> Android provides the following <code>Cipher</code> transformations: 
 <table>
      <thead>
          <tr>
              <th>Name</th>
              <th>Supported (API Levels)</th>
          </tr>
      </thead>
          <tr>
              <td>AES/CBC/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CBC/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CBC/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CTR/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CTR/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CTR/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CTS/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CTS/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/CTS/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/ECB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/ECB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/ECB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/OFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/OFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>AES/OFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>ARCFOUR/ECB/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CBC/ISO10126Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CBC/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CBC/PKCS5Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CFB/ISO10126Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CFB/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CFB/PKCS5Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CTR/ISO10126Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CTR/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CTR/PKCS5Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CTS/ISO10126Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CTS/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/CTS/PKCS5Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/ECB/ISO10126Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/ECB/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/ECB/PKCS5Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/OFB/ISO10126Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/OFB/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>BLOWFISH/OFB/PKCS5Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>DES/CBC/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CBC/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CBC/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CTR/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CTR/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CTR/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CTS/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CTS/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/CTS/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/ECB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/ECB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/ECB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/OFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/OFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DES/OFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CBC/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CBC/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CBC/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CTR/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CTR/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CTR/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CTS/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CTS/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/CTS/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/ECB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/ECB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/ECB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/OFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/OFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>DESede/OFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CBC/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CBC/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CBC/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CTR/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CTR/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CTR/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CTS/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CTS/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/CTS/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/ECB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/ECB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/ECB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/OFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/OFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithMD5andDES/OFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CBC/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CBC/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CBC/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CTR/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CTR/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CTR/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CTS/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CTS/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/CTS/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/ECB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/ECB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/ECB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/OFB/ISO10126Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/OFB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>PBEwithSHA1andDESede/OFB/PKCS5Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>RC4/ECB/NoPadding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>RSA/ECB/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>RSA/ECB/OAEPPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>RSA/ECB/OAEPwithSHA-1andMGF1Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>RSA/ECB/OAEPwithSHA-256andMGF1Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>RSA/ECB/PKCS1Padding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>RSA/NONE/NoPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>RSA/NONE/OAEPPadding</td>
              <td>1+</td>
          </tr>
          <tr>
              <td>RSA/NONE/OAEPwithSHA-1andMGF1Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>RSA/NONE/OAEPwithSHA-256andMGF1Padding</td>
              <td>10+</td>
          </tr>
          <tr>
              <td>RSA/NONE/PKCS1Padding</td>
              <td>1+</td>
          </tr>
      </tbody>
      </tbody>
  </table>
  These transformations are described in the 
 <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Cipher">
  Cipher section</a> of the
  Java Cryptography Architecture Standard Algorithm Name Documentation.
 @author Jan Luehe
 - seealso: KeyGenerator
 - seealso: SecretKey
 @since 1.4
 */
@interface JavaxCryptoCipher : NSObject
@property (readonly, class) jint ENCRYPT_MODE NS_SWIFT_NAME(ENCRYPT_MODE);
@property (readonly, class) jint DECRYPT_MODE NS_SWIFT_NAME(DECRYPT_MODE);
@property (readonly, class) jint WRAP_MODE NS_SWIFT_NAME(WRAP_MODE);
@property (readonly, class) jint UNWRAP_MODE NS_SWIFT_NAME(UNWRAP_MODE);
@property (readonly, class) jint PUBLIC_KEY NS_SWIFT_NAME(PUBLIC_KEY);
@property (readonly, class) jint PRIVATE_KEY NS_SWIFT_NAME(PRIVATE_KEY);
@property (readonly, class) jint SECRET_KEY NS_SWIFT_NAME(SECRET_KEY);

+ (jint)ENCRYPT_MODE;

+ (jint)DECRYPT_MODE;

+ (jint)WRAP_MODE;

+ (jint)UNWRAP_MODE;

+ (jint)PUBLIC_KEY;

+ (jint)PRIVATE_KEY;

+ (jint)SECRET_KEY;

#pragma mark Public

/*!
 @brief Finishes a multiple-part encryption or decryption operation, depending
  on how this cipher was initialized.
 <p>Input data that may have been buffered during a previous 
 <code>update</code> operation is processed, with padding (if requested)
  being applied.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in a new buffer. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again.
 @return the new buffer with the result
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 */
- (IOSByteArray *)doFinal;

/*!
 @brief Encrypts or decrypts data in a single-part operation, or finishes a
  multiple-part operation.The data is encrypted or decrypted,
  depending on how this cipher was initialized.
 <p>The bytes in the <code>input</code> buffer, and any input bytes that
  may have been buffered during a previous <code>update</code> operation,
  are processed, with padding (if requested) being applied.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in a new buffer. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again.
 @param input the input buffer
 @return the new buffer with the result
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 */
- (IOSByteArray *)doFinalWithByteArray:(IOSByteArray *)input;

/*!
 @brief Finishes a multiple-part encryption or decryption operation, depending
  on how this cipher was initialized.
 <p>Input data that may have been buffered during a previous 
 <code>update</code> operation is processed, with padding (if requested)
  being applied.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in the <code>output</code> buffer, starting at 
 <code>outputOffset</code> inclusive. 
 <p>If the <code>output</code> buffer is too small to hold the result,
  a <code>ShortBufferException</code> is thrown. In this case, repeat this
  call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again.
 @param output the buffer for the result
 @param outputOffset the offset in  <code> output </code>  where the result
   is stored
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw ShortBufferExceptionif the given output buffer is too small
  to hold the result
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 */
- (jint)doFinalWithByteArray:(IOSByteArray *)output
                     withInt:(jint)outputOffset;

/*!
 @brief Encrypts or decrypts data in a single-part operation, or finishes a
  multiple-part operation.The data is encrypted or decrypted,
  depending on how this cipher was initialized.
 <p>The first <code>inputLen</code> bytes in the <code>input</code>
  buffer, starting at <code>inputOffset</code> inclusive, and any input
  bytes that may have been buffered during a previous <code>update</code>
  operation, are processed, with padding (if requested) being applied.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in a new buffer. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again.
 @param input the input buffer
 @param inputOffset the offset in  <code> input </code>  where the input
   starts
 @param inputLen the input length
 @return the new buffer with the result
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 */
- (IOSByteArray *)doFinalWithByteArray:(IOSByteArray *)input
                               withInt:(jint)inputOffset
                               withInt:(jint)inputLen;

/*!
 @brief Encrypts or decrypts data in a single-part operation, or finishes a
  multiple-part operation.The data is encrypted or decrypted,
  depending on how this cipher was initialized.
 <p>The first <code>inputLen</code> bytes in the <code>input</code>
  buffer, starting at <code>inputOffset</code> inclusive, and any input
  bytes that may have been buffered during a previous <code>update</code>
  operation, are processed, with padding (if requested) being applied.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in the <code>output</code> buffer. 
 <p>If the <code>output</code> buffer is too small to hold the result,
  a <code>ShortBufferException</code> is thrown. In this case, repeat this
  call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again. 
 <p>Note: this method should be copy-safe, which means the 
 <code>input</code> and <code>output</code> buffers can reference
  the same byte array and no unprocessed input data is overwritten
  when the result is copied into the output buffer.
 @param input the input buffer
 @param inputOffset the offset in  <code> input </code>  where the input
   starts
 @param inputLen the input length
 @param output the buffer for the result
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw ShortBufferExceptionif the given output buffer is too small
  to hold the result
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 */
- (jint)doFinalWithByteArray:(IOSByteArray *)input
                     withInt:(jint)inputOffset
                     withInt:(jint)inputLen
               withByteArray:(IOSByteArray *)output;

/*!
 @brief Encrypts or decrypts data in a single-part operation, or finishes a
  multiple-part operation.The data is encrypted or decrypted,
  depending on how this cipher was initialized.
 <p>The first <code>inputLen</code> bytes in the <code>input</code>
  buffer, starting at <code>inputOffset</code> inclusive, and any input
  bytes that may have been buffered during a previous 
 <code>update</code> operation, are processed, with padding
  (if requested) being applied.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in the <code>output</code> buffer, starting at 
 <code>outputOffset</code> inclusive. 
 <p>If the <code>output</code> buffer is too small to hold the result,
  a <code>ShortBufferException</code> is thrown. In this case, repeat this
  call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again. 
 <p>Note: this method should be copy-safe, which means the 
 <code>input</code> and <code>output</code> buffers can reference
  the same byte array and no unprocessed input data is overwritten
  when the result is copied into the output buffer.
 @param input the input buffer
 @param inputOffset the offset in  <code> input </code>  where the input
   starts
 @param inputLen the input length
 @param output the buffer for the result
 @param outputOffset the offset in  <code> output </code>  where the result
   is stored
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw ShortBufferExceptionif the given output buffer is too small
  to hold the result
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 */
- (jint)doFinalWithByteArray:(IOSByteArray *)input
                     withInt:(jint)inputOffset
                     withInt:(jint)inputLen
               withByteArray:(IOSByteArray *)output
                     withInt:(jint)outputOffset;

/*!
 @brief Encrypts or decrypts data in a single-part operation, or finishes a
  multiple-part operation.The data is encrypted or decrypted,
  depending on how this cipher was initialized.
 <p>All <code>input.remaining()</code> bytes starting at 
 <code>input.position()</code> are processed.
  If an AEAD mode such as GCM/CCM is being used, the authentication
  tag is appended in the case of encryption, or verified in the
  case of decryption.
  The result is stored in the output buffer.
  Upon return, the input buffer's position will be equal
  to its limit; its limit will not have changed. The output buffer's
  position will have advanced by n, where n is the value returned
  by this method; the output buffer's limit will not have changed. 
 <p>If <code>output.remaining()</code> bytes are insufficient to
  hold the result, a <code>ShortBufferException</code> is thrown.
  In this case, repeat this call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>Upon finishing, this method resets this cipher object to the state
  it was in when previously initialized via a call to <code>init</code>.
  That is, the object is reset and available to encrypt or decrypt
  (depending on the operation mode that was specified in the call to 
 <code>init</code>) more data. 
 <p>Note: if any exception is thrown, this cipher object may need to
  be reset before it can be used again. 
 <p>Note: this method should be copy-safe, which means the 
 <code>input</code> and <code>output</code> buffers can reference
  the same byte array and no unprocessed input data is overwritten
  when the result is copied into the output buffer.
 @param input the input ByteBuffer
 @param output the output ByteBuffer
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalArgumentExceptionif input and output are the
    same object
 @throw ReadOnlyBufferExceptionif the output buffer is read-only
 @throw IllegalBlockSizeExceptionif this cipher is a block cipher,
  no padding has been requested (only in encryption mode), and the total
  input length of the data processed by this cipher is not a multiple of
  block size; or if this encryption algorithm is unable to
  process the input data provided.
 @throw ShortBufferExceptionif there is insufficient space in the
  output buffer
 @throw BadPaddingExceptionif this cipher is in decryption mode,
  and (un)padding has been requested, but the decrypted data is not
  bounded by the appropriate padding bytes
 @throw AEADBadTagExceptionif this cipher is decrypting in an
  AEAD mode (such as GCM/CCM), and the received authentication tag
  does not match the calculated value
 @since 1.5
 */
- (jint)doFinalWithJavaNioByteBuffer:(JavaNioByteBuffer *)input
               withJavaNioByteBuffer:(JavaNioByteBuffer *)output;

/*!
 @brief Returns the algorithm name of this <code>Cipher</code> object.
 <p>This is the same name that was specified in one of the 
 <code>getInstance</code> calls that created this <code>Cipher</code>
  object..
 @return the algorithm name of this <code>Cipher</code> object.
 */
- (NSString *)getAlgorithm;

/*!
 @brief Returns the block size (in bytes).
 @return the block size (in bytes), or 0 if the underlying algorithm is
  not a block cipher
 */
- (jint)getBlockSize;

/*!
 @brief Returns the <code>CipherSpi</code> backing this <code>Cipher</code> or <code>null</code> if no 
 <code>CipherSpi</code> is backing this <code>Cipher</code>.
 */
- (JavaxCryptoCipherSpi *)getCurrentSpi;

/*!
 @brief Returns the exemption mechanism object used with this cipher.
 @return the exemption mechanism object used with this cipher, or
  null if this cipher does not use any exemption mechanism.
 */
- (JavaxCryptoExemptionMechanism *)getExemptionMechanism;

/*!
 @brief Returns a <code>Cipher</code> object that implements the specified
  transformation.
 <p> This method traverses the list of registered security Providers,
  starting with the most preferred Provider.
  A new Cipher object encapsulating the
  CipherSpi implementation from the first
  Provider that supports the specified algorithm is returned. 
 <p> Note that the list of registered providers may be retrieved via the 
 <code>Security.getProviders()</code> method.
 @param transformation the name of the transformation, e.g.,  
  <i> DES/CBC/PKCS5Padding </i> .  See the Cipher section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Cipher">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard transformation names.
 @return a cipher that implements the requested transformation.
 @throw NoSuchAlgorithmExceptionif <code>transformation</code>
           is null, empty, in an invalid format,
           or if no Provider supports a CipherSpi implementation for the
           specified algorithm.
 @throw NoSuchPaddingExceptionif <code>transformation</code>
           contains a padding scheme that is not available.
 - seealso: java.security.Provider
 */
+ (JavaxCryptoCipher *)getInstanceWithNSString:(NSString *)transformation;

/*!
 @brief Returns a <code>Cipher</code> object that implements the specified
  transformation.
 <p> A new Cipher object encapsulating the
  CipherSpi implementation from the specified Provider
  object is returned.  Note that the specified Provider object
  does not have to be registered in the provider list.
 @param transformation the name of the transformation,  e.g., 
  <i> DES/CBC/PKCS5Padding </i> .  See the Cipher section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Cipher">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard transformation names.
 @param provider the provider.
 @return a cipher that implements the requested transformation.
 @throw NoSuchAlgorithmExceptionif <code>transformation</code>
           is null, empty, in an invalid format,
           or if a CipherSpi implementation for the specified algorithm
           is not available from the specified Provider object.
 @throw NoSuchPaddingExceptionif <code>transformation</code>
           contains a padding scheme that is not available.
 @throw IllegalArgumentExceptionif the <code>provider</code>
           is null.
 - seealso: java.security.Provider
 */
+ (JavaxCryptoCipher *)getInstanceWithNSString:(NSString *)transformation
                      withJavaSecurityProvider:(JavaSecurityProvider *)provider;

/*!
 @brief Returns a <code>Cipher</code> object that implements the specified
  transformation.
 <p> A new Cipher object encapsulating the
  CipherSpi implementation from the specified provider
  is returned.  The specified provider must be registered
  in the security provider list. 
 <p> Note that the list of registered providers may be retrieved via the 
 <code>Security.getProviders()</code> method.
 @param transformation the name of the transformation,  e.g., 
  <i> DES/CBC/PKCS5Padding </i> .  See the Cipher section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Cipher">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard transformation names.
 @param provider the name of the provider.
 @return a cipher that implements the requested transformation.
 @throw NoSuchAlgorithmExceptionif <code>transformation</code>
           is null, empty, in an invalid format,
           or if a CipherSpi implementation for the specified algorithm
           is not available from the specified provider.
 @throw NoSuchProviderExceptionif the specified provider is not
           registered in the security provider list.
 @throw NoSuchPaddingExceptionif <code>transformation</code>
           contains a padding scheme that is not available.
 @throw IllegalArgumentExceptionif the <code>provider</code>
           is null or empty.
 - seealso: java.security.Provider
 */
+ (JavaxCryptoCipher *)getInstanceWithNSString:(NSString *)transformation
                                  withNSString:(NSString *)provider;

/*!
 @brief Returns the initialization vector (IV) in a new buffer.
 <p>This is useful in the case where a random IV was created,
  or in the context of password-based encryption or
  decryption, where the IV is derived from a user-supplied password.
 @return the initialization vector in a new buffer, or null if the
  underlying algorithm does not use an IV, or if the IV has not yet
  been set.
 */
- (IOSByteArray *)getIV;

/*!
 @brief Returns the maximum key length for the specified transformation
  according to the installed JCE jurisdiction policy files.If
  JCE unlimited strength jurisdiction policy files are installed,
  Integer.MAX_VALUE will be returned.
 For more information on default key size in JCE jurisdiction
  policy files, please see Appendix E in the 
 <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/crypto/CryptoSpec.html#AppC">
  Java Cryptography Architecture Reference Guide</a>.
 @param transformation the cipher transformation.
 @return the maximum key length in bits or Integer.MAX_VALUE.
 @throw NullPointerExceptionif <code>transformation</code> is null.
 @throw NoSuchAlgorithmExceptionif <code>transformation</code>
  is not a valid transformation, i.e. in the form of "algorithm" or
  "algorithm/mode/padding".
 @since 1.5
 */
+ (jint)getMaxAllowedKeyLengthWithNSString:(NSString *)transformation;

/*!
 @brief Returns an AlgorithmParameterSpec object which contains
  the maximum cipher parameter value according to the
  jurisdiction policy file.If JCE unlimited strength jurisdiction
  policy files are installed or there is no maximum limit on the
  parameters for the specified transformation in the policy file,
  null will be returned.
 @param transformation the cipher transformation.
 @return an AlgorithmParameterSpec which holds the maximum
  value or null.
 @throw NullPointerExceptionif <code>transformation</code>
  is null.
 @throw NoSuchAlgorithmExceptionif <code>transformation</code>
  is not a valid transformation, i.e. in the form of "algorithm" or
  "algorithm/mode/padding".
 @since 1.5
 */
+ (id<JavaSecuritySpecAlgorithmParameterSpec>)getMaxAllowedParameterSpecWithNSString:(NSString *)transformation;

/*!
 @brief Returns the length in bytes that an output buffer would need to be in
  order to hold the result of the next <code>update</code> or 
 <code>doFinal</code> operation, given the input length 
 <code>inputLen</code> (in bytes).
 <p>This call takes into account any unprocessed (buffered) data from a
  previous <code>update</code> call, padding, and AEAD tagging. 
 <p>The actual output length of the next <code>update</code> or 
 <code>doFinal</code> call may be smaller than the length returned by
  this method.
 @param inputLen the input length (in bytes)
 @return the required output buffer size (in bytes)
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not yet been initialized)
 */
- (jint)getOutputSizeWithInt:(jint)inputLen;

/*!
 @brief Returns the parameters used with this cipher.
 <p>The returned parameters may be the same that were used to initialize
  this cipher, or may contain a combination of default and random
  parameter values used by the underlying cipher implementation if this
  cipher requires algorithm parameters but was not initialized with any.
 @return the parameters used with this cipher, or null if this cipher
  does not use any parameters.
 */
- (JavaSecurityAlgorithmParameters *)getParameters;

/*!
 @brief Returns the provider of this <code>Cipher</code> object.
 @return the provider of this <code>Cipher</code> object
 */
- (JavaSecurityProvider *)getProvider;

/*!
 @brief Initializes this cipher with the public key from the given certificate.
 <p> The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or  key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If the certificate is of type X.509 and has a <i>key usage</i>
  extension field marked as critical, and the value of the <i>key usage</i>
  extension field implies that the public key in
  the certificate and its corresponding private key are not
  supposed to be used for the operation represented by the value
  of <code>opmode</code>,
  an <code>InvalidKeyException</code>
  is thrown. 
 <p> If this cipher requires any algorithm parameters that cannot be
  derived from the public key in the given certificate, the underlying
  cipher
  implementation is supposed to generate the required parameters itself
  (using provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an <code>
  InvalidKeyException</code> if it is being initialized for decryption or
  key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them using the 
 <code>SecureRandom</code>
  implementation of the highest-priority
  installed provider as the source of randomness.
  (If none of the installed providers supply an implementation of
  SecureRandom, a system-provided source of randomness will be used.) 
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following:
    <code>
  ENCRYPT_MODE </code> ,  <code> DECRYPT_MODE </code> ,   <code>
  WRAP_MODE </code>  or  <code> UNWRAP_MODE </code> )
 @param certificate the certificate
 @throw InvalidKeyExceptionif the public key in the given
  certificate is inappropriate for initializing this cipher, or this
  cipher requires algorithm parameters that cannot be determined from the
  public key in the given certificate, or the keysize of the public key
  in the given certificate has a keysize that exceeds the maximum
  allowable keysize (as determined by the configured jurisdiction policy
  files).
 */
- (void)init__WithInt:(jint)opmode
withJavaSecurityCertCertificate:(JavaSecurityCertCertificate *)certificate OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with the public key from the given certificate
  and
  a source of randomness.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping
  or key unwrapping, depending on
  the value of <code>opmode</code>.
  
 <p>If the certificate is of type X.509 and has a <i>key usage</i>
  extension field marked as critical, and the value of the <i>key usage</i>
  extension field implies that the public key in
  the certificate and its corresponding private key are not
  supposed to be used for the operation represented by the value of 
 <code>opmode</code>,
  an <code>InvalidKeyException</code>
  is thrown. 
 <p>If this cipher requires any algorithm parameters that cannot be
  derived from the public key in the given <code>certificate</code>,
  the underlying cipher
  implementation is supposed to generate the required parameters itself
  (using provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidKeyException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them from <code>random</code>.
  
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following:
    <code>
  ENCRYPT_MODE </code> ,  <code> DECRYPT_MODE </code> ,   <code>
  WRAP_MODE </code>  or  <code> UNWRAP_MODE </code> )
 @param certificate the certificate
 @param random the source of randomness
 @throw InvalidKeyExceptionif the public key in the given
  certificate is inappropriate for initializing this cipher, or this cipher
  requires algorithm parameters that cannot be determined from the
  public key in the given certificate, or the keysize of the public key
  in the given certificate has a keysize that exceeds the maximum
  allowable keysize (as determined by the configured jurisdiction policy
  files).
 */
- (void)init__WithInt:(jint)opmode
withJavaSecurityCertCertificate:(JavaSecurityCertCertificate *)certificate
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with a key.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If this cipher requires any algorithm parameters that cannot be
  derived from the given <code>key</code>, the underlying cipher
  implementation is supposed to generate the required parameters itself
  (using provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidKeyException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them using the <code><code>SecureRandom</code></code>
  implementation of the highest-priority
  installed provider as the source of randomness.
  (If none of the installed providers supply an implementation of
  SecureRandom, a system-provided source of randomness will be used.) 
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of  the following:
    <code>
  ENCRYPT_MODE </code> ,  <code> DECRYPT_MODE </code> ,   <code>
  WRAP_MODE </code>  or  <code> UNWRAP_MODE </code> )
 @param key the key
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this cipher, or requires
  algorithm parameters that cannot be
  determined from the given key, or if the given key has a keysize that
  exceeds the maximum allowable keysize (as determined from the
  configured jurisdiction policy files).
 */
- (void)init__WithInt:(jint)opmode
  withJavaSecurityKey:(id<JavaSecurityKey>)key OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with a key and a set of algorithm
  parameters.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or  key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If this cipher requires any algorithm parameters and 
 <code>params</code> is null, the underlying cipher implementation is
  supposed to generate the required parameters itself (using
  provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidAlgorithmParameterException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them using the <code><code>SecureRandom</code></code>
  implementation of the highest-priority
  installed provider as the source of randomness.
  (If none of the installed providers supply an implementation of
  SecureRandom, a system-provided source of randomness will be used.) 
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following: 
  <code> ENCRYPT_MODE </code> ,   <code>
  DECRYPT_MODE </code> ,  <code> WRAP_MODE </code>  or 
  <code> UNWRAP_MODE </code> )
 @param key the encryption key
 @param params the algorithm parameters
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this cipher, or its keysize exceeds the maximum allowable
  keysize (as determined from the configured jurisdiction policy files).
 @throw InvalidAlgorithmParameterExceptionif the given algorithm
  parameters are inappropriate for this cipher,
  or this cipher requires
  algorithm parameters and <code>params</code> is null, or the given
  algorithm parameters imply a cryptographic strength that would exceed
  the legal limits (as determined from the configured jurisdiction
  policy files).
 */
- (void)init__WithInt:(jint)opmode
  withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with a key, a set of algorithm
  parameters, and a source of randomness.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or  key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If this cipher requires any algorithm parameters and 
 <code>params</code> is null, the underlying cipher implementation is
  supposed to generate the required parameters itself (using
  provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidAlgorithmParameterException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them from <code>random</code>.
  
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following: 
  <code> ENCRYPT_MODE </code> ,   <code>
  DECRYPT_MODE </code> ,  <code> WRAP_MODE </code>  or 
  <code> UNWRAP_MODE </code> )
 @param key the encryption key
 @param params the algorithm parameters
 @param random the source of randomness
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this cipher, or its keysize exceeds the maximum allowable
  keysize (as determined from the configured jurisdiction policy files).
 @throw InvalidAlgorithmParameterExceptionif the given algorithm
  parameters are inappropriate for this cipher,
  or this cipher requires
  algorithm parameters and <code>params</code> is null, or the given
  algorithm parameters imply a cryptographic strength that would exceed
  the legal limits (as determined from the configured jurisdiction
  policy files).
 */
- (void)init__WithInt:(jint)opmode
  withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with a key and a set of algorithm
  parameters.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or  key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If this cipher requires any algorithm parameters and 
 <code>params</code> is null, the underlying cipher implementation is
  supposed to generate the required parameters itself (using
  provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidAlgorithmParameterException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them using the <code><code>SecureRandom</code></code>
  implementation of the highest-priority
  installed provider as the source of randomness.
  (If none of the installed providers supply an implementation of
  SecureRandom, a system-provided source of randomness will be used.) 
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following:
    <code>
  ENCRYPT_MODE </code> ,  <code> DECRYPT_MODE </code> ,   <code>
  WRAP_MODE </code>  or  <code> UNWRAP_MODE </code> )
 @param key the encryption key
 @param params the algorithm parameters
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this cipher, or its keysize exceeds the maximum allowable
  keysize (as determined from the configured jurisdiction policy files).
 @throw InvalidAlgorithmParameterExceptionif the given algorithm
  parameters are inappropriate for this cipher,
  or this cipher requires
  algorithm parameters and <code>params</code> is null, or the given
  algorithm parameters imply a cryptographic strength that would exceed
  the legal limits (as determined from the configured jurisdiction
  policy files).
 */
- (void)init__WithInt:(jint)opmode
  withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with a key, a set of algorithm
  parameters, and a source of randomness.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or  key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If this cipher requires any algorithm parameters and 
 <code>params</code> is null, the underlying cipher implementation is
  supposed to generate the required parameters itself (using
  provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidAlgorithmParameterException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them from <code>random</code>.
  
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following:
    <code>
  ENCRYPT_MODE </code> ,  <code> DECRYPT_MODE </code> ,   <code>
  WRAP_MODE </code>  or  <code> UNWRAP_MODE </code> )
 @param key the encryption key
 @param params the algorithm parameters
 @param random the source of randomness
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this cipher, or its keysize exceeds the maximum allowable
  keysize (as determined from the configured jurisdiction policy files).
 @throw InvalidAlgorithmParameterExceptionif the given algorithm
  parameters are inappropriate for this cipher,
  or this cipher requires
  algorithm parameters and <code>params</code> is null, or the given
  algorithm parameters imply a cryptographic strength that would exceed
  the legal limits (as determined from the configured jurisdiction
  policy files).
 */
- (void)init__WithInt:(jint)opmode
  withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this cipher with a key and a source of randomness.
 <p>The cipher is initialized for one of the following four operations:
  encryption, decryption, key wrapping or  key unwrapping, depending
  on the value of <code>opmode</code>.
  
 <p>If this cipher requires any algorithm parameters that cannot be
  derived from the given <code>key</code>, the underlying cipher
  implementation is supposed to generate the required parameters itself
  (using provider-specific default or random values) if it is being
  initialized for encryption or key wrapping, and raise an 
 <code>InvalidKeyException</code> if it is being
  initialized for decryption or key unwrapping.
  The generated parameters can be retrieved using 
 <code>getParameters</code> or 
 <code>getIV</code> (if the parameter is an IV). 
 <p>If this cipher requires algorithm parameters that cannot be
  derived from the input parameters, and there are no reasonable
  provider-specific default values, initialization will
  necessarily fail. 
 <p>If this cipher (including its underlying feedback or padding scheme)
  requires any random bytes (e.g., for parameter generation), it will get
  them from <code>random</code>.
  
 <p>Note that when a Cipher object is initialized, it loses all
  previously-acquired state. In other words, initializing a Cipher is
  equivalent to creating a new instance of that Cipher and initializing
  it.
 @param opmode the operation mode of this cipher (this is one of the  following:
    <code>
  ENCRYPT_MODE </code> ,  <code> DECRYPT_MODE </code> ,   <code>
  WRAP_MODE </code>  or  <code> UNWRAP_MODE </code> )
 @param key the encryption key
 @param random the source of randomness
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this cipher, or requires
  algorithm parameters that cannot be
  determined from the given key, or if the given key has a keysize that
  exceeds the maximum allowable keysize (as determined from the
  configured jurisdiction policy files).
 */
- (void)init__WithInt:(jint)opmode
  withJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Unwrap a previously wrapped key.
 @param wrappedKey the key to be unwrapped.
 @param wrappedKeyAlgorithm the algorithm associated with the wrapped  key.
 @param wrappedKeyType the type of the wrapped key. This must be one of  
  <code> SECRET_KEY </code> ,  <code> PRIVATE_KEY </code> , or
    <code> PUBLIC_KEY </code> .
 @return the unwrapped key.
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized).
 @throw NoSuchAlgorithmExceptionif no installed providers
  can create keys of type <code>wrappedKeyType</code> for the 
 <code>wrappedKeyAlgorithm</code>.
 @throw InvalidKeyExceptionif <code>wrappedKey</code> does not
  represent a wrapped key of type <code>wrappedKeyType</code> for
  the <code>wrappedKeyAlgorithm</code>.
 */
- (id<JavaSecurityKey>)unwrapWithByteArray:(IOSByteArray *)wrappedKey
                              withNSString:(NSString *)wrappedKeyAlgorithm
                                   withInt:(jint)wrappedKeyType;

/*!
 @brief Continues a multiple-part encryption or decryption operation
  (depending on how this cipher was initialized), processing another data
  part.
 <p>The bytes in the <code>input</code> buffer are processed, and the
  result is stored in a new buffer. 
 <p>If <code>input</code> has a length of zero, this method returns 
 <code>null</code>.
 @param input the input buffer
 @return the new buffer with the result, or null if the underlying
  cipher is a block cipher and the input data is too short to result in a
  new block.
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 */
- (IOSByteArray *)updateWithByteArray:(IOSByteArray *)input;

/*!
 @brief Continues a multiple-part encryption or decryption operation
  (depending on how this cipher was initialized), processing another data
  part.
 <p>The first <code>inputLen</code> bytes in the <code>input</code>
  buffer, starting at <code>inputOffset</code> inclusive, are processed,
  and the result is stored in a new buffer. 
 <p>If <code>inputLen</code> is zero, this method returns 
 <code>null</code>.
 @param input the input buffer
 @param inputOffset the offset in  <code> input </code>  where the input
   starts
 @param inputLen the input length
 @return the new buffer with the result, or null if the underlying
  cipher is a block cipher and the input data is too short to result in a
  new block.
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 */
- (IOSByteArray *)updateWithByteArray:(IOSByteArray *)input
                              withInt:(jint)inputOffset
                              withInt:(jint)inputLen;

/*!
 @brief Continues a multiple-part encryption or decryption operation
  (depending on how this cipher was initialized), processing another data
  part.
 <p>The first <code>inputLen</code> bytes in the <code>input</code>
  buffer, starting at <code>inputOffset</code> inclusive, are processed,
  and the result is stored in the <code>output</code> buffer. 
 <p>If the <code>output</code> buffer is too small to hold the result,
  a <code>ShortBufferException</code> is thrown. In this case, repeat this
  call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>If <code>inputLen</code> is zero, this method returns
  a length of zero. 
 <p>Note: this method should be copy-safe, which means the 
 <code>input</code> and <code>output</code> buffers can reference
  the same byte array and no unprocessed input data is overwritten
  when the result is copied into the output buffer.
 @param input the input buffer
 @param inputOffset the offset in  <code> input </code>  where the input
   starts
 @param inputLen the input length
 @param output the buffer for the result
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw ShortBufferExceptionif the given output buffer is too small
  to hold the result
 */
- (jint)updateWithByteArray:(IOSByteArray *)input
                    withInt:(jint)inputOffset
                    withInt:(jint)inputLen
              withByteArray:(IOSByteArray *)output;

/*!
 @brief Continues a multiple-part encryption or decryption operation
  (depending on how this cipher was initialized), processing another data
  part.
 <p>The first <code>inputLen</code> bytes in the <code>input</code>
  buffer, starting at <code>inputOffset</code> inclusive, are processed,
  and the result is stored in the <code>output</code> buffer, starting at 
 <code>outputOffset</code> inclusive. 
 <p>If the <code>output</code> buffer is too small to hold the result,
  a <code>ShortBufferException</code> is thrown. In this case, repeat this
  call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>If <code>inputLen</code> is zero, this method returns
  a length of zero. 
 <p>Note: this method should be copy-safe, which means the 
 <code>input</code> and <code>output</code> buffers can reference
  the same byte array and no unprocessed input data is overwritten
  when the result is copied into the output buffer.
 @param input the input buffer
 @param inputOffset the offset in  <code> input </code>  where the input
   starts
 @param inputLen the input length
 @param output the buffer for the result
 @param outputOffset the offset in  <code> output </code>  where the result
   is stored
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw ShortBufferExceptionif the given output buffer is too small
  to hold the result
 */
- (jint)updateWithByteArray:(IOSByteArray *)input
                    withInt:(jint)inputOffset
                    withInt:(jint)inputLen
              withByteArray:(IOSByteArray *)output
                    withInt:(jint)outputOffset;

/*!
 @brief Continues a multiple-part encryption or decryption operation
  (depending on how this cipher was initialized), processing another data
  part.
 <p>All <code>input.remaining()</code> bytes starting at 
 <code>input.position()</code> are processed. The result is stored
  in the output buffer.
  Upon return, the input buffer's position will be equal
  to its limit; its limit will not have changed. The output buffer's
  position will have advanced by n, where n is the value returned
  by this method; the output buffer's limit will not have changed. 
 <p>If <code>output.remaining()</code> bytes are insufficient to
  hold the result, a <code>ShortBufferException</code> is thrown.
  In this case, repeat this call with a larger output buffer. Use 
 <code>getOutputSize</code> to determine how big
  the output buffer should be. 
 <p>Note: this method should be copy-safe, which means the 
 <code>input</code> and <code>output</code> buffers can reference
  the same block of memory and no unprocessed input data is overwritten
  when the result is copied into the output buffer.
 @param input the input ByteBuffer
 @param output the output ByteByffer
 @return the number of bytes stored in <code>output</code>
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized)
 @throw IllegalArgumentExceptionif input and output are the
    same object
 @throw ReadOnlyBufferExceptionif the output buffer is read-only
 @throw ShortBufferExceptionif there is insufficient space in the
  output buffer
 @since 1.5
 */
- (jint)updateWithJavaNioByteBuffer:(JavaNioByteBuffer *)input
              withJavaNioByteBuffer:(JavaNioByteBuffer *)output;

/*!
 @brief Continues a multi-part update of the Additional Authentication
  Data (AAD).
 <p>
  Calls to this method provide AAD to the cipher when operating in
  modes such as AEAD (GCM/CCM).  If this cipher is operating in
  either GCM or CCM mode, all AAD must be supplied before beginning
  operations on the ciphertext (via the <code>update</code> and <code>doFinal</code>
  methods).
 @param src the buffer containing the Additional Authentication Data
 @throw IllegalArgumentExceptionif the <code>src</code>
  byte array is null
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized), does not accept AAD, or if
  operating in either GCM or CCM mode and one of the <code>update</code>
  methods has already been called for the active
  encryption/decryption operation
 @throw UnsupportedOperationExceptionif the corresponding method
  in the <code>CipherSpi</code> has not been overridden by an
  implementation
 @since 1.7
 */
- (void)updateAADWithByteArray:(IOSByteArray *)src;

/*!
 @brief Continues a multi-part update of the Additional Authentication
  Data (AAD), using a subset of the provided buffer.
 <p>
  Calls to this method provide AAD to the cipher when operating in
  modes such as AEAD (GCM/CCM).  If this cipher is operating in
  either GCM or CCM mode, all AAD must be supplied before beginning
  operations on the ciphertext (via the <code>update</code> and <code>doFinal</code>
  methods).
 @param src the buffer containing the AAD
 @param offset the offset in <code>src</code>  where the AAD input starts
 @param len the number of AAD bytes
 @throw IllegalArgumentExceptionif the <code>src</code>
  byte array is null, or the <code>offset</code> or <code>length</code>
  is less than 0, or the sum of the <code>offset</code> and 
 <code>len</code> is greater than the length of the 
 <code>src</code> byte array
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized), does not accept AAD, or if
  operating in either GCM or CCM mode and one of the <code>update</code>
  methods has already been called for the active
  encryption/decryption operation
 @throw UnsupportedOperationExceptionif the corresponding method
  in the <code>CipherSpi</code> has not been overridden by an
  implementation
 @since 1.7
 */
- (void)updateAADWithByteArray:(IOSByteArray *)src
                       withInt:(jint)offset
                       withInt:(jint)len;

/*!
 @brief Continues a multi-part update of the Additional Authentication
  Data (AAD).
 <p>
  Calls to this method provide AAD to the cipher when operating in
  modes such as AEAD (GCM/CCM).  If this cipher is operating in
  either GCM or CCM mode, all AAD must be supplied before beginning
  operations on the ciphertext (via the <code>update</code> and <code>doFinal</code>
  methods). 
 <p>
  All <code>src.remaining()</code> bytes starting at 
 <code>src.position()</code> are processed.
  Upon return, the input buffer's position will be equal
  to its limit; its limit will not have changed.
 @param src the buffer containing the AAD
 @throw IllegalArgumentExceptionif the <code>src ByteBuffer</code>
  is null
 @throw IllegalStateExceptionif this cipher is in a wrong state
  (e.g., has not been initialized), does not accept AAD, or if
  operating in either GCM or CCM mode and one of the <code>update</code>
  methods has already been called for the active
  encryption/decryption operation
 @throw UnsupportedOperationExceptionif the corresponding method
  in the <code>CipherSpi</code> has not been overridden by an
  implementation
 @since 1.7
 */
- (void)updateAADWithJavaNioByteBuffer:(JavaNioByteBuffer *)src;

/*!
 @brief Wrap a key.
 @param key the key to be wrapped.
 @return the wrapped key.
 @throw IllegalStateExceptionif this cipher is in a wrong
  state (e.g., has not been initialized).
 @throw IllegalBlockSizeExceptionif this cipher is a block
  cipher, no padding has been requested, and the length of the
  encoding of the key to be wrapped is not a
  multiple of the block size.
 @throw InvalidKeyExceptionif it is impossible or unsafe to
  wrap the key with this cipher (e.g., a hardware protected key is
  being passed to a software-only cipher).
 */
- (IOSByteArray *)wrapWithJavaSecurityKey:(id<JavaSecurityKey>)key;

#pragma mark Protected

/*!
 @brief Creates a Cipher object.
 @param cipherSpi the delegate
 @param provider the provider
 @param transformation the transformation
 */
- (instancetype __nonnull)initWithJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)cipherSpi
                              withJavaSecurityProvider:(JavaSecurityProvider *)provider
                                          withNSString:(NSString *)transformation;

#pragma mark Package-Private

+ (JavaxCryptoCipher *)createCipherWithNSString:(NSString *)transformation
                       withJavaSecurityProvider:(JavaSecurityProvider *)provider;

/*!
 @brief If the attribute listed exists, check that it matches the regular
  expression.
 */
+ (jboolean)matchAttributeWithJavaSecurityProvider_Service:(JavaSecurityProvider_Service *)service
                                              withNSString:(NSString *)attr
                                              withNSString:(NSString *)value;

/*!
 @brief Tries to find the correct <code>Cipher</code> transform to use.Returns a 
 <code>org.apache.harmony.security.fortress.Engine.SpiAndProvider</code>, throws the first exception that was
  encountered during attempted initialization, or <code>null</code> if there are
  no providers that support the <code>initParams</code>.
 <p>
  <code>tokenizedTransformation</code> must be in the format returned by 
 <code>Cipher.checkTransformation(String)</code>. The combinations of mode strings
  tried are as follows: 
 <ul>
  <li><code>[cipher]/[mode]/[padding]</code>
  <li><code>[cipher]/[mode]</code>
  <li><code>[cipher]//[padding]</code>
  <li><code>[cipher]</code>
  </ul>
  <code>services</code> is a list of cipher services. Needs to be non-null only if 
 <code>provider != null</code>
 */
+ (JavaxCryptoCipher_CipherSpiAndProvider *)tryCombinationsWithJavaxCryptoCipher_InitParams:(JavaxCryptoCipher_InitParams *)initParams
                                                                   withJavaSecurityProvider:(JavaSecurityProvider *)provider
                                                                          withNSStringArray:(IOSObjectArray *)tokenizedTransformation;

/*!
 @brief Tries to initialize the <code>Cipher</code> from a given <code>service</code>.If
  initialization is successful, the initialized <code>spi</code> is returned.
 If
  the <code>service</code> cannot be initialized with the specified 
 <code>initParams</code>, then it's expected to throw 
 <code>InvalidKeyException</code> or <code>InvalidAlgorithmParameterException</code>
  as a hint to the caller that it should continue searching for a 
 <code>Service</code> that will work.
 */
+ (JavaxCryptoCipher_CipherSpiAndProvider *)tryTransformWithProviderWithJavaxCryptoCipher_InitParams:(JavaxCryptoCipher_InitParams *)initParams
                                                                                   withNSStringArray:(IOSObjectArray *)tokenizedTransformation
                                                                     withJavaxCryptoCipher_NeedToSet:(JavaxCryptoCipher_NeedToSet *)type
                                                                    withJavaSecurityProvider_Service:(JavaSecurityProvider_Service *)service;

/*!
 @brief Choose the Spi from the first provider available.Used if
  delayed provider selection is not possible because init()
  is not the first method called.
 */
- (void)updateProviderIfNeeded;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoCipher)

/*!
 @brief Constant used to initialize cipher to encryption mode.
 */
inline jint JavaxCryptoCipher_get_ENCRYPT_MODE(void);
#define JavaxCryptoCipher_ENCRYPT_MODE 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, ENCRYPT_MODE, jint)

/*!
 @brief Constant used to initialize cipher to decryption mode.
 */
inline jint JavaxCryptoCipher_get_DECRYPT_MODE(void);
#define JavaxCryptoCipher_DECRYPT_MODE 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, DECRYPT_MODE, jint)

/*!
 @brief Constant used to initialize cipher to key-wrapping mode.
 */
inline jint JavaxCryptoCipher_get_WRAP_MODE(void);
#define JavaxCryptoCipher_WRAP_MODE 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, WRAP_MODE, jint)

/*!
 @brief Constant used to initialize cipher to key-unwrapping mode.
 */
inline jint JavaxCryptoCipher_get_UNWRAP_MODE(void);
#define JavaxCryptoCipher_UNWRAP_MODE 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, UNWRAP_MODE, jint)

/*!
 @brief Constant used to indicate the to-be-unwrapped key is a "public key".
 */
inline jint JavaxCryptoCipher_get_PUBLIC_KEY(void);
#define JavaxCryptoCipher_PUBLIC_KEY 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, PUBLIC_KEY, jint)

/*!
 @brief Constant used to indicate the to-be-unwrapped key is a "private key".
 */
inline jint JavaxCryptoCipher_get_PRIVATE_KEY(void);
#define JavaxCryptoCipher_PRIVATE_KEY 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, PRIVATE_KEY, jint)

/*!
 @brief Constant used to indicate the to-be-unwrapped key is a "secret key".
 */
inline jint JavaxCryptoCipher_get_SECRET_KEY(void);
#define JavaxCryptoCipher_SECRET_KEY 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoCipher, SECRET_KEY, jint)

FOUNDATION_EXPORT void JavaxCryptoCipher_initWithJavaxCryptoCipherSpi_withJavaSecurityProvider_withNSString_(JavaxCryptoCipher *self, JavaxCryptoCipherSpi *cipherSpi, JavaSecurityProvider *provider, NSString *transformation);

FOUNDATION_EXPORT JavaxCryptoCipher *new_JavaxCryptoCipher_initWithJavaxCryptoCipherSpi_withJavaSecurityProvider_withNSString_(JavaxCryptoCipherSpi *cipherSpi, JavaSecurityProvider *provider, NSString *transformation) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoCipher *create_JavaxCryptoCipher_initWithJavaxCryptoCipherSpi_withJavaSecurityProvider_withNSString_(JavaxCryptoCipherSpi *cipherSpi, JavaSecurityProvider *provider, NSString *transformation);

FOUNDATION_EXPORT JavaxCryptoCipher *JavaxCryptoCipher_getInstanceWithNSString_(NSString *transformation);

FOUNDATION_EXPORT JavaxCryptoCipher *JavaxCryptoCipher_getInstanceWithNSString_withNSString_(NSString *transformation, NSString *provider);

FOUNDATION_EXPORT JavaxCryptoCipher *JavaxCryptoCipher_getInstanceWithNSString_withJavaSecurityProvider_(NSString *transformation, JavaSecurityProvider *provider);

FOUNDATION_EXPORT JavaxCryptoCipher *JavaxCryptoCipher_createCipherWithNSString_withJavaSecurityProvider_(NSString *transformation, JavaSecurityProvider *provider);

FOUNDATION_EXPORT jint JavaxCryptoCipher_getMaxAllowedKeyLengthWithNSString_(NSString *transformation);

FOUNDATION_EXPORT id<JavaSecuritySpecAlgorithmParameterSpec> JavaxCryptoCipher_getMaxAllowedParameterSpecWithNSString_(NSString *transformation);

FOUNDATION_EXPORT jboolean JavaxCryptoCipher_matchAttributeWithJavaSecurityProvider_Service_withNSString_withNSString_(JavaSecurityProvider_Service *service, NSString *attr, NSString *value);

FOUNDATION_EXPORT JavaxCryptoCipher_CipherSpiAndProvider *JavaxCryptoCipher_tryCombinationsWithJavaxCryptoCipher_InitParams_withJavaSecurityProvider_withNSStringArray_(JavaxCryptoCipher_InitParams *initParams, JavaSecurityProvider *provider, IOSObjectArray *tokenizedTransformation);

FOUNDATION_EXPORT JavaxCryptoCipher_CipherSpiAndProvider *JavaxCryptoCipher_tryTransformWithProviderWithJavaxCryptoCipher_InitParams_withNSStringArray_withJavaxCryptoCipher_NeedToSet_withJavaSecurityProvider_Service_(JavaxCryptoCipher_InitParams *initParams, IOSObjectArray *tokenizedTransformation, JavaxCryptoCipher_NeedToSet *type, JavaSecurityProvider_Service *service);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher)

#endif

#if !defined (JavaxCryptoCipher_NeedToSet_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher_NeedToSet))
#define JavaxCryptoCipher_NeedToSet_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, JavaxCryptoCipher_NeedToSet_Enum) {
  JavaxCryptoCipher_NeedToSet_Enum_NONE = 0,
  JavaxCryptoCipher_NeedToSet_Enum_MODE = 1,
  JavaxCryptoCipher_NeedToSet_Enum_PADDING = 2,
  JavaxCryptoCipher_NeedToSet_Enum_BOTH = 3,
};

/*!
 @brief Items that need to be set on the Cipher instance.
 */
@interface JavaxCryptoCipher_NeedToSet : JavaLangEnum

@property (readonly, class, nonnull) JavaxCryptoCipher_NeedToSet *NONE NS_SWIFT_NAME(NONE);
@property (readonly, class, nonnull) JavaxCryptoCipher_NeedToSet *MODE NS_SWIFT_NAME(MODE);
@property (readonly, class, nonnull) JavaxCryptoCipher_NeedToSet *PADDING NS_SWIFT_NAME(PADDING);
@property (readonly, class, nonnull) JavaxCryptoCipher_NeedToSet *BOTH NS_SWIFT_NAME(BOTH);
+ (JavaxCryptoCipher_NeedToSet * __nonnull)NONE;

+ (JavaxCryptoCipher_NeedToSet * __nonnull)MODE;

+ (JavaxCryptoCipher_NeedToSet * __nonnull)PADDING;

+ (JavaxCryptoCipher_NeedToSet * __nonnull)BOTH;

#pragma mark Public

+ (JavaxCryptoCipher_NeedToSet *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaxCryptoCipher_NeedToSet_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(JavaxCryptoCipher_NeedToSet)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_values_[];

inline JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_get_NONE(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_NeedToSet, NONE)

inline JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_get_MODE(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_NeedToSet, MODE)

inline JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_get_PADDING(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_NeedToSet, PADDING)

inline JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_get_BOTH(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_NeedToSet, BOTH)

FOUNDATION_EXPORT IOSObjectArray *JavaxCryptoCipher_NeedToSet_values(void);

FOUNDATION_EXPORT JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaxCryptoCipher_NeedToSet *JavaxCryptoCipher_NeedToSet_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher_NeedToSet)

#endif

#if !defined (JavaxCryptoCipher_Transform_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher_Transform))
#define JavaxCryptoCipher_Transform_

@class JavaxCryptoCipher_NeedToSet;

/*!
 @brief Expresses the various types of transforms that may be used during
  initialization.
 */
@interface JavaxCryptoCipher_Transform : NSObject

#pragma mark Public

- (instancetype __nonnull)initWithNSString:(NSString *)name
           withJavaxCryptoCipher_NeedToSet:(JavaxCryptoCipher_NeedToSet *)needToSet;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoCipher_Transform)

FOUNDATION_EXPORT void JavaxCryptoCipher_Transform_initWithNSString_withJavaxCryptoCipher_NeedToSet_(JavaxCryptoCipher_Transform *self, NSString *name, JavaxCryptoCipher_NeedToSet *needToSet);

FOUNDATION_EXPORT JavaxCryptoCipher_Transform *new_JavaxCryptoCipher_Transform_initWithNSString_withJavaxCryptoCipher_NeedToSet_(NSString *name, JavaxCryptoCipher_NeedToSet *needToSet) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoCipher_Transform *create_JavaxCryptoCipher_Transform_initWithNSString_withJavaxCryptoCipher_NeedToSet_(NSString *name, JavaxCryptoCipher_NeedToSet *needToSet);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher_Transform)

#endif

#if !defined (JavaxCryptoCipher_InitParams_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher_InitParams))
#define JavaxCryptoCipher_InitParams_

@class JavaSecurityAlgorithmParameters;
@class JavaSecuritySecureRandom;
@class JavaxCryptoCipher_InitType;
@protocol JavaSecurityKey;
@protocol JavaSecuritySpecAlgorithmParameterSpec;

/*!
 @brief Keeps track of the possible arguments to <code>Cipher#init(...)
 </code>.
 */
@interface JavaxCryptoCipher_InitParams : NSObject {
 @public
  JavaxCryptoCipher_InitType *initType_;
  jint opmode_;
  id<JavaSecurityKey> key_;
  JavaSecuritySecureRandom *random_;
  id<JavaSecuritySpecAlgorithmParameterSpec> spec_;
  JavaSecurityAlgorithmParameters *params_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaxCryptoCipher_InitType:(JavaxCryptoCipher_InitType *)initType
                                                     withInt:(jint)opmode
                                         withJavaSecurityKey:(id<JavaSecurityKey>)key
                                withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random
                  withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)spec
                         withJavaSecurityAlgorithmParameters:(JavaSecurityAlgorithmParameters *)params;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoCipher_InitParams)

J2OBJC_FIELD_SETTER(JavaxCryptoCipher_InitParams, initType_, JavaxCryptoCipher_InitType *)
J2OBJC_FIELD_SETTER(JavaxCryptoCipher_InitParams, key_, id<JavaSecurityKey>)
J2OBJC_FIELD_SETTER(JavaxCryptoCipher_InitParams, random_, JavaSecuritySecureRandom *)
J2OBJC_FIELD_SETTER(JavaxCryptoCipher_InitParams, spec_, id<JavaSecuritySpecAlgorithmParameterSpec>)
J2OBJC_FIELD_SETTER(JavaxCryptoCipher_InitParams, params_, JavaSecurityAlgorithmParameters *)

FOUNDATION_EXPORT void JavaxCryptoCipher_InitParams_initWithJavaxCryptoCipher_InitType_withInt_withJavaSecurityKey_withJavaSecuritySecureRandom_withJavaSecuritySpecAlgorithmParameterSpec_withJavaSecurityAlgorithmParameters_(JavaxCryptoCipher_InitParams *self, JavaxCryptoCipher_InitType *initType, jint opmode, id<JavaSecurityKey> key, JavaSecuritySecureRandom *random, id<JavaSecuritySpecAlgorithmParameterSpec> spec, JavaSecurityAlgorithmParameters *params);

FOUNDATION_EXPORT JavaxCryptoCipher_InitParams *new_JavaxCryptoCipher_InitParams_initWithJavaxCryptoCipher_InitType_withInt_withJavaSecurityKey_withJavaSecuritySecureRandom_withJavaSecuritySpecAlgorithmParameterSpec_withJavaSecurityAlgorithmParameters_(JavaxCryptoCipher_InitType *initType, jint opmode, id<JavaSecurityKey> key, JavaSecuritySecureRandom *random, id<JavaSecuritySpecAlgorithmParameterSpec> spec, JavaSecurityAlgorithmParameters *params) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoCipher_InitParams *create_JavaxCryptoCipher_InitParams_initWithJavaxCryptoCipher_InitType_withInt_withJavaSecurityKey_withJavaSecuritySecureRandom_withJavaSecuritySpecAlgorithmParameterSpec_withJavaSecurityAlgorithmParameters_(JavaxCryptoCipher_InitType *initType, jint opmode, id<JavaSecurityKey> key, JavaSecuritySecureRandom *random, id<JavaSecuritySpecAlgorithmParameterSpec> spec, JavaSecurityAlgorithmParameters *params);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher_InitParams)

#endif

#if !defined (JavaxCryptoCipher_InitType_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher_InitType))
#define JavaxCryptoCipher_InitType_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, JavaxCryptoCipher_InitType_Enum) {
  JavaxCryptoCipher_InitType_Enum_KEY = 0,
  JavaxCryptoCipher_InitType_Enum_ALGORITHM_PARAMS = 1,
  JavaxCryptoCipher_InitType_Enum_ALGORITHM_PARAM_SPEC = 2,
};

/*!
 @brief Used to keep track of which underlying <code>CipherSpi#engineInit(...)
 </code>
  variant to call when testing suitability.
 */
@interface JavaxCryptoCipher_InitType : JavaLangEnum

@property (readonly, class, nonnull) JavaxCryptoCipher_InitType *KEY NS_SWIFT_NAME(KEY);
@property (readonly, class, nonnull) JavaxCryptoCipher_InitType *ALGORITHM_PARAMS NS_SWIFT_NAME(ALGORITHM_PARAMS);
@property (readonly, class, nonnull) JavaxCryptoCipher_InitType *ALGORITHM_PARAM_SPEC NS_SWIFT_NAME(ALGORITHM_PARAM_SPEC);
+ (JavaxCryptoCipher_InitType * __nonnull)KEY;

+ (JavaxCryptoCipher_InitType * __nonnull)ALGORITHM_PARAMS;

+ (JavaxCryptoCipher_InitType * __nonnull)ALGORITHM_PARAM_SPEC;

#pragma mark Public

+ (JavaxCryptoCipher_InitType *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaxCryptoCipher_InitType_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(JavaxCryptoCipher_InitType)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaxCryptoCipher_InitType *JavaxCryptoCipher_InitType_values_[];

inline JavaxCryptoCipher_InitType *JavaxCryptoCipher_InitType_get_KEY(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_InitType, KEY)

inline JavaxCryptoCipher_InitType *JavaxCryptoCipher_InitType_get_ALGORITHM_PARAMS(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_InitType, ALGORITHM_PARAMS)

inline JavaxCryptoCipher_InitType *JavaxCryptoCipher_InitType_get_ALGORITHM_PARAM_SPEC(void);
J2OBJC_ENUM_CONSTANT(JavaxCryptoCipher_InitType, ALGORITHM_PARAM_SPEC)

FOUNDATION_EXPORT IOSObjectArray *JavaxCryptoCipher_InitType_values(void);

FOUNDATION_EXPORT JavaxCryptoCipher_InitType *JavaxCryptoCipher_InitType_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaxCryptoCipher_InitType *JavaxCryptoCipher_InitType_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher_InitType)

#endif

#if !defined (JavaxCryptoCipher_SpiAndProviderUpdater_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher_SpiAndProviderUpdater))
#define JavaxCryptoCipher_SpiAndProviderUpdater_

@class JavaSecurityProvider;
@class JavaxCryptoCipher;
@class JavaxCryptoCipherSpi;
@class JavaxCryptoCipher_CipherSpiAndProvider;
@class JavaxCryptoCipher_InitParams;

@interface JavaxCryptoCipher_SpiAndProviderUpdater : NSObject

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaxCryptoCipher:(JavaxCryptoCipher *)outer$
                           withJavaSecurityProvider:(JavaSecurityProvider *)specifiedProvider
                           withJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)specifiedSpi;

- (JavaxCryptoCipherSpi *)getCurrentSpiWithJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)spiImpl;

- (void)setCipherSpiImplAndProviderWithJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)cipherSpi
                                   withJavaSecurityProvider:(JavaSecurityProvider *)provider;

/*!
 @brief Convenience call when the Key is not available.
 */
- (JavaxCryptoCipher_CipherSpiAndProvider *)updateAndGetSpiAndProviderWithJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)spiImpl
                                                                      withJavaSecurityProvider:(JavaSecurityProvider *)provider;

/*!
 @brief Makes sure a CipherSpi that matches this type is selected.If
  <code>key !
 = null</code> then it assumes that a suitable provider exists for
  this instance (used by <code>Cipher.init</code>. If the <code>initParams</code> is passed
  in, then the <code>CipherSpi</code> returned will be initialized.
 @throw InvalidKeyExceptionif the specified key cannot be used to
                              initialize this cipher.
 */
- (JavaxCryptoCipher_CipherSpiAndProvider *)updateAndGetSpiAndProviderWithJavaxCryptoCipher_InitParams:(JavaxCryptoCipher_InitParams *)initParams
                                                                              withJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)spiImpl
                                                                              withJavaSecurityProvider:(JavaSecurityProvider *)provider;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoCipher_SpiAndProviderUpdater)

FOUNDATION_EXPORT void JavaxCryptoCipher_SpiAndProviderUpdater_initWithJavaxCryptoCipher_withJavaSecurityProvider_withJavaxCryptoCipherSpi_(JavaxCryptoCipher_SpiAndProviderUpdater *self, JavaxCryptoCipher *outer$, JavaSecurityProvider *specifiedProvider, JavaxCryptoCipherSpi *specifiedSpi);

FOUNDATION_EXPORT JavaxCryptoCipher_SpiAndProviderUpdater *new_JavaxCryptoCipher_SpiAndProviderUpdater_initWithJavaxCryptoCipher_withJavaSecurityProvider_withJavaxCryptoCipherSpi_(JavaxCryptoCipher *outer$, JavaSecurityProvider *specifiedProvider, JavaxCryptoCipherSpi *specifiedSpi) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoCipher_SpiAndProviderUpdater *create_JavaxCryptoCipher_SpiAndProviderUpdater_initWithJavaxCryptoCipher_withJavaSecurityProvider_withJavaxCryptoCipherSpi_(JavaxCryptoCipher *outer$, JavaSecurityProvider *specifiedProvider, JavaxCryptoCipherSpi *specifiedSpi);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher_SpiAndProviderUpdater)

#endif

#if !defined (JavaxCryptoCipher_CipherSpiAndProvider_) && (INCLUDE_ALL_JavaxCryptoCipher || defined(INCLUDE_JavaxCryptoCipher_CipherSpiAndProvider))
#define JavaxCryptoCipher_CipherSpiAndProvider_

@class JavaSecurityProvider;
@class JavaxCryptoCipherSpi;

@interface JavaxCryptoCipher_CipherSpiAndProvider : NSObject {
 @public
  JavaxCryptoCipherSpi *cipherSpi_;
  JavaSecurityProvider *provider_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaxCryptoCipherSpi:(JavaxCryptoCipherSpi *)cipherSpi
                              withJavaSecurityProvider:(JavaSecurityProvider *)provider;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoCipher_CipherSpiAndProvider)

J2OBJC_FIELD_SETTER(JavaxCryptoCipher_CipherSpiAndProvider, cipherSpi_, JavaxCryptoCipherSpi *)
J2OBJC_FIELD_SETTER(JavaxCryptoCipher_CipherSpiAndProvider, provider_, JavaSecurityProvider *)

FOUNDATION_EXPORT void JavaxCryptoCipher_CipherSpiAndProvider_initWithJavaxCryptoCipherSpi_withJavaSecurityProvider_(JavaxCryptoCipher_CipherSpiAndProvider *self, JavaxCryptoCipherSpi *cipherSpi, JavaSecurityProvider *provider);

FOUNDATION_EXPORT JavaxCryptoCipher_CipherSpiAndProvider *new_JavaxCryptoCipher_CipherSpiAndProvider_initWithJavaxCryptoCipherSpi_withJavaSecurityProvider_(JavaxCryptoCipherSpi *cipherSpi, JavaSecurityProvider *provider) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoCipher_CipherSpiAndProvider *create_JavaxCryptoCipher_CipherSpiAndProvider_initWithJavaxCryptoCipherSpi_withJavaSecurityProvider_(JavaxCryptoCipherSpi *cipherSpi, JavaSecurityProvider *provider);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoCipher_CipherSpiAndProvider)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaxCryptoCipher")
