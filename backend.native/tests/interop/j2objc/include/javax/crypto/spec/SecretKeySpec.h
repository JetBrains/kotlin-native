//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/javax/crypto/spec/SecretKeySpec.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxCryptoSpecSecretKeySpec")
#ifdef RESTRICT_JavaxCryptoSpecSecretKeySpec
#define INCLUDE_ALL_JavaxCryptoSpecSecretKeySpec 0
#else
#define INCLUDE_ALL_JavaxCryptoSpecSecretKeySpec 1
#endif
#undef RESTRICT_JavaxCryptoSpecSecretKeySpec

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxCryptoSpecSecretKeySpec_) && (INCLUDE_ALL_JavaxCryptoSpecSecretKeySpec || defined(INCLUDE_JavaxCryptoSpecSecretKeySpec))
#define JavaxCryptoSpecSecretKeySpec_

#define RESTRICT_JavaSecuritySpecKeySpec 1
#define INCLUDE_JavaSecuritySpecKeySpec 1
#include "java/security/spec/KeySpec.h"

#define RESTRICT_JavaxCryptoSecretKey 1
#define INCLUDE_JavaxCryptoSecretKey 1
#include "javax/crypto/SecretKey.h"

@class IOSByteArray;

/*!
 @brief This class specifies a secret key in a provider-independent fashion.
 <p>It can be used to construct a <code>SecretKey</code> from a byte array,
  without having to go through a (provider-based) 
 <code>SecretKeyFactory</code>.
  
 <p>This class is only useful for raw secret keys that can be represented as
  a byte array and have no key parameters associated with them, e.g., DES or
  Triple DES keys.
 @author Jan Luehe
 - seealso: javax.crypto.SecretKey
 - seealso: javax.crypto.SecretKeyFactory
 @since 1.4
 */
@interface JavaxCryptoSpecSecretKeySpec : NSObject < JavaSecuritySpecKeySpec, JavaxCryptoSecretKey >

#pragma mark Public

/*!
 @brief Constructs a secret key from the given byte array, using the first 
 <code>len</code> bytes of <code>key</code>, starting at 
 <code>offset</code> inclusive.
 <p> The bytes that constitute the secret key are
  those between <code>key[offset]</code> and 
 <code>key[offset+len-1]</code> inclusive. 
 <p>This constructor does not check if the given bytes indeed specify a
  secret key of the specified algorithm. For example, if the algorithm is
  DES, this constructor does not check if <code>key</code> is 8 bytes
  long, and also does not check for weak or semi-weak keys.
  In order for those checks to be performed, an algorithm-specific key
  specification class (in this case: 
 <code>DESKeySpec</code>)
  must be used.
 @param key the key material of the secret key. The first  
  <code> len </code>  bytes of the array beginning at   <code>
  offset </code>  inclusive are copied to protect  against subsequent modification.
 @param offset the offset in  <code> key </code>  where the key material
   starts.
 @param len the length of the key material.
 @param algorithm the name of the secret-key algorithm to be associated  with the given key material.
   See Appendix A in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/crypto/CryptoSpec.html#AppA">
   Java Cryptography Architecture Reference Guide
  </a>  for information about standard algorithm names.
 @throw IllegalArgumentExceptionif <code>algorithm</code>
  is null or <code>key</code> is null, empty, or too short,
  i.e. <code>key.length-offset<len</code>.
 @throw ArrayIndexOutOfBoundsExceptionis thrown if 
 <code>offset</code> or <code>len</code> index bytes outside the 
 <code>key</code>.
 */
- (instancetype __nonnull)initWithByteArray:(IOSByteArray *)key
                                    withInt:(jint)offset
                                    withInt:(jint)len
                               withNSString:(NSString *)algorithm;

/*!
 @brief Constructs a secret key from the given byte array.
 <p>This constructor does not check if the given bytes indeed specify a
  secret key of the specified algorithm. For example, if the algorithm is
  DES, this constructor does not check if <code>key</code> is 8 bytes
  long, and also does not check for weak or semi-weak keys.
  In order for those checks to be performed, an algorithm-specific 
 <i>key specification</i> class (in this case: 
 <code>DESKeySpec</code>)
  should be used.
 @param key the key material of the secret key. The contents of  the array are copied to protect against subsequent modification.
 @param algorithm the name of the secret-key algorithm to be associated  with the given key material.
   See Appendix A in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/crypto/CryptoSpec.html#AppA">
   Java Cryptography Architecture Reference Guide
  </a>  for information about standard algorithm names.
 @throw IllegalArgumentExceptionif <code>algorithm</code>
  is null or <code>key</code> is null or empty.
 */
- (instancetype __nonnull)initWithByteArray:(IOSByteArray *)key
                               withNSString:(NSString *)algorithm;

/*!
 @brief Tests for equality between the specified object and this
  object.Two SecretKeySpec objects are considered equal if
  they are both SecretKey instances which have the
  same case-insensitive algorithm name and key encoding.
 @param obj the object to test for equality with this object.
 @return true if the objects are considered equal, false if 
 <code>obj</code> is null or otherwise.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns the name of the algorithm associated with this secret key.
 @return the secret key algorithm.
 */
- (NSString *)getAlgorithm;

/*!
 @brief Returns the key material of this secret key.
 @return the key material. Returns a new array
  each time this method is called.
 */
- (IOSByteArray *)getEncoded;

/*!
 @brief Returns the name of the encoding format for this secret key.
 @return the string "RAW".
 */
- (NSString *)getFormat;

/*!
 @brief Calculates a hash code value for the object.
 Objects that are equal will also have the same hashcode.
 */
- (NSUInteger)hash;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoSpecSecretKeySpec)

FOUNDATION_EXPORT void JavaxCryptoSpecSecretKeySpec_initWithByteArray_withNSString_(JavaxCryptoSpecSecretKeySpec *self, IOSByteArray *key, NSString *algorithm);

FOUNDATION_EXPORT JavaxCryptoSpecSecretKeySpec *new_JavaxCryptoSpecSecretKeySpec_initWithByteArray_withNSString_(IOSByteArray *key, NSString *algorithm) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoSpecSecretKeySpec *create_JavaxCryptoSpecSecretKeySpec_initWithByteArray_withNSString_(IOSByteArray *key, NSString *algorithm);

FOUNDATION_EXPORT void JavaxCryptoSpecSecretKeySpec_initWithByteArray_withInt_withInt_withNSString_(JavaxCryptoSpecSecretKeySpec *self, IOSByteArray *key, jint offset, jint len, NSString *algorithm);

FOUNDATION_EXPORT JavaxCryptoSpecSecretKeySpec *new_JavaxCryptoSpecSecretKeySpec_initWithByteArray_withInt_withInt_withNSString_(IOSByteArray *key, jint offset, jint len, NSString *algorithm) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoSpecSecretKeySpec *create_JavaxCryptoSpecSecretKeySpec_initWithByteArray_withInt_withInt_withNSString_(IOSByteArray *key, jint offset, jint len, NSString *algorithm);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoSpecSecretKeySpec)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaxCryptoSpecSecretKeySpec")
