//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/javax/crypto/Mac.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxCryptoMac")
#ifdef RESTRICT_JavaxCryptoMac
#define INCLUDE_ALL_JavaxCryptoMac 0
#else
#define INCLUDE_ALL_JavaxCryptoMac 1
#endif
#undef RESTRICT_JavaxCryptoMac

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxCryptoMac_) && (INCLUDE_ALL_JavaxCryptoMac || defined(INCLUDE_JavaxCryptoMac))
#define JavaxCryptoMac_

@class IOSByteArray;
@class JavaNioByteBuffer;
@class JavaSecurityProvider;
@class JavaxCryptoMacSpi;
@protocol JavaSecurityKey;
@protocol JavaSecuritySpecAlgorithmParameterSpec;

/*!
 @brief This class provides the functionality of a "Message Authentication Code"
  (MAC) algorithm.
 <p> A MAC provides a way to check
  the integrity of information transmitted over or stored in an unreliable
  medium, based on a secret key. Typically, message
  authentication codes are used between two parties that share a secret
  key in order to validate information transmitted between these
  parties. 
 <p> A MAC mechanism that is based on cryptographic hash functions is
  referred to as HMAC. HMAC can be used with any cryptographic hash function,
  e.g., MD5 or SHA-1, in combination with a secret shared key. HMAC is
  specified in RFC 2104. 
 <p> Android provides the following <code>Mac</code> algorithms: 
 <table>
    <thead>
      <tr>
        <th>Algorithm</th>
        <th>Supported API Levels</th>
      </tr>
    </thead>
    <tbody>
      <tr class="deprecated">
        <td>DESMAC</td>
        <td>1-8</td>
      </tr>
      <tr class="deprecated">
        <td>DESMAC/CFB8</td>
        <td>1-8</td>
      </tr>
      <tr class="deprecated">
        <td>DESedeMAC</td>
        <td>1-8</td>
      </tr>
      <tr class="deprecated">
        <td>DESedeMAC/CFB8</td>
        <td>1-8</td>
      </tr>
      <tr class="deprecated">
        <td>DESedeMAC64</td>
        <td>1-8</td>
      </tr>
      <tr class="deprecated">
        <td>DESwithISO9797</td>
        <td>1-8</td>
      </tr>
      <tr>
        <td>HmacMD5</td>
        <td>1+</td>
      </tr>
      <tr>
        <td>HmacSHA1</td>
        <td>1+</td>
      </tr>
      <tr>
        <td>HmacSHA224</td>
        <td>1-8,22+</td>
      </tr>
      <tr>
        <td>HmacSHA256</td>
        <td>1+</td>
      </tr>
      <tr>
        <td>HmacSHA384</td>
        <td>1+</td>
      </tr>
      <tr>
        <td>HmacSHA512</td>
        <td>1+</td>
      </tr>
      <tr class="deprecated">
        <td>ISO9797ALG3MAC</td>
        <td>1-8</td>
      </tr>
      <tr>
        <td>PBEwithHmacSHA</td>
        <td>1+</td>
      </tr>
      <tr>
        <td>PBEwithHmacSHA1</td>
        <td>1+</td>
      </tr>
      <tr>
        <td>PBEwithHmacSHA224</td>
        <td>26+</td>
      </tr>
      <tr>
        <td>PBEwithHmacSHA256</td>
        <td>26+</td>
      </tr>
      <tr>
        <td>PBEwithHmacSHA384</td>
        <td>26+</td>
      </tr>
      <tr>
        <td>PBEwithHmacSHA512</td>
        <td>26+</td>
      </tr>
    </tbody>
  </table>
  These algorithms are described in the 
 <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Mac">
  Mac section</a> of the
  Java Cryptography Architecture Standard Algorithm Name Documentation.
 @author Jan Luehe
 @since 1.4
 */
@interface JavaxCryptoMac : NSObject < NSCopying >

#pragma mark Public

/*!
 @brief Returns a clone if the provider implementation is cloneable.
 @return a clone if the provider implementation is cloneable.
 @throw CloneNotSupportedExceptionif this is called on a
  delegate that does not support <code>Cloneable</code>.
 */
- (id)java_clone;

/*!
 @brief Finishes the MAC operation.
 <p>A call to this method resets this <code>Mac</code> object to the
  state it was in when previously initialized via a call to 
 <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
  That is, the object is reset and available to generate another MAC from
  the same key, if desired, via new calls to <code>update</code> and 
 <code>doFinal</code>.
  (In order to reuse this <code>Mac</code> object with a different key,
  it must be reinitialized via a call to <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
 @return the MAC result.
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 */
- (IOSByteArray *)doFinal;

/*!
 @brief Processes the given array of bytes and finishes the MAC operation.
 <p>A call to this method resets this <code>Mac</code> object to the
  state it was in when previously initialized via a call to 
 <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
  That is, the object is reset and available to generate another MAC from
  the same key, if desired, via new calls to <code>update</code> and 
 <code>doFinal</code>.
  (In order to reuse this <code>Mac</code> object with a different key,
  it must be reinitialized via a call to <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
 @param input data in bytes
 @return the MAC result.
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 */
- (IOSByteArray *)doFinalWithByteArray:(IOSByteArray *)input;

/*!
 @brief Finishes the MAC operation.
 <p>A call to this method resets this <code>Mac</code> object to the
  state it was in when previously initialized via a call to 
 <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
  That is, the object is reset and available to generate another MAC from
  the same key, if desired, via new calls to <code>update</code> and 
 <code>doFinal</code>.
  (In order to reuse this <code>Mac</code> object with a different key,
  it must be reinitialized via a call to <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
  
 <p>The MAC result is stored in <code>output</code>, starting at 
 <code>outOffset</code> inclusive.
 @param output the buffer where the MAC result is stored
 @param outOffset the offset in  <code> output </code>  where the MAC is
   stored
 @throw ShortBufferExceptionif the given output buffer is too small
  to hold the result
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 */
- (void)doFinalWithByteArray:(IOSByteArray *)output
                     withInt:(jint)outOffset;

/*!
 @brief Returns the algorithm name of this <code>Mac</code> object.
 <p>This is the same name that was specified in one of the 
 <code>getInstance</code> calls that created this 
 <code>Mac</code> object.
 @return the algorithm name of this <code>Mac</code> object.
 */
- (NSString *)getAlgorithm;

/*!
 @brief Returns the <code>MacSpi</code> backing this <code>Mac</code> or <code>null</code> if no <code>MacSpi</code> is
  backing this <code>Mac</code>.
 */
- (JavaxCryptoMacSpi *)getCurrentSpi;

/*!
 @brief Returns a <code>Mac</code> object that implements the
  specified MAC algorithm.
 <p> This method traverses the list of registered security Providers,
  starting with the most preferred Provider.
  A new Mac object encapsulating the
  MacSpi implementation from the first
  Provider that supports the specified algorithm is returned. 
 <p> Note that the list of registered providers may be retrieved via the 
 <code>Security.getProviders()</code> method.
 @param algorithm the standard name of the requested MAC algorithm.  See the Mac section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Mac">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard algorithm names.
 @return the new <code>Mac</code> object.
 @throw NoSuchAlgorithmExceptionif no Provider supports a
           MacSpi implementation for the
           specified algorithm.
 - seealso: java.security.Provider
 */
+ (JavaxCryptoMac *)getInstanceWithNSString:(NSString *)algorithm;

/*!
 @brief Returns a <code>Mac</code> object that implements the
  specified MAC algorithm.
 <p> A new Mac object encapsulating the
  MacSpi implementation from the specified Provider
  object is returned.  Note that the specified Provider object
  does not have to be registered in the provider list.
 @param algorithm the standard name of the requested MAC algorithm.  See the Mac section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Mac">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard algorithm names.
 @param provider the provider.
 @return the new <code>Mac</code> object.
 @throw NoSuchAlgorithmExceptionif a MacSpi
           implementation for the specified algorithm is not available
           from the specified Provider object.
 @throw IllegalArgumentExceptionif the <code>provider</code>
           is null.
 - seealso: java.security.Provider
 */
+ (JavaxCryptoMac *)getInstanceWithNSString:(NSString *)algorithm
                   withJavaSecurityProvider:(JavaSecurityProvider *)provider;

/*!
 @brief Returns a <code>Mac</code> object that implements the
  specified MAC algorithm.
 <p> A new Mac object encapsulating the
  MacSpi implementation from the specified provider
  is returned.  The specified provider must be registered
  in the security provider list. 
 <p> Note that the list of registered providers may be retrieved via the 
 <code>Security.getProviders()</code> method.
 @param algorithm the standard name of the requested MAC algorithm.  See the Mac section in the 
  <a href="{@@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/security/StandardNames.html#Mac">
   Java Cryptography Architecture Standard Algorithm Name Documentation
  </a>  for information about standard algorithm names.
 @param provider the name of the provider.
 @return the new <code>Mac</code> object.
 @throw NoSuchAlgorithmExceptionif a MacSpi
           implementation for the specified algorithm is not
           available from the specified provider.
 @throw NoSuchProviderExceptionif the specified provider is not
           registered in the security provider list.
 @throw IllegalArgumentExceptionif the <code>provider</code>
           is null or empty.
 - seealso: java.security.Provider
 */
+ (JavaxCryptoMac *)getInstanceWithNSString:(NSString *)algorithm
                               withNSString:(NSString *)provider;

/*!
 @brief Returns the length of the MAC in bytes.
 @return the MAC length in bytes.
 */
- (jint)getMacLength;

/*!
 @brief Returns the provider of this <code>Mac</code> object.
 @return the provider of this <code>Mac</code> object.
 */
- (JavaSecurityProvider *)getProvider;

/*!
 @brief Initializes this <code>Mac</code> object with the given key.
 @param key the key.
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this MAC.
 */
- (void)init__WithJavaSecurityKey:(id<JavaSecurityKey>)key OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Initializes this <code>Mac</code> object with the given key and
  algorithm parameters.
 @param key the key.
 @param params the algorithm parameters.
 @throw InvalidKeyExceptionif the given key is inappropriate for
  initializing this MAC.
 @throw InvalidAlgorithmParameterExceptionif the given algorithm
  parameters are inappropriate for this MAC.
 */
- (void)init__WithJavaSecurityKey:(id<JavaSecurityKey>)key
withJavaSecuritySpecAlgorithmParameterSpec:(id<JavaSecuritySpecAlgorithmParameterSpec>)params OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Resets this <code>Mac</code> object.
 <p>A call to this method resets this <code>Mac</code> object to the
  state it was in when previously initialized via a call to 
 <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
  That is, the object is reset and available to generate another MAC from
  the same key, if desired, via new calls to <code>update</code> and 
 <code>doFinal</code>.
  (In order to reuse this <code>Mac</code> object with a different key,
  it must be reinitialized via a call to <code>init(Key)</code> or 
 <code>init(Key, AlgorithmParameterSpec)</code>.
 */
- (void)reset;

/*!
 @brief Processes the given byte.
 @param input the input byte to be processed.
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 */
- (void)updateWithByte:(jbyte)input;

/*!
 @brief Processes the given array of bytes.
 @param input the array of bytes to be processed.
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 */
- (void)updateWithByteArray:(IOSByteArray *)input;

/*!
 @brief Processes the first <code>len</code> bytes in <code>input</code>,
  starting at <code>offset</code> inclusive.
 @param input the input buffer.
 @param offset the offset in  <code> input </code>  where the input starts.
 @param len the number of bytes to process.
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 */
- (void)updateWithByteArray:(IOSByteArray *)input
                    withInt:(jint)offset
                    withInt:(jint)len;

/*!
 @brief Processes <code>input.remaining()</code> bytes in the ByteBuffer 
 <code>input</code>, starting at <code>input.position()</code>.
 Upon return, the buffer's position will be equal to its limit;
  its limit will not have changed.
 @param input the ByteBuffer
 @throw IllegalStateExceptionif this <code>Mac</code> has not been
  initialized.
 @since 1.5
 */
- (void)updateWithJavaNioByteBuffer:(JavaNioByteBuffer *)input;

#pragma mark Protected

/*!
 @brief Creates a MAC object.
 @param macSpi the delegate
 @param provider the provider
 @param algorithm the algorithm
 */
- (instancetype __nonnull)initWithJavaxCryptoMacSpi:(JavaxCryptoMacSpi *)macSpi
                           withJavaSecurityProvider:(JavaSecurityProvider *)provider
                                       withNSString:(NSString *)algorithm;

#pragma mark Package-Private

/*!
 @brief Choose the Spi from the first provider available.Used if
  delayed provider selection is not possible because init()
  is not the first method called.
 */
- (void)chooseFirstProvider;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoMac)

FOUNDATION_EXPORT void JavaxCryptoMac_initWithJavaxCryptoMacSpi_withJavaSecurityProvider_withNSString_(JavaxCryptoMac *self, JavaxCryptoMacSpi *macSpi, JavaSecurityProvider *provider, NSString *algorithm);

FOUNDATION_EXPORT JavaxCryptoMac *new_JavaxCryptoMac_initWithJavaxCryptoMacSpi_withJavaSecurityProvider_withNSString_(JavaxCryptoMacSpi *macSpi, JavaSecurityProvider *provider, NSString *algorithm) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoMac *create_JavaxCryptoMac_initWithJavaxCryptoMacSpi_withJavaSecurityProvider_withNSString_(JavaxCryptoMacSpi *macSpi, JavaSecurityProvider *provider, NSString *algorithm);

FOUNDATION_EXPORT JavaxCryptoMac *JavaxCryptoMac_getInstanceWithNSString_(NSString *algorithm);

FOUNDATION_EXPORT JavaxCryptoMac *JavaxCryptoMac_getInstanceWithNSString_withNSString_(NSString *algorithm, NSString *provider);

FOUNDATION_EXPORT JavaxCryptoMac *JavaxCryptoMac_getInstanceWithNSString_withJavaSecurityProvider_(NSString *algorithm, JavaSecurityProvider *provider);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoMac)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaxCryptoMac")
