//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/javax/crypto/SealedObject.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxCryptoSealedObject")
#ifdef RESTRICT_JavaxCryptoSealedObject
#define INCLUDE_ALL_JavaxCryptoSealedObject 0
#else
#define INCLUDE_ALL_JavaxCryptoSealedObject 1
#endif
#undef RESTRICT_JavaxCryptoSealedObject

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxCryptoSealedObject_) && (INCLUDE_ALL_JavaxCryptoSealedObject || defined(INCLUDE_JavaxCryptoSealedObject))
#define JavaxCryptoSealedObject_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSByteArray;
@class JavaxCryptoCipher;
@protocol JavaSecurityKey;

/*!
 @brief This class enables a programmer to create an object and protect its
  confidentiality with a cryptographic algorithm.
 <p> Given any Serializable object, one can create a SealedObject
  that encapsulates the original object, in serialized
  format (i.e., a "deep copy"), and seals (encrypts) its serialized contents,
  using a cryptographic algorithm such as DES, to protect its
  confidentiality.  The encrypted content can later be decrypted (with
  the corresponding algorithm using the correct decryption key) and
  de-serialized, yielding the original object. 
 <p> Note that the Cipher object must be fully initialized with the
  correct algorithm, key, padding scheme, etc., before being applied
  to a SealedObject. 
 <p> The original object that was sealed can be recovered in two different
  ways: 
 <ul>
  
 <li>by using the <code>getObject</code>
  method that takes a <code>Cipher</code> object. 
 <p> This method requires a fully initialized <code>Cipher</code> object,
  initialized with the
  exact same algorithm, key, padding scheme, etc., that were used to seal the
  object. 
 <p> This approach has the advantage that the party who unseals the
  sealed object does not require knowledge of the decryption key. For example,
  after one party has initialized the cipher object with the required
  decryption key, it could hand over the cipher object to
  another party who then unseals the sealed object. 
 <li>by using one of the 
 <code>getObject</code> methods
  that take a <code>Key</code> object. 
 <p> In this approach, the <code>getObject</code> method creates a cipher
  object for the appropriate decryption algorithm and initializes it with the
  given decryption key and the algorithm parameters (if any) that were stored
  in the sealed object. 
 <p> This approach has the advantage that the party who
  unseals the object does not need to keep track of the parameters (e.g., an
  IV) that were used to seal the object. 
 </ul>
 @author Li Gong
 @author Jan Luehe
 - seealso: Cipher
 @since 1.4
 */
@interface JavaxCryptoSealedObject : NSObject < JavaIoSerializable > {
 @public
  /*!
   @brief The cryptographic parameters used by the sealing Cipher,
  encoded in the default format.
   <p>
  That is, <code>cipher.getParameters().getEncoded()</code>.
   */
  IOSByteArray *encodedParams_;
}
@property (readonly, class) jlong serialVersionUID NS_SWIFT_NAME(serialVersionUID);

+ (jlong)serialVersionUID;

#pragma mark Public

/*!
 @brief Constructs a SealedObject from any Serializable object.
 <p>The given object is serialized, and its serialized contents are
  encrypted using the given Cipher, which must be fully initialized. 
 <p>Any algorithm parameters that may be used in the encryption
  operation are stored inside of the new <code>SealedObject</code>.
 @param object the object to be sealed; can be null.
 @param c the cipher used to seal the object.
 @throw NullPointerExceptionif the given cipher is null.
 @throw IOExceptionif an error occurs during serialization
 @throw IllegalBlockSizeExceptionif the given cipher is a block
  cipher, no padding has been requested, and the total input length
  (i.e., the length of the serialized object contents) is not a multiple
  of the cipher's block size
 */
- (instancetype __nonnull)initWithJavaIoSerializable:(id<JavaIoSerializable>)object
                               withJavaxCryptoCipher:(JavaxCryptoCipher *)c;

/*!
 @brief Returns the algorithm that was used to seal this object.
 @return the algorithm that was used to seal this object.
 */
- (NSString *)getAlgorithm;

/*!
 @brief Retrieves the original (encapsulated) object.
 <p>The encapsulated object is unsealed (using the given Cipher,
  assuming that the Cipher is already properly initialized) and
  de-serialized, before it is returned.
 @param c the cipher used to unseal the object
 @return the original object.
 @throw NullPointerExceptionif the given cipher is null.
 @throw IOExceptionif an error occurs during de-serialiazation
 @throw ClassNotFoundExceptionif an error occurs during
  de-serialiazation
 @throw IllegalBlockSizeExceptionif the given cipher is a block
  cipher, no padding has been requested, and the total input length is
  not a multiple of the cipher's block size
 @throw BadPaddingExceptionif the given cipher has been
  initialized for decryption, and padding has been specified, but
  the input data does not have proper expected padding bytes
 */
- (id)getObjectWithJavaxCryptoCipher:(JavaxCryptoCipher *)c;

/*!
 @brief Retrieves the original (encapsulated) object.
 <p>This method creates a cipher for the algorithm that had been used in
  the sealing operation.
  If the default provider package provides an implementation of that
  algorithm, an instance of Cipher containing that implementation is used.
  If the algorithm is not available in the default package, other
  packages are searched.
  The Cipher object is initialized for decryption, using the given 
 <code>key</code> and the parameters (if any) that had been used in the
  sealing operation. 
 <p>The encapsulated object is unsealed and de-serialized, before it is
  returned.
 @param key the key used to unseal the object.
 @return the original object.
 @throw IOExceptionif an error occurs during de-serialiazation.
 @throw ClassNotFoundExceptionif an error occurs during
  de-serialiazation.
 @throw NoSuchAlgorithmExceptionif the algorithm to unseal the
  object is not available.
 @throw InvalidKeyExceptionif the given key cannot be used to unseal
  the object (e.g., it has the wrong algorithm).
 @throw NullPointerExceptionif <code>key</code> is null.
 */
- (id)getObjectWithJavaSecurityKey:(id<JavaSecurityKey>)key;

/*!
 @brief Retrieves the original (encapsulated) object.
 <p>This method creates a cipher for the algorithm that had been used in
  the sealing operation, using an implementation of that algorithm from
  the given <code>provider</code>.
  The Cipher object is initialized for decryption, using the given 
 <code>key</code> and the parameters (if any) that had been used in the
  sealing operation. 
 <p>The encapsulated object is unsealed and de-serialized, before it is
  returned.
 @param key the key used to unseal the object.
 @param provider the name of the provider of the algorithm to unseal  the object.
 @return the original object.
 @throw IllegalArgumentExceptionif the given provider is null
  or empty.
 @throw IOExceptionif an error occurs during de-serialiazation.
 @throw ClassNotFoundExceptionif an error occurs during
  de-serialiazation.
 @throw NoSuchAlgorithmExceptionif the algorithm to unseal the
  object is not available.
 @throw NoSuchProviderExceptionif the given provider is not
  configured.
 @throw InvalidKeyExceptionif the given key cannot be used to unseal
  the object (e.g., it has the wrong algorithm).
 @throw NullPointerExceptionif <code>key</code> is null.
 */
- (id)getObjectWithJavaSecurityKey:(id<JavaSecurityKey>)key
                      withNSString:(NSString *)provider;

#pragma mark Protected

/*!
 @brief Constructs a SealedObject object from the passed-in SealedObject.
 @param so a SealedObject object
 @throw NullPointerExceptionif the given sealed object is null.
 */
- (instancetype __nonnull)initWithJavaxCryptoSealedObject:(JavaxCryptoSealedObject *)so;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoSealedObject)

J2OBJC_FIELD_SETTER(JavaxCryptoSealedObject, encodedParams_, IOSByteArray *)

inline jlong JavaxCryptoSealedObject_get_serialVersionUID(void);
#define JavaxCryptoSealedObject_serialVersionUID 4482838265551344752LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaxCryptoSealedObject, serialVersionUID, jlong)

FOUNDATION_EXPORT void JavaxCryptoSealedObject_initWithJavaIoSerializable_withJavaxCryptoCipher_(JavaxCryptoSealedObject *self, id<JavaIoSerializable> object, JavaxCryptoCipher *c);

FOUNDATION_EXPORT JavaxCryptoSealedObject *new_JavaxCryptoSealedObject_initWithJavaIoSerializable_withJavaxCryptoCipher_(id<JavaIoSerializable> object, JavaxCryptoCipher *c) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoSealedObject *create_JavaxCryptoSealedObject_initWithJavaIoSerializable_withJavaxCryptoCipher_(id<JavaIoSerializable> object, JavaxCryptoCipher *c);

FOUNDATION_EXPORT void JavaxCryptoSealedObject_initWithJavaxCryptoSealedObject_(JavaxCryptoSealedObject *self, JavaxCryptoSealedObject *so);

FOUNDATION_EXPORT JavaxCryptoSealedObject *new_JavaxCryptoSealedObject_initWithJavaxCryptoSealedObject_(JavaxCryptoSealedObject *so) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoSealedObject *create_JavaxCryptoSealedObject_initWithJavaxCryptoSealedObject_(JavaxCryptoSealedObject *so);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoSealedObject)

#endif

#if !defined (JavaxCryptoextObjectInputStream_) && (INCLUDE_ALL_JavaxCryptoSealedObject || defined(INCLUDE_JavaxCryptoextObjectInputStream))
#define JavaxCryptoextObjectInputStream_

#define RESTRICT_JavaIoObjectInputStream 1
#define INCLUDE_JavaIoObjectInputStream 1
#include "java/io/ObjectInputStream.h"

@class IOSClass;
@class JavaIoInputStream;
@class JavaIoObjectStreamClass;

@interface JavaxCryptoextObjectInputStream : JavaIoObjectInputStream

#pragma mark Protected

- (IOSClass *)resolveClassWithJavaIoObjectStreamClass:(JavaIoObjectStreamClass *)v;

#pragma mark Package-Private

- (instancetype __nonnull)initPackagePrivateWithJavaIoInputStream:(JavaIoInputStream *)inArg;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

- (instancetype __nonnull)initWithJavaIoInputStream:(JavaIoInputStream *)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxCryptoextObjectInputStream)

FOUNDATION_EXPORT void JavaxCryptoextObjectInputStream_initPackagePrivateWithJavaIoInputStream_(JavaxCryptoextObjectInputStream *self, JavaIoInputStream *inArg);

FOUNDATION_EXPORT JavaxCryptoextObjectInputStream *new_JavaxCryptoextObjectInputStream_initPackagePrivateWithJavaIoInputStream_(JavaIoInputStream *inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxCryptoextObjectInputStream *create_JavaxCryptoextObjectInputStream_initPackagePrivateWithJavaIoInputStream_(JavaIoInputStream *inArg);

J2OBJC_TYPE_LITERAL_HEADER(JavaxCryptoextObjectInputStream)

@compatibility_alias JavaxCryptoExtObjectInputStream JavaxCryptoextObjectInputStream;

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaxCryptoSealedObject")
