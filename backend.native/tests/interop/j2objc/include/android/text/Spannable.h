//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/frameworks/base/core/java/android/text/Spannable.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidTextSpannable")
#ifdef RESTRICT_AndroidTextSpannable
#define INCLUDE_ALL_AndroidTextSpannable 0
#else
#define INCLUDE_ALL_AndroidTextSpannable 1
#endif
#undef RESTRICT_AndroidTextSpannable

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidTextSpannable_) && (INCLUDE_ALL_AndroidTextSpannable || defined(INCLUDE_AndroidTextSpannable))
#define AndroidTextSpannable_

#define RESTRICT_AndroidTextSpanned 1
#define INCLUDE_AndroidTextSpanned 1
#include "android/text/Spanned.h"

/*!
 @brief This is the interface for text to which markup objects can be
  attached and detached.Not all Spannable classes have mutable text;
  see <code>Editable</code> for that.
 */
@protocol AndroidTextSpannable < AndroidTextSpanned, JavaObject >

/*!
 @brief Attach the specified markup object to the range <code>start&hellip;end</code>
  of the text, or move the object to that range if it was already
  attached elsewhere.See <code>Spanned</code> for an explanation of
  what the flags mean.
 The object can be one that has meaning only
  within your application, or it can be one that the text system will
  use to affect text display or behavior.  Some noteworthy ones are 
 <code>android.text.TextWatcher</code> and <code>android.text.SpanWatcher</code>.
 */
- (void)setSpanWithId:(id)what
              withInt:(jint)start
              withInt:(jint)end
              withInt:(jint)flags;

/*!
 @brief Remove the specified object from the range of text to which it
  was attached, if any.It is OK to remove an object that was never
  attached in the first place.
 */
- (void)removeSpanWithId:(id)what;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidTextSpannable)

J2OBJC_TYPE_LITERAL_HEADER(AndroidTextSpannable)

#endif

#if !defined (AndroidTextSpannable_Factory_) && (INCLUDE_ALL_AndroidTextSpannable || defined(INCLUDE_AndroidTextSpannable_Factory))
#define AndroidTextSpannable_Factory_

@protocol AndroidTextSpannable;
@protocol JavaLangCharSequence;

/*!
 @brief Factory used by TextView to create new Spannables.You can subclass
  it to provide something other than SpannableString.
 */
@interface AndroidTextSpannable_Factory : NSObject

#pragma mark Public

- (instancetype __nonnull)init;

/*!
 @brief Returns the standard Spannable Factory.
 */
+ (AndroidTextSpannable_Factory *)getInstance;

/*!
 @brief Returns a new SpannableString from the specified CharSequence.
 You can override this to provide a different kind of Spannable.
 */
- (id<AndroidTextSpannable>)newSpannableWithJavaLangCharSequence:(id<JavaLangCharSequence>)source OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_STATIC_INIT(AndroidTextSpannable_Factory)

FOUNDATION_EXPORT void AndroidTextSpannable_Factory_init(AndroidTextSpannable_Factory *self);

FOUNDATION_EXPORT AndroidTextSpannable_Factory *new_AndroidTextSpannable_Factory_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidTextSpannable_Factory *create_AndroidTextSpannable_Factory_init(void);

FOUNDATION_EXPORT AndroidTextSpannable_Factory *AndroidTextSpannable_Factory_getInstance(void);

J2OBJC_TYPE_LITERAL_HEADER(AndroidTextSpannable_Factory)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidTextSpannable")
