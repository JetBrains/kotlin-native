//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/frameworks/base/core/java/android/text/util/Rfc822Tokenizer.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidTextUtilRfc822Tokenizer")
#ifdef RESTRICT_AndroidTextUtilRfc822Tokenizer
#define INCLUDE_ALL_AndroidTextUtilRfc822Tokenizer 0
#else
#define INCLUDE_ALL_AndroidTextUtilRfc822Tokenizer 1
#endif
#undef RESTRICT_AndroidTextUtilRfc822Tokenizer

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidTextUtilRfc822Tokenizer_) && (INCLUDE_ALL_AndroidTextUtilRfc822Tokenizer || defined(INCLUDE_AndroidTextUtilRfc822Tokenizer))
#define AndroidTextUtilRfc822Tokenizer_

@class IOSObjectArray;
@protocol JavaLangCharSequence;
@protocol JavaUtilCollection;

/*!
 @brief This class works as a Tokenizer for MultiAutoCompleteTextView for
  address list fields, and also provides a method for converting
  a string of addresses (such as might be typed into such a field)
  into a series of Rfc822Tokens.
 */
@interface AndroidTextUtilRfc822Tokenizer : NSObject

#pragma mark Public

- (instancetype __nonnull)init;

/*!
 */
- (jint)findTokenEndWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                     withInt:(jint)cursor;

/*!
 */
- (jint)findTokenStartWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                       withInt:(jint)cursor;

/*!
 @brief Terminates the specified address with a comma and space.
 This assumes that the specified text already has valid syntax.
  The Adapter subclass's convertToString() method must make that
  guarantee.
 */
- (id<JavaLangCharSequence>)terminateTokenWithJavaLangCharSequence:(id<JavaLangCharSequence>)text;

/*!
 @brief This method will try to take a string like
  "Foo Bar (something) &lt;foo\@@google.com&gt;,
  blah\@@google.com (something)"
  and convert it into one or more Rfc822Tokens.
 It does *not* decode MIME encoded-words; charset conversion
  must already have taken place if necessary.
  It will try to be tolerant of broken syntax instead of
  returning an error.
 */
+ (IOSObjectArray *)tokenizeWithJavaLangCharSequence:(id<JavaLangCharSequence>)text;

/*!
 @brief This constructor will try to take a string like
  "Foo Bar (something) &lt;foo\@@google.com&gt;,
  blah\@@google.com (something)"
  and convert it into one or more Rfc822Tokens, output into the supplied
  collection.
 It does *not* decode MIME encoded-words; charset conversion
  must already have taken place if necessary.
  It will try to be tolerant of broken syntax instead of
  returning an error.
 */
+ (void)tokenizeWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                  withJavaUtilCollection:(id<JavaUtilCollection>)outArg;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidTextUtilRfc822Tokenizer)

FOUNDATION_EXPORT void AndroidTextUtilRfc822Tokenizer_init(AndroidTextUtilRfc822Tokenizer *self);

FOUNDATION_EXPORT AndroidTextUtilRfc822Tokenizer *new_AndroidTextUtilRfc822Tokenizer_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidTextUtilRfc822Tokenizer *create_AndroidTextUtilRfc822Tokenizer_init(void);

FOUNDATION_EXPORT void AndroidTextUtilRfc822Tokenizer_tokenizeWithJavaLangCharSequence_withJavaUtilCollection_(id<JavaLangCharSequence> text, id<JavaUtilCollection> outArg);

FOUNDATION_EXPORT IOSObjectArray *AndroidTextUtilRfc822Tokenizer_tokenizeWithJavaLangCharSequence_(id<JavaLangCharSequence> text);

J2OBJC_TYPE_LITERAL_HEADER(AndroidTextUtilRfc822Tokenizer)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidTextUtilRfc822Tokenizer")
