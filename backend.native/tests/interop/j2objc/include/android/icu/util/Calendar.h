//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/util/Calendar.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuUtilCalendar")
#ifdef RESTRICT_AndroidIcuUtilCalendar
#define INCLUDE_ALL_AndroidIcuUtilCalendar 0
#else
#define INCLUDE_ALL_AndroidIcuUtilCalendar 1
#endif
#undef RESTRICT_AndroidIcuUtilCalendar

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuUtilCalendar_) && (INCLUDE_ALL_AndroidIcuUtilCalendar || defined(INCLUDE_AndroidIcuUtilCalendar))
#define AndroidIcuUtilCalendar_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class AndroidIcuTextDateFormat;
@class AndroidIcuUtilCalendar_WeekData;
@class AndroidIcuUtilTimeZone;
@class AndroidIcuUtilULocale;
@class AndroidIcuUtilULocale_Type;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaUtilDate;
@class JavaUtilLocale;

/*!
 @brief <strong>[icu enhancement]</strong> ICU's replacement for <code>java.util.Calendar</code>.
 &nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
 <p><code>Calendar</code> is an abstract base class for converting between
  a <code>Date</code> object and a set of integer fields such as 
 <code>YEAR</code>, <code>MONTH</code>, <code>DAY</code>, <code>HOUR</code>,
  and so on. (A <code>Date</code> object represents a specific instant in
  time with millisecond precision. See 
 <code>Date</code>
  for information about the <code>Date</code> class.) 
 <p>Subclasses of <code>Calendar</code> interpret a <code>Date</code>
  according to the rules of a specific calendar system.  ICU4J contains
  several subclasses implementing different international calendar systems. 
 <p>
  Like other locale-sensitive classes, <code>Calendar</code> provides a
  class method, <code>getInstance</code>, for getting a generally useful
  object of this type. <code>Calendar</code>'s <code>getInstance</code> method
  returns a calendar of a type appropriate to the locale, whose
  time fields have been initialized with the current date and time: 
 <blockquote>
  @code
Calendar rightNow = Calendar.getInstance()
@endcode
  </blockquote>
  
 <p>When a <code>ULocale</code> is used by <code>getInstance</code>, its
  '<code>calendar</code>' tag and value are retrieved if present.  If a recognized
  value is supplied, a calendar is provided and configured as appropriate.
  Currently recognized tags are "buddhist", "chinese", "coptic", "ethiopic",
  "gregorian", "hebrew", "islamic", "islamic-civil", "japanese", and "roc".  For
  example: <blockquote>
  @code
Calendar cal = Calendar.getInstance(new ULocale("en_US@@calendar=japanese"));
@endcode
  </blockquote> will return an instance of JapaneseCalendar (using en_US conventions for
  minimum days in first week, start day of week, et cetera). 
 <p>A <code>Calendar</code> object can produce all the time field values
  needed to implement the date-time formatting for a particular language and
  calendar style (for example, Japanese-Gregorian, Japanese-Traditional). 
 <code>Calendar</code> defines the range of values returned by certain fields,
  as well as their meaning.  For example, the first month of the year has value 
 <code>MONTH</code> == <code>JANUARY</code> for all calendars.  Other values
  are defined by the concrete subclass, such as <code>ERA</code> and 
 <code>YEAR</code>.  See individual field documentation and subclass
  documentation for details. 
 <p>When a <code>Calendar</code> is <em>lenient</em>, it accepts a wider range
  of field values than it produces.  For example, a lenient 
 <code>GregorianCalendar</code> interprets <code>MONTH</code> == 
 <code>JANUARY</code>, <code>DAY_OF_MONTH</code> == 32 as February 1.  A
  non-lenient <code>GregorianCalendar</code> throws an exception when given
  out-of-range field settings.  When calendars recompute field values for
  return by <code>get()</code>, they normalize them.  For example, a 
 <code>GregorianCalendar</code> always produces <code>DAY_OF_MONTH</code>
  values between 1 and the length of the month. 
 <p><code>Calendar</code> defines a locale-specific seven day week using two
  parameters: the first day of the week and the minimal days in first week
  (from 1 to 7).  These numbers are taken from the locale resource data when a 
 <code>Calendar</code> is constructed.  They may also be specified explicitly
  through the API. 
 <p>When setting or getting the <code>WEEK_OF_MONTH</code> or 
 <code>WEEK_OF_YEAR</code> fields, <code>Calendar</code> must determine the
  first week of the month or year as a reference point.  The first week of a
  month or year is defined as the earliest seven day period beginning on 
 <code>getFirstDayOfWeek()</code> and containing at least 
 <code>getMinimalDaysInFirstWeek()</code> days of that month or year.  Weeks
  numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
  it.  Note that the normalized numbering returned by <code>get()</code> may be
  different.  For example, a specific <code>Calendar</code> subclass may
  designate the week before week 1 of a year as week <em>n</em> of the previous
  year. 
 <p> When computing a <code>Date</code> from time fields, some special
  circumstances may arise: there may be insufficient information to compute the 
 <code>Date</code> (such as only year and month but no day in the month),
  there may be inconsistent information (such as "Tuesday, July 15, 1996" --
  July 15, 1996 is actually a Monday), or the input time might be ambiguous
  because of time zone transition. 
 <p><strong>Insufficient information.</strong> The calendar will use default
  information to specify the missing fields. This may vary by calendar; for
  the Gregorian calendar, the default for a field is the same as that of the
  start of the epoch: i.e., YEAR = 1970, MONTH = JANUARY, DATE = 1, etc. 
 <p><strong>Inconsistent information.</strong> If fields conflict, the calendar
  will give preference to fields set more recently. For example, when
  determining the day, the calendar will look for one of the following
  combinations of fields.  The most recent combination, as determined by the
  most recently set single field, will be used. 
 <blockquote>
  @code

  MONTH + DAY_OF_MONTH
  MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
  MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
  DAY_OF_YEAR
  DAY_OF_WEEK + WEEK_OF_YEAR
@endcode
  </blockquote>
  For the time of day: 
 <blockquote>
  @code

  HOUR_OF_DAY
  AM_PM + HOUR
@endcode
  </blockquote>
  
 <p><strong>Ambiguous Wall Clock Time.</strong> When time offset from UTC has
  changed, it produces an ambiguous time slot around the transition. For example,
  many US locations observe daylight saving time. On the date switching to daylight
  saving time in US, wall clock time jumps from 12:59 AM (standard) to 2:00 AM
  (daylight). Therefore, wall clock time from 1:00 AM to 1:59 AM do not exist on
  the date. When the input wall time fall into this missing time slot, the ICU
  Calendar resolves the time using the UTC offset before the transition by default.
  In this example, 1:30 AM is interpreted as 1:30 AM standard time (non-exist),
  so the final result will be 2:30 AM daylight time. 
 <p>On the date switching back to standard time, wall clock time is moved back one
  hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
  case, the ICU Calendar resolves the time using the UTC offset after the transition
  by default. For example, 1:30 AM on the date is resolved as 1:30 AM standard time. 
 <p>Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs 
 <code>setRepeatedWallTimeOption(int)</code> and <code>setSkippedWallTimeOption(int)</code>.
  These methods are available in ICU 49 or later versions. 
 <p><strong>Note:</strong> for some non-Gregorian calendars, different
  fields may be necessary for complete disambiguation. For example, a full
  specification of the historial Arabic astronomical calendar requires year,
  month, day-of-month <em>and</em> day-of-week in some cases. 
 <p><strong>Note:</strong> There are certain possible ambiguities in
  interpretation of certain singular times, which are resolved in the
  following ways: 
 <ol>
      <li> 24:00:00 "belongs" to the following day. That is,
           23:59 on Dec 31, 1969 &lt; 24:00 on Jan 1, 1970 &lt; 24:01:00 on Jan 1, 1970
      <li> Although historically not precise, midnight also belongs to "am",
           and noon belongs to "pm", so on the same day,
           12:00 am (midnight) &lt; 12:01 am, and 12:00 pm (noon) &lt; 12:01 pm 
 </ol>
  
 <p>The date or time format strings are not part of the definition of a
  calendar, as those must be modifiable or overridable by the user at
  runtime. Use <code>DateFormat</code>
  to format dates. 
 <p><strong>Field manipulation methods</strong></p>
  
 <p><code>Calendar</code> fields can be changed using three methods: 
 <code>set()</code>, <code>add()</code>, and <code>roll()</code>.</p>
  
 <p><strong><code>set(f, value)</code></strong> changes field 
 <code>f</code> to <code>value</code>.  In addition, it sets an
  internal member variable to indicate that field <code>f</code> has
  been changed. Although field <code>f</code> is changed immediately,
  the calendar's milliseconds is not recomputed until the next call to 
 <code>get()</code>, <code>getTime()</code>, or 
 <code>getTimeInMillis()</code> is made. Thus, multiple calls to 
 <code>set()</code> do not trigger multiple, unnecessary
  computations. As a result of changing a field using 
 <code>set()</code>, other fields may also change, depending on the
  field, the field value, and the calendar system. In addition, 
 <code>get(f)</code> will not necessarily return <code>value</code>
  after the fields have been recomputed. The specifics are determined by
  the concrete calendar class.</p>
  
 <p><em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to August 31, 1999. Calling <code>set(Calendar.MONTH,
  Calendar.SEPTEMBER)</code> sets the calendar to September 31,
  1999. This is a temporary internal representation that resolves to
  October 1, 1999 if <code>getTime()</code>is then called. However, a
  call to <code>set(Calendar.DAY_OF_MONTH, 30)</code> before the call to 
 <code>getTime()</code> sets the calendar to September 30, 1999, since
  no recomputation occurs after <code>set()</code> itself.</p>
  
 <p><strong><code>add(f, delta)</code></strong> adds <code>delta</code>
  to field <code>f</code>.  This is equivalent to calling <code>set(f,
  get(f) + delta)</code> with two adjustments:</p>
  
 <blockquote>
    <p><strong>Add rule 1</strong>. The value of field <code>f</code>
    after the call minus the value of field <code>f</code> before the
    call is <code>delta</code>, modulo any overflow that has occurred in
    field <code>f</code>. Overflow occurs when a field value exceeds its
    range and, as a result, the next larger field is incremented or
    decremented and the field value is adjusted back into its range.</p>
    <p><strong>Add rule 2</strong>. If a smaller field is expected to be
    invariant, but &nbsp; it is impossible for it to be equal to its
    prior value because of changes in its minimum or maximum after field   
 <code>f</code> is changed, then its value is adjusted to be as close
    as possible to its expected value. A smaller field represents a
    smaller unit of time. <code>HOUR</code> is a smaller field than
    <code>DAY_OF_MONTH</code>. No adjustment is made to smaller fields
    that are not expected to be invariant. The calendar system
    determines what fields are expected to be invariant.</p>
  </blockquote>
  
 <p>In addition, unlike <code>set()</code>, <code>add()</code> forces
  an immediate recomputation of the calendar's milliseconds and all
  fields.</p>
  
 <p><em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to August 31, 1999. Calling <code>add(Calendar.MONTH,
  13)</code> sets the calendar to September 30, 2000. <strong>Add rule
  1</strong> sets the <code>MONTH</code> field to September, since
  adding 13 months to August gives September of the next year. Since 
 <code>DAY_OF_MONTH</code> cannot be 31 in September in a 
 <code>GregorianCalendar</code>, <strong>add rule 2</strong> sets the 
 <code>DAY_OF_MONTH</code> to 30, the closest possible value. Although
  it is a smaller field, <code>DAY_OF_WEEK</code> is not adjusted by
  rule 2, since it is expected to change when the month changes in a 
 <code>GregorianCalendar</code>.</p>
  
 <p><strong><code>roll(f, delta)</code></strong> adds 
 <code>delta</code> to field <code>f</code> without changing larger
  fields. This is equivalent to calling <code>add(f, delta)</code> with
  the following adjustment:</p>
  
 <blockquote>
    <p><strong>Roll rule</strong>. Larger fields are unchanged after the
    call. A larger field represents a larger unit of
    time. <code>DAY_OF_MONTH</code> is a larger field than
    <code>HOUR</code>.</p>
  </blockquote>
  
 <p><em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to August 31, 1999. Calling <code>roll(Calendar.MONTH,
  8)</code> sets the calendar to April 30, <strong>1999</strong>.  Add
  rule 1 sets the <code>MONTH</code> field to April. Using a 
 <code>GregorianCalendar</code>, the <code>DAY_OF_MONTH</code> cannot
  be 31 in the month April. Add rule 2 sets it to the closest possible
  value, 30. Finally, the <strong>roll rule</strong> maintains the 
 <code>YEAR</code> field value of 1999.</p>
  
 <p><em>Example</em>: Consider a <code>GregorianCalendar</code>
  originally set to Sunday June 6, 1999. Calling 
 <code>roll(Calendar.WEEK_OF_MONTH, -1)</code> sets the calendar to
  Tuesday June 1, 1999, whereas calling 
 <code>add(Calendar.WEEK_OF_MONTH, -1)</code> sets the calendar to
  Sunday May 30, 1999. This is because the roll rule imposes an
  additional constraint: The <code>MONTH</code> must not change when the 
 <code>WEEK_OF_MONTH</code> is rolled. Taken together with add rule 1,
  the resultant date must be between Tuesday June 1 and Saturday June
  5. According to add rule 2, the <code>DAY_OF_WEEK</code>, an invariant
  when changing the <code>WEEK_OF_MONTH</code>, is set to Tuesday, the
  closest possible value to Sunday (where Sunday is the first day of the
  week).</p>
  
 <p><strong>Usage model</strong>. To motivate the behavior of 
 <code>add()</code> and <code>roll()</code>, consider a user interface
  component with increment and decrement buttons for the month, day, and
  year, and an underlying <code>GregorianCalendar</code>. If the
  interface reads January 31, 1999 and the user presses the month
  increment button, what should it read? If the underlying
  implementation uses <code>set()</code>, it might read March 3, 1999. A
  better result would be February 28, 1999. Furthermore, if the user
  presses the month increment button again, it should read March 31,
  1999, not March 28, 1999. By saving the original date and using either 
 <code>add()</code> or <code>roll()</code>, depending on whether larger
  fields should be affected, the user interface can behave as most users
  will intuitively expect.</p>
  
 <p><b>Note:</b> You should always use <code>roll</code> and <code>add</code> rather
  than attempting to perform arithmetic operations directly on the fields
  of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  to have fields with non-linear behavior, for example missing months
  or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  methods will take this into account, while simple arithmetic manipulations
  may give invalid results. 
 <p><big><big><b>Calendar Architecture in ICU4J</b></big></big></p>
  
 <p>Recently the implementation of <code>Calendar</code> has changed
  significantly in order to better support subclassing. The original 
 <code>Calendar</code> class was designed to support subclassing, but
  it had only one implemented subclass, <code>GregorianCalendar</code>.
  With the implementation of several new calendar subclasses, including the 
 <code>BuddhistCalendar</code>, <code>ChineseCalendar</code>,
  <code>HebrewCalendar</code>, <code>IslamicCalendar</code>, and 
 <code>JapaneseCalendar</code>, the subclassing API has been reworked
  thoroughly. This section details the new subclassing API and other
  ways in which <code>android.icu.util.Calendar</code> differs from 
 <code>java.util.Calendar</code>.
  </p>
  
 <p><big><b>Changes</b></big></p>
  
 <p>Overview of changes between the classic <code>Calendar</code>
  architecture and the new architecture. 
 <ul>
    <li>The <code>fields[]</code> array is <code>private</code> now
      instead of <code>protected</code>.  Subclasses must access it
      using the methods <code>internalSet</code> and
      <code>internalGet</code>.  <b>Motivation:</b> Subclasses should
      not directly access data members.</li>
    <li>The <code>time</code> long word is <code>private</code> now
      instead of <code>protected</code>.  Subclasses may access it using
      the method <code>internalGetTimeInMillis</code>, which does not
      provoke an update. <b>Motivation:</b> Subclasses should not
      directly access data members.</li>
    <li>The scope of responsibility of subclasses has been drastically
      reduced. As much functionality as possible is implemented in the     
 <code>Calendar</code> base class. As a result, it is much easier
      to subclass <code>Calendar</code>. <b>Motivation:</b> Subclasses
      should not have to reimplement common code. Certain behaviors are
      common across calendar systems: The definition and behavior of
      week-related fields and time fields, the arithmetic
      (<code>add</code> and <code>roll</code>) behavior of many
      fields, and the field validation system.</li>
    <li>The subclassing API has been completely redesigned.</li>
    <li>The <code>Calendar</code> base class contains some Gregorian
      calendar algorithmic support that subclasses can use (specifically
      in <code>handleComputeFields</code>).  Subclasses can use the
      methods <code>getGregorianXxx()</code> to obtain precomputed
      values. <b>Motivation:</b> This is required by all
      <code>Calendar</code> subclasses in order to implement consistent
      time zone behavior, and Gregorian-derived systems can use the
      already computed data.</li>
    <li>The <code>FIELD_COUNT</code> constant has been removed. Use
      <code>getFieldCount</code>.  In addition, framework API has been
      added to allow subclasses to define additional fields.     
 <b>Motivation: </b>The number of fields is not constant across
      calendar systems.</li>
    <li>The range of handled dates has been narrowed from +/-
      ~300,000,000 years to +/- ~5,000,000 years. In practical terms
      this should not affect clients. However, it does mean that client
      code cannot be guaranteed well-behaved results with dates such as     
 <code>Date(Long.MIN_VALUE)</code> or
      <code>Date(Long.MAX_VALUE)</code>. Instead, the
      <code>Calendar</code> protected constants should be used.
      <b>Motivation:</b> With
      the addition of the <code>JULIAN_DAY</code> field, Julian day
      numbers must be restricted to a 32-bit <code>int</code>.  This
      restricts the overall supported range. Furthermore, restricting
      the supported range simplifies the computations by removing
      special case code that was used to accomodate arithmetic overflow
      at millis near <code>Long.MIN_VALUE</code> and
      <code>Long.MAX_VALUE</code>.</li>
    <li>New fields are implemented: <code>JULIAN_DAY</code> defines
      single-field specification of the
      date. <code>MILLISECONDS_IN_DAY</code> defines a single-field
      specification of the wall time. <code>DOW_LOCAL</code> and
      <code>YEAR_WOY</code> implement localized day-of-week and
      week-of-year behavior.</li>
    <li>Subclasses can access protected millisecond constants
    defined in <code>Calendar</code>.</li>
    <li>New API has been added to support calendar-specific subclasses
      of <code>DateFormat</code>.</li>
    <li>Several subclasses have been implemented, representing
      various international calendar systems.</li>
  
 </ul>
  
 <p><big><b>Subclass API</b></big></p>
  
 <p>The original <code>Calendar</code> API was based on the experience
  of implementing a only a single subclass, 
 <code>GregorianCalendar</code>. As a result, all of the subclassing
  kinks had not been worked out. The new subclassing API has been
  refined based on several implemented subclasses. This includes methods
  that must be overridden and methods for subclasses to call. Subclasses
  no longer have direct access to <code>fields</code> and 
 <code>stamp</code>. Instead, they have new API to access
  these. Subclasses are able to allocate the <code>fields</code> array
  through a protected framework method; this allows subclasses to
  specify additional fields. </p>
  
 <p>More functionality has been moved into the base class. The base
  class now contains much of the computational machinery to support the
  Gregorian calendar. This is based on two things: (1) Many calendars
  are based on the Gregorian calendar (such as the Buddhist and Japanese
  imperial calendars). (2) <em>All</em> calendars require basic
  Gregorian support in order to handle timezone computations. </p>
  
 <p>Common computations have been moved into 
 <code>Calendar</code>. Subclasses no longer compute the week related
  fields and the time related fields. These are commonly handled for all
  calendars by the base class. </p>
  
 <p><b>Subclass computation of time <tt>=&gt;</tt> fields</b>
  
 <p>The <code>ERA</code>, <code>YEAR</code>,
  <code>EXTENDED_YEAR</code>, <code>MONTH</code>,
  <code>DAY_OF_MONTH</code>, and <code>DAY_OF_YEAR</code> fields are
  computed by the subclass, based on the Julian day. All other fields
  are computed by <code>Calendar</code>.
  
 <ul>
    <li>Subclasses should implement <code>handleComputeFields</code>
      to compute the <code>ERA</code>, <code>YEAR</code>,
      <code>EXTENDED_YEAR</code>, <code>MONTH</code>,
      <code>DAY_OF_MONTH</code>, and <code>DAY_OF_YEAR</code> fields,
      based on the value of the <code>JULIAN_DAY</code> field. If there
      are calendar-specific fields not defined by <code>Calendar</code>,
      they must also be computed. These are the only fields that the
      subclass should compute. All other fields are computed by the base
      class, so time and week fields behave in a consistent way across
      all calendars. The default version of this method in     
 <code>Calendar</code> implements a proleptic Gregorian
      calendar. Within this method, subclasses may call     
 <code>getGregorianXxx()</code> to obtain the Gregorian calendar
      month, day of month, and extended year for the given date.</li>
  
 </ul>
  
 <p><b>Subclass computation of fields <tt>=&gt;</tt> time</b>
  
 <p>The interpretation of most field values is handled entirely by 
 <code>Calendar</code>. <code>Calendar</code> determines which fields
  are set, which are not, which are set more recently, and so on. In
  addition, <code>Calendar</code> handles the computation of the time
  from the time fields and handles the week-related fields. The only
  thing the subclass must do is determine the extended year, based on
  the year fields, and then, given an extended year and a month, it must
  return a Julian day number. 
 <ul>
    <li>Subclasses should implement <code>handleGetExtendedYear</code>
      to return the extended year for this calendar system, based on the     
 <code>YEAR</code>, <code>EXTENDED_YEAR</code>, and any fields that
      the calendar system uses that are larger than a year, such as     
 <code>ERA</code>.</li>
    <li>Subclasses should implement <code>handleComputeMonthStart</code>
      to return the Julian day number
      associated with a month and extended year. This is the Julian day
      number of the day before the first day of the month. The month
      number is zero-based. This computation should not depend on any
      field values.</li>
  
 </ul>
  
 <p><b>Other methods</b>
  
 <ul>
    <li>Subclasses should implement <code>handleGetMonthLength</code>
      to return the number of days in a
      given month of a given extended year. The month number, as always,
      is zero-based.</li>
    <li>Subclasses should implement <code>handleGetYearLength</code>
      to return the number of days in the given
      extended year. This method is used by     
 <tt>computeWeekFields</tt> to compute the
      <code>WEEK_OF_YEAR</code> and <code>YEAR_WOY</code> fields.</li>
    <li>Subclasses should implement <code>handleGetLimit</code>
      to return the protected values of a field, depending on the value of     
 <code>limitType</code>. This method only needs to handle the
      fields <code>ERA</code>, <code>YEAR</code>, <code>MONTH</code>,
      <code>WEEK_OF_YEAR</code>, <code>WEEK_OF_MONTH</code>,
      <code>DAY_OF_MONTH</code>, <code>DAY_OF_YEAR</code>,
      <code>DAY_OF_WEEK_IN_MONTH</code>, <code>YEAR_WOY</code>, and
      <code>EXTENDED_YEAR</code>.  Other fields are invariant (with
      respect to calendar system) and are handled by the base
      class.</li>
    <li>Optionally, subclasses may override <code>validateField</code>
      to check any subclass-specific fields. If the
      field's value is out of range, the method should throw an     
 <code>IllegalArgumentException</code>. The method may call
      <code>super.validateField(field)</code> to handle fields in a
      generic way, that is, to compare them to the range     
 <code>getMinimum(field)</code>..<code>getMaximum(field)</code>.</li>
    <li>Optionally, subclasses may override
      <code>handleCreateFields</code> to create an <code>int[]</code>
      array large enough to hold the calendar's fields. This is only
      necessary if the calendar defines additional fields beyond those
      defined by <code>Calendar</code>. The length of the result must be
      be between the base and maximum field counts.</li>
    <li>Optionally, subclasses may override
      <code>handleGetDateFormat</code> to create a
      <code>DateFormat</code> appropriate to this calendar. This is only
      required if a calendar subclass redefines the use of a field (for
      example, changes the <code>ERA</code> field from a symbolic field
      to a numeric one) or defines an additional field.</li>
    <li>Optionally, subclasses may override <code>roll</code> and
      <code>add</code> to handle fields that are discontinuous. For
      example, in the Hebrew calendar the month &quot;Adar I&quot; only
      occurs in leap years; in other years the calendar jumps from
      Shevat (month #4) to Adar (month #6). The <code>HebrewCalendar.add</code>
  and <code>HebrewCalendar.roll</code>
  methods take this into
      account, so that adding 1 month to Shevat gives the proper result
      (Adar) in a non-leap year. The protected utility method <code>pinField</code>
  is often useful when implementing these two
      methods. </li>
  
 </ul>
  
 <p><big><b>Normalized behavior</b></big>
  
 <p>The behavior of certain fields has been made consistent across all
  calendar systems and implemented in <code>Calendar</code>.
  
 <ul>
    <li>Time is normalized. Even though some calendar systems transition
      between days at sunset or at other times, all ICU4J calendars
      transition between days at <em>local zone midnight</em>.  This
      allows ICU4J to centralize the time computations in     
 <code>Calendar</code> and to maintain basic correpsondences
      between calendar systems. Affected fields: <code>AM_PM</code>,
      <code>HOUR</code>, <code>HOUR_OF_DAY</code>, <code>MINUTE</code>,
      <code>SECOND</code>, <code>MILLISECOND</code>,
      <code>ZONE_OFFSET</code>, and <code>DST_OFFSET</code>.</li>
    <li>DST behavior is normalized. Daylight savings time behavior is
      computed the same for all calendar systems, and depends on the
      value of several <code>GregorianCalendar</code> fields: the
      <code>YEAR</code>, <code>MONTH</code>, and
      <code>DAY_OF_MONTH</code>. As a result, <code>Calendar</code>
      always computes these fields, even for non-Gregorian calendar
      systems. These fields are available to subclasses.</li>
    <li>Weeks are normalized. Although locales define the week
      differently, in terms of the day on which it starts, and the
      designation of week number one of a month or year, they all use a
      common mechanism. Furthermore, the day of the week has a simple
      and consistent definition throughout history. For example,
      although the Gregorian calendar introduced a discontinuity when
      first instituted, the day of week was not disrupted. For this
      reason, the fields <code>DAY_OF_WEEK</code>, <code>WEEK_OF_YEAR,
      WEEK_OF_MONTH</code>, <code>DAY_OF_WEEK_IN_MONTH</code>,
      <code>DOW_LOCAL</code>, <code>YEAR_WOY</code> are all computed in
      a consistent way in the base class, based on the     
 <code>EXTENDED_YEAR</code>, <code>DAY_OF_YEAR</code>,
      <code>MONTH</code>, and <code>DAY_OF_MONTH</code>, which are
      computed by the subclass.</li>
  
 </ul>
  
 <p><big><b>Supported range</b></big>
  
 <p>The allowable range of <code>Calendar</code> has been
  narrowed. <code>GregorianCalendar</code> used to attempt to support
  the range of dates with millisecond values from 
 <code>Long.MIN_VALUE</code> to <code>Long.MAX_VALUE</code>. This
  introduced awkward constructions (hacks) which slowed down
  performance. It also introduced non-uniform behavior at the
  boundaries. The new <code>Calendar</code> protocol specifies the
  maximum range of supportable dates as those having Julian day numbers of 
 <code>-0x7F000000</code> to <code>+0x7F000000</code>. This
  corresponds to years from ~5,800,000 BCE to ~5,800,000 CE. Programmers
  should use the protected constants in <code>Calendar</code> to
  specify an extremely early or extremely late date.</p>
  
 <p><big><b>General notes</b></big>
  
 <ul>
    <li>Calendars implementations are <em>proleptic</em>. For example,
      even though the Gregorian calendar was not instituted until the
      16th century, the <code>GregorianCalendar</code> class supports
      dates before the historical onset of the calendar by extending the
      calendar system backward in time. Similarly, the     
 <code>HebrewCalendar</code> extends backward before the start of
      its epoch into zero and negative years. Subclasses do not throw
      exceptions because a date precedes the historical start of a
      calendar system. Instead, they implement     
 <code>handleGetLimit</code> to return appropriate limits on
      <code>YEAR</code>, <code>ERA</code>, etc. fields. Then, if the
      calendar is set to not be lenient, out-of-range field values will
      trigger an exception.</li>
    <li>Calendar system subclasses compute a <em>extended
      year</em>. This differs from the <code>YEAR</code> field in that
      it ranges over all integer values, including zero and negative
      values, and it encapsulates the information of the     
 <code>YEAR</code> field and all larger fields.  Thus, for the
      Gregorian calendar, the <code>EXTENDED_YEAR</code> is computed as
      <code>ERA==AD ? YEAR : 1-YEAR</code>. Another example is the Mayan
      long count, which has years (<code>KUN</code>) and nested cycles
      of years (<code>KATUN</code> and <code>BAKTUN</code>). The Mayan
      <code>EXTENDED_YEAR</code> is computed as <code>TUN + 20 * (KATUN
      + 20 * BAKTUN)</code>. The <code>Calendar</code> base class uses
      the <code>EXTENDED_YEAR</code> field to compute the week-related
      fields.</li>
  
 </ul>
 - seealso: Date
 - seealso: GregorianCalendar
 - seealso: TimeZone
 - seealso: DateFormat
 @author Mark Davis, Deborah Goldsmith, Chen-Lieh Huang, Alan Liu, Laura Werner
 */
@interface AndroidIcuUtilCalendar : NSObject < JavaIoSerializable, NSCopying, JavaLangComparable >
@property (readonly, class) jint ERA NS_SWIFT_NAME(ERA);
@property (readonly, class) jint YEAR NS_SWIFT_NAME(YEAR);
@property (readonly, class) jint MONTH NS_SWIFT_NAME(MONTH);
@property (readonly, class) jint WEEK_OF_YEAR NS_SWIFT_NAME(WEEK_OF_YEAR);
@property (readonly, class) jint WEEK_OF_MONTH NS_SWIFT_NAME(WEEK_OF_MONTH);
@property (readonly, class) jint DATE NS_SWIFT_NAME(DATE);
@property (readonly, class) jint DAY_OF_MONTH NS_SWIFT_NAME(DAY_OF_MONTH);
@property (readonly, class) jint DAY_OF_YEAR NS_SWIFT_NAME(DAY_OF_YEAR);
@property (readonly, class) jint DAY_OF_WEEK NS_SWIFT_NAME(DAY_OF_WEEK);
@property (readonly, class) jint DAY_OF_WEEK_IN_MONTH NS_SWIFT_NAME(DAY_OF_WEEK_IN_MONTH);
@property (readonly, class) jint AM_PM NS_SWIFT_NAME(AM_PM);
@property (readonly, class) jint HOUR NS_SWIFT_NAME(HOUR);
@property (readonly, class) jint HOUR_OF_DAY NS_SWIFT_NAME(HOUR_OF_DAY);
@property (readonly, class) jint MINUTE NS_SWIFT_NAME(MINUTE);
@property (readonly, class) jint SECOND NS_SWIFT_NAME(SECOND);
@property (readonly, class) jint MILLISECOND NS_SWIFT_NAME(MILLISECOND);
@property (readonly, class) jint ZONE_OFFSET NS_SWIFT_NAME(ZONE_OFFSET);
@property (readonly, class) jint DST_OFFSET NS_SWIFT_NAME(DST_OFFSET);
@property (readonly, class) jint YEAR_WOY NS_SWIFT_NAME(YEAR_WOY);
@property (readonly, class) jint DOW_LOCAL NS_SWIFT_NAME(DOW_LOCAL);
@property (readonly, class) jint EXTENDED_YEAR NS_SWIFT_NAME(EXTENDED_YEAR);
@property (readonly, class) jint JULIAN_DAY NS_SWIFT_NAME(JULIAN_DAY);
@property (readonly, class) jint MILLISECONDS_IN_DAY NS_SWIFT_NAME(MILLISECONDS_IN_DAY);
@property (readonly, class) jint IS_LEAP_MONTH NS_SWIFT_NAME(IS_LEAP_MONTH);
@property (readonly, class) jint BASE_FIELD_COUNT NS_SWIFT_NAME(BASE_FIELD_COUNT);
@property (readonly, class) jint MAX_FIELD_COUNT NS_SWIFT_NAME(MAX_FIELD_COUNT);
@property (readonly, class) jint SUNDAY NS_SWIFT_NAME(SUNDAY);
@property (readonly, class) jint MONDAY NS_SWIFT_NAME(MONDAY);
@property (readonly, class) jint TUESDAY NS_SWIFT_NAME(TUESDAY);
@property (readonly, class) jint WEDNESDAY NS_SWIFT_NAME(WEDNESDAY);
@property (readonly, class) jint THURSDAY NS_SWIFT_NAME(THURSDAY);
@property (readonly, class) jint FRIDAY NS_SWIFT_NAME(FRIDAY);
@property (readonly, class) jint SATURDAY NS_SWIFT_NAME(SATURDAY);
@property (readonly, class) jint JANUARY NS_SWIFT_NAME(JANUARY);
@property (readonly, class) jint FEBRUARY NS_SWIFT_NAME(FEBRUARY);
@property (readonly, class) jint MARCH NS_SWIFT_NAME(MARCH);
@property (readonly, class) jint APRIL NS_SWIFT_NAME(APRIL);
@property (readonly, class) jint MAY NS_SWIFT_NAME(MAY);
@property (readonly, class) jint JUNE NS_SWIFT_NAME(JUNE);
@property (readonly, class) jint JULY NS_SWIFT_NAME(JULY);
@property (readonly, class) jint AUGUST NS_SWIFT_NAME(AUGUST);
@property (readonly, class) jint SEPTEMBER NS_SWIFT_NAME(SEPTEMBER);
@property (readonly, class) jint OCTOBER NS_SWIFT_NAME(OCTOBER);
@property (readonly, class) jint NOVEMBER NS_SWIFT_NAME(NOVEMBER);
@property (readonly, class) jint DECEMBER NS_SWIFT_NAME(DECEMBER);
@property (readonly, class) jint UNDECIMBER NS_SWIFT_NAME(UNDECIMBER);
@property (readonly, class) jint AM NS_SWIFT_NAME(AM);
@property (readonly, class) jint PM NS_SWIFT_NAME(PM);
@property (readonly, class) jint WEEKDAY NS_SWIFT_NAME(WEEKDAY);
@property (readonly, class) jint WEEKEND NS_SWIFT_NAME(WEEKEND);
@property (readonly, class) jint WEEKEND_ONSET NS_SWIFT_NAME(WEEKEND_ONSET);
@property (readonly, class) jint WEEKEND_CEASE NS_SWIFT_NAME(WEEKEND_CEASE);
@property (readonly, class) jint WALLTIME_LAST NS_SWIFT_NAME(WALLTIME_LAST);
@property (readonly, class) jint WALLTIME_FIRST NS_SWIFT_NAME(WALLTIME_FIRST);
@property (readonly, class) jint WALLTIME_NEXT_VALID NS_SWIFT_NAME(WALLTIME_NEXT_VALID);
@property (readonly, class) jint ONE_SECOND NS_SWIFT_NAME(ONE_SECOND);
@property (readonly, class) jint ONE_MINUTE NS_SWIFT_NAME(ONE_MINUTE);
@property (readonly, class) jint ONE_HOUR NS_SWIFT_NAME(ONE_HOUR);
@property (readonly, class) jlong ONE_DAY NS_SWIFT_NAME(ONE_DAY);
@property (readonly, class) jlong ONE_WEEK NS_SWIFT_NAME(ONE_WEEK);
@property (readonly, class) jint JAN_1_1_JULIAN_DAY NS_SWIFT_NAME(JAN_1_1_JULIAN_DAY);
@property (readonly, class) jint EPOCH_JULIAN_DAY NS_SWIFT_NAME(EPOCH_JULIAN_DAY);
@property (readonly, class) jint MIN_JULIAN NS_SWIFT_NAME(MIN_JULIAN);
@property (readonly, class) jlong MIN_MILLIS NS_SWIFT_NAME(MIN_MILLIS);
@property (readonly, class, strong) JavaUtilDate *MIN_DATE NS_SWIFT_NAME(MIN_DATE);
@property (readonly, class) jint MAX_JULIAN NS_SWIFT_NAME(MAX_JULIAN);
@property (readonly, class) jlong MAX_MILLIS NS_SWIFT_NAME(MAX_MILLIS);
@property (readonly, class, strong) JavaUtilDate *MAX_DATE NS_SWIFT_NAME(MAX_DATE);
@property (readonly, class) jint UNSET NS_SWIFT_NAME(UNSET);
@property (readonly, class) jint INTERNALLY_SET NS_SWIFT_NAME(INTERNALLY_SET);
@property (readonly, class) jint MINIMUM_USER_STAMP NS_SWIFT_NAME(MINIMUM_USER_STAMP);
@property (readonly, class) jint MINIMUM NS_SWIFT_NAME(MINIMUM);
@property (readonly, class) jint GREATEST_MINIMUM NS_SWIFT_NAME(GREATEST_MINIMUM);
@property (readonly, class) jint LEAST_MAXIMUM NS_SWIFT_NAME(LEAST_MAXIMUM);
@property (readonly, class) jint MAXIMUM NS_SWIFT_NAME(MAXIMUM);
@property (readonly, class) jint RESOLVE_REMAP NS_SWIFT_NAME(RESOLVE_REMAP);
@property (readonly, class, strong) IOSObjectArray *DATE_PRECEDENCE NS_SWIFT_NAME(DATE_PRECEDENCE);
@property (readonly, class, strong) IOSObjectArray *DOW_PRECEDENCE NS_SWIFT_NAME(DOW_PRECEDENCE);

+ (jint)ERA;

+ (jint)YEAR;

+ (jint)MONTH;

+ (jint)WEEK_OF_YEAR;

+ (jint)WEEK_OF_MONTH;

+ (jint)DATE;

+ (jint)DAY_OF_MONTH;

+ (jint)DAY_OF_YEAR;

+ (jint)DAY_OF_WEEK;

+ (jint)DAY_OF_WEEK_IN_MONTH;

+ (jint)AM_PM;

+ (jint)HOUR;

+ (jint)HOUR_OF_DAY;

+ (jint)MINUTE;

+ (jint)SECOND;

+ (jint)MILLISECOND;

+ (jint)ZONE_OFFSET;

+ (jint)DST_OFFSET;

+ (jint)YEAR_WOY;

+ (jint)DOW_LOCAL;

+ (jint)EXTENDED_YEAR;

+ (jint)JULIAN_DAY;

+ (jint)MILLISECONDS_IN_DAY;

+ (jint)IS_LEAP_MONTH;

+ (jint)BASE_FIELD_COUNT;

+ (jint)MAX_FIELD_COUNT;

+ (jint)SUNDAY;

+ (jint)MONDAY;

+ (jint)TUESDAY;

+ (jint)WEDNESDAY;

+ (jint)THURSDAY;

+ (jint)FRIDAY;

+ (jint)SATURDAY;

+ (jint)JANUARY;

+ (jint)FEBRUARY;

+ (jint)MARCH;

+ (jint)APRIL;

+ (jint)MAY;

+ (jint)JUNE;

+ (jint)JULY;

+ (jint)AUGUST;

+ (jint)SEPTEMBER;

+ (jint)OCTOBER;

+ (jint)NOVEMBER;

+ (jint)DECEMBER;

+ (jint)UNDECIMBER;

+ (jint)AM;

+ (jint)PM;

+ (jint)WEEKDAY;

+ (jint)WEEKEND;

+ (jint)WEEKEND_ONSET;

+ (jint)WEEKEND_CEASE;

+ (jint)WALLTIME_LAST;

+ (jint)WALLTIME_FIRST;

+ (jint)WALLTIME_NEXT_VALID;

+ (jint)ONE_SECOND;

+ (jint)ONE_MINUTE;

+ (jint)ONE_HOUR;

+ (jlong)ONE_DAY;

+ (jlong)ONE_WEEK;

+ (jint)JAN_1_1_JULIAN_DAY;

+ (jint)EPOCH_JULIAN_DAY;

+ (jint)MIN_JULIAN;

+ (jlong)MIN_MILLIS;

+ (JavaUtilDate *)MIN_DATE;

+ (jint)MAX_JULIAN;

+ (jlong)MAX_MILLIS;

+ (JavaUtilDate *)MAX_DATE;

+ (jint)UNSET;

+ (jint)INTERNALLY_SET;

+ (jint)MINIMUM_USER_STAMP;

+ (jint)MINIMUM;

+ (jint)GREATEST_MINIMUM;

+ (jint)LEAST_MAXIMUM;

+ (jint)MAXIMUM;

+ (jint)RESOLVE_REMAP;

+ (IOSObjectArray *)DATE_PRECEDENCE;

+ (IOSObjectArray *)DOW_PRECEDENCE;

#pragma mark Public

/*!
 @brief Add a signed amount to a specified field, using this calendar's rules.
 For example, to add three days to the current date, you can call 
 <code>add(Calendar.DATE, 3)</code>.
  <p>
  When adding to certain fields, the values of other fields may conflict and
  need to be changed.  For example, when adding one to the <code>MONTH</code> field
  for the Gregorian date 1/31/96, the <code>DAY_OF_MONTH</code> field
  must be adjusted so that the result is 2/29/96 rather than the invalid
  2/31/96. 
 <p>
  Adding a positive value always means moving forward in time, so for the Gregorian
  calendar, starting with 100 BC and adding +1 to year results in 99 BC (even though
  this actually reduces the numeric value of the field itself). 
 <p>
  <strong>[icu] Note:</strong> The ICU implementation of this method is able to add to
  all fields except for <code>ERA</code>, <code>DST_OFFSET</code>,
  and <code>ZONE_OFFSET</code>.  Subclasses may, of course, add support for
  additional fields in their overrides of <code>add</code>.
  <p>
  <b>Note:</b> You should always use <tt>roll</tt> and <tt>add</tt> rather
  than attempting to perform arithmetic operations directly on the fields
  of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  to have fields with non-linear behavior, for example missing months
  or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  methods will take this into account, while simple arithmetic manipulations
  may give invalid results. 
 <p>
  <b>Subclassing:</b><br>
  This implementation of <code>add</code> assumes that the behavior of the
  field is continuous between its minimum and maximum, which are found by
  calling <code>getActualMinimum</code> and 
 <code>getActualMaximum</code>.
  For such fields, simple arithmetic operations are sufficient to
  perform the add. 
 <p>
  Subclasses that have fields for which this assumption of continuity breaks
  down must overide <code>add</code> to handle those fields specially.
  For example, in the Hebrew calendar the month "Adar I"
  only occurs in leap years; in other years the calendar jumps from
  Shevat (month #4) to Adar (month #6).  The 
 <code>HebrewCalendar.add</code> method takes this into account,
  so that adding one month
  to a date in Shevat gives the proper result (Adar) in a non-leap year. 
 <p>
 @param field the time field.
 @param amount the amount to add to the field.
 @throw IllegalArgumentExceptionif the field is invalid or refers
               to a field that cannot be handled by this method.
 - seealso: #roll(int, int)
 */
- (void)addWithInt:(jint)field
           withInt:(jint)amount;

/*!
 @brief Compares the time field records.
 Equivalent to comparing result of conversion to UTC.
 @param when the Calendar to be compared with this Calendar.
 @return true if the current time of this Calendar is after
  the time of Calendar when; false otherwise.
 */
- (jboolean)afterWithId:(id)when;

/*!
 @brief Compares the time field records.
 Equivalent to comparing result of conversion to UTC.
 @param when the Calendar to be compared with this Calendar.
 @return true if the current time of this Calendar is before
  the time of Calendar when; false otherwise.
 */
- (jboolean)beforeWithId:(id)when;

/*!
 @brief Clears the values of all the time fields.
 */
- (void)clear;

/*!
 @brief Clears the value in the given time field.
 @param field the time field to be cleared.
 */
- (void)clearWithInt:(jint)field;

/*!
 @brief Overrides Cloneable
 */
- (id)java_clone;

/*!
 @brief Compares the times (in millis) represented by two 
 <code>Calendar</code> objects.
 @param that the  <code> Calendar </code>  to compare to this.
 @return <code>0</code> if the time represented by
  this <code>Calendar</code> is equal to the time represented
  by that <code>Calendar</code>, a value less than 
 <code>0</code> if the time represented by this is before
  the time represented by that, and a value greater than 
 <code>0</code> if the time represented by this
  is after the time represented by that.
 @throw NullPointerExceptionif that 
 <code>Calendar</code> is null.
 @throw IllegalArgumentExceptionif the time of that 
 <code>Calendar</code> can't be obtained because of invalid
  calendar values.
 */
- (jint)compareToWithId:(AndroidIcuUtilCalendar *)that;

/*!
 @brief Compares this calendar to the specified object.
 The result is <code>true</code> if and only if the argument is
  not <code>null</code> and is a <code>Calendar</code> object that
  represents the same calendar as this object.
 @param obj the object to compare with.
 @return <code>true</code> if the objects are the same; 
 <code>false</code> otherwise.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief <strong>[icu]</strong> Returns the difference between the given time and the time this
  calendar object is set to.If this calendar is set 
 <em>before</em> the given time, the returned value will be
  positive.
 If this calendar is set <em>after</em> the given
  time, the returned value will be negative.  The 
 <code>field</code> parameter specifies the units of the return
  value.  For example, if <code>fieldDifference(when,
  Calendar.MONTH)</code> returns 3, then this calendar is set to
  3 months before <code>when</code>, and possibly some additional
  time less than one month. 
 <p>As a side effect of this call, this calendar is advanced
  toward <code>when</code> by the given amount.  That is, calling
  this method has the side effect of calling <code>add(field,
  n)</code>, where <code>n</code> is the return value. 
 <p>Usage: To use this method, call it first with the largest
  field of interest, then with progressively smaller fields.  For
  example: 
 @code

  int y = cal.fieldDifference(when, Calendar.YEAR);
  int m = cal.fieldDifference(when, Calendar.MONTH);
  int d = cal.fieldDifference(when, Calendar.DATE);
@endcode
  computes the difference between <code>cal</code> and 
 <code>when</code> in years, months, and days. 
 <p>Note: <code>fieldDifference()</code> is 
 <em>asymmetrical</em>.  That is, in the following code: 
 @code

  cal.setTime(date1);
  int m1 = cal.fieldDifference(date2, Calendar.MONTH);
  int d1 = cal.fieldDifference(date2, Calendar.DATE);
  cal.setTime(date2);
  int m2 = cal.fieldDifference(date1, Calendar.MONTH);
  int d2 = cal.fieldDifference(date1, Calendar.DATE);
@endcode
  one might expect that <code>m1 == -m2 &amp;&amp; d1 == -d2</code>.
  However, this is not generally the case, because of
  irregularities in the underlying calendar system (e.g., the
  Gregorian calendar has a varying number of days per month).
 @param when the date to compare this calendar's time to
 @param field the field in which to compute the result
 @return the difference, either positive or negative, between
  this calendar's time and <code>when</code>, in terms of 
 <code>field</code>.
 */
- (jint)fieldDifferenceWithJavaUtilDate:(JavaUtilDate *)when
                                withInt:(jint)field;

/*!
 @brief Returns the value for a given time field.
 @param field the given time field.
 @return the value for the given time field.
 */
- (jint)getWithInt:(jint)field;

/*!
 @brief Returns the maximum value that this field could have, given the
  current date.For example, with the Gregorian date February 3, 1997
  and the <code>DAY_OF_MONTH</code> field, the actual maximum
  is 28; for February 3, 1996 it is 29.
 <p>The actual maximum computation ignores smaller fields and the
  current value of like-sized fields.  For example, the actual maximum
  of the DAY_OF_YEAR or MONTH depends only on the year and supra-year
  fields.  The actual maximum of the DAY_OF_MONTH depends, in
  addition, on the MONTH field and any other fields at that
  granularity (such as IS_LEAP_MONTH).  The
  DAY_OF_WEEK_IN_MONTH field does not depend on the current
  DAY_OF_WEEK; it returns the maximum for any day of week in the
  current month.  Likewise for the WEEK_OF_MONTH and WEEK_OF_YEAR
  fields.
 @param field the field whose maximum is desired
 @return the maximum of the given field for the current date of this calendar
 - seealso: #getMaximum
 - seealso: #getLeastMaximum
 */
- (jint)getActualMaximumWithInt:(jint)field;

/*!
 @brief Returns the minimum value that this field could have, given the current date.
 For most fields, this is the same as <code>getMinimum</code>
  and <code>getGreatestMinimum</code>.  However, some fields,
  especially those related to week number, are more complicated. 
 <p>
  For example, assume <code>getMinimalDaysInFirstWeek</code>
  returns 4 and <code>getFirstDayOfWeek</code> returns SUNDAY.
  If the first day of the month is Sunday, Monday, Tuesday, or Wednesday
  there will be four or more days in the first week, so it will be week number 1,
  and <code>getActualMinimum(WEEK_OF_MONTH)</code> will return 1.  However,
  if the first of the month is a Thursday, Friday, or Saturday, there are 
 <em>not</em> four days in that week, so it is week number 0, and 
 <code>getActualMinimum(WEEK_OF_MONTH)</code> will return 0. 
 <p>
 @param field the field whose actual minimum value is desired.
 @return the minimum of the given field for the current date of this calendar
 - seealso: #getMinimum
 - seealso: #getGreatestMinimum
 */
- (jint)getActualMinimumWithInt:(jint)field;

/*!
 @brief Returns the list of locales for which Calendars are installed.
 @return the list of locales for which Calendars are installed.
 */
+ (IOSObjectArray *)getAvailableLocales;

/*!
 @brief <strong>[icu]</strong> Returns the list of locales for which Calendars are installed.
 @return the list of locales for which Calendars are installed.
 */
+ (IOSObjectArray *)getAvailableULocales;

/*!
 @brief <strong>[icu]</strong> Returns a <code>DateFormat</code> appropriate to this calendar.
 Subclasses wishing to specialize this behavior should override 
 <code>handleGetDateFormat</code>.
 */
- (AndroidIcuTextDateFormat *)getDateTimeFormatWithInt:(jint)dateStyle
                                               withInt:(jint)timeStyle
                                    withJavaUtilLocale:(JavaUtilLocale *)loc;

/*!
 @brief <strong>[icu]</strong> Returns a <code>DateFormat</code> appropriate to this calendar.
 Subclasses wishing to specialize this behavior should override 
 <code>handleGetDateFormat</code>.
 */
- (AndroidIcuTextDateFormat *)getDateTimeFormatWithInt:(jint)dateStyle
                                               withInt:(jint)timeStyle
                             withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)loc;

/*!
 @brief Get the date time format string for the specified values.
 This is a copy of <code>formatHelper(Calendar, ULocale, int, int)</code> with the following
  changes: 
 <ul>
      <li>Made public, but hidden</li>
      <li>take calendar type string instead of Calendar</li>
      <li>Ignore overrides</li>
      <li>Return format string instead of DateFormat.</li>
  </ul>
  This is not meant as public API.
 */
+ (NSString *)getDateTimeFormatStringWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)loc
                                                  withNSString:(NSString *)calType
                                                       withInt:(jint)dateStyle
                                                       withInt:(jint)timeStyle;

/*!
 */
+ (NSString *)getDateTimePatternWithAndroidIcuUtilCalendar:(AndroidIcuUtilCalendar *)cal
                                 withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)uLocale
                                                   withInt:(jint)dateStyle __attribute__((deprecated));

/*!
 @brief <strong>[icu]</strong> Returns whether the given day of the week is a weekday, a
  weekend day, or a day that transitions from one to the other, for the
  locale and calendar system associated with this Calendar (the locale's
  region is often the most determinant factor).If a transition occurs at
  midnight, then the days before and after the transition will have the
  type WEEKDAY or WEEKEND.
 If a transition occurs at a time
  other than midnight, then the day of the transition will have
  the type WEEKEND_ONSET or WEEKEND_CEASE.  In this case, the
  method getWeekendTransition() will return the point of
  transition.
 @param dayOfWeek either SUNDAY, MONDAY, TUESDAY, WEDNESDAY,  THURSDAY, FRIDAY, or SATURDAY
 @return either WEEKDAY, WEEKEND, WEEKEND_ONSET, or
  WEEKEND_CEASE
 @throw IllegalArgumentExceptionif dayOfWeek is not
  between SUNDAY and SATURDAY, inclusive
 - seealso: #WEEKDAY
 - seealso: #WEEKEND
 - seealso: #WEEKEND_ONSET
 - seealso: #WEEKEND_CEASE
 - seealso: #getWeekendTransition
 - seealso: #isWeekend(Date)
 - seealso: #isWeekend()
 */
- (jint)getDayOfWeekTypeWithInt:(jint)dayOfWeek __attribute__((deprecated));

/*!
 @brief Returns the name of this calendar in the language of the given locale.
 */
- (NSString *)getDisplayNameWithJavaUtilLocale:(JavaUtilLocale *)loc;

/*!
 @brief Returns the name of this calendar in the language of the given locale.
 */
- (NSString *)getDisplayNameWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)loc;

/*!
 @brief <strong>[icu]</strong> Returns the number of fields defined by this calendar.Valid field
  arguments to <code>set()</code> and <code>get()</code> are 
 <code>0..getFieldCount()-1</code>.
 */
- (jint)getFieldCount;

/*!
 @brief Returns what the first day of the week is,
  where 1 = <code>SUNDAY</code> and 7 = <code>SATURDAY</code>.
 e.g., Sunday in US, Monday in France
 @return the first day of the week, where 1 = <code>SUNDAY</code> and 7 = <code>SATURDAY</code>.
 */
- (jint)getFirstDayOfWeek;

/*!
 @brief Returns the highest minimum value for the given field if varies.
 Otherwise same as getMinimum(). For Gregorian, no difference.
 @param field the given time field.
 @return the highest minimum value for the given time field.
 */
- (jint)getGreatestMinimumWithInt:(jint)field;

/*!
 @brief Returns a calendar using the default time zone and locale.
 @return a Calendar.
 */
+ (AndroidIcuUtilCalendar *)getInstance;

/*!
 @brief Returns a calendar using the default time zone and specified locale.
 @param aLocale the locale for the week data
 @return a Calendar.
 */
+ (AndroidIcuUtilCalendar *)getInstanceWithJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Returns a calendar using the specified time zone and default locale.
 @param zone the time zone to use
 @return a Calendar.
 */
+ (AndroidIcuUtilCalendar *)getInstanceWithAndroidIcuUtilTimeZone:(AndroidIcuUtilTimeZone *)zone;

/*!
 @brief Returns a calendar with the specified time zone and locale.
 @param zone the time zone to use
 @param aLocale the locale for the week data
 @return a Calendar.
 */
+ (AndroidIcuUtilCalendar *)getInstanceWithAndroidIcuUtilTimeZone:(AndroidIcuUtilTimeZone *)zone
                                               withJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Returns a calendar with the specified time zone and locale.
 @param zone the time zone to use
 @param locale the ulocale for the week data
 @return a Calendar.
 */
+ (AndroidIcuUtilCalendar *)getInstanceWithAndroidIcuUtilTimeZone:(AndroidIcuUtilTimeZone *)zone
                                        withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Returns a calendar using the default time zone and specified locale.
 @param locale the ulocale for the week data
 @return a Calendar.
 */
+ (AndroidIcuUtilCalendar *)getInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief <strong>[icu]</strong> Given a key and a locale, returns an array of string values in a preferred
  order that would make a difference.These are all and only those values where
  the open (creation) of the service with the locale formed from the input locale
  plus input keyword and that value has different behavior than creation with the
  input locale alone.
 @param key one of the keys supported by this service.  For now, only                       "calendar" is supported.
 @param locale the locale
 @param commonlyUsed if set to true it will return only commonly used values                       with the given locale in preferred order.  Otherwise,
                        it will return all the available values for the locale.
 @return an array of string values for the given key and the locale.
 */
+ (IOSObjectArray *)getKeywordValuesForLocaleWithNSString:(NSString *)key
                                withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale
                                              withBoolean:(jboolean)commonlyUsed;

/*!
 @brief Returns the lowest maximum value for the given field if varies.
 Otherwise same as getMaximum(). e.g., for Gregorian DAY_OF_MONTH, 28.
 @param field the given time field.
 @return the lowest maximum value for the given time field.
 */
- (jint)getLeastMaximumWithInt:(jint)field;

/*!
 @brief <strong>[icu]</strong> Returns the locale that was used to create this object, or null.
 This may may differ from the locale requested at the time of
  this object's creation.  For example, if an object is created
  for locale <tt>en_US_CALIFORNIA</tt>, the actual data may be
  drawn from <tt>en</tt> (the <i>actual</i> locale), and 
 <tt>en_US</tt> may be the most specific locale that exists (the 
 <i>valid</i> locale). 
 <p>Note: This method will be implemented in ICU 3.0; ICU 2.8
  contains a partial preview implementation.  The * <i>actual</i>
  locale is returned correctly, but the <i>valid</i> locale is
  not, in most cases.
 @param type type of information requested, either <code>android.icu.util.ULocale.VALID_LOCALE</code>
   or <code>android.icu.util.ULocale.ACTUAL_LOCALE</code>
  .
 @return the information specified by <i>type</i>, or null if
  this object was not constructed from locale data.
 - seealso: android.icu.util.ULocale
 - seealso: android.icu.util.ULocale#VALID_LOCALE
 - seealso: android.icu.util.ULocale#ACTUAL_LOCALE
 */
- (AndroidIcuUtilULocale *)getLocaleWithAndroidIcuUtilULocale_Type:(AndroidIcuUtilULocale_Type *)type;

/*!
 @brief Returns the maximum value for the given time field.
 e.g. for Gregorian DAY_OF_MONTH, 31.
 @param field the given time field.
 @return the maximum value for the given time field.
 */
- (jint)getMaximumWithInt:(jint)field;

/*!
 @brief Returns what the minimal days required in the first week of the year are.
 That is, if the first week is defined as one that contains the first day
  of the first month of a year, getMinimalDaysInFirstWeek returns 1. If
  the minimal days required must be a full week, getMinimalDaysInFirstWeek
  returns 7.
 @return the minimal days required in the first week of the year.
 */
- (jint)getMinimalDaysInFirstWeek;

/*!
 @brief Returns the minimum value for the given time field.
 e.g., for Gregorian DAY_OF_MONTH, 1.
 @param field the given time field.
 @return the minimum value for the given time field.
 */
- (jint)getMinimumWithInt:(jint)field;

/*!
 */
- (jint)getRelatedYear __attribute__((deprecated));

/*!
 @brief <strong>[icu]</strong>Gets the behavior for handling wall time repeating multiple times
  at negative time zone offset transitions.
 @return the behavior for handling repeating wall time, either 
 <code>WALLTIME_FIRST</code> or <code>WALLTIME_LAST</code>.
 - seealso: #setRepeatedWallTimeOption(int)
 - seealso: #WALLTIME_FIRST
 - seealso: #WALLTIME_LAST
 */
- (jint)getRepeatedWallTimeOption;

/*!
 @brief <strong>[icu]</strong>Gets the behavior for handling skipped wall time at positive time zone offset
  transitions.
 @return the behavior for handling skipped wall time, one of 
 <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and <code>WALLTIME_NEXT_VALID</code>.
 - seealso: #setSkippedWallTimeOption(int)
 - seealso: #WALLTIME_FIRST
 - seealso: #WALLTIME_LAST
 - seealso: #WALLTIME_NEXT_VALID
 */
- (jint)getSkippedWallTimeOption;

/*!
 @brief Returns this Calendar's current time.
 @return the current time.
 */
- (JavaUtilDate *)getTime;

/*!
 @brief Returns this Calendar's current time as a long.
 @return the current time as UTC milliseconds from the epoch.
 */
- (jlong)getTimeInMillis;

/*!
 @brief Returns the time zone.
 @return the time zone object associated with this calendar.
 */
- (AndroidIcuUtilTimeZone *)getTimeZone;

/*!
 @brief <strong>[icu]</strong> Returns the calendar type name string for this Calendar object.
 The returned string is the legacy ICU calendar attribute value,
  for example, "gregorian" or "japanese". 
 <p>See type="old type name" for the calendar attribute of locale IDs
  at http://www.unicode.org/reports/tr35/#Key_Type_Definitions
 @return legacy calendar type name string
 */
- (NSString *)getType;

/*!
 @brief <strong>[icu]</strong> Return simple, immutable struct-like class for access to the weekend data in this calendar.
 @return the WeekData for this calendar.
 */
- (AndroidIcuUtilCalendar_WeekData *)getWeekData;

/*!
 @brief <strong>[icu]</strong> Return simple, immutable struct-like class for access to the CLDR weekend data.
 @param region The input region. The results are undefined if the region code is not valid.
 @return the WeekData for the input region. It is never null.
 */
+ (AndroidIcuUtilCalendar_WeekData *)getWeekDataForRegionWithNSString:(NSString *)region;

/*!
 @brief <strong>[icu]</strong> Returns the time during the day at which the weekend begins or end in this
  calendar system.If getDayOfWeekType(dayOfWeek) == WEEKEND_ONSET return the time
  at which the weekend begins.
 If getDayOfWeekType(dayOfWeek) == WEEKEND_CEASE
  return the time at which the weekend ends.  If getDayOfWeekType(dayOfWeek) has some
  other value, then throw an exception.
 @param dayOfWeek either SUNDAY, MONDAY, TUESDAY, WEDNESDAY,  THURSDAY, FRIDAY, or SATURDAY
 @return the milliseconds after midnight at which the
  weekend begins or ends
 @throw IllegalArgumentExceptionif dayOfWeek is not
  WEEKEND_ONSET or WEEKEND_CEASE
 - seealso: #getDayOfWeekType
 - seealso: #isWeekend(Date)
 - seealso: #isWeekend()
 */
- (jint)getWeekendTransitionWithInt:(jint)dayOfWeek __attribute__((deprecated));

/*!
 @brief Returns a hash code for this calendar.
 @return a hash code value for this object.
 */
- (NSUInteger)hash;

/*!
 @brief Returns if two digit representation of year in this calendar type
  customarily implies a default century (i.e.03 -&gt; 2003).
 The default implementation returns <code>true</code>. A subclass may
  return <code>false</code> if such practice is not applicable (for example,
  Chinese calendar and Japanese calendar).
 @return <code>true</code> if this calendar has a default century.
 */
- (jboolean)haveDefaultCentury __attribute__((deprecated));

/*!
 @brief <strong>[icu]</strong> Returns true if the given Calendar object is equivalent to this
  one.An equivalent Calendar will behave exactly as this one
  does, but it may be set to a different time.
 By contrast, for
  the equals() method to return true, the other Calendar must
  be set to the same time.
 @param other the Calendar to be compared with this Calendar
 */
- (jboolean)isEquivalentToWithAndroidIcuUtilCalendar:(AndroidIcuUtilCalendar *)other;

/*!
 @brief Tell whether date/time interpretation is to be lenient.
 */
- (jboolean)isLenient;

/*!
 @brief Determines if the given time field has a value set.
 @return true if the given time field has a value set; false otherwise.
 */
- (jboolean)isSetWithInt:(jint)field;

/*!
 @brief <strong>[icu]</strong> Returns true if this Calendar's current date and time is in the weekend in
  this calendar system.
 @return true if the given date and time is part of the
  weekend
 - seealso: #getDayOfWeekType
 - seealso: #getWeekendTransition
 - seealso: #isWeekend(Date)
 */
- (jboolean)isWeekend;

/*!
 @brief <strong>[icu]</strong> Returns true if the given date and time is in the weekend in this calendar
  system.Equivalent to calling setTime() followed by isWeekend().
 Note: This
  method changes the time this calendar is set to.
 @param date the date and time
 @return true if the given date and time is part of the
  weekend
 - seealso: #getDayOfWeekType
 - seealso: #getWeekendTransition
 - seealso: #isWeekend()
 */
- (jboolean)isWeekendWithJavaUtilDate:(JavaUtilDate *)date;

/*!
 @brief Rolls (up/down) a single unit of time on the given field.If the
  field is rolled past its maximum allowable value, it will "wrap" back
  to its minimum and continue rolling.
 For
  example, to roll the current date up by one day, you can call: 
 <p>
  <code>roll(<code>DATE</code>, true)</code>
  <p>
  When rolling on the <code>YEAR</code> field, it will roll the year
  value in the range between 1 and the value returned by calling 
 <code>getMaximum</code>(<code>YEAR</code>).
  <p>
  When rolling on certain fields, the values of other fields may conflict and
  need to be changed.  For example, when rolling the <code>MONTH</code> field
  for the Gregorian date 1/31/96 upward, the <code>DAY_OF_MONTH</code> field
  must be adjusted so that the result is 2/29/96 rather than the invalid
  2/31/96. 
 <p>
  Rolling up always means rolling forward in time (unless
  the limit of the field is reached, in which case it may pin or wrap), so for the
  Gregorian calendar, starting with 100 BC and rolling the year up results in 99 BC.
  When eras have a definite beginning and end (as in the Chinese calendar, or as in
  most eras in the Japanese calendar) then rolling the year past either limit of the
  era will cause the year to wrap around. When eras only have a limit at one end,
  then attempting to roll the year past that limit will result in pinning the year
  at that limit. Note that for most calendars in which era 0 years move forward in
  time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
  result in negative years for era 0 (that is the only way to represent years before
  the calendar epoch in such calendars). 
 <p>
  <b>Note:</b> Calling <tt>roll(field, true)</tt> N times is <em>not</em>
  necessarily equivalent to calling <tt>roll(field, N)</tt>.  For example,
  imagine that you start with the date Gregorian date January 31, 1995.  If you call 
 <tt>roll(Calendar.MONTH, 2)</tt>, the result will be March 31, 1995.
  But if you call <tt>roll(Calendar.MONTH, true)</tt>, the result will be
  February 28, 1995.  Calling it one more time will give March 28, 1995, which
  is usually not the desired result. 
 <p>
  <b>Note:</b> You should always use <tt>roll</tt> and <tt>add</tt> rather
  than attempting to perform arithmetic operations directly on the fields
  of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  to have fields with non-linear behavior, for example missing months
  or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  methods will take this into account, while simple arithmetic manipulations
  may give invalid results. 
 <p>
 @param field the calendar field to roll.
 @param up indicates if the value of the specified time field is to be               rolled up or rolled down. Use 
  <code> true </code>  if rolling up,               
  <code> false </code>  otherwise.
 @throw IllegalArgumentExceptionif the field is invalid or refers
               to a field that cannot be handled by this method.
 - seealso: #roll(int, int)
 - seealso: #add
 */
- (void)rollWithInt:(jint)field
        withBoolean:(jboolean)up;

/*!
 @brief Rolls (up/down) a specified amount time on the given field.For
  example, to roll the current date up by three days, you can call 
 <code>roll(Calendar.DATE, 3)</code>.
 If the
  field is rolled past its maximum allowable value, it will "wrap" back
  to its minimum and continue rolling.
  For example, calling <code>roll(Calendar.DATE, 10)</code>
  on a Gregorian calendar set to 4/25/96 will result in the date 4/5/96. 
 <p>
  When rolling on certain fields, the values of other fields may conflict and
  need to be changed.  For example, when rolling the <code>MONTH</code> field
  for the Gregorian date 1/31/96 by +1, the <code>DAY_OF_MONTH</code> field
  must be adjusted so that the result is 2/29/96 rather than the invalid
  2/31/96. 
 <p>
  Rolling by a positive value always means rolling forward in time (unless
  the limit of the field is reached, in which case it may pin or wrap), so for the
  Gregorian calendar, starting with 100 BC and rolling the year by + 1 results in 99 BC.
  When eras have a definite beginning and end (as in the Chinese calendar, or as in
  most eras in the Japanese calendar) then rolling the year past either limit of the
  era will cause the year to wrap around. When eras only have a limit at one end,
  then attempting to roll the year past that limit will result in pinning the year
  at that limit. Note that for most calendars in which era 0 years move forward in
  time (such as Buddhist, Hebrew, or Islamic), it is possible for add or roll to
  result in negative years for era 0 (that is the only way to represent years before
  the calendar epoch in such calendars). 
 <p>
  <strong>[icu] Note:</strong> the ICU implementation of this method is able to roll
  all fields except for <code>ERA</code>, <code>DST_OFFSET</code>,
  and <code>ZONE_OFFSET</code>.  Subclasses may, of course, add support for
  additional fields in their overrides of <code>roll</code>.
  <p>
  <b>Note:</b> You should always use <tt>roll</tt> and <tt>add</tt> rather
  than attempting to perform arithmetic operations directly on the fields
  of a <tt>Calendar</tt>.  It is quite possible for <tt>Calendar</tt> subclasses
  to have fields with non-linear behavior, for example missing months
  or days during non-leap years.  The subclasses' <tt>add</tt> and <tt>roll</tt>
  methods will take this into account, while simple arithmetic manipulations
  may give invalid results. 
 <p>
  <b>Subclassing:</b><br>
  This implementation of <code>roll</code> assumes that the behavior of the
  field is continuous between its minimum and maximum, which are found by
  calling <code>getActualMinimum</code> and <code>getActualMaximum</code>.
  For most such fields, simple addition, subtraction, and modulus operations
  are sufficient to perform the roll.  For week-related fields,
  the results of <code>getFirstDayOfWeek</code> and 
 <code>getMinimalDaysInFirstWeek</code> are also necessary.
  Subclasses can override these two methods if their values differ from the defaults. 
 <p>
  Subclasses that have fields for which the assumption of continuity breaks
  down must overide <code>roll</code> to handle those fields specially.
  For example, in the Hebrew calendar the month "Adar I"
  only occurs in leap years; in other years the calendar jumps from
  Shevat (month #4) to Adar (month #6).  The 
 <code>HebrewCalendar.roll</code> method takes this into account,
  so that rolling the month of Shevat by one gives the proper result (Adar) in a
  non-leap year. 
 <p>
 @param field the calendar field to roll.
 @param amount the amount by which the field should be rolled.
 @throw IllegalArgumentExceptionif the field is invalid or refers
               to a field that cannot be handled by this method.
 - seealso: #roll(int, boolean)
 - seealso: #add
 */
- (void)rollWithInt:(jint)field
            withInt:(jint)amount;

/*!
 @brief Sets the time field with the given value.
 @param field the given time field.
 @param value the value to be set for the given time field.
 */
- (void)setWithInt:(jint)field
           withInt:(jint)value;

/*!
 @brief Sets the values for the fields year, month, and date.
 Previous values of other fields are retained.  If this is not desired,
  call <code>clear()</code> first.
 @param year the value used to set the YEAR time field.
 @param month the value used to set the MONTH time field.  Month value is 0-based. e.g., 0 for January.
 @param date the value used to set the DATE time field.
 */
- (void)setWithInt:(jint)year
           withInt:(jint)month
           withInt:(jint)date;

/*!
 @brief Sets the values for the fields year, month, date, hour, and minute.
 Previous values of other fields are retained.  If this is not desired,
  call <code>clear()</code> first.
 @param year the value used to set the YEAR time field.
 @param month the value used to set the MONTH time field.  Month value is 0-based. e.g., 0 for January.
 @param date the value used to set the DATE time field.
 @param hour the value used to set the HOUR_OF_DAY time field.
 @param minute the value used to set the MINUTE time field.
 */
- (void)setWithInt:(jint)year
           withInt:(jint)month
           withInt:(jint)date
           withInt:(jint)hour
           withInt:(jint)minute;

/*!
 @brief Sets the values for the fields year, month, date, hour, minute, and second.
 Previous values of other fields are retained.  If this is not desired,
  call <code>clear</code> first.
 @param year the value used to set the YEAR time field.
 @param month the value used to set the MONTH time field.  Month value is 0-based. e.g., 0 for January.
 @param date the value used to set the DATE time field.
 @param hour the value used to set the HOUR_OF_DAY time field.
 @param minute the value used to set the MINUTE time field.
 @param second the value used to set the SECOND time field.
 */
- (void)setWithInt:(jint)year
           withInt:(jint)month
           withInt:(jint)date
           withInt:(jint)hour
           withInt:(jint)minute
           withInt:(jint)second;

/*!
 @brief Sets what the first day of the week is,
  where 1 = <code>SUNDAY</code> and 7 = <code>SATURDAY</code>.
 @param value the given first day of the week, where 1 = <code>SUNDAY</code>  and 7 = <code>SATURDAY</code> .
 */
- (void)setFirstDayOfWeekWithInt:(jint)value;

/*!
 @brief Specify whether or not date/time interpretation is to be lenient.With
  lenient interpretation, a date such as "February 942, 1996" will be
  treated as being equivalent to the 941st day after February 1, 1996.
 With strict interpretation, such dates will cause an exception to be
  thrown.
 - seealso: DateFormat#setLenient
 */
- (void)setLenientWithBoolean:(jboolean)lenient;

/*!
 @brief Sets what the minimal days required in the first week of the year are.
 For example, if the first week is defined as one that contains the first
  day of the first month of a year, call the method with value 1. If it
  must be a full week, use value 7.
 @param value the given minimal days required in the first week  of the year.
 */
- (void)setMinimalDaysInFirstWeekWithInt:(jint)value;

/*!
 */
- (void)setRelatedYearWithInt:(jint)year __attribute__((deprecated));

/*!
 @brief <strong>[icu]</strong>Sets the behavior for handling wall time repeating multiple times
  at negative time zone offset transitions.For example, 1:30 AM on
  November 6, 2011 in US Eastern time (Ameirca/New_York) occurs twice;
  1:30 AM EDT, then 1:30 AM EST one hour later.
 When <code>WALLTIME_FIRST</code>
  is used, the wall time 1:30AM in this example will be interpreted as 1:30 AM EDT
  (first occurrence). When <code>WALLTIME_LAST</code> is used, it will be
  interpreted as 1:30 AM EST (last occurrence). The default value is 
 <code>WALLTIME_LAST</code>.
 @param option the behavior for handling repeating wall time, either  
  <code> WALLTIME_FIRST </code>  or  <code> WALLTIME_LAST </code> .
 @throw IllegalArgumentExceptionwhen <code>option</code> is neither 
 <code>WALLTIME_FIRST</code> nor <code>WALLTIME_LAST</code>.
 - seealso: #getRepeatedWallTimeOption()
 - seealso: #WALLTIME_FIRST
 - seealso: #WALLTIME_LAST
 */
- (void)setRepeatedWallTimeOptionWithInt:(jint)option;

/*!
 @brief <strong>[icu]</strong>Sets the behavior for handling skipped wall time at positive time zone offset
  transitions.For example, 2:30 AM on March 13, 2011 in US Eastern time (America/New_York)
  does not exist because the wall time jump from 1:59 AM EST to 3:00 AM EDT.
 When 
 <code>WALLTIME_FIRST</code> is used, 2:30 AM is interpreted as 30 minutes before 3:00 AM
  EDT, therefore, it will be resolved as 1:30 AM EST. When <code>WALLTIME_LAST</code>
  is used, 2:30 AM is interpreted as 31 minutes after 1:59 AM EST, therefore, it will be
  resolved as 3:30 AM EDT. When <code>WALLTIME_NEXT_VALID</code> is used, 2:30 AM will
  be resolved as next valid wall time, that is 3:00 AM EDT. The default value is 
 <code>WALLTIME_LAST</code>.
  <p>
  <b>Note:</b>This option is effective only when this calendar is <code>lenient</code>.
  When the calendar is strict, such non-existing wall time will cause an exception.
 @param option the behavior for handling skipped wall time at positive time zone  offset transitions, one of 
  <code> WALLTIME_FIRST </code> ,  <code> WALLTIME_LAST </code>  and
    <code> WALLTIME_NEXT_VALID </code> .
 @throw IllegalArgumentExceptionwhen <code>option</code> is not any of 
 <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and <code>WALLTIME_NEXT_VALID</code>.
 - seealso: #getSkippedWallTimeOption()
 - seealso: #WALLTIME_FIRST
 - seealso: #WALLTIME_LAST
 - seealso: #WALLTIME_NEXT_VALID
 */
- (void)setSkippedWallTimeOptionWithInt:(jint)option;

/*!
 @brief Sets this Calendar's current time with the given Date.
 <p>Note: Calling <code>setTime</code> with 
 <code>Date(Long.MAX_VALUE)</code> or <code>Date(Long.MIN_VALUE)</code>
  may yield incorrect field values from <code>get(int)</code>.
 @param date the given Date.
 */
- (void)setTimeWithJavaUtilDate:(JavaUtilDate *)date;

/*!
 @brief Sets this Calendar's current time from the given long value.
 An IllegalIcuArgumentException is thrown when millis is outside the range permitted
  by a Calendar object when in strict mode.
  When in lenient mode the out of range values are pinned to their respective min/max.
 @param millis the new time in UTC milliseconds from the epoch.
 */
- (void)setTimeInMillisWithLong:(jlong)millis;

/*!
 @brief Sets the time zone with the given time zone value.
 @param value the given time zone.
 */
- (void)setTimeZoneWithAndroidIcuUtilTimeZone:(AndroidIcuUtilTimeZone *)value;

/*!
 @brief <strong>[icu]</strong> Set data in this calendar based on the WeekData input.
 @param wdata The week data to use
 @return this, for chaining
 */
- (AndroidIcuUtilCalendar *)setWeekDataWithAndroidIcuUtilCalendar_WeekData:(AndroidIcuUtilCalendar_WeekData *)wdata;

/*!
 @brief Returns a string representation of this calendar.This method
  is intended to be used only for debugging purposes, and the
  format of the returned string may vary between implementations.
 The returned string may be empty but may not be <code>null</code>.
 @return a string representation of this calendar.
 */
- (NSString *)description;

#pragma mark Protected

/*!
 @brief Constructs a Calendar with the default time zone
  and the default <code>FORMAT</code> locale.
 - seealso: TimeZone#getDefault
 - seealso: Category#FORMAT
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs a calendar with the specified time zone and locale.
 @param zone the time zone to use
 @param aLocale the locale for the week data
 */
- (instancetype __nonnull)initWithAndroidIcuUtilTimeZone:(AndroidIcuUtilTimeZone *)zone
                                      withJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Constructs a calendar with the specified time zone and locale.
 @param zone the time zone to use
 @param locale the ulocale for the week data
 */
- (instancetype __nonnull)initWithAndroidIcuUtilTimeZone:(AndroidIcuUtilTimeZone *)zone
                               withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Fills in any unset fields in the time field list.
 */
- (void)complete;

/*!
 @brief Converts the current millisecond time value <code>time</code> to
  field values in <code>fields[]</code>.This synchronizes the time
  field values with a new time that is set for the calendar.
 The time is 
 <em>not</em> recomputed first; to recompute the time, then the
  fields, call the <code>complete</code> method.
 - seealso: #complete
 */
- (void)computeFields;

/*!
 @brief Compute the Gregorian calendar year, month, and day of month from the
  Julian day.These values are not stored in fields, but in member
  variables gregorianXxx.
 They are used for time zone computations and by
  subclasses that are Gregorian derivatives.  Subclasses may call this
  method to perform a Gregorian calendar millis-&gt;fields computation.
  To perform a Gregorian calendar fields-&gt;millis computation, call
  computeGregorianMonthStart().
 - seealso: #computeGregorianMonthStart
 */
- (void)computeGregorianFieldsWithInt:(jint)julianDay;

/*!
 @brief Compute the Julian day of a month of the Gregorian calendar.
 Subclasses may call this method to perform a Gregorian calendar
  fields-&gt;millis computation.  To perform a Gregorian calendar
  millis-&gt;fields computation, call computeGregorianFields().
 @param year extended Gregorian year
 @param month zero-based Gregorian month
 @return the Julian day number of the day before the first
  day of the given month in the given extended year
 - seealso: #computeGregorianFields
 */
- (jint)computeGregorianMonthStartWithInt:(jint)year
                                  withInt:(jint)month;

/*!
 @brief Compute the Julian day number as specified by this calendar's fields.
 */
- (jint)computeJulianDay;

/*!
 @brief Compute the milliseconds in the day from the fields.This is a
  value from 0 to 23:59:59.999 inclusive, unless fields are out of
  range, in which case it can be an arbitrary value.
 This value
  reflects local zone wall time.
 */
- (jint)computeMillisInDay __attribute__((deprecated));

/*!
 @brief Converts the current field values in <code>fields[]</code> to the
  millisecond time value <code>time</code>.
 */
- (void)computeTime;

/*!
 @brief This method can assume EXTENDED_YEAR has been set.
 @param millis milliseconds of the date fields (local midnight millis)
 @param millisInDay milliseconds of the time fields; may be out  or range.
 @return total zone offset (raw + DST) for the given moment
 */
- (jint)computeZoneOffsetWithLong:(jlong)millis
                          withInt:(jint)millisInDay __attribute__((deprecated));

/*!
 @brief Returns a string name for a field, for debugging and exceptions.
 */
- (NSString *)fieldNameWithInt:(jint)field;

/*!
 @brief Divide two integers, returning the floor of the quotient.
 <p>
  Unlike the built-in division, this is mathematically well-behaved.
  E.g., <code>-1/4</code> =&gt; 0
  but <code>floorDivide(-1,4)</code> =&gt; -1.
 @param numerator the numerator
 @param denominator a divisor which must be  &gt;  0
 @return the floor of the quotient.
 */
+ (jint)floorDivideWithInt:(jint)numerator
                   withInt:(jint)denominator;

/*!
 @brief Divide two integers, returning the floor of the quotient, and
  the modulus remainder.
 <p>
  Unlike the built-in division, this is mathematically well-behaved.
  E.g., <code>-1/4</code> =&gt; 0 and <code>-1%4</code> =&gt; -1,
  but <code>floorDivide(-1,4)</code> =&gt; -1 with <code>remainder[0]</code> =&gt; 3.
 @param numerator the numerator
 @param denominator a divisor which must be  &gt;  0
 @param remainder an array of at least one element in which the value  
  <code> numerator mod denominator </code>  is returned. Unlike  <code> numerator  % denominator
  </code> , this will always be non-negative.
 @return the floor of the quotient.
 */
+ (jint)floorDivideWithInt:(jint)numerator
                   withInt:(jint)denominator
              withIntArray:(IOSIntArray *)remainder;

/*!
 @brief Divide two integers, returning the floor of the quotient, and
  the modulus remainder.
 <p>
  Unlike the built-in division, this is mathematically well-behaved.
  E.g., <code>-1/4</code> =&gt; 0 and <code>-1%4</code> =&gt; -1,
  but <code>floorDivide(-1,4)</code> =&gt; -1 with <code>remainder[0]</code> =&gt; 3.
 @param numerator the numerator
 @param denominator a divisor which must be  &gt;  0
 @param remainder an array of at least one element in which the value  
  <code> numerator mod denominator </code>  is returned. Unlike  <code> numerator  % denominator
  </code> , this will always be non-negative.
 @return the floor of the quotient.
 */
+ (jint)floorDivideWithLong:(jlong)numerator
                    withInt:(jint)denominator
               withIntArray:(IOSIntArray *)remainder;

/*!
 @brief Divide two long integers, returning the floor of the quotient.
 <p>
  Unlike the built-in division, this is mathematically well-behaved.
  E.g., <code>-1/4</code> =&gt; 0
  but <code>floorDivide(-1,4)</code> =&gt; -1.
 @param numerator the numerator
 @param denominator a divisor which must be  &gt;  0
 @return the floor of the quotient.
 */
+ (jlong)floorDivideWithLong:(jlong)numerator
                    withLong:(jlong)denominator;

/*!
 @brief Subclasses may override this.
 Called by handleComputeJulianDay.  Returns the default day (1-based) for the month,
  taking currently-set year and era into account.  Defaults to 1 for Gregorian.
 @param extendedYear the extendedYear, as returned by handleGetExtendedYear
 @param month the month, as returned by getDefaultMonthInYear
 @return the default day of the month
 - seealso: #DAY_OF_MONTH
 */
- (jint)getDefaultDayInMonthWithInt:(jint)extendedYear
                            withInt:(jint)month;

/*!
 @brief Subclasses may override this.
 Called by handleComputeJulianDay.  Returns the default month (0-based) for the year,
  taking year and era into account.  Defaults to 0 (JANUARY) for Gregorian.
 @param extendedYear the extendedYear, as returned by handleGetExtendedYear
 @return the default month
 - seealso: #MONTH
 */
- (jint)getDefaultMonthInYearWithInt:(jint)extendedYear;

/*!
 @brief Returns the field resolution array for this calendar.Calendars that
  define additional fields or change the semantics of existing fields
  should override this method to adjust the field resolution semantics
  accordingly.
 Other subclasses should not override this method.
 - seealso: #resolveFields
 */
- (IOSObjectArray *)getFieldResolutionTable;

/*!
 @brief Returns the day of month (1-based) on the Gregorian calendar as
  computed by <code>computeGregorianFields()</code>.
 - seealso: #computeGregorianFields
 */
- (jint)getGregorianDayOfMonth;

/*!
 @brief Returns the day of year (1-based) on the Gregorian calendar as
  computed by <code>computeGregorianFields()</code>.
 - seealso: #computeGregorianFields
 */
- (jint)getGregorianDayOfYear;

/*!
 @brief Returns the month (0-based) on the Gregorian calendar as computed by 
 <code>computeGregorianFields()</code>.
 - seealso: #computeGregorianFields
 */
- (jint)getGregorianMonth;

/*!
 @brief Returns the extended year on the Gregorian calendar as computed by 
 <code>computeGregorianFields()</code>.
 - seealso: #computeGregorianFields
 */
- (jint)getGregorianYear;

/*!
 @brief Returns a limit for a field.
 @param field the field, from 0.. <code> getFieldCount()-1 </code>
 @param limitType the type specifier for the limit
 - seealso: #MINIMUM
 - seealso: #GREATEST_MINIMUM
 - seealso: #LEAST_MAXIMUM
 - seealso: #MAXIMUM
 */
- (jint)getLimitWithInt:(jint)field
                withInt:(jint)limitType;

/*!
 @brief Returns the timestamp of a field.
 */
- (jint)getStampWithInt:(jint)field;

/*!
 @brief Returns the length of a month of the Gregorian calendar.
 @param y the extended year
 @param m the 0-based month number
 @return the number of days in the given month
 */
+ (jint)gregorianMonthLengthWithInt:(jint)y
                            withInt:(jint)m;

/*!
 @brief Returns the length of a previous month of the Gregorian calendar.
 @param y the extended year
 @param m the 0-based month number
 @return the number of days in the month previous to the given month
 */
+ (jint)gregorianPreviousMonthLengthWithInt:(jint)y
                                    withInt:(jint)m;

/*!
 @brief Subclasses may override this method to compute several fields
  specific to each calendar system.These are: 
 <ul><li>ERA
  <li>YEAR
  <li>MONTH
  <li>DAY_OF_MONTH
  <li>DAY_OF_YEAR
  <li>EXTENDED_YEAR</ul>
  Subclasses can refer to the DAY_OF_WEEK and DOW_LOCAL fields, which
  will be set when this method is called.
 Subclasses can also call
  the getGregorianXxx() methods to obtain Gregorian calendar
  equivalents for the given Julian day. 
 <p>In addition, subclasses should compute any subclass-specific
  fields, that is, fields from BASE_FIELD_COUNT to
  getFieldCount() - 1. 
 <p>The default implementation in <code>Calendar</code> implements
  a pure proleptic Gregorian calendar.
 */
- (void)handleComputeFieldsWithInt:(jint)julianDay;

/*!
 @brief Subclasses may override this.This method calls
  handleGetMonthLength() to obtain the calendar-specific month
  length.
 */
- (jint)handleComputeJulianDayWithInt:(jint)bestField;

/*!
 @brief Returns the Julian day number of day before the first day of the
  given month in the given extended year.Subclasses should override
  this method to implement their calendar system.
 @param eyear the extended year
 @param month the zero-based month, or 0 if useMonth is false
 @param useMonth if false, compute the day before the first day of  the given year, otherwise, compute the day before the first day of
   the given month
 @return the Julian day number of the day before the first
  day of the given month and year
 */
- (jint)handleComputeMonthStartWithInt:(jint)eyear
                               withInt:(jint)month
                           withBoolean:(jboolean)useMonth;

/*!
 @brief Subclasses that use additional fields beyond those defined in 
 <code>Calendar</code> should override this method to return an 
 <code>int[]</code> array of the appropriate length.The length
  must be at least <code>BASE_FIELD_COUNT</code> and no more than 
 <code>MAX_FIELD_COUNT</code>.
 */
- (IOSIntArray *)handleCreateFields;

/*!
 @brief Creates a <code>DateFormat</code> appropriate to this calendar.
 This is a framework method for subclasses to override.  This method
  is responsible for creating the calendar-specific DateFormat and
  DateFormatSymbols objects as needed.
 @param pattern the pattern, specific to the  <code> DateFormat </code>
   subclass
 @param locale the locale for which the symbols should be drawn
 @return a <code>DateFormat</code> appropriate to this calendar
 */
- (AndroidIcuTextDateFormat *)handleGetDateFormatWithNSString:(NSString *)pattern
                                           withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Creates a <code>DateFormat</code> appropriate to this calendar.
 This is a framework method for subclasses to override.  This method
  is responsible for creating the calendar-specific DateFormat and
  DateFormatSymbols objects as needed.
 @param pattern the pattern, specific to the  <code> DateFormat </code>
   subclass
 @param override The override string.  A numbering system override string can take one of the following forms:      1). If just a numbering system name is specified, it applies to all numeric fields in the date format pattern.
       2). To specify an alternate numbering system on a field by field basis, use the field letters from the pattern
           followed by an = sign, followed by the numbering system name.  For example, to specify that just the year
           be formatted using Hebrew digits, use the override "y=hebr".  Multiple overrides can be specified in a single
           string by separating them with a semi-colon. For example, the override string "m=thai;y=deva" would format using
           Thai digits for the month and Devanagari digits for the year.
 @param locale the locale for which the symbols should be drawn
 @return a <code>DateFormat</code> appropriate to this calendar
 */
- (AndroidIcuTextDateFormat *)handleGetDateFormatWithNSString:(NSString *)pattern
                                                 withNSString:(NSString *)override
                                           withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Creates a <code>DateFormat</code> appropriate to this calendar.
 This is a framework method for subclasses to override.  This method
  is responsible for creating the calendar-specific DateFormat and
  DateFormatSymbols objects as needed.
 @param pattern the pattern, specific to the  <code> DateFormat </code>
   subclass
 @param locale the locale for which the symbols should be drawn
 @return a <code>DateFormat</code> appropriate to this calendar
 */
- (AndroidIcuTextDateFormat *)handleGetDateFormatWithNSString:(NSString *)pattern
                                                 withNSString:(NSString *)override
                                    withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Creates a <code>DateFormat</code> appropriate to this calendar.
 This is a framework method for subclasses to override.  This method
  is responsible for creating the calendar-specific DateFormat and
  DateFormatSymbols objects as needed.
 @param pattern the pattern, specific to the  <code> DateFormat </code>
   subclass
 @param locale the locale for which the symbols should be drawn
 @return a <code>DateFormat</code> appropriate to this calendar
 */
- (AndroidIcuTextDateFormat *)handleGetDateFormatWithNSString:(NSString *)pattern
                                    withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Returns the extended year defined by the current fields.This will
  use the EXTENDED_YEAR field or the YEAR and supra-year fields (such
  as ERA) specific to the calendar system, depending on which set of
  fields is newer.
 @return the extended year
 */
- (jint)handleGetExtendedYear;

/*!
 @brief Subclass API for defining limits of different types.
 Subclasses must implement this method to return limits for the
  following fields: 
 @code
ERA
  YEAR
  MONTH
  WEEK_OF_YEAR
  WEEK_OF_MONTH
  DAY_OF_MONTH
  DAY_OF_YEAR
  DAY_OF_WEEK_IN_MONTH
  YEAR_WOY
  EXTENDED_YEAR
@endcode
 @param field one of the above field numbers
 @param limitType one of  <code> MINIMUM </code> ,  <code> GREATEST_MINIMUM </code>
  ,   <code> LEAST_MAXIMUM </code> , or  <code> MAXIMUM
  </code>
 */
- (jint)handleGetLimitWithInt:(jint)field
                      withInt:(jint)limitType;

/*!
 @brief Returns the number of days in the given month of the given extended
  year of this calendar system.Subclasses should override this
  method if they can provide a more correct or more efficient
  implementation than the default implementation in Calendar.
 */
- (jint)handleGetMonthLengthWithInt:(jint)extendedYear
                            withInt:(jint)month;

/*!
 @brief Returns the number of days in the given extended year of this
  calendar system.Subclasses should override this method if they can
  provide a more correct or more efficient implementation than the
  default implementation in Calendar.
 */
- (jint)handleGetYearLengthWithInt:(jint)eyear;

/*!
 @brief Returns the value for a given time field.This is an internal method
  for subclasses that does <em>not</em> trigger any calculations.
 @param field the given time field.
 @return the value for the given time field.
 */
- (jint)internalGetWithInt:(jint)field;

/*!
 @brief Returns the value for a given time field, or return the given default
  value if the field is not set.This is an internal method for
  subclasses that does <em>not</em> trigger any calculations.
 @param field the given time field.
 @param defaultValue value to return if field is not set
 @return the value for the given time field of defaultValue if the
  field is unset
 */
- (jint)internalGetWithInt:(jint)field
                   withInt:(jint)defaultValue;

/*!
 @brief Returns the current milliseconds without recomputing.
 */
- (jlong)internalGetTimeInMillis;

/*!
 @brief Set a field to a value.Subclasses should use this method when
  computing fields.
 It sets the time stamp in the 
 <code>stamp[]</code> array to <code>INTERNALLY_SET</code>.  If a
  field that may not be set by subclasses is passed in, an 
 <code>IllegalArgumentException</code> is thrown.  This prevents
  subclasses from modifying fields that are intended to be
  calendar-system invariant.
 */
- (void)internalSetWithInt:(jint)field
                   withInt:(jint)value;

/*!
 @brief Determines if the given year is a leap year.Returns true if the
  given year is a leap year.
 @param year the given year.
 @return true if the given year is a leap year; false otherwise.
 */
+ (jboolean)isGregorianLeapYearWithInt:(jint)year;

/*!
 @brief Returns the day of week, from SUNDAY to SATURDAY, given a Julian day.
 */
+ (jint)julianDayToDayOfWeekWithInt:(jint)julian;

/*!
 @brief Converts Julian day to time as milliseconds.
 @param julian the given Julian day number.
 @return time as milliseconds.
 */
+ (jlong)julianDayToMillisWithInt:(jint)julian;

/*!
 @brief Converts time as milliseconds to Julian day.
 @param millis the given milliseconds.
 @return the Julian day number.
 */
+ (jint)millisToJulianDayWithLong:(jlong)millis;

/*!
 @brief Returns the field that is newer, either defaultField, or
  alternateField.If neither is newer or neither is set, return defaultField.
 */
- (jint)newerFieldWithInt:(jint)defaultField
                  withInt:(jint)alternateField OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns the newest stamp of a given range of fields.
 */
- (jint)newestStampWithInt:(jint)first
                   withInt:(jint)last
                   withInt:(jint)bestStampSoFar OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Adjust the specified field so that it is within
  the allowable range for the date to which this calendar is set.
 For example, in a Gregorian calendar pinning the <code>DAY_OF_MONTH</code>
  field for a calendar set to April 31 would cause it to be set
  to April 30. 
 <p>
  <b>Subclassing:</b>
  <br>
  This utility method is intended for use by subclasses that need to implement
  their own overrides of <code>roll</code> and <code>add</code>.
  <p>
  <b>Note:</b>
  <code>pinField</code> is implemented in terms of 
 <code>getActualMinimum</code>
  and <code>getActualMaximum</code>.  If either of those methods uses
  a slow, iterative algorithm for a particular field, it would be
  unwise to attempt to call <code>pinField</code> for that field.  If you
  really do need to do so, you should override this method to do
  something more efficient for that field. 
 <p>
 @param field The calendar field whose value should be pinned.
 - seealso: #getActualMinimum
 - seealso: #getActualMaximum
 */
- (void)pinFieldWithInt:(jint)field;

/*!
 @brief Prepare this calendar for computing the actual minimum or maximum.
 This method modifies this calendar's fields; it is called on a
  temporary calendar. 
 <p>Rationale: The semantics of getActualXxx() is to return the
  maximum or minimum value that the given field can take, taking into
  account other relevant fields.  In general these other fields are
  larger fields.  For example, when computing the actual maximum
  DAY_OF_MONTH, the current value of DAY_OF_MONTH itself is ignored,
  as is the value of any field smaller. 
 <p>The time fields all have fixed minima and maxima, so we don't
  need to worry about them.  This also lets us set the
  MILLISECONDS_IN_DAY to zero to erase any effects the time fields
  might have when computing date fields. 
 <p>DAY_OF_WEEK is adjusted specially for the WEEK_OF_MONTH and
  WEEK_OF_YEAR fields to ensure that they are computed correctly.
 */
- (void)prepareGetActualWithInt:(jint)field
                    withBoolean:(jboolean)isMinimum;

/*!
 @brief Given a precedence table, return the newest field combination in
  the table, or -1 if none is found.
 <p>The precedence table is a 3-dimensional array of integers.  It
  may be thought of as an array of groups.  Each group is an array of
  lines.  Each line is an array of field numbers.  Within a line, if
  all fields are set, then the time stamp of the line is taken to be
  the stamp of the most recently set field.  If any field of a line is
  unset, then the line fails to match.  Within a group, the line with
  the newest time stamp is selected.  The first field of the line is
  returned to indicate which line matched. 
 <p>In some cases, it may be desirable to map a line to field that
  whose stamp is NOT examined.  For example, if the best field is
  DAY_OF_WEEK then the DAY_OF_WEEK_IN_MONTH algorithm may be used.  In
  order to do this, insert the value <code>REMAP_RESOLVE | F</code> at
  the start of the line, where <code>F</code> is the desired return
  field value.  This field will NOT be examined; it only determines
  the return value if the other fields in the line are the newest. 
 <p>If all lines of a group contain at least one unset field, then no
  line will match, and the group as a whole will fail to match.  In
  that case, the next group will be processed.  If all groups fail to
  match, then -1 is returned.
 */
- (jint)resolveFieldsWithIntArray3:(IOSObjectArray *)precedenceTable;

/*!
 @brief Validate a single field of this calendar.Subclasses should
  override this method to validate any calendar-specific fields.
 Generic fields can be handled by 
 <code>Calendar.validateField()</code>.
 - seealso: #validateField(int, int, int)
 */
- (void)validateFieldWithInt:(jint)field;

/*!
 @brief Validate a single field of this calendar given its minimum and
  maximum allowed value.If the field is out of range, throw a
  descriptive <code>IllegalArgumentException</code>.
 Subclasses may
  use this method in their implementation of <code>validateField(int)</code>
 .
 */
- (void)validateFieldWithInt:(jint)field
                     withInt:(jint)min
                     withInt:(jint)max;

/*!
 @brief Ensure that each field is within its valid range by calling <code>validateField(int)</code>
  on each field that has been set.This method
  should only be called if this calendar is not lenient.
 - seealso: #isLenient
 - seealso: #validateField(int)
 */
- (void)validateFields;

/*!
 @brief Returns the week number of a day, within a period.This may be the week number in
  a year, or the week number in a month.
 Usually this will be a value &gt;= 1, but if
  some initial days of the period are excluded from week 1, because 
 <code>getMinimalDaysInFirstWeek</code> is &gt; 1,
  then the week number will be zero for those
  initial days. This method requires the day of week for the given date in order to
  determine the result. 
 <p>
  <b>Subclassing:</b>
  <br>
  This method is intended for use by subclasses in implementing their 
 <code>computeTime</code> and/or <code>computeFields</code> methods.
  It is often useful in <code>getActualMinimum</code> and 
 <code>getActualMaximum</code> as well. 
 <p>
 @param dayOfPeriod The <code>DAY_OF_YEAR</code>  or                       
 <code>DAY_OF_MONTH</code>  whose week number is desired.                       Should be 1 for the first day of the period.
 @param dayOfWeek The <code>DAY_OF_WEEK</code>  for the day                       corresponding to the 
  <code> dayOfPeriod </code>  parameter.                       1-based with 1=Sunday.
 @return The week number (one-based), or zero if the day falls before
               the first week because              
 <code>getMinimalDaysInFirstWeek</code>
               is more than one.
 */
- (jint)weekNumberWithInt:(jint)dayOfPeriod
                  withInt:(jint)dayOfWeek;

/*!
 @brief Returns the week number of a day, within a period.This may be the week number in
  a year or the week number in a month.
 Usually this will be a value &gt;= 1, but if
  some initial days of the period are excluded from week 1, because 
 <code>getMinimalDaysInFirstWeek</code> is &gt; 1, then
  the week number will be zero for those
  initial days. This method requires the day number and day of week for some
  known date in the period in order to determine the day of week
  on the desired day. 
 <p>
  <b>Subclassing:</b>
  <br>
  This method is intended for use by subclasses in implementing their 
 <code>computeTime</code> and/or <code>computeFields</code> methods.
  It is often useful in <code>getActualMinimum</code> and 
 <code>getActualMaximum</code> as well. 
 <p>
  This variant is handy for computing the week number of some other
  day of a period (often the first or last day of the period) when its day
  of the week is not known but the day number and day of week for some other
  day in the period (e.g. the current date) <em>is</em> known. 
 <p>
 @param desiredDay The <code>DAY_OF_YEAR</code>  or               
 <code>DAY_OF_MONTH</code>  whose week number is desired.               Should be 1 for the first day of the period.
 @param dayOfPeriod The <code>DAY_OF_YEAR</code>               or 
 <code>DAY_OF_MONTH</code>  for a day in the period whose               
 <code>DAY_OF_WEEK</code>  is specified by the               
  <code> dayOfWeek </code>  parameter.               Should be 1 for first day of period.
 @param dayOfWeek The <code>DAY_OF_WEEK</code>  for the day               corresponding to the 
  <code> dayOfPeriod </code>  parameter.               1-based with 1=Sunday.
 @return The week number (one-based), or zero if the day falls before
               the first week because              
 <code>getMinimalDaysInFirstWeek</code>
               is more than one.
 */
- (jint)weekNumberWithInt:(jint)desiredDay
                  withInt:(jint)dayOfPeriod
                  withInt:(jint)dayOfWeek;

#pragma mark Package-Private

/*!
 @brief Set information about the locales that were used to create this
  object.If the object was not constructed from locale data,
  both arguments should be set to null.
 Otherwise, neither
  should be null.  The actual locale must be at the same level or
  less specific than the valid locale.  This method is intended
  for use by factories or other entities that create objects of
  this class.
 @param valid the most specific locale containing any resource  data, or null
 @param actual the locale containing data used to construct this  object, or null
 - seealso: android.icu.util.ULocale
 - seealso: android.icu.util.ULocale#VALID_LOCALE
 - seealso: android.icu.util.ULocale#ACTUAL_LOCALE
 */
- (void)setLocaleWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)valid
                 withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)actual;

@end

J2OBJC_STATIC_INIT(AndroidIcuUtilCalendar)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  era, e.g., AD or BC in the Julian calendar.This is a calendar-specific
  value; see subclass documentation.
 - seealso: GregorianCalendar#AD
 - seealso: GregorianCalendar#BC
 */
inline jint AndroidIcuUtilCalendar_get_ERA(void);
#define AndroidIcuUtilCalendar_ERA 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ERA, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  year.This is a calendar-specific value; see subclass documentation.
 */
inline jint AndroidIcuUtilCalendar_get_YEAR(void);
#define AndroidIcuUtilCalendar_YEAR 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, YEAR, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  month.This is a calendar-specific value.
 The first month of the year is 
 <code>JANUARY</code>; the last depends on the number of months in a year.
 - seealso: #JANUARY
 - seealso: #FEBRUARY
 - seealso: #MARCH
 - seealso: #APRIL
 - seealso: #MAY
 - seealso: #JUNE
 - seealso: #JULY
 - seealso: #AUGUST
 - seealso: #SEPTEMBER
 - seealso: #OCTOBER
 - seealso: #NOVEMBER
 - seealso: #DECEMBER
 - seealso: #UNDECIMBER
 */
inline jint AndroidIcuUtilCalendar_get_MONTH(void);
#define AndroidIcuUtilCalendar_MONTH 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MONTH, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  week number within the current year.The first week of the year, as
  defined by <code>getFirstDayOfWeek()</code> and 
 <code>getMinimalDaysInFirstWeek()</code>, has value 1.
 Subclasses define
  the value of <code>WEEK_OF_YEAR</code> for days before the first week of
  the year.
 - seealso: #getFirstDayOfWeek
 - seealso: #getMinimalDaysInFirstWeek
 */
inline jint AndroidIcuUtilCalendar_get_WEEK_OF_YEAR(void);
#define AndroidIcuUtilCalendar_WEEK_OF_YEAR 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEEK_OF_YEAR, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  week number within the current month.The first week of the month, as
  defined by <code>getFirstDayOfWeek()</code> and 
 <code>getMinimalDaysInFirstWeek()</code>, has value 1.
 Subclasses define
  the value of <code>WEEK_OF_MONTH</code> for days before the first week of
  the month.
 - seealso: #getFirstDayOfWeek
 - seealso: #getMinimalDaysInFirstWeek
 */
inline jint AndroidIcuUtilCalendar_get_WEEK_OF_MONTH(void);
#define AndroidIcuUtilCalendar_WEEK_OF_MONTH 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEEK_OF_MONTH, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  day of the month.This is a synonym for <code>DAY_OF_MONTH</code>.
 The first day of the month has value 1.
 - seealso: #DAY_OF_MONTH
 */
inline jint AndroidIcuUtilCalendar_get_DATE(void);
#define AndroidIcuUtilCalendar_DATE 5
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DATE, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  day of the month.This is a synonym for <code>DATE</code>.
 The first day of the month has value 1.
 - seealso: #DATE
 */
inline jint AndroidIcuUtilCalendar_get_DAY_OF_MONTH(void);
#define AndroidIcuUtilCalendar_DAY_OF_MONTH 5
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DAY_OF_MONTH, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the day
  number within the current year.The first day of the year has value 1.
 */
inline jint AndroidIcuUtilCalendar_get_DAY_OF_YEAR(void);
#define AndroidIcuUtilCalendar_DAY_OF_YEAR 6
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DAY_OF_YEAR, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the day
  of the week.This field takes values <code>SUNDAY</code>,
  <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>,
  <code>THURSDAY</code>, <code>FRIDAY</code>, and <code>SATURDAY</code>.
 - seealso: #SUNDAY
 - seealso: #MONDAY
 - seealso: #TUESDAY
 - seealso: #WEDNESDAY
 - seealso: #THURSDAY
 - seealso: #FRIDAY
 - seealso: #SATURDAY
 */
inline jint AndroidIcuUtilCalendar_get_DAY_OF_WEEK(void);
#define AndroidIcuUtilCalendar_DAY_OF_WEEK 7
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DAY_OF_WEEK, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  ordinal number of the day of the week within the current month.Together
  with the <code>DAY_OF_WEEK</code> field, this uniquely specifies a day
  within a month.
 Unlike <code>WEEK_OF_MONTH</code> and 
 <code>WEEK_OF_YEAR</code>, this field's value does <em>not</em> depend on 
 <code>getFirstDayOfWeek()</code> or 
 <code>getMinimalDaysInFirstWeek()</code>.  <code>DAY_OF_MONTH 1</code>
  through <code>7</code> always correspond to <code>DAY_OF_WEEK_IN_MONTH
  1</code>; <code>8</code> through <code>15</code> correspond to 
 <code>DAY_OF_WEEK_IN_MONTH 2</code>, and so on. 
 <code>DAY_OF_WEEK_IN_MONTH 0</code> indicates the week before 
 <code>DAY_OF_WEEK_IN_MONTH 1</code>.  Negative values count back from the
  end of the month, so the last Sunday of a month is specified as 
 <code>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1</code>.  Because
  negative values count backward they will usually be aligned differently
  within the month than positive values.  For example, if a month has 31
  days, <code>DAY_OF_WEEK_IN_MONTH -1</code> will overlap 
 <code>DAY_OF_WEEK_IN_MONTH 5</code> and the end of <code>4</code>.
 - seealso: #DAY_OF_WEEK
 - seealso: #WEEK_OF_MONTH
 */
inline jint AndroidIcuUtilCalendar_get_DAY_OF_WEEK_IN_MONTH(void);
#define AndroidIcuUtilCalendar_DAY_OF_WEEK_IN_MONTH 8
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DAY_OF_WEEK_IN_MONTH, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating
  whether the <code>HOUR</code> is before or after noon.
 E.g., at 10:04:15.250 PM the <code>AM_PM</code> is <code>PM</code>.
 - seealso: #AM
 - seealso: #PM
 - seealso: #HOUR
 */
inline jint AndroidIcuUtilCalendar_get_AM_PM(void);
#define AndroidIcuUtilCalendar_AM_PM 9
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, AM_PM, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  hour of the morning or afternoon.
 <code>HOUR</code> is used for the 12-hour
  clock.
  E.g., at 10:04:15.250 PM the <code>HOUR</code> is 10.
 - seealso: #AM_PM
 - seealso: #HOUR_OF_DAY
 */
inline jint AndroidIcuUtilCalendar_get_HOUR(void);
#define AndroidIcuUtilCalendar_HOUR 10
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, HOUR, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  hour of the day.
 <code>HOUR_OF_DAY</code> is used for the 24-hour clock.
  E.g., at 10:04:15.250 PM the <code>HOUR_OF_DAY</code> is 22.
 - seealso: #HOUR
 */
inline jint AndroidIcuUtilCalendar_get_HOUR_OF_DAY(void);
#define AndroidIcuUtilCalendar_HOUR_OF_DAY 11
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, HOUR_OF_DAY, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  minute within the hour.
 E.g., at 10:04:15.250 PM the <code>MINUTE</code> is 4.
 */
inline jint AndroidIcuUtilCalendar_get_MINUTE(void);
#define AndroidIcuUtilCalendar_MINUTE 12
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MINUTE, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  second within the minute.
 E.g., at 10:04:15.250 PM the <code>SECOND</code> is 15.
 */
inline jint AndroidIcuUtilCalendar_get_SECOND(void);
#define AndroidIcuUtilCalendar_SECOND 13
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, SECOND, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  millisecond within the second.
 E.g., at 10:04:15.250 PM the <code>MILLISECOND</code> is 250.
 */
inline jint AndroidIcuUtilCalendar_get_MILLISECOND(void);
#define AndroidIcuUtilCalendar_MILLISECOND 14
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MILLISECOND, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  raw offset from GMT in milliseconds.
 */
inline jint AndroidIcuUtilCalendar_get_ZONE_OFFSET(void);
#define AndroidIcuUtilCalendar_ZONE_OFFSET 15
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ZONE_OFFSET, jint)

/*!
 @brief Field number for <code>get</code> and <code>set</code> indicating the
  daylight savings offset in milliseconds.
 */
inline jint AndroidIcuUtilCalendar_get_DST_OFFSET(void);
#define AndroidIcuUtilCalendar_DST_OFFSET 16
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DST_OFFSET, jint)

/*!
 @brief <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  indicating the extended year corresponding to the 
 <code>WEEK_OF_YEAR</code> field.This may be one greater or less
  than the value of <code>EXTENDED_YEAR</code>.
 */
inline jint AndroidIcuUtilCalendar_get_YEAR_WOY(void);
#define AndroidIcuUtilCalendar_YEAR_WOY 17
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, YEAR_WOY, jint)

/*!
 @brief <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  indicating the localized day of week.This will be a value from 1
  to 7 inclusive, with 1 being the localized first day of the week.
 */
inline jint AndroidIcuUtilCalendar_get_DOW_LOCAL(void);
#define AndroidIcuUtilCalendar_DOW_LOCAL 18
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DOW_LOCAL, jint)

/*!
 @brief <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  indicating the extended year.This is a single number designating
  the year of this calendar system, encompassing all supra-year
  fields.
 For example, for the Julian calendar system, year numbers
  are positive, with an era of BCE or CE.  An extended year value for
  the Julian calendar system assigns positive values to CE years and
  negative values to BCE years, with 1 BCE being year 0.
 */
inline jint AndroidIcuUtilCalendar_get_EXTENDED_YEAR(void);
#define AndroidIcuUtilCalendar_EXTENDED_YEAR 19
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, EXTENDED_YEAR, jint)

/*!
 @brief <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  indicating the modified Julian day number.This is different from
  the conventional Julian day number in two regards.
 First, it
  demarcates days at local zone midnight, rather than noon GMT.
  Second, it is a local number; that is, it depends on the local time
  zone.  It can be thought of as a single number that encompasses all
  the date-related fields.
 */
inline jint AndroidIcuUtilCalendar_get_JULIAN_DAY(void);
#define AndroidIcuUtilCalendar_JULIAN_DAY 20
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, JULIAN_DAY, jint)

/*!
 @brief <strong>[icu]</strong> Field number for <code>get()</code> and <code>set()</code>
  indicating the milliseconds in the day.This ranges from 0 to
  23:59:59.999 (regardless of DST).
 This field behaves 
 <em>exactly</em> like a composite of all time-related fields, not
  including the zone fields.  As such, it also reflects
  discontinuities of those fields on DST transition days.  On a day of
  DST onset, it will jump forward.  On a day of DST cessation, it will
  jump backward.  This reflects the fact that is must be combined with
  the DST_OFFSET field to obtain a unique local time value.
 */
inline jint AndroidIcuUtilCalendar_get_MILLISECONDS_IN_DAY(void);
#define AndroidIcuUtilCalendar_MILLISECONDS_IN_DAY 21
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MILLISECONDS_IN_DAY, jint)

/*!
 @brief <strong>[icu]</strong> Field indicating whether or not the current month is a leap month.
 Should have a value of 0 for non-leap months, and 1 for leap months.
 */
inline jint AndroidIcuUtilCalendar_get_IS_LEAP_MONTH(void);
#define AndroidIcuUtilCalendar_IS_LEAP_MONTH 22
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, IS_LEAP_MONTH, jint)

/*!
 @brief The number of fields defined by this class.Subclasses may define
  addition fields starting with this number.
 */
inline jint AndroidIcuUtilCalendar_get_BASE_FIELD_COUNT(void);
#define AndroidIcuUtilCalendar_BASE_FIELD_COUNT 23
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, BASE_FIELD_COUNT, jint)

/*!
 @brief The maximum number of fields possible.Subclasses must not define
  more total fields than this number.
 */
inline jint AndroidIcuUtilCalendar_get_MAX_FIELD_COUNT(void);
#define AndroidIcuUtilCalendar_MAX_FIELD_COUNT 32
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MAX_FIELD_COUNT, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Sunday.
 */
inline jint AndroidIcuUtilCalendar_get_SUNDAY(void);
#define AndroidIcuUtilCalendar_SUNDAY 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, SUNDAY, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Monday.
 */
inline jint AndroidIcuUtilCalendar_get_MONDAY(void);
#define AndroidIcuUtilCalendar_MONDAY 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MONDAY, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Tuesday.
 */
inline jint AndroidIcuUtilCalendar_get_TUESDAY(void);
#define AndroidIcuUtilCalendar_TUESDAY 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, TUESDAY, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Wednesday.
 */
inline jint AndroidIcuUtilCalendar_get_WEDNESDAY(void);
#define AndroidIcuUtilCalendar_WEDNESDAY 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEDNESDAY, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Thursday.
 */
inline jint AndroidIcuUtilCalendar_get_THURSDAY(void);
#define AndroidIcuUtilCalendar_THURSDAY 5
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, THURSDAY, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Friday.
 */
inline jint AndroidIcuUtilCalendar_get_FRIDAY(void);
#define AndroidIcuUtilCalendar_FRIDAY 6
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, FRIDAY, jint)

/*!
 @brief Value of the <code>DAY_OF_WEEK</code> field indicating
  Saturday.
 */
inline jint AndroidIcuUtilCalendar_get_SATURDAY(void);
#define AndroidIcuUtilCalendar_SATURDAY 7
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, SATURDAY, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  first month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_JANUARY(void);
#define AndroidIcuUtilCalendar_JANUARY 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, JANUARY, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  second month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_FEBRUARY(void);
#define AndroidIcuUtilCalendar_FEBRUARY 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, FEBRUARY, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  third month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_MARCH(void);
#define AndroidIcuUtilCalendar_MARCH 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MARCH, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  fourth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_APRIL(void);
#define AndroidIcuUtilCalendar_APRIL 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, APRIL, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  fifth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_MAY(void);
#define AndroidIcuUtilCalendar_MAY 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MAY, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  sixth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_JUNE(void);
#define AndroidIcuUtilCalendar_JUNE 5
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, JUNE, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  seventh month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_JULY(void);
#define AndroidIcuUtilCalendar_JULY 6
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, JULY, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  eighth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_AUGUST(void);
#define AndroidIcuUtilCalendar_AUGUST 7
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, AUGUST, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  ninth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_SEPTEMBER(void);
#define AndroidIcuUtilCalendar_SEPTEMBER 8
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, SEPTEMBER, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  tenth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_OCTOBER(void);
#define AndroidIcuUtilCalendar_OCTOBER 9
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, OCTOBER, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  eleventh month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_NOVEMBER(void);
#define AndroidIcuUtilCalendar_NOVEMBER 10
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, NOVEMBER, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  twelfth month of the year.
 */
inline jint AndroidIcuUtilCalendar_get_DECEMBER(void);
#define AndroidIcuUtilCalendar_DECEMBER 11
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, DECEMBER, jint)

/*!
 @brief Value of the <code>MONTH</code> field indicating the
  thirteenth month of the year.Although <code>GregorianCalendar</code>
  does not use this value, lunar calendars do.
 */
inline jint AndroidIcuUtilCalendar_get_UNDECIMBER(void);
#define AndroidIcuUtilCalendar_UNDECIMBER 12
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, UNDECIMBER, jint)

/*!
 @brief Value of the <code>AM_PM</code> field indicating the
  period of the day from midnight to just before noon.
 */
inline jint AndroidIcuUtilCalendar_get_AM(void);
#define AndroidIcuUtilCalendar_AM 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, AM, jint)

/*!
 @brief Value of the <code>AM_PM</code> field indicating the
  period of the day from noon to just before midnight.
 */
inline jint AndroidIcuUtilCalendar_get_PM(void);
#define AndroidIcuUtilCalendar_PM 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, PM, jint)

/*!
 @brief <strong>[icu]</strong> Value returned by getDayOfWeekType(int dayOfWeek) to indicate a
  weekday.
 - seealso: #WEEKEND
 - seealso: #WEEKEND_ONSET
 - seealso: #WEEKEND_CEASE
 - seealso: #getDayOfWeekType
 */
inline jint AndroidIcuUtilCalendar_get_WEEKDAY(void);
#define AndroidIcuUtilCalendar_WEEKDAY 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEEKDAY, jint)

/*!
 @brief <strong>[icu]</strong> Value returned by getDayOfWeekType(int dayOfWeek) to indicate a
  weekend day.
 - seealso: #WEEKDAY
 - seealso: #WEEKEND_ONSET
 - seealso: #WEEKEND_CEASE
 - seealso: #getDayOfWeekType
 */
inline jint AndroidIcuUtilCalendar_get_WEEKEND(void);
#define AndroidIcuUtilCalendar_WEEKEND 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEEKEND, jint)

/*!
 @brief <strong>[icu]</strong> Value returned by getDayOfWeekType(int dayOfWeek) to indicate a
  day that starts as a weekday and transitions to the weekend.
 Call getWeekendTransition() to get the point of transition.
 - seealso: #WEEKDAY
 - seealso: #WEEKEND
 - seealso: #WEEKEND_CEASE
 - seealso: #getDayOfWeekType
 */
inline jint AndroidIcuUtilCalendar_get_WEEKEND_ONSET(void);
#define AndroidIcuUtilCalendar_WEEKEND_ONSET 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEEKEND_ONSET, jint)

/*!
 @brief <strong>[icu]</strong> Value returned by getDayOfWeekType(int dayOfWeek) to indicate a
  day that starts as the weekend and transitions to a weekday.
 Call getWeekendTransition() to get the point of transition.
 - seealso: #WEEKDAY
 - seealso: #WEEKEND
 - seealso: #WEEKEND_ONSET
 - seealso: #getDayOfWeekType
 */
inline jint AndroidIcuUtilCalendar_get_WEEKEND_CEASE(void);
#define AndroidIcuUtilCalendar_WEEKEND_CEASE 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WEEKEND_CEASE, jint)

/*!
 @brief <strong>[icu]</strong>Option used by <code>setRepeatedWallTimeOption(int)</code> and 
 <code>setSkippedWallTimeOption(int)</code> specifying an ambiguous wall time
  to be interpreted as the latest.
 - seealso: #setRepeatedWallTimeOption(int)
 - seealso: #getRepeatedWallTimeOption()
 - seealso: #setSkippedWallTimeOption(int)
 - seealso: #getSkippedWallTimeOption()
 */
inline jint AndroidIcuUtilCalendar_get_WALLTIME_LAST(void);
#define AndroidIcuUtilCalendar_WALLTIME_LAST 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WALLTIME_LAST, jint)

/*!
 @brief <strong>[icu]</strong>Option used by <code>setRepeatedWallTimeOption(int)</code> and 
 <code>setSkippedWallTimeOption(int)</code> specifying an ambiguous wall time
  to be interpreted as the earliest.
 - seealso: #setRepeatedWallTimeOption(int)
 - seealso: #getRepeatedWallTimeOption()
 - seealso: #setSkippedWallTimeOption(int)
 - seealso: #getSkippedWallTimeOption()
 */
inline jint AndroidIcuUtilCalendar_get_WALLTIME_FIRST(void);
#define AndroidIcuUtilCalendar_WALLTIME_FIRST 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WALLTIME_FIRST, jint)

/*!
 @brief <strong>[icu]</strong>Option used by <code>setSkippedWallTimeOption(int)</code> specifying an
  ambiguous wall time to be interpreted as the next valid wall time.
 - seealso: #setSkippedWallTimeOption(int)
 - seealso: #getSkippedWallTimeOption()
 */
inline jint AndroidIcuUtilCalendar_get_WALLTIME_NEXT_VALID(void);
#define AndroidIcuUtilCalendar_WALLTIME_NEXT_VALID 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, WALLTIME_NEXT_VALID, jint)

/*!
 @brief The number of milliseconds in one second.
 */
inline jint AndroidIcuUtilCalendar_get_ONE_SECOND(void);
#define AndroidIcuUtilCalendar_ONE_SECOND 1000
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ONE_SECOND, jint)

/*!
 @brief The number of milliseconds in one minute.
 */
inline jint AndroidIcuUtilCalendar_get_ONE_MINUTE(void);
#define AndroidIcuUtilCalendar_ONE_MINUTE 60000
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ONE_MINUTE, jint)

/*!
 @brief The number of milliseconds in one hour.
 */
inline jint AndroidIcuUtilCalendar_get_ONE_HOUR(void);
#define AndroidIcuUtilCalendar_ONE_HOUR 3600000
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ONE_HOUR, jint)

/*!
 @brief The number of milliseconds in one day.Although ONE_DAY and
  ONE_WEEK can fit into ints, they must be longs in order to prevent
  arithmetic overflow when performing (bug 4173516).
 */
inline jlong AndroidIcuUtilCalendar_get_ONE_DAY(void);
#define AndroidIcuUtilCalendar_ONE_DAY 86400000LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ONE_DAY, jlong)

/*!
 @brief The number of milliseconds in one week.Although ONE_DAY and
  ONE_WEEK can fit into ints, they must be longs in order to prevent
  arithmetic overflow when performing (bug 4173516).
 */
inline jlong AndroidIcuUtilCalendar_get_ONE_WEEK(void);
#define AndroidIcuUtilCalendar_ONE_WEEK 604800000LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, ONE_WEEK, jlong)

/*!
 @brief The Julian day of the Gregorian epoch, that is, January 1, 1 on the
  Gregorian calendar.
 */
inline jint AndroidIcuUtilCalendar_get_JAN_1_1_JULIAN_DAY(void);
#define AndroidIcuUtilCalendar_JAN_1_1_JULIAN_DAY 1721426
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, JAN_1_1_JULIAN_DAY, jint)

/*!
 @brief The Julian day of the epoch, that is, January 1, 1970 on the
  Gregorian calendar.
 */
inline jint AndroidIcuUtilCalendar_get_EPOCH_JULIAN_DAY(void);
#define AndroidIcuUtilCalendar_EPOCH_JULIAN_DAY 2440588
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, EPOCH_JULIAN_DAY, jint)

/*!
 @brief The minimum supported Julian day.This value is equivalent to 
 <code>MIN_MILLIS</code> and <code>MIN_DATE</code>.
 - seealso: #JULIAN_DAY
 */
inline jint AndroidIcuUtilCalendar_get_MIN_JULIAN(void);
#define AndroidIcuUtilCalendar_MIN_JULIAN -2130706432
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MIN_JULIAN, jint)

/*!
 @brief The minimum supported epoch milliseconds.This value is equivalent
  to <code>MIN_JULIAN</code> and <code>MIN_DATE</code>.
 */
inline jlong AndroidIcuUtilCalendar_get_MIN_MILLIS(void);
#define AndroidIcuUtilCalendar_MIN_MILLIS -184303902528000000LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MIN_MILLIS, jlong)

/*!
 @brief The minimum supported <code>Date</code>.This value is equivalent
  to <code>MIN_JULIAN</code> and <code>MIN_MILLIS</code>.
 */
inline JavaUtilDate *AndroidIcuUtilCalendar_get_MIN_DATE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilDate *AndroidIcuUtilCalendar_MIN_DATE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuUtilCalendar, MIN_DATE, JavaUtilDate *)

/*!
 @brief The maximum supported Julian day.This value is equivalent to 
 <code>MAX_MILLIS</code> and <code>MAX_DATE</code>.
 - seealso: #JULIAN_DAY
 */
inline jint AndroidIcuUtilCalendar_get_MAX_JULIAN(void);
#define AndroidIcuUtilCalendar_MAX_JULIAN 2130706432
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MAX_JULIAN, jint)

/*!
 @brief The maximum supported epoch milliseconds.This value is equivalent
  to <code>MAX_JULIAN</code> and <code>MAX_DATE</code>.
 */
inline jlong AndroidIcuUtilCalendar_get_MAX_MILLIS(void);
#define AndroidIcuUtilCalendar_MAX_MILLIS 183882168921600000LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MAX_MILLIS, jlong)

/*!
 @brief The maximum supported <code>Date</code>.This value is equivalent
  to <code>MAX_JULIAN</code> and <code>MAX_MILLIS</code>.
 */
inline JavaUtilDate *AndroidIcuUtilCalendar_get_MAX_DATE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilDate *AndroidIcuUtilCalendar_MAX_DATE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuUtilCalendar, MAX_DATE, JavaUtilDate *)

/*!
 @brief Value of the time stamp <code>stamp[]</code> indicating that
  a field has not been set since the last call to <code>clear()</code>.
 - seealso: #INTERNALLY_SET
 - seealso: #MINIMUM_USER_STAMP
 */
inline jint AndroidIcuUtilCalendar_get_UNSET(void);
#define AndroidIcuUtilCalendar_UNSET 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, UNSET, jint)

/*!
 @brief Value of the time stamp <code>stamp[]</code> indicating that a field
  has been set via computations from the time or from other fields.
 - seealso: #UNSET
 - seealso: #MINIMUM_USER_STAMP
 */
inline jint AndroidIcuUtilCalendar_get_INTERNALLY_SET(void);
#define AndroidIcuUtilCalendar_INTERNALLY_SET 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, INTERNALLY_SET, jint)

/*!
 @brief If the time stamp <code>stamp[]</code> has a value greater than or
  equal to <code>MINIMUM_USER_SET</code> then it has been set by the
  user via a call to <code>set()</code>.
 - seealso: #UNSET
 - seealso: #INTERNALLY_SET
 */
inline jint AndroidIcuUtilCalendar_get_MINIMUM_USER_STAMP(void);
#define AndroidIcuUtilCalendar_MINIMUM_USER_STAMP 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MINIMUM_USER_STAMP, jint)

/*!
 @brief Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  indicating the minimum value that a field can take (least minimum).
 - seealso: #getLimit
 - seealso: #handleGetLimit
 */
inline jint AndroidIcuUtilCalendar_get_MINIMUM(void);
#define AndroidIcuUtilCalendar_MINIMUM 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MINIMUM, jint)

/*!
 @brief Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  indicating the greatest minimum value that a field can take.
 - seealso: #getLimit
 - seealso: #handleGetLimit
 */
inline jint AndroidIcuUtilCalendar_get_GREATEST_MINIMUM(void);
#define AndroidIcuUtilCalendar_GREATEST_MINIMUM 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, GREATEST_MINIMUM, jint)

/*!
 @brief Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  indicating the least maximum value that a field can take.
 - seealso: #getLimit
 - seealso: #handleGetLimit
 */
inline jint AndroidIcuUtilCalendar_get_LEAST_MAXIMUM(void);
#define AndroidIcuUtilCalendar_LEAST_MAXIMUM 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, LEAST_MAXIMUM, jint)

/*!
 @brief Limit type for <code>getLimit()</code> and <code>handleGetLimit()</code>
  indicating the maximum value that a field can take (greatest maximum).
 - seealso: #getLimit
 - seealso: #handleGetLimit
 */
inline jint AndroidIcuUtilCalendar_get_MAXIMUM(void);
#define AndroidIcuUtilCalendar_MAXIMUM 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, MAXIMUM, jint)

/*!
 @brief Value to OR against resolve table field values for remapping.
 - seealso: #resolveFields
 */
inline jint AndroidIcuUtilCalendar_get_RESOLVE_REMAP(void);
#define AndroidIcuUtilCalendar_RESOLVE_REMAP 32
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuUtilCalendar, RESOLVE_REMAP, jint)

inline IOSObjectArray *AndroidIcuUtilCalendar_get_DATE_PRECEDENCE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *AndroidIcuUtilCalendar_DATE_PRECEDENCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuUtilCalendar, DATE_PRECEDENCE, IOSObjectArray *)

inline IOSObjectArray *AndroidIcuUtilCalendar_get_DOW_PRECEDENCE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *AndroidIcuUtilCalendar_DOW_PRECEDENCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuUtilCalendar, DOW_PRECEDENCE, IOSObjectArray *)

FOUNDATION_EXPORT void AndroidIcuUtilCalendar_init(AndroidIcuUtilCalendar *self);

FOUNDATION_EXPORT void AndroidIcuUtilCalendar_initWithAndroidIcuUtilTimeZone_withJavaUtilLocale_(AndroidIcuUtilCalendar *self, AndroidIcuUtilTimeZone *zone, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT void AndroidIcuUtilCalendar_initWithAndroidIcuUtilTimeZone_withAndroidIcuUtilULocale_(AndroidIcuUtilCalendar *self, AndroidIcuUtilTimeZone *zone, AndroidIcuUtilULocale *locale);

FOUNDATION_EXPORT AndroidIcuUtilCalendar *AndroidIcuUtilCalendar_getInstance(void);

FOUNDATION_EXPORT AndroidIcuUtilCalendar *AndroidIcuUtilCalendar_getInstanceWithAndroidIcuUtilTimeZone_(AndroidIcuUtilTimeZone *zone);

FOUNDATION_EXPORT AndroidIcuUtilCalendar *AndroidIcuUtilCalendar_getInstanceWithJavaUtilLocale_(JavaUtilLocale *aLocale);

FOUNDATION_EXPORT AndroidIcuUtilCalendar *AndroidIcuUtilCalendar_getInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *locale);

FOUNDATION_EXPORT AndroidIcuUtilCalendar *AndroidIcuUtilCalendar_getInstanceWithAndroidIcuUtilTimeZone_withJavaUtilLocale_(AndroidIcuUtilTimeZone *zone, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT AndroidIcuUtilCalendar *AndroidIcuUtilCalendar_getInstanceWithAndroidIcuUtilTimeZone_withAndroidIcuUtilULocale_(AndroidIcuUtilTimeZone *zone, AndroidIcuUtilULocale *locale);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuUtilCalendar_getAvailableLocales(void);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuUtilCalendar_getAvailableULocales(void);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuUtilCalendar_getKeywordValuesForLocaleWithNSString_withAndroidIcuUtilULocale_withBoolean_(NSString *key, AndroidIcuUtilULocale *locale, jboolean commonlyUsed);

FOUNDATION_EXPORT NSString *AndroidIcuUtilCalendar_getDateTimeFormatStringWithAndroidIcuUtilULocale_withNSString_withInt_withInt_(AndroidIcuUtilULocale *loc, NSString *calType, jint dateStyle, jint timeStyle);

FOUNDATION_EXPORT NSString *AndroidIcuUtilCalendar_getDateTimePatternWithAndroidIcuUtilCalendar_withAndroidIcuUtilULocale_withInt_(AndroidIcuUtilCalendar *cal, AndroidIcuUtilULocale *uLocale, jint dateStyle);

FOUNDATION_EXPORT AndroidIcuUtilCalendar_WeekData *AndroidIcuUtilCalendar_getWeekDataForRegionWithNSString_(NSString *region);

FOUNDATION_EXPORT jboolean AndroidIcuUtilCalendar_isGregorianLeapYearWithInt_(jint year);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_gregorianMonthLengthWithInt_withInt_(jint y, jint m);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_gregorianPreviousMonthLengthWithInt_withInt_(jint y, jint m);

FOUNDATION_EXPORT jlong AndroidIcuUtilCalendar_floorDivideWithLong_withLong_(jlong numerator, jlong denominator);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_floorDivideWithInt_withInt_(jint numerator, jint denominator);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_floorDivideWithInt_withInt_withIntArray_(jint numerator, jint denominator, IOSIntArray *remainder);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_floorDivideWithLong_withInt_withIntArray_(jlong numerator, jint denominator, IOSIntArray *remainder);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_millisToJulianDayWithLong_(jlong millis);

FOUNDATION_EXPORT jlong AndroidIcuUtilCalendar_julianDayToMillisWithInt_(jint julian);

FOUNDATION_EXPORT jint AndroidIcuUtilCalendar_julianDayToDayOfWeekWithInt_(jint julian);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuUtilCalendar)

#endif

#if !defined (AndroidIcuUtilCalendar_PatternData_) && (INCLUDE_ALL_AndroidIcuUtilCalendar || defined(INCLUDE_AndroidIcuUtilCalendar_PatternData))
#define AndroidIcuUtilCalendar_PatternData_

@class IOSObjectArray;

@interface AndroidIcuUtilCalendar_PatternData : NSObject

#pragma mark Public

- (instancetype __nonnull)initWithNSStringArray:(IOSObjectArray *)patterns
                              withNSStringArray:(IOSObjectArray *)overrides;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuUtilCalendar_PatternData)

FOUNDATION_EXPORT void AndroidIcuUtilCalendar_PatternData_initWithNSStringArray_withNSStringArray_(AndroidIcuUtilCalendar_PatternData *self, IOSObjectArray *patterns, IOSObjectArray *overrides);

FOUNDATION_EXPORT AndroidIcuUtilCalendar_PatternData *new_AndroidIcuUtilCalendar_PatternData_initWithNSStringArray_withNSStringArray_(IOSObjectArray *patterns, IOSObjectArray *overrides) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuUtilCalendar_PatternData *create_AndroidIcuUtilCalendar_PatternData_initWithNSStringArray_withNSStringArray_(IOSObjectArray *patterns, IOSObjectArray *overrides);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuUtilCalendar_PatternData)

#endif

#if !defined (AndroidIcuUtilCalendar_FormatConfiguration_) && (INCLUDE_ALL_AndroidIcuUtilCalendar || defined(INCLUDE_AndroidIcuUtilCalendar_FormatConfiguration))
#define AndroidIcuUtilCalendar_FormatConfiguration_

@class AndroidIcuTextDateFormatSymbols;
@class AndroidIcuUtilCalendar;
@class AndroidIcuUtilULocale;

/*!
 @brief An instance of FormatConfiguration represents calendar specific
  date format configuration and used for calling the ICU private
  SimpleDateFormat factory method.
 */
__attribute__((deprecated))
@interface AndroidIcuUtilCalendar_FormatConfiguration : NSObject

#pragma mark Public

/*!
 @brief Returns the calendar
 @return the calendar
 */
- (AndroidIcuUtilCalendar *)getCalendar __attribute__((deprecated));

/*!
 @brief Returns the format symbols
 @return the format symbols
 */
- (AndroidIcuTextDateFormatSymbols *)getDateFormatSymbols __attribute__((deprecated));

/*!
 @brief Returns the locale
 @return the locale
 */
- (AndroidIcuUtilULocale *)getLocale __attribute__((deprecated));

/*!
 */
- (NSString *)getOverrideString __attribute__((deprecated));

/*!
 @brief Returns the pattern string
 @return the format pattern string
 */
- (NSString *)getPatternString __attribute__((deprecated));

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuUtilCalendar_FormatConfiguration)

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuUtilCalendar_FormatConfiguration)

#endif

#if !defined (AndroidIcuUtilCalendar_WeekData_) && (INCLUDE_ALL_AndroidIcuUtilCalendar || defined(INCLUDE_AndroidIcuUtilCalendar_WeekData))
#define AndroidIcuUtilCalendar_WeekData_

/*!
 @brief Simple, immutable struct-like class for access to the CLDR weekend data.
 */
@interface AndroidIcuUtilCalendar_WeekData : NSObject {
 @public
  /*!
   @brief the first day of the week, where 1 = <code>SUNDAY</code> and 7 = <code>SATURDAY</code>
   */
  jint firstDayOfWeek_;
  /*!
   @brief the minimal number of days in the first week
   */
  jint minimalDaysInFirstWeek_;
  /*!
   @brief the onset day, where 1 = <code>SUNDAY</code> and 7 = <code>SATURDAY</code>
   */
  jint weekendOnset_;
  /*!
   @brief the onset time in millis during the onset day
   */
  jint weekendOnsetMillis_;
  /*!
   @brief the cease day, where 1 = <code>SUNDAY</code> and 7 = <code>SATURDAY</code>
   */
  jint weekendCease_;
  /*!
   @brief the cease time in millis during the cease day.Exclusive, so the max is 24:00:00.000.
   Note that this will format as 00:00 the next day.
   */
  jint weekendCeaseMillis_;
}

#pragma mark Public

/*!
 @brief Constructor
 @param fdow the first day of the week, where 1 = <code>SUNDAY</code>  and 7 = <code>SATURDAY</code>
 @param mdifw the minimal number of days in the first week
 @param weekendOnset the onset day, where 1 = Sunday and 7 = Saturday
 @param weekendOnsetMillis the onset time in millis during the onset day
 @param weekendCease the cease day, where 1 = Sunday and 7 = Saturday
 @param weekendCeaseMillis the cease time in millis during the cease day.
 */
- (instancetype __nonnull)initWithInt:(jint)fdow
                              withInt:(jint)mdifw
                              withInt:(jint)weekendOnset
                              withInt:(jint)weekendOnsetMillis
                              withInt:(jint)weekendCease
                              withInt:(jint)weekendCeaseMillis;

/*!
 */
- (jboolean)isEqual:(id)other;

/*!
 */
- (NSUInteger)hash;

/*!
 */
- (NSString *)description;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuUtilCalendar_WeekData)

FOUNDATION_EXPORT void AndroidIcuUtilCalendar_WeekData_initWithInt_withInt_withInt_withInt_withInt_withInt_(AndroidIcuUtilCalendar_WeekData *self, jint fdow, jint mdifw, jint weekendOnset, jint weekendOnsetMillis, jint weekendCease, jint weekendCeaseMillis);

FOUNDATION_EXPORT AndroidIcuUtilCalendar_WeekData *new_AndroidIcuUtilCalendar_WeekData_initWithInt_withInt_withInt_withInt_withInt_withInt_(jint fdow, jint mdifw, jint weekendOnset, jint weekendOnsetMillis, jint weekendCease, jint weekendCeaseMillis) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuUtilCalendar_WeekData *create_AndroidIcuUtilCalendar_WeekData_initWithInt_withInt_withInt_withInt_withInt_withInt_(jint fdow, jint mdifw, jint weekendOnset, jint weekendOnsetMillis, jint weekendCease, jint weekendCeaseMillis);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuUtilCalendar_WeekData)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuUtilCalendar")
