//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/UnicodeSet.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuTextUnicodeSet")
#ifdef RESTRICT_AndroidIcuTextUnicodeSet
#define INCLUDE_ALL_AndroidIcuTextUnicodeSet 0
#else
#define INCLUDE_ALL_AndroidIcuTextUnicodeSet 1
#endif
#undef RESTRICT_AndroidIcuTextUnicodeSet

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuTextUnicodeSet_) && (INCLUDE_ALL_AndroidIcuTextUnicodeSet || defined(INCLUDE_AndroidIcuTextUnicodeSet))
#define AndroidIcuTextUnicodeSet_

#define RESTRICT_AndroidIcuTextUnicodeFilter 1
#define INCLUDE_AndroidIcuTextUnicodeFilter 1
#include "android/icu/text/UnicodeFilter.h"

#define RESTRICT_JavaLangIterable 1
#define INCLUDE_JavaLangIterable 1
#include "java/lang/Iterable.h"

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

#define RESTRICT_AndroidIcuUtilFreezable 1
#define INCLUDE_AndroidIcuUtilFreezable 1
#include "android/icu/util/Freezable.h"

@class AndroidIcuTextUnicodeSet_ComparisonStyle;
@class AndroidIcuTextUnicodeSet_SpanCondition;
@class AndroidIcuTextUnicodeSet_XSymbolTable;
@class AndroidIcuUtilOutputInt;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaLangStringBuffer;
@class JavaTextParsePosition;
@class JavaUtilTreeSet;
@protocol AndroidIcuTextReplaceable;
@protocol AndroidIcuTextSymbolTable;
@protocol JavaLangCharSequence;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;

/*!
 @brief A mutable set of Unicode characters and multicharacter strings.
 Objects of this class represent <em>character classes</em> used
  in regular expressions. A character specifies a subset of Unicode
  code points.  Legal code points are U+0000 to U+10FFFF, inclusive.
  Note: method freeze() will not only make the set immutable, but
  also makes important methods much higher performance:
  contains(c), containsNone(...), span(...), spanBack(...) etc.
  After the object is frozen, any subsequent call that wants to change
  the object will throw UnsupportedOperationException. 
 <p>The UnicodeSet class is not designed to be subclassed. 
 <p><code>UnicodeSet</code> supports two APIs. The first is the 
 <em>operand</em> API that allows the caller to modify the value of
  a <code>UnicodeSet</code> object. It conforms to Java 2's 
 <code>java.util.Set</code> interface, although 
 <code>UnicodeSet</code> does not actually implement that
  interface. All methods of <code>Set</code> are supported, with the
  modification that they take a character range or single character
  instead of an <code>Object</code>, and they take a 
 <code>UnicodeSet</code> instead of a <code>Collection</code>.  The
  operand API may be thought of in terms of boolean logic: a boolean
  OR is implemented by <code>add</code>, a boolean AND is implemented
  by <code>retain</code>, a boolean XOR is implemented by 
 <code>complement</code> taking an argument, and a boolean NOT is
  implemented by <code>complement</code> with no argument.  In terms
  of traditional set theory function names, <code>add</code> is a
  union, <code>retain</code> is an intersection, <code>remove</code>
  is an asymmetric difference, and <code>complement</code> with no
  argument is a set complement with respect to the superset range 
 <code>MIN_VALUE-MAX_VALUE</code>
  
 <p>The second API is the 
 <code>applyPattern()</code>/<code>toPattern()</code> API from the 
 <code>java.text.Format</code>-derived classes.  Unlike the
  methods that add characters, add categories, and control the logic
  of the set, the method <code>applyPattern()</code> sets all
  attributes of a <code>UnicodeSet</code> at once, based on a
  string pattern. 
 <p><b>Pattern syntax</b></p>
  Patterns are accepted by the constructors and the 
 <code>applyPattern()</code> methods and returned by the 
 <code>toPattern()</code> method.  These patterns follow a syntax
  similar to that employed by version 8 regular expression character
  classes.  Here are some simple examples: 
 <blockquote>
    <table>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[]</code></td>
        <td style="vertical-align: top;">No characters</td>
      </tr><tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[a]</code></td>
        <td style="vertical-align: top;">The character 'a'</td>
      </tr><tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[ae]</code></td>
        <td style="vertical-align: top;">The characters 'a' and 'e'</td>
      </tr>
      <tr>
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[a-e]</code></td>
        <td style="vertical-align: top;">The characters 'a' through 'e' inclusive, in Unicode code
        point order</td>
      </tr>
      <tr>
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[\\u4E01]</code></td>
        <td style="vertical-align: top;">The character U+4E01</td>
      </tr>
      <tr>
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[a{ab}{ac}]</code></td>
        <td style="vertical-align: top;">The character 'a' and the multicharacter strings &quot;ab&quot; and
        &quot;ac&quot;</td>
      </tr>
      <tr>
        <td style="white-space: nowrap; vertical-align: top; horizontal-align: left;"><code>[\p{Lu}]</code></td>
        <td style="vertical-align: top;">All characters in the general category Uppercase Letter</td>
      </tr>
    </table>
  </blockquote>
  Any character may be preceded by a backslash in order to remove any special
  meaning.  White space characters, as defined by the Unicode Pattern_White_Space property, are
  ignored, unless they are escaped. 
 <p>Property patterns specify a set of characters having a certain
  property as defined by the Unicode standard.  Both the POSIX-like
  "[:Lu:]" and the Perl-like syntax "\p{Lu}" are recognized.  For a
  complete list of supported property patterns, see the User's Guide
  for UnicodeSet at 
 <a href="http://www.icu-project.org/userguide/unicodeSet.html">
  http://www.icu-project.org/userguide/unicodeSet.html</a>.
  Actual determination of property data is defined by the underlying
  Unicode database as implemented by UCharacter. 
 <p>Patterns specify individual characters, ranges of characters, and
  Unicode property sets.  When elements are concatenated, they
  specify their union.  To complement a set, place a '^' immediately
  after the opening '['.  Property patterns are inverted by modifying
  their delimiters; "[:^foo]" and "\P{foo}".  In any other location,
  '^' has no special meaning. 
 <p>Ranges are indicated by placing two a '-' between two
  characters, as in "a-z".  This specifies the range of all
  characters from the left to the right, in Unicode order.  If the
  left character is greater than or equal to the
  right character it is a syntax error.  If a '-' occurs as the first
  character after the opening '[' or '[^', or if it occurs as the
  last character before the closing ']', then it is taken as a
  literal.  Thus "[a\\-b]", "[-ab]", and "[ab-]" all indicate the same
  set of three characters, 'a', 'b', and '-'. 
 <p>Sets may be intersected using the '&amp;' operator or the asymmetric
  set difference may be taken using the '-' operator, for example,
  "[[:L:]&amp;[\\u0000-\\u0FFF]]" indicates the set of all Unicode letters
  with values less than 4096.  Operators ('&amp;' and '|') have equal
  precedence and bind left-to-right.  Thus
  "[[:L:]-[a-z]-[\\u0100-\\u01FF]]" is equivalent to
  "[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]".  This only really matters for
  difference; intersection is commutative. 
 <table>
  <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[a]</code><td>The set containing 'a' 
 <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[a-z]</code><td>The set containing 'a'
  through 'z' and all letters in between, in Unicode order 
 <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[^a-z]</code><td>The set containing
  all characters but 'a' through 'z',
  that is, U+0000 through 'a'-1 and 'z'+1 through U+10FFFF 
 <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[[<em>pat1</em>][<em>pat2</em>]]</code>
  <td>The union of sets specified by <em>pat1</em> and <em>pat2</em>
  <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[[<em>pat1</em>]&amp;[<em>pat2</em>]]</code>
  <td>The intersection of sets specified by <em>pat1</em> and <em>pat2</em>
  <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[[<em>pat1</em>]-[<em>pat2</em>]]</code>
  <td>The asymmetric difference of sets specified by <em>pat1</em> and 
 <em>pat2</em>
  <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[:Lu:] or \p{Lu}</code>
  <td>The set of characters having the specified
  Unicode property; in
  this case, Unicode uppercase letters 
 <tr style="vertical-align: top;"><td style="white-space: nowrap;"><code>[:^Lu:] or \P{Lu}</code>
  <td>The set of characters <em>not</em> having the given
  Unicode property 
 </table>
  
 <p><b>Warning</b>: you cannot add an empty string ("") to a UnicodeSet.</p>
  
 <p><b>Formal syntax</b></p>
  
 <blockquote>
    <table>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>pattern :=&nbsp; </code></td>
        <td style="vertical-align: top;"><code>('[' '^'? item* ']') |
        property</code></td>
      </tr>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>item :=&nbsp; </code></td>
        <td style="vertical-align: top;"><code>char | (char '-' char) | pattern-expr<br>
        </code></td>
      </tr>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>pattern-expr :=&nbsp; </code></td>
        <td style="vertical-align: top;"><code>pattern | pattern-expr pattern |
        pattern-expr op pattern<br>
        </code></td>
      </tr>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>op :=&nbsp; </code></td>
        <td style="vertical-align: top;"><code>'&amp;' | '-'<br>
        </code></td>
      </tr>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>special :=&nbsp; </code></td>
        <td style="vertical-align: top;"><code>'[' | ']' | '-'<br>
        </code></td>
      </tr>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>char :=&nbsp; </code></td>
        <td style="vertical-align: top;"><em>any character that is not</em><code> special<br>
        | ('\\' </code><em>any character</em><code>)<br>
        | ('&#92;u' hex hex hex hex)<br>
        </code></td>
      </tr>
      <tr style="vertical-align: top">
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>hex :=&nbsp; </code></td>
        <td style="vertical-align: top;"><em>any character for which
        </em><code>Character.digit(c, 16)</code><em>
        returns a non-negative result</em></td>
      </tr>
      <tr>
        <td style="white-space: nowrap; vertical-align: top;" align="right"><code>property :=&nbsp; </code></td>
        <td style="vertical-align: top;"><em>a Unicode property set pattern</em></td>
      </tr>
    </table>
    <br>
    <table border="1">
      <tr>
        <td>Legend: <table>
          <tr>
            <td style="white-space: nowrap; vertical-align: top;"><code>a := b</code></td>
            <td style="width: 20; vertical-align: top;">&nbsp; </td>
            <td style="vertical-align: top;"><code>a</code> may be replaced by <code>b</code> </td>
          </tr>
          <tr>
            <td style="white-space: nowrap; vertical-align: top;"><code>a?</code></td>
            <td style="vertical-align: top;"></td>
            <td style="vertical-align: top;">zero or one instance of <code>a</code><br>
            </td>
          </tr>
          <tr>
            <td style="white-space: nowrap; vertical-align: top;"><code>a*</code></td>
            <td style="vertical-align: top;"></td>
            <td style="vertical-align: top;">one or more instances of <code>a</code><br>
            </td>
          </tr>
          <tr>
            <td style="white-space: nowrap; vertical-align: top;"><code>a | b</code></td>
            <td style="vertical-align: top;"></td>
            <td style="vertical-align: top;">either <code>a</code> or <code>b</code><br>
            </td>
          </tr>
          <tr>
            <td style="white-space: nowrap; vertical-align: top;"><code>'a'</code></td>
            <td style="vertical-align: top;"></td>
            <td style="vertical-align: top;">the literal string between the quotes </td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
  </blockquote>
  <p>To iterate over contents of UnicodeSet, the following are available: 
 <ul><li><code>ranges()</code> to iterate through the ranges</li>
  <li><code>strings()</code> to iterate through the strings</li>
  <li><code>iterator()</code> to iterate through the entire contents in a single loop.
  That method is, however, not particularly efficient, since it "boxes" each code point into a String. 
 </ul>
  All of the above can be used in <b>for</b> loops.
  The <code>UnicodeSetIterator</code> can also be used, but not in <b>for</b> loops. 
 <p>To replace, count elements, or delete spans, see <code>UnicodeSetSpanner</code>.
 @author Alan Liu
 - seealso: UnicodeSetIterator
 - seealso: UnicodeSetSpanner
 */
@interface AndroidIcuTextUnicodeSet : AndroidIcuTextUnicodeFilter < JavaLangIterable, JavaLangComparable, AndroidIcuUtilFreezable > {
 @public
  JavaUtilTreeSet *strings_;
}
@property (readonly, class, strong) AndroidIcuTextUnicodeSet *EMPTY NS_SWIFT_NAME(EMPTY);
@property (readonly, class, strong) AndroidIcuTextUnicodeSet *ALL_CODE_POINTS NS_SWIFT_NAME(ALL_CODE_POINTS);
@property (readonly, class) jint MIN_VALUE NS_SWIFT_NAME(MIN_VALUE);
@property (readonly, class) jint MAX_VALUE NS_SWIFT_NAME(MAX_VALUE);
@property (readonly, class) jint IGNORE_SPACE NS_SWIFT_NAME(IGNORE_SPACE);
@property (readonly, class) jint CASE NS_SWIFT_NAME(CASE);
@property (readonly, class) jint CASE_INSENSITIVE NS_SWIFT_NAME(CASE_INSENSITIVE);
@property (readonly, class) jint ADD_CASE_MAPPINGS NS_SWIFT_NAME(ADD_CASE_MAPPINGS);

+ (AndroidIcuTextUnicodeSet *)EMPTY;

+ (AndroidIcuTextUnicodeSet *)ALL_CODE_POINTS;

+ (jint)MIN_VALUE;

+ (jint)MAX_VALUE;

+ (jint)IGNORE_SPACE;

+ (jint)CASE;

+ (jint)CASE_INSENSITIVE;

+ (jint)ADD_CASE_MAPPINGS;

#pragma mark Public

/*!
 @brief Constructs an empty set.
 */
- (instancetype __nonnull)init;

/*!
 @brief Quickly constructs a set from a set of ranges &lt;s0, e0, s1, e1, s2, e2, ..., sn, en&gt;.
 There must be an even number of integers, and they must be all greater than zero,
  all less than or equal to Character.MAX_CODE_POINT.
  In each pair (..., si, ei, ...) it must be true that si &lt;= ei
  Between adjacent pairs (...ei, sj...), it must be true that ei+1 &lt; sj
 @param pairs pairs of character representing ranges
 */
- (instancetype __nonnull)initWithIntArray:(IOSIntArray *)pairs;

/*!
 @brief Constructs a set containing the given range.If <code>end &gt;
  start</code> then an empty set is created.
 @param start first character, inclusive, of range
 @param end last character, inclusive, of range
 */
- (instancetype __nonnull)initWithInt:(jint)start
                              withInt:(jint)end;

/*!
 @brief Constructs a set from the given pattern.See the class description
  for the syntax of the pattern language.
 Whitespace is ignored.
 @param pattern a string specifying what characters are in the set
 @throw java.lang.IllegalArgumentExceptionif the pattern contains
  a syntax error.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern;

/*!
 @brief Constructs a set from the given pattern.See the class description
  for the syntax of the pattern language.
 @param pattern a string specifying what characters are in the set
 @param ignoreWhitespace if true, ignore Unicode Pattern_White_Space characters
 @throw java.lang.IllegalArgumentExceptionif the pattern contains
  a syntax error.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                               withBoolean:(jboolean)ignoreWhitespace;

/*!
 @brief Constructs a set from the given pattern.See the class description
  for the syntax of the pattern language.
 @param pattern a string specifying what characters are in the set
 @param options a bitmask indicating which options to apply.  Valid options are IGNORE_SPACE and CASE.
 @throw java.lang.IllegalArgumentExceptionif the pattern contains
  a syntax error.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                                   withInt:(jint)options;

/*!
 @brief Constructs a set from the given pattern.See the class description
  for the syntax of the pattern language.
 @param pattern a string specifying what characters are in the set
 @param pos on input, the position in pattern at which to start parsing.  On output, the position after the last character parsed.
 @param symbols a symbol table mapping variables to char[] arrays  and chars to UnicodeSets
 @throw java.lang.IllegalArgumentExceptionif the pattern
  contains a syntax error.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                 withJavaTextParsePosition:(JavaTextParsePosition *)pos
             withAndroidIcuTextSymbolTable:(id<AndroidIcuTextSymbolTable>)symbols;

/*!
 @brief Constructs a set from the given pattern.See the class description
  for the syntax of the pattern language.
 @param pattern a string specifying what characters are in the set
 @param pos on input, the position in pattern at which to start parsing.  On output, the position after the last character parsed.
 @param symbols a symbol table mapping variables to char[] arrays  and chars to UnicodeSets
 @param options a bitmask indicating which options to apply.  Valid options are IGNORE_SPACE and CASE.
 @throw java.lang.IllegalArgumentExceptionif the pattern
  contains a syntax error.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                 withJavaTextParsePosition:(JavaTextParsePosition *)pos
             withAndroidIcuTextSymbolTable:(id<AndroidIcuTextSymbolTable>)symbols
                                   withInt:(jint)options;

/*!
 @brief Constructs a copy of an existing set.
 */
- (instancetype __nonnull)initWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)other;

/*!
 @brief Generate and append a string representation of this set to result.
 This does not use this.pat, the cleaned up copy of the string
  passed to applyPattern().
 @param result the buffer into which to generate the pattern
 @param escapeUnprintable escape unprintable characters if true
 */
- (JavaLangStringBuffer *)_generatePatternWithJavaLangStringBuffer:(JavaLangStringBuffer *)result
                                                       withBoolean:(jboolean)escapeUnprintable;

/*!
 @brief Generate and append a string representation of this set to result.
 This does not use this.pat, the cleaned up copy of the string
  passed to applyPattern().
 @param includeStrings if false, doesn't include the strings.
 */
- (JavaLangStringBuffer *)_generatePatternWithJavaLangStringBuffer:(JavaLangStringBuffer *)result
                                                       withBoolean:(jboolean)escapeUnprintable
                                                       withBoolean:(jboolean)includeStrings;

/*!
 @brief Adds the specified multicharacter to this set if it is not already
  present.If this set already contains the multicharacter,
  the call leaves this set unchanged.
 Thus "ch" =&gt; {"ch"} 
 <br><b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
 @param s the source string
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)addWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Adds the specified character to this set if it is not already
  present.If this set already contains the specified character,
  the call leaves this set unchanged.
 */
- (AndroidIcuTextUnicodeSet *)addWithInt:(jint)c;

/*!
 @brief Adds the specified range to this set if it is not already
  present.If this set already contains the specified range,
  the call leaves this set unchanged.
 If <code>end &gt; start</code>
  then an empty range is added, leaving the set unchanged.
 @param start first character, inclusive, of range to be added  to this set.
 @param end last character, inclusive, of range to be added  to this set.
 */
- (AndroidIcuTextUnicodeSet *)addWithInt:(jint)start
                                 withInt:(jint)end;

/*!
 @brief Add the contents of the collection (as strings) into this UnicodeSet.
 The collection must not contain null.
 @param source the collection to add
 @return a reference to this object
 */
- (AndroidIcuTextUnicodeSet *)addWithJavaLangIterable:(id<JavaLangIterable>)source;

/*!
 @brief Adds each of the characters in this string to the set.Thus "ch" =&gt; {"c", "h"}
  If this set already any particular character, it has no effect on that character.
 @param s the source string
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)addAllWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Adds all characters in range (uses preferred naming convention).
 @param start The index of where to start on adding all characters.
 @param end The index of where to end on adding all characters.
 @return a reference to this object
 */
- (AndroidIcuTextUnicodeSet *)addAllWithInt:(jint)start
                                    withInt:(jint)end;

/*!
 @brief Add a collection (as strings) into this UnicodeSet.
 Uses standard naming convention.
 @param source collection to add into
 @return a reference to this object
 */
- (AndroidIcuTextUnicodeSet *)addAllWithJavaLangIterable:(id<JavaLangIterable>)source;

/*!
 - seealso: #addAll(android.icu.text.UnicodeSet)
 */
- (AndroidIcuTextUnicodeSet *)addAllWithJavaLangCharSequenceArray:(IOSObjectArray *)collection;

/*!
 @brief Adds all of the elements in the specified set to this set if
  they're not already present.This operation effectively
  modifies this set so that its value is the <i>union</i> of the two
  sets.
 The behavior of this operation is unspecified if the specified
  collection is modified while the operation is in progress.
 @param c set whose elements are to be added to this set.
 */
- (AndroidIcuTextUnicodeSet *)addAllWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)c;

/*!
 @brief Utility for adding the contents of an iterable to a collection.
 */
+ (IOSObjectArray *)addAllToWithJavaLangIterable:(id<JavaLangIterable>)source
                               withNSObjectArray:(IOSObjectArray *)target;

/*!
 @brief Utility for adding the contents of an iterable to a collection.
 */
+ (id<JavaUtilCollection>)addAllToWithJavaLangIterable:(id<JavaLangIterable>)source
                                withJavaUtilCollection:(id<JavaUtilCollection>)target;

/*!
 @brief Add the contents of the UnicodeSet (as strings) into a collection.
 @param target collection to add into
 */
- (IOSObjectArray *)addAllToWithNSStringArray:(IOSObjectArray *)target;

/*!
 @brief Add the contents of the UnicodeSet (as strings) into a collection.
 @param target collection to add into
 */
- (id<JavaUtilCollection>)addAllToWithJavaUtilCollection:(id<JavaUtilCollection>)target;

/*!
 @brief Simplify the ranges in a Unicode set by merging any ranges that are only separated by characters in the dontCare set.
 For example, the ranges: \\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E change to \\u2E80-\\u303E
  if the dontCare set includes unassigned characters (for a particular version of Unicode).
 @param dontCare Set with the don't-care characters for spanning
 @return the input set, modified
 */
- (AndroidIcuTextUnicodeSet *)addBridgesWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)dontCare __attribute__((deprecated));

/*!
 @brief Implementation of UnicodeMatcher API.Union the set of all
  characters that may be matched by this object into the given
  set.
 @param toUnionTo the set into which to union the source characters
 */
- (void)addMatchSetToWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)toUnionTo;

/*!
 @brief Modifies this set to contain those code points which have the
  given value for the given binary or enumerated property, as
  returned by UCharacter.getIntPropertyValue.Prior contents of
  this set are lost.
 @param prop a property in the range  UProperty.BIN_START..UProperty.BIN_LIMIT-1 or
   UProperty.INT_START..UProperty.INT_LIMIT-1 or.
   UProperty.MASK_START..UProperty.MASK_LIMIT-1.
 @param value a value in the range  UCharacter.getIntPropertyMinValue(prop)..
   UCharacter.getIntPropertyMaxValue(prop), with one exception.
   If prop is UProperty.GENERAL_CATEGORY_MASK, then value should not be
   a UCharacter.getType() result, but rather a mask value produced
   by logically ORing (1  &lt; &lt;  UCharacter.getType()) values together.  This allows grouped categories such as [:L:] to be represented.
 @return a reference to this set
 */
- (AndroidIcuTextUnicodeSet *)applyIntPropertyValueWithInt:(jint)prop
                                                   withInt:(jint)value;

/*!
 @brief Modifies this set to represent the set specified by the given pattern.
 See the class description for the syntax of the pattern language.
  Whitespace is ignored.
 @param pattern a string specifying what characters are in the set
 @throw java.lang.IllegalArgumentExceptionif the pattern
  contains a syntax error.
 */
- (AndroidIcuTextUnicodeSet *)applyPatternWithNSString:(NSString *)pattern;

/*!
 @brief Modifies this set to represent the set specified by the given pattern,
  optionally ignoring whitespace.
 See the class description for the syntax of the pattern language.
 @param pattern a string specifying what characters are in the set
 @param ignoreWhitespace if true then Unicode Pattern_White_Space characters are ignored
 @throw java.lang.IllegalArgumentExceptionif the pattern
  contains a syntax error.
 */
- (AndroidIcuTextUnicodeSet *)applyPatternWithNSString:(NSString *)pattern
                                           withBoolean:(jboolean)ignoreWhitespace;

/*!
 @brief Modifies this set to represent the set specified by the given pattern,
  optionally ignoring whitespace.
 See the class description for the syntax of the pattern language.
 @param pattern a string specifying what characters are in the set
 @param options a bitmask indicating which options to apply.  Valid options are IGNORE_SPACE and CASE.
 @throw java.lang.IllegalArgumentExceptionif the pattern
  contains a syntax error.
 */
- (AndroidIcuTextUnicodeSet *)applyPatternWithNSString:(NSString *)pattern
                                               withInt:(jint)options;

/*!
 @brief Parses the given pattern, starting at the given position.The character
  at pattern.charAt(pos.getIndex()) must be '[', or the parse fails.
 Parsing continues until the corresponding closing ']'.  If a syntax error
  is encountered between the opening and closing brace, the parse fails.
  Upon return from a successful parse, the ParsePosition is updated to
  point to the character following the closing ']', and an inversion
  list for the parsed pattern is returned.  This method
  calls itself recursively to parse embedded subpatterns.
 @param pattern the string containing the pattern to be parsed.  The  portion of the string from pos.getIndex(), which must be a '[', to the
   corresponding closing ']', is parsed.
 @param pos upon entry, the position at which to being parsing.  The  character at pattern.charAt(pos.getIndex()) must be a '['.  Upon return
   from a successful parse, pos.getIndex() is either the character after the
   closing ']' of the parsed pattern, or pattern.length() if the closing ']'
   is the last character of the pattern string.
 @return an inversion list for the parsed substring
  of <code>pattern</code>
 @throw java.lang.IllegalArgumentExceptionif the parse fails.
 */
- (AndroidIcuTextUnicodeSet *)applyPatternWithNSString:(NSString *)pattern
                             withJavaTextParsePosition:(JavaTextParsePosition *)pos
                         withAndroidIcuTextSymbolTable:(id<AndroidIcuTextSymbolTable>)symbols
                                               withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Modifies this set to contain those code points which have the
  given value for the given property.Prior contents of this
  set are lost.
 @param propertyAlias a property alias, either short or long.  The name is matched loosely.  See PropertyAliases.txt for names
   and a description of loose matching.  If the value string is
   empty, then this string is interpreted as either a
   General_Category value alias, a Script value alias, a binary
   property alias, or a special ID.  Special IDs are matched
   loosely and correspond to the following sets:
   "ANY" = [\\u0000-\\u0010FFFF],  "ASCII" = [\\u0000-\\u007F].
 @param valueAlias a value alias, either short or long.  The  name is matched loosely.  See PropertyValueAliases.txt for
   names and a description of loose matching.  In addition to
   aliases listed, numeric values and canonical combining classes
   may be expressed numerically, e.g., ("nv", "0.5") or ("ccc",
   "220").  The value string may also be empty.
 @return a reference to this set
 */
- (AndroidIcuTextUnicodeSet *)applyPropertyAliasWithNSString:(NSString *)propertyAlias
                                                withNSString:(NSString *)valueAlias;

/*!
 @brief Modifies this set to contain those code points which have the
  given value for the given property.Prior contents of this
  set are lost.
 @param propertyAlias A string of the property alias.
 @param valueAlias A string of the value alias.
 @param symbols if not null, then symbols are first called to see if a property  is available. If true, then everything else is skipped.
 @return this set
 */
- (AndroidIcuTextUnicodeSet *)applyPropertyAliasWithNSString:(NSString *)propertyAlias
                                                withNSString:(NSString *)valueAlias
                               withAndroidIcuTextSymbolTable:(id<AndroidIcuTextSymbolTable>)symbols;

/*!
 @brief Returns the character at the given index within this set, where
  the set is ordered by ascending code point.If the index is
  out of range, return -1.
 The inverse of this method is 
 <code>indexOf()</code>.
 @param index an index from 0..size()-1
 @return the character at the given index, or -1.
 */
- (jint)charAtWithInt:(jint)index;

/*!
 @brief Removes all of the elements from this set.This set will be
  empty after this call returns.
 */
- (AndroidIcuTextUnicodeSet *)clear;

/*!
 @brief Return a new set that is equivalent to this one.
 */
- (id)java_clone;

/*!
 @brief Clone a thawed version of this class, according to the Freezable interface.
 @return the clone, not frozen
 */
- (AndroidIcuTextUnicodeSet *)cloneAsThawed;

/*!
 @brief Close this set over the given attribute.For the attribute
  CASE, the result is to modify this set so that:
  1.
 For each character or string 'a' in this set, all strings
  'b' such that foldCase(a) == foldCase(b) are added to this set.
  (For most 'a' that are single characters, 'b' will have
  b.length() == 1.)
  2. For each string 'e' in the resulting set, if e !=
  foldCase(e), 'e' will be removed. Example: [aqß{Bc}{bC}{Fi}] =
 &gt; [aAqQßﬁ{ss}{bc}{fi}]
  (Here foldCase(x) refers to the operation
  UCharacter.foldCase(x, true), and a == b actually denotes
  a.equals(b), not pointer comparison.)
 @param attribute bitmask for attributes to close over.  Currently only the CASE bit is supported.  Any undefined bits
   are ignored.
 @return a reference to this set.
 */
- (AndroidIcuTextUnicodeSet *)closeOverWithInt:(jint)attribute;

/*!
 @brief Reallocate this objects internal structures to take up the least
  possible space, without changing this object's value.
 */
- (AndroidIcuTextUnicodeSet *)compact;

/*!
 @brief Utility to compare a string to a code point.
 Same results as turning the code point into a string (with the [ugly] new StringBuilder().appendCodePoint(codepoint).toString())
  and comparing, but much faster (no object creation).
  Actually, there is one difference; a null compares as less.
  Note that this (=String) order is UTF-16 order -- *not* code point order.
 */
+ (jint)compareWithJavaLangCharSequence:(id<JavaLangCharSequence>)string
                                withInt:(jint)codePoint;

/*!
 @brief Utility to compare two collections, optionally by size, and then lexicographically.
 */
+ (jint)compareWithJavaUtilCollection:(id<JavaUtilCollection>)collection1
               withJavaUtilCollection:(id<JavaUtilCollection>)collection2
withAndroidIcuTextUnicodeSet_ComparisonStyle:(AndroidIcuTextUnicodeSet_ComparisonStyle *)style;

/*!
 @brief Utility to compare a string to a code point.
 Same results as turning the code point into a string and comparing, but much faster (no object creation).
  Actually, there is one difference; a null compares as less.
  Note that this (=String) order is UTF-16 order -- *not* code point order.
 */
+ (jint)compareWithInt:(jint)codePoint
withJavaLangCharSequence:(id<JavaLangCharSequence>)string;

/*!
 @brief Utility to compare two iterables.Warning: the ordering in iterables is important.
 For Collections that are ordered,
  like Lists, that is expected. However, Sets in Java violate Leibniz's law when it comes to iteration.
  That means that sets can't be compared directly with this method, unless they are TreeSets without
  (or with the same) comparator. Unfortunately, it is impossible to reliably detect in Java whether subclass of
  Collection satisfies the right criteria, so it is left to the user to avoid those circumstances.
 */
+ (jint)compareWithJavaLangIterable:(id<JavaLangIterable>)collection1
               withJavaLangIterable:(id<JavaLangIterable>)collection2;

/*!
 @brief Utility to compare two iterators.Warning: the ordering in iterables is important.
 For Collections that are ordered,
  like Lists, that is expected. However, Sets in Java violate Leibniz's law when it comes to iteration.
  That means that sets can't be compared directly with this method, unless they are TreeSets without
  (or with the same) comparator. Unfortunately, it is impossible to reliably detect in Java whether subclass of
  Collection satisfies the right criteria, so it is left to the user to avoid those circumstances.
 */
+ (jint)compareWithJavaUtilIterator:(id<JavaUtilIterator>)first
               withJavaUtilIterator:(id<JavaUtilIterator>)other __attribute__((deprecated));

/*!
 */
- (jint)compareToWithJavaLangIterable:(id<JavaLangIterable>)other;

/*!
 @brief Compares UnicodeSets, where shorter come first, and otherwise lexigraphically
  (according to the comparison of the first characters that differ).
 - seealso: java.lang.Comparable#compareTo(java.lang.Object)
 */
- (jint)compareToWithId:(AndroidIcuTextUnicodeSet *)o;

/*!
 @brief Compares UnicodeSets, in three different ways.
 - seealso: java.lang.Comparable#compareTo(java.lang.Object)
 */
- (jint)compareToWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)o
 withAndroidIcuTextUnicodeSet_ComparisonStyle:(AndroidIcuTextUnicodeSet_ComparisonStyle *)style;

/*!
 @brief This is equivalent to 
 <code>complement(MIN_VALUE, MAX_VALUE)</code>.
 */
- (AndroidIcuTextUnicodeSet *)complement;

/*!
 @brief Complement the specified string in this set.
 The set will not contain the specified string once the call
  returns. 
 <br><b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
 @param s the string to complement
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)complementWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Complements the specified character in this set.The character
  will be removed if it is in this set, or will be added if it is
  not in this set.
 */
- (AndroidIcuTextUnicodeSet *)complementWithInt:(jint)c;

/*!
 @brief Complements the specified range in this set.Any character in
  the range will be removed if it is in this set, or will be
  added if it is not in this set.
 If <code>end &gt; start</code>
  then an empty range is complemented, leaving the set unchanged.
 @param start first character, inclusive, of range to be removed  from this set.
 @param end last character, inclusive, of range to be removed  from this set.
 */
- (AndroidIcuTextUnicodeSet *)complementWithInt:(jint)start
                                        withInt:(jint)end;

/*!
 @brief Complement EACH of the characters in this string.Note: "ch" == {"c", "h"}
  If this set already any particular character, it has no effect on that character.
 @param s the source string
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)complementAllWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Complements in this set all elements contained in the specified
  set.Any character in the other set will be removed if it is
  in this set, or will be added if it is not in this set.
 @param c set that defines which elements will be complemented from           this set.
 */
- (AndroidIcuTextUnicodeSet *)complementAllWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)c;

/*!
 @brief Returns <tt>true</tt> if this set contains the given
  multicharacter string.
 @param s string to be checked for containment
 @return <tt>true</tt> if this set contains the specified string
 */
- (jboolean)containsWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Returns true if this set contains the given character.
 @param c character to be checked for containment
 @return true if the test condition is met
 */
- (jboolean)containsWithInt:(jint)c;

/*!
 @brief Returns true if this set contains every character
  of the given range.
 @param start first character, inclusive, of the range
 @param end last character, inclusive, of the range
 @return true if the test condition is met
 */
- (jboolean)containsWithInt:(jint)start
                    withInt:(jint)end;

/*!
 - seealso: #containsAll(android.icu.text.UnicodeSet)
 */
- (jboolean)containsAllWithJavaLangIterable:(id<JavaLangIterable>)collection;

/*!
 @brief Returns true if there is a partition of the string such that this set contains each of the partitioned strings.
 For example, for the Unicode set [a{bc}{cd}]<br>
  containsAll is true for each of: "a", "bc", ""cdbca"<br>
  containsAll is false for each of: "acb", "bcda", "bcx"<br>
 @param s string containing characters to be checked for containment
 @return true if the test condition is met
 */
- (jboolean)containsAllWithNSString:(NSString *)s;

/*!
 @brief Returns true if this set contains all the characters and strings
  of the given set.
 @param b set to be checked for containment
 @return true if the test condition is met
 */
- (jboolean)containsAllWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)b;

/*!
 @brief Returns true if this set contains none of the characters
  of the given string.
 @param s string containing characters to be checked for containment
 @return true if the test condition is met
 */
- (jboolean)containsNoneWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Returns true if this set contains none of the characters
  of the given range.
 @param start first character, inclusive, of the range
 @param end last character, inclusive, of the range
 @return true if the test condition is met
 */
- (jboolean)containsNoneWithInt:(jint)start
                        withInt:(jint)end;

/*!
 - seealso: #containsNone(android.icu.text.UnicodeSet)
 */
- (jboolean)containsNoneWithJavaLangIterable:(id<JavaLangIterable>)collection;

/*!
 @brief Returns true if none of the characters or strings in this UnicodeSet appears in the string.
 For example, for the Unicode set [a{bc}{cd}]<br>
  containsNone is true for: "xy", "cb"<br>
  containsNone is false for: "a", "bc", "bcd"<br>
 @param b set to be checked for containment
 @return true if the test condition is met
 */
- (jboolean)containsNoneWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)b;

/*!
 @brief Returns true if this set contains one or more of the characters
  of the given string.
 @param s string containing characters to be checked for containment
 @return true if the condition is met
 */
- (jboolean)containsSomeWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Returns true if this set contains one or more of the characters
  in the given range.
 @param start first character, inclusive, of the range
 @param end last character, inclusive, of the range
 @return true if the condition is met
 */
- (jboolean)containsSomeWithInt:(jint)start
                        withInt:(jint)end;

/*!
 - seealso: #containsAll(android.icu.text.UnicodeSet)
 */
- (jboolean)containsSomeWithJavaLangIterable:(id<JavaLangIterable>)collection;

/*!
 @brief Returns true if this set contains one or more of the characters
  and strings of the given set.
 @param s set to be checked for containment
 @return true if the condition is met
 */
- (jboolean)containsSomeWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)s;

/*!
 @brief Compares the specified object with this set for equality.Returns
  <tt>true</tt> if the specified object is also a set, the two sets
  have the same size, and every member of the specified set is
  contained in this set (or equivalently, every member of this set is
  contained in the specified set).
 @param o Object to be compared for equality with this set.
 @return <tt>true</tt> if the specified Object is equal to this set.
 */
- (jboolean)isEqual:(id)o;

/*!
 @brief Find the first index at or after fromIndex where the UnicodeSet matches at that index.
 If findNot is true, then reverse the sense of the match: find the first place where the UnicodeSet doesn't match.
  If there is no match, length is returned.
 */
- (jint)findInWithJavaLangCharSequence:(id<JavaLangCharSequence>)value
                               withInt:(jint)fromIndex
                           withBoolean:(jboolean)findNot __attribute__((deprecated));

/*!
 @brief Find the last index before fromIndex where the UnicodeSet matches at that index.
 If findNot is true, then reverse the sense of the match: find the last place where the UnicodeSet doesn't match.
  If there is no match, -1 is returned.
  BEFORE index is not in the UnicodeSet.
 */
- (jint)findLastInWithJavaLangCharSequence:(id<JavaLangCharSequence>)value
                                   withInt:(jint)fromIndex
                               withBoolean:(jboolean)findNot __attribute__((deprecated));

/*!
 @brief Freeze this class, according to the Freezable interface.
 @return this
 */
- (AndroidIcuTextUnicodeSet *)freeze;

/*!
 @brief Makes a set from a multicharacter string.Thus "ch" =&gt; {"ch"} 
 <br><b>Warning: you cannot add an empty string ("") to a UnicodeSet.
 </b>
 @param s the source string
 @return a newly created set containing the given string
 */
+ (AndroidIcuTextUnicodeSet *)fromWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Makes a set from each of the characters in the string.Thus "ch" =&gt; {"c", "h"}
 @param s the source string
 @return a newly created set containing the given characters
 */
+ (AndroidIcuTextUnicodeSet *)fromAllWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Get the default symbol table.Null means ordinary processing.
 For internal use only.
 @return the symbol table
 */
+ (AndroidIcuTextUnicodeSet_XSymbolTable *)getDefaultXSymbolTable __attribute__((deprecated));

/*!
 @brief Iteration method that returns the number of ranges contained in
  this set.
 - seealso: #getRangeStart
 - seealso: #getRangeEnd
 */
- (jint)getRangeCount;

/*!
 @brief Iteration method that returns the last character in the
  specified range of this set.
 @throw ArrayIndexOutOfBoundsExceptionif index is outside
  the range <code>0..getRangeCount()-1</code>
 - seealso: #getRangeStart
 - seealso: #getRangeEnd
 */
- (jint)getRangeEndWithInt:(jint)index;

/*!
 @brief Iteration method that returns the first character in the
  specified range of this set.
 @throw ArrayIndexOutOfBoundsExceptionif index is outside
  the range <code>0..getRangeCount()-1</code>
 - seealso: #getRangeCount
 - seealso: #getRangeEnd
 */
- (jint)getRangeStartWithInt:(jint)index;

/*!
 @brief Get the Regex equivalent for this UnicodeSet
 @return regex pattern equivalent to this UnicodeSet
 */
- (NSString *)getRegexEquivalent __attribute__((deprecated));

/*!
 @brief Return the value of the first code point, if the string is exactly one code point.Otherwise return Integer.MAX_VALUE.
 */
+ (jint)getSingleCodePointWithJavaLangCharSequence:(id<JavaLangCharSequence>)s __attribute__((deprecated));

/*!
 @brief Returns the hash code value for this set.
 @return the hash code value for this set.
 - seealso: java.lang.Object#hashCode()
 */
- (NSUInteger)hash;

/*!
 @brief Returns the index of the given character within this set, where
  the set is ordered by ascending code point.If the character
  is not in this set, return -1.
 The inverse of this method is 
 <code>charAt()</code>.
 @return an index from 0..size()-1, or -1
 */
- (jint)indexOfWithInt:(jint)c;

/*!
 @brief Returns <tt>true</tt> if this set contains no elements.
 @return <tt>true</tt> if this set contains no elements.
 */
- (jboolean)isEmpty;

/*!
 @brief Is this frozen, according to the Freezable interface?
 @return value
 */
- (jboolean)isFrozen;

/*!
 @brief Returns a string iterator.Uses the same order of iteration as <code>UnicodeSetIterator</code>.
 <p><b>Warning: </b>For speed, UnicodeSet iteration does not check for concurrent modification.
  Do not alter the UnicodeSet while iterating.
 - seealso: java.util.Set#iterator()
 */
- (id<JavaUtilIterator>)iterator;

/*!
 @brief Implementation of UnicodeMatcher.matches().Always matches the
  longest possible multichar string.
 */
- (jint)matchesWithAndroidIcuTextReplaceable:(id<AndroidIcuTextReplaceable>)text
                                withIntArray:(IOSIntArray *)offset
                                     withInt:(jint)limit
                                 withBoolean:(jboolean)incremental;

/*!
 @brief Tests whether the text matches at the offset.If so, returns the end of the longest substring that it matches.
 If not, returns -1.
 */
- (jint)matchesAtWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                  withInt:(jint)offset __attribute__((deprecated));

/*!
 @brief Implementation of UnicodeMatcher API.Returns <tt>true</tt> if
  this set contains any character whose low byte is the given
  value.
 This is used by <tt>RuleBasedTransliterator</tt> for
  indexing.
 */
- (jboolean)matchesIndexValueWithInt:(jint)v;

/*!
 @brief Provide for faster iteration than by String.Returns an Iterable/Iterator over ranges of code points.
 The UnicodeSet must not be altered during the iteration.
  The EntryRange instance is the same each time; the contents are just reset. 
 <p><b>Warning: </b>To iterate over the full contents, you have to also iterate over the strings. 
 <p><b>Warning: </b>For speed, UnicodeSet iteration does not check for concurrent modification.
  Do not alter the UnicodeSet while iterating. 
 @code

  // Sample code
  for (EntryRange range : us1.ranges()) {
      // do something with code points between range.codepoint and range.codepointEnd;
  }
  for (String s : us1.strings()) {
      // do something with each string;
  } 
  
@endcode
 */
- (id<JavaLangIterable>)ranges;

/*!
 @brief Removes the specified string from this set if it is present.
 The set will not contain the specified string once the call
  returns.
 @param s the string to be removed
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)removeWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 @brief Removes the specified character from this set if it is present.
 The set will not contain the specified character once the call
  returns.
 @param c the character to be removed
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)removeWithInt:(jint)c;

/*!
 @brief Removes the specified range from this set if it is present.
 The set will not contain the specified range once the call
  returns.  If <code>end &gt; start</code> then an empty range is
  removed, leaving the set unchanged.
 @param start first character, inclusive, of range to be removed  from this set.
 @param end last character, inclusive, of range to be removed  from this set.
 */
- (AndroidIcuTextUnicodeSet *)removeWithInt:(jint)start
                                    withInt:(jint)end;

/*!
 @brief Remove EACH of the characters in this string.Note: "ch" == {"c", "h"}
  If this set already any particular character, it has no effect on that character.
 @param s the source string
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)removeAllWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 - seealso: #removeAll(android.icu.text.UnicodeSet)
 */
- (AndroidIcuTextUnicodeSet *)removeAllWithJavaLangIterable:(id<JavaLangIterable>)collection;

/*!
 @brief Removes from this set all of its elements that are contained in the
  specified set.This operation effectively modifies this
  set so that its value is the <i>asymmetric set difference</i> of
  the two sets.
 @param c set that defines which elements will be removed from           this set.
 */
- (AndroidIcuTextUnicodeSet *)removeAllWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)c;

/*!
 @brief Remove all strings from this UnicodeSet
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)removeAllStrings;

/*!
 @brief Return true if the given position, in the given pattern, appears
  to be the start of a UnicodeSet pattern.
 */
+ (jboolean)resemblesPatternWithNSString:(NSString *)pattern
                                 withInt:(jint)pos;

/*!
 @brief Retain the specified string in this set if it is present.
 Upon return this set will be empty if it did not contain s, or
  will only contain s if it did contain s.
 @param cs the string to be retained
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)retain__WithJavaLangCharSequence:(id<JavaLangCharSequence>)cs;

/*!
 @brief Retain the specified character from this set if it is present.
 Upon return this set will be empty if it did not contain c, or
  will only contain c if it did contain c.
 @param c the character to be retained
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)retain__WithInt:(jint)c;

/*!
 @brief Retain only the elements in this set that are contained in the
  specified range.If <code>end &gt; start</code> then an empty range is
  retained, leaving the set empty.
 @param start first character, inclusive, of range to be retained  to this set.
 @param end last character, inclusive, of range to be retained  to this set.
 */
- (AndroidIcuTextUnicodeSet *)retain__WithInt:(jint)start
                                      withInt:(jint)end;

/*!
 @brief Retains EACH of the characters in this string.Note: "ch" == {"c", "h"}
  If this set already any particular character, it has no effect on that character.
 @param s the source string
 @return this object, for chaining
 */
- (AndroidIcuTextUnicodeSet *)retainAllWithJavaLangCharSequence:(id<JavaLangCharSequence>)s;

/*!
 - seealso: #retainAll(android.icu.text.UnicodeSet)
 */
- (AndroidIcuTextUnicodeSet *)retainAllWithJavaLangIterable:(id<JavaLangIterable>)collection;

/*!
 @brief Retains only the elements in this set that are contained in the
  specified set.In other words, removes from this set all of
  its elements that are not contained in the specified set.
 This
  operation effectively modifies this set so that its value is
  the <i>intersection</i> of the two sets.
 @param c set that defines which elements this set will retain.
 */
- (AndroidIcuTextUnicodeSet *)retainAllWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)c;

/*!
 @brief Make this object represent the range <code>start - end</code>.
 If <code>end &gt; start</code> then this object is set to an
  an empty range.
 @param start first character in the set, inclusive
 @param end last character in the set, inclusive
 */
- (AndroidIcuTextUnicodeSet *)setWithInt:(jint)start
                                 withInt:(jint)end;

/*!
 @brief Make this object represent the same set as <code>other</code>.
 @param other a  <code> UnicodeSet </code>  whose value will be
   copied to this object
 */
- (AndroidIcuTextUnicodeSet *)setWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)other;

/*!
 @brief Set the default symbol table.Null means ordinary processing.
 For internal use only. Will affect all subsequent parsing
  of UnicodeSets. 
 <p>
  WARNING: If this function is used with a UnicodeProperty, and the
  Unassigned characters (gc=Cn) are different than in ICU other than in ICU, you MUST call 
 <code>UnicodeProperty.ResetCacheProperties</code> afterwards. If you then call <code>UnicodeSet.setDefaultXSymbolTable</code>
  with null to clear the value, you MUST also call <code>UnicodeProperty.ResetCacheProperties</code>.
 @param xSymbolTable the new default symbol table.
 */
+ (void)setDefaultXSymbolTableWithAndroidIcuTextUnicodeSet_XSymbolTable:(AndroidIcuTextUnicodeSet_XSymbolTable *)xSymbolTable __attribute__((deprecated));

/*!
 @brief Returns the number of elements in this set (its cardinality)
  Note than the elements of a set may include both individual
  codepoints and strings.
 @return the number of elements in this set (its cardinality).
 */
- (jint)size;

/*!
 @brief Span a string using this UnicodeSet.
 If the start index is less than 0, span will start from 0.
    If the start index is greater than the string length, span returns the string length. 
 <p>To replace, count elements, or delete spans, see <code>UnicodeSetSpanner</code>.
 @param s The string to be spanned
 @param start The start index that the span begins
 @param spanCondition The span condition
 @return the string index which ends the span (i.e. exclusive)
 */
- (jint)spanWithJavaLangCharSequence:(id<JavaLangCharSequence>)s
                             withInt:(jint)start
withAndroidIcuTextUnicodeSet_SpanCondition:(AndroidIcuTextUnicodeSet_SpanCondition *)spanCondition;

/*!
 @brief Span a string using this UnicodeSet.
 <p>To replace, count elements, or delete spans, see <code>UnicodeSetSpanner</code>.
 @param s The string to be spanned
 @param spanCondition The span condition
 @return the length of the span
 */
- (jint)spanWithJavaLangCharSequence:(id<JavaLangCharSequence>)s
withAndroidIcuTextUnicodeSet_SpanCondition:(AndroidIcuTextUnicodeSet_SpanCondition *)spanCondition;

/*!
 @brief Same as span() but also counts the smallest number of set elements on any path across the span.
 <p>To replace, count elements, or delete spans, see <code>UnicodeSetSpanner</code>.
 @param outCount An output-only object (must not be null) for returning the count.
 @return the limit (exclusive end) of the span
 */
- (jint)spanAndCountWithJavaLangCharSequence:(id<JavaLangCharSequence>)s
                                     withInt:(jint)start
  withAndroidIcuTextUnicodeSet_SpanCondition:(AndroidIcuTextUnicodeSet_SpanCondition *)spanCondition
                 withAndroidIcuUtilOutputInt:(AndroidIcuUtilOutputInt *)outCount __attribute__((deprecated));

/*!
 @brief Span a string backwards (from the fromIndex) using this UnicodeSet.
 If the fromIndex is less than 0, spanBack will return 0.
  If fromIndex is greater than the string length, spanBack will start from the string length. 
 <p>To replace, count elements, or delete spans, see <code>UnicodeSetSpanner</code>.
 @param s The string to be spanned
 @param fromIndex The index of the char (exclusive) that the string should be spanned backwards
 @param spanCondition The span condition
 @return The string index which starts the span (i.e. inclusive).
 */
- (jint)spanBackWithJavaLangCharSequence:(id<JavaLangCharSequence>)s
                                 withInt:(jint)fromIndex
withAndroidIcuTextUnicodeSet_SpanCondition:(AndroidIcuTextUnicodeSet_SpanCondition *)spanCondition;

/*!
 @brief Span a string backwards (from the end) using this UnicodeSet.
 <p>To replace, count elements, or delete spans, see <code>UnicodeSetSpanner</code>.
 @param s The string to be spanned
 @param spanCondition The span condition
 @return The string index which starts the span (i.e. inclusive).
 */
- (jint)spanBackWithJavaLangCharSequence:(id<JavaLangCharSequence>)s
withAndroidIcuTextUnicodeSet_SpanCondition:(AndroidIcuTextUnicodeSet_SpanCondition *)spanCondition;

/*!
 @brief For iterating through the strings in the set.Example:
  @code

  for (String key : myUnicodeSet.strings()) {
    doSomethingWith(key);
  } 
  
@endcode
 */
- (id<JavaUtilCollection>)strings;

/*!
 @brief Strips code points from source.If matches is true, script all that match <i>this</i>.
 If matches is false, then strip all that <i>don't</i> match.
 @param source The source of the CharSequence to strip from.
 @param matches A boolean to either strip all that matches or don't match with the current UnicodeSet object.
 @return The string after it has been stripped.
 */
- (NSString *)stripFromWithJavaLangCharSequence:(id<JavaLangCharSequence>)source
                                    withBoolean:(jboolean)matches __attribute__((deprecated));

/*!
 @brief Add the contents of the UnicodeSet (as strings) into an array.
 */
+ (IOSObjectArray *)toArrayWithAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)set;

/*!
 @brief Returns a string representation of this set.If the result of
  calling this function is passed to a UnicodeSet constructor, it
  will produce another set that is equal to this one.
 */
- (NSString *)toPatternWithBoolean:(jboolean)escapeUnprintable;

/*!
 @brief Return a programmer-readable string representation of this object.
 */
- (NSString *)description;

#pragma mark Package-Private

@end

J2OBJC_STATIC_INIT(AndroidIcuTextUnicodeSet)

J2OBJC_FIELD_SETTER(AndroidIcuTextUnicodeSet, strings_, JavaUtilTreeSet *)

/*!
 @brief Constant for the empty set.
 */
inline AndroidIcuTextUnicodeSet *AndroidIcuTextUnicodeSet_get_EMPTY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *AndroidIcuTextUnicodeSet_EMPTY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextUnicodeSet, EMPTY, AndroidIcuTextUnicodeSet *)

/*!
 @brief Constant for the set of all code points.
 (Since UnicodeSets can include strings, does not include everything that a UnicodeSet can.)
 */
inline AndroidIcuTextUnicodeSet *AndroidIcuTextUnicodeSet_get_ALL_CODE_POINTS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *AndroidIcuTextUnicodeSet_ALL_CODE_POINTS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextUnicodeSet, ALL_CODE_POINTS, AndroidIcuTextUnicodeSet *)

/*!
 @brief Minimum value that can be stored in a UnicodeSet.
 */
inline jint AndroidIcuTextUnicodeSet_get_MIN_VALUE(void);
#define AndroidIcuTextUnicodeSet_MIN_VALUE 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextUnicodeSet, MIN_VALUE, jint)

/*!
 @brief Maximum value that can be stored in a UnicodeSet.
 */
inline jint AndroidIcuTextUnicodeSet_get_MAX_VALUE(void);
#define AndroidIcuTextUnicodeSet_MAX_VALUE 1114111
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextUnicodeSet, MAX_VALUE, jint)

/*!
 @brief Bitmask for constructor and applyPattern() indicating that
  white space should be ignored.If set, ignore Unicode Pattern_White_Space characters,
  unless they are quoted or escaped.
 This may be ORed together
  with other selectors.
 */
inline jint AndroidIcuTextUnicodeSet_get_IGNORE_SPACE(void);
#define AndroidIcuTextUnicodeSet_IGNORE_SPACE 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextUnicodeSet, IGNORE_SPACE, jint)

/*!
 @brief Bitmask for constructor, applyPattern(), and closeOver()
  indicating letter case.This may be ORed together with other
  selectors.
 Enable case insensitive matching.  E.g., "[ab]" with this flag
  will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
  match all except 'a', 'A', 'b', and 'B'. This performs a full
  closure over case mappings, e.g. U+017F for s.
  The resulting set is a superset of the input for the code points but
  not for the strings.
  It performs a case mapping closure of the code points and adds
  full case folding strings for the code points, and reduces strings of
  the original set to their full case folding equivalents.
  This is designed for case-insensitive matches, for example
  in regular expressions. The full code point case closure allows checking of
  an input character directly against the closure set.
  Strings are matched by comparing the case-folded form from the closure
  set with an incremental case folding of the string in question.
  The closure set will also contain single code points if the original
  set contained case-equivalent strings (like U+00DF for "ss" or "Ss" etc.).
  This is not necessary (that is, redundant) for the above matching method
  but results in the same closure sets regardless of whether the original
  set contained the code point or a string.
 */
inline jint AndroidIcuTextUnicodeSet_get_CASE(void);
#define AndroidIcuTextUnicodeSet_CASE 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextUnicodeSet, CASE, jint)

/*!
 @brief Alias for UnicodeSet.CASE, for ease of porting from C++ where ICU4C
  also has both USET_CASE and USET_CASE_INSENSITIVE (see uset.h).
 - seealso: #CASE
 */
inline jint AndroidIcuTextUnicodeSet_get_CASE_INSENSITIVE(void);
#define AndroidIcuTextUnicodeSet_CASE_INSENSITIVE 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextUnicodeSet, CASE_INSENSITIVE, jint)

/*!
 @brief Bitmask for constructor, applyPattern(), and closeOver()
  indicating letter case.This may be ORed together with other
  selectors.
 Enable case insensitive matching.  E.g., "[ab]" with this flag
  will match 'a', 'A', 'b', and 'B'.  "[^ab]" with this flag will
  match all except 'a', 'A', 'b', and 'B'. This adds the lower-,
  title-, and uppercase mappings as well as the case folding
  of each existing element in the set.
 */
inline jint AndroidIcuTextUnicodeSet_get_ADD_CASE_MAPPINGS(void);
#define AndroidIcuTextUnicodeSet_ADD_CASE_MAPPINGS 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextUnicodeSet, ADD_CASE_MAPPINGS, jint)

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_init(AndroidIcuTextUnicodeSet *self);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_init(void);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithAndroidIcuTextUnicodeSet_(AndroidIcuTextUnicodeSet *self, AndroidIcuTextUnicodeSet *other);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithAndroidIcuTextUnicodeSet_(AndroidIcuTextUnicodeSet *other) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithAndroidIcuTextUnicodeSet_(AndroidIcuTextUnicodeSet *other);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithInt_withInt_(AndroidIcuTextUnicodeSet *self, jint start, jint end);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithInt_withInt_(jint start, jint end) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithInt_withInt_(jint start, jint end);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithIntArray_(AndroidIcuTextUnicodeSet *self, IOSIntArray *pairs);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithIntArray_(IOSIntArray *pairs) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithIntArray_(IOSIntArray *pairs);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithNSString_(AndroidIcuTextUnicodeSet *self, NSString *pattern);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithNSString_withBoolean_(AndroidIcuTextUnicodeSet *self, NSString *pattern, jboolean ignoreWhitespace);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithNSString_withBoolean_(NSString *pattern, jboolean ignoreWhitespace) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithNSString_withBoolean_(NSString *pattern, jboolean ignoreWhitespace);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithNSString_withInt_(AndroidIcuTextUnicodeSet *self, NSString *pattern, jint options);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithNSString_withInt_(NSString *pattern, jint options) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithNSString_withInt_(NSString *pattern, jint options);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithNSString_withJavaTextParsePosition_withAndroidIcuTextSymbolTable_(AndroidIcuTextUnicodeSet *self, NSString *pattern, JavaTextParsePosition *pos, id<AndroidIcuTextSymbolTable> symbols);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithNSString_withJavaTextParsePosition_withAndroidIcuTextSymbolTable_(NSString *pattern, JavaTextParsePosition *pos, id<AndroidIcuTextSymbolTable> symbols) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithNSString_withJavaTextParsePosition_withAndroidIcuTextSymbolTable_(NSString *pattern, JavaTextParsePosition *pos, id<AndroidIcuTextSymbolTable> symbols);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_initWithNSString_withJavaTextParsePosition_withAndroidIcuTextSymbolTable_withInt_(AndroidIcuTextUnicodeSet *self, NSString *pattern, JavaTextParsePosition *pos, id<AndroidIcuTextSymbolTable> symbols, jint options);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *new_AndroidIcuTextUnicodeSet_initWithNSString_withJavaTextParsePosition_withAndroidIcuTextSymbolTable_withInt_(NSString *pattern, JavaTextParsePosition *pos, id<AndroidIcuTextSymbolTable> symbols, jint options) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *create_AndroidIcuTextUnicodeSet_initWithNSString_withJavaTextParsePosition_withAndroidIcuTextSymbolTable_withInt_(NSString *pattern, JavaTextParsePosition *pos, id<AndroidIcuTextSymbolTable> symbols, jint options);

FOUNDATION_EXPORT jboolean AndroidIcuTextUnicodeSet_resemblesPatternWithNSString_withInt_(NSString *pattern, jint pos);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *AndroidIcuTextUnicodeSet_fromWithJavaLangCharSequence_(id<JavaLangCharSequence> s);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *AndroidIcuTextUnicodeSet_fromAllWithJavaLangCharSequence_(id<JavaLangCharSequence> s);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuTextUnicodeSet_toArrayWithAndroidIcuTextUnicodeSet_(AndroidIcuTextUnicodeSet *set);

FOUNDATION_EXPORT jint AndroidIcuTextUnicodeSet_compareWithJavaLangCharSequence_withInt_(id<JavaLangCharSequence> string, jint codePoint);

FOUNDATION_EXPORT jint AndroidIcuTextUnicodeSet_compareWithInt_withJavaLangCharSequence_(jint codePoint, id<JavaLangCharSequence> string);

FOUNDATION_EXPORT jint AndroidIcuTextUnicodeSet_compareWithJavaLangIterable_withJavaLangIterable_(id<JavaLangIterable> collection1, id<JavaLangIterable> collection2);

FOUNDATION_EXPORT jint AndroidIcuTextUnicodeSet_compareWithJavaUtilIterator_withJavaUtilIterator_(id<JavaUtilIterator> first, id<JavaUtilIterator> other);

FOUNDATION_EXPORT jint AndroidIcuTextUnicodeSet_compareWithJavaUtilCollection_withJavaUtilCollection_withAndroidIcuTextUnicodeSet_ComparisonStyle_(id<JavaUtilCollection> collection1, id<JavaUtilCollection> collection2, AndroidIcuTextUnicodeSet_ComparisonStyle *style);

FOUNDATION_EXPORT id<JavaUtilCollection> AndroidIcuTextUnicodeSet_addAllToWithJavaLangIterable_withJavaUtilCollection_(id<JavaLangIterable> source, id<JavaUtilCollection> target);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuTextUnicodeSet_addAllToWithJavaLangIterable_withNSObjectArray_(id<JavaLangIterable> source, IOSObjectArray *target);

FOUNDATION_EXPORT jint AndroidIcuTextUnicodeSet_getSingleCodePointWithJavaLangCharSequence_(id<JavaLangCharSequence> s);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_XSymbolTable *AndroidIcuTextUnicodeSet_getDefaultXSymbolTable(void);

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_setDefaultXSymbolTableWithAndroidIcuTextUnicodeSet_XSymbolTable_(AndroidIcuTextUnicodeSet_XSymbolTable *xSymbolTable);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextUnicodeSet)

#endif

#if !defined (AndroidIcuTextUnicodeSet_XSymbolTable_) && (INCLUDE_ALL_AndroidIcuTextUnicodeSet || defined(INCLUDE_AndroidIcuTextUnicodeSet_XSymbolTable))
#define AndroidIcuTextUnicodeSet_XSymbolTable_

#define RESTRICT_AndroidIcuTextSymbolTable 1
#define INCLUDE_AndroidIcuTextSymbolTable 1
#include "android/icu/text/SymbolTable.h"

@class AndroidIcuTextUnicodeSet;
@class IOSCharArray;
@class JavaTextParsePosition;
@protocol AndroidIcuTextUnicodeMatcher;

/*!
 @brief Internal class for customizing UnicodeSet parsing of properties.
 TODO: extend to allow customizing of codepoint ranges
 @author medavis
 */
@interface AndroidIcuTextUnicodeSet_XSymbolTable : NSObject < AndroidIcuTextSymbolTable >

#pragma mark Public

/*!
 @brief Default constructor
 */
- (instancetype __nonnull)init;

/*!
 @brief Override the interpretation of the sequence [:propertyName=propertyValue:] (and its negated and Perl-style
  variant).The propertyName and propertyValue may be existing Unicode aliases, or may not be.
 <p>
  This routine will be called whenever the parsing of a UnicodeSet pattern finds such a
  propertyName+propertyValue combination.
 @param propertyName the name of the property
 @param propertyValue the name of the property value
 @param result UnicodeSet value to change             a set to which the characters having the propertyName+propertyValue are to be added.
 @return returns true if the propertyName+propertyValue combination is to be overridden, and the characters
          with that property have been added to the UnicodeSet, and returns false if the
          propertyName+propertyValue combination is not recognized (in which case result is unaltered).
 */
- (jboolean)applyPropertyAliasWithNSString:(NSString *)propertyName
                              withNSString:(NSString *)propertyValue
              withAndroidIcuTextUnicodeSet:(AndroidIcuTextUnicodeSet *)result;

/*!
 @brief Supplies default implementation for SymbolTable (no action).
 */
- (IOSCharArray *)lookupWithNSString:(NSString *)s;

/*!
 @brief Supplies default implementation for SymbolTable (no action).
 */
- (id<AndroidIcuTextUnicodeMatcher>)lookupMatcherWithInt:(jint)i;

/*!
 @brief Supplies default implementation for SymbolTable (no action).
 */
- (NSString *)parseReferenceWithNSString:(NSString *)text
               withJavaTextParsePosition:(JavaTextParsePosition *)pos
                                 withInt:(jint)limit;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextUnicodeSet_XSymbolTable)

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_XSymbolTable_init(AndroidIcuTextUnicodeSet_XSymbolTable *self);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextUnicodeSet_XSymbolTable)

#endif

#if !defined (AndroidIcuTextUnicodeSet_EntryRange_) && (INCLUDE_ALL_AndroidIcuTextUnicodeSet || defined(INCLUDE_AndroidIcuTextUnicodeSet_EntryRange))
#define AndroidIcuTextUnicodeSet_EntryRange_

/*!
 @brief A struct-like class used for iteration through ranges, for faster iteration than by String.
 Read about the restrictions on usage in <code>UnicodeSet.ranges()</code>.
 */
@interface AndroidIcuTextUnicodeSet_EntryRange : NSObject {
 @public
  /*!
   @brief The starting code point of the range.
   */
  jint codepoint_;
  /*!
   @brief The ending code point of the range
   */
  jint codepointEnd_;
}

#pragma mark Public

/*!
 */
- (NSString *)description;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextUnicodeSet_EntryRange)

FOUNDATION_EXPORT void AndroidIcuTextUnicodeSet_EntryRange_init(AndroidIcuTextUnicodeSet_EntryRange *self);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_EntryRange *new_AndroidIcuTextUnicodeSet_EntryRange_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_EntryRange *create_AndroidIcuTextUnicodeSet_EntryRange_init(void);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextUnicodeSet_EntryRange)

#endif

#if !defined (AndroidIcuTextUnicodeSet_ComparisonStyle_) && (INCLUDE_ALL_AndroidIcuTextUnicodeSet || defined(INCLUDE_AndroidIcuTextUnicodeSet_ComparisonStyle))
#define AndroidIcuTextUnicodeSet_ComparisonStyle_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, AndroidIcuTextUnicodeSet_ComparisonStyle_Enum) {
  AndroidIcuTextUnicodeSet_ComparisonStyle_Enum_SHORTER_FIRST = 0,
  AndroidIcuTextUnicodeSet_ComparisonStyle_Enum_LEXICOGRAPHIC = 1,
  AndroidIcuTextUnicodeSet_ComparisonStyle_Enum_LONGER_FIRST = 2,
};

/*!
 @brief Comparison style enums used by <code>UnicodeSet.compareTo(UnicodeSet, ComparisonStyle)</code>.
 */
@interface AndroidIcuTextUnicodeSet_ComparisonStyle : JavaLangEnum

@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_ComparisonStyle *SHORTER_FIRST NS_SWIFT_NAME(SHORTER_FIRST);
@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_ComparisonStyle *LEXICOGRAPHIC NS_SWIFT_NAME(LEXICOGRAPHIC);
@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_ComparisonStyle *LONGER_FIRST NS_SWIFT_NAME(LONGER_FIRST);
+ (AndroidIcuTextUnicodeSet_ComparisonStyle * __nonnull)SHORTER_FIRST;

+ (AndroidIcuTextUnicodeSet_ComparisonStyle * __nonnull)LEXICOGRAPHIC;

+ (AndroidIcuTextUnicodeSet_ComparisonStyle * __nonnull)LONGER_FIRST;

#pragma mark Public

+ (AndroidIcuTextUnicodeSet_ComparisonStyle *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (AndroidIcuTextUnicodeSet_ComparisonStyle_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextUnicodeSet_ComparisonStyle)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_ComparisonStyle *AndroidIcuTextUnicodeSet_ComparisonStyle_values_[];

/*!
 */
inline AndroidIcuTextUnicodeSet_ComparisonStyle *AndroidIcuTextUnicodeSet_ComparisonStyle_get_SHORTER_FIRST(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_ComparisonStyle, SHORTER_FIRST)

/*!
 */
inline AndroidIcuTextUnicodeSet_ComparisonStyle *AndroidIcuTextUnicodeSet_ComparisonStyle_get_LEXICOGRAPHIC(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_ComparisonStyle, LEXICOGRAPHIC)

/*!
 */
inline AndroidIcuTextUnicodeSet_ComparisonStyle *AndroidIcuTextUnicodeSet_ComparisonStyle_get_LONGER_FIRST(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_ComparisonStyle, LONGER_FIRST)

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuTextUnicodeSet_ComparisonStyle_values(void);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_ComparisonStyle *AndroidIcuTextUnicodeSet_ComparisonStyle_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_ComparisonStyle *AndroidIcuTextUnicodeSet_ComparisonStyle_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextUnicodeSet_ComparisonStyle)

#endif

#if !defined (AndroidIcuTextUnicodeSet_SpanCondition_) && (INCLUDE_ALL_AndroidIcuTextUnicodeSet || defined(INCLUDE_AndroidIcuTextUnicodeSet_SpanCondition))
#define AndroidIcuTextUnicodeSet_SpanCondition_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, AndroidIcuTextUnicodeSet_SpanCondition_Enum) {
  AndroidIcuTextUnicodeSet_SpanCondition_Enum_NOT_CONTAINED = 0,
  AndroidIcuTextUnicodeSet_SpanCondition_Enum_CONTAINED = 1,
  AndroidIcuTextUnicodeSet_SpanCondition_Enum_SIMPLE = 2,
  AndroidIcuTextUnicodeSet_SpanCondition_Enum_CONDITION_COUNT = 3,
};

/*!
 @brief Argument values for whether span() and similar functions continue while the current character is contained vs.
 not contained in the set. 
 <p>
  The functionality is straightforward for sets with only single code points, without strings (which is the common
  case): 
 <ul>
  <li>CONTAINED and SIMPLE work the same. 
 <li>CONTAINED and SIMPLE are inverses of NOT_CONTAINED. 
 <li>span() and spanBack() partition any string the
  same way when alternating between span(NOT_CONTAINED) and span(either "contained" condition). 
 <li>Using a
  complemented (inverted) set and the opposite span conditions yields the same results. 
 </ul>
  When a set contains multi-code point strings, then these statements may not be true, depending on the strings in
  the set (for example, whether they overlap with each other) and the string that is processed. For a set with
  strings: 
 <ul>
  <li>The complement of the set contains the opposite set of code points, but the same set of strings.
  Therefore, complementing both the set and the span conditions may yield different results. 
 <li>When starting spans
  at different positions in a string (span(s, ...) vs. span(s+1, ...)) the ends of the spans may be different
  because a set string may start before the later position. 
 <li>span(SIMPLE) may be shorter than
  span(CONTAINED) because it will not recursively try all possible paths. For example, with a set which
  contains the three strings "xy", "xya" and "ax", span("xyax", CONTAINED) will return 4 but span("xyax",
  SIMPLE) will return 3. span(SIMPLE) will never be longer than span(CONTAINED). 
 <li>With either "contained" condition, span() and spanBack() may partition a string in different ways. For example,
  with a set which contains the two strings "ab" and "ba", and when processing the string "aba", span() will yield
  contained/not-contained boundaries of { 0, 2, 3 } while spanBack() will yield boundaries of { 0, 1, 3 }. 
 </ul>
  Note: If it is important to get the same boundaries whether iterating forward or backward through a string, then
  either only span() should be used and the boundaries cached for backward operation, or an ICU BreakIterator could
  be used. 
 <p>
  Note: Unpaired surrogates are treated like surrogate code points. Similarly, set strings match only on code point
  boundaries, never in the middle of a surrogate pair.
 */
@interface AndroidIcuTextUnicodeSet_SpanCondition : JavaLangEnum

@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_SpanCondition *NOT_CONTAINED NS_SWIFT_NAME(NOT_CONTAINED);
@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_SpanCondition *CONTAINED NS_SWIFT_NAME(CONTAINED);
@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_SpanCondition *SIMPLE NS_SWIFT_NAME(SIMPLE);
@property (readonly, class, nonnull) AndroidIcuTextUnicodeSet_SpanCondition *CONDITION_COUNT NS_SWIFT_NAME(CONDITION_COUNT);
+ (AndroidIcuTextUnicodeSet_SpanCondition * __nonnull)NOT_CONTAINED;

+ (AndroidIcuTextUnicodeSet_SpanCondition * __nonnull)CONTAINED;

+ (AndroidIcuTextUnicodeSet_SpanCondition * __nonnull)SIMPLE;

+ (AndroidIcuTextUnicodeSet_SpanCondition * __nonnull)CONDITION_COUNT;

#pragma mark Public

+ (AndroidIcuTextUnicodeSet_SpanCondition *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (AndroidIcuTextUnicodeSet_SpanCondition_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextUnicodeSet_SpanCondition)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_values_[];

/*!
 @brief Continues a span() while there is no set element at the current position.
 Increments by one code point at a time.
  Stops before the first set element (character or string).
  (For code points only, this is like while contains(current)==false). 
 <p>
  When span() returns, the substring between where it started and the position it returned consists only of
  characters that are not in the set, and none of its strings overlap with the span.
 */
inline AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_get_NOT_CONTAINED(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_SpanCondition, NOT_CONTAINED)

/*!
 @brief Spans the longest substring that is a concatenation of set elements (characters or strings).
 (For characters only, this is like while contains(current)==true). 
 <p>
  When span() returns, the substring between where it started and the position it returned consists only of set
  elements (characters or strings) that are in the set. 
 <p>
  If a set contains strings, then the span will be the longest substring for which there
  exists at least one non-overlapping concatenation of set elements (characters or strings).
  This is equivalent to a POSIX regular expression for <code>(OR of each set element)*</code>.
  (Java/ICU/Perl regex stops at the first match of an OR.)
 */
inline AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_get_CONTAINED(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_SpanCondition, CONTAINED)

/*!
 @brief Continues a span() while there is a set element at the current position.
 Increments by the longest matching element at each position.
  (For characters only, this is like while contains(current)==true). 
 <p>
  When span() returns, the substring between where it started and the position it returned consists only of set
  elements (characters or strings) that are in the set. 
 <p>
  If a set only contains single characters, then this is the same as CONTAINED. 
 <p>
  If a set contains strings, then the span will be the longest substring with a match at each position with the
  longest single set element (character or string). 
 <p>
  Use this span condition together with other longest-match algorithms, such as ICU converters
  (ucnv_getUnicodeSet()).
 */
inline AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_get_SIMPLE(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_SpanCondition, SIMPLE)

/*!
 @brief One more than the last span condition.
 */
inline AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_get_CONDITION_COUNT(void);
J2OBJC_ENUM_CONSTANT(AndroidIcuTextUnicodeSet_SpanCondition, CONDITION_COUNT)

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuTextUnicodeSet_SpanCondition_values(void);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT AndroidIcuTextUnicodeSet_SpanCondition *AndroidIcuTextUnicodeSet_SpanCondition_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextUnicodeSet_SpanCondition)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuTextUnicodeSet")
