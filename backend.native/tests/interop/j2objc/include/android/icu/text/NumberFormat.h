//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/NumberFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuTextNumberFormat")
#ifdef RESTRICT_AndroidIcuTextNumberFormat
#define INCLUDE_ALL_AndroidIcuTextNumberFormat 0
#else
#define INCLUDE_ALL_AndroidIcuTextNumberFormat 1
#endif
#undef RESTRICT_AndroidIcuTextNumberFormat
#ifdef INCLUDE_AndroidIcuTextNumberFormat_SimpleNumberFormatFactory
#define INCLUDE_AndroidIcuTextNumberFormat_NumberFormatFactory 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuTextNumberFormat_) && (INCLUDE_ALL_AndroidIcuTextNumberFormat || defined(INCLUDE_AndroidIcuTextNumberFormat))
#define AndroidIcuTextNumberFormat_

#define RESTRICT_AndroidIcuTextUFormat 1
#define INCLUDE_AndroidIcuTextUFormat 1
#include "android/icu/text/UFormat.h"

@class AndroidIcuMathBigDecimal;
@class AndroidIcuTextDisplayContext;
@class AndroidIcuTextDisplayContext_Type;
@class AndroidIcuTextNumberFormat_NumberFormatFactory;
@class AndroidIcuUtilCurrency;
@class AndroidIcuUtilCurrencyAmount;
@class AndroidIcuUtilULocale;
@class IOSObjectArray;
@class JavaLangStringBuffer;
@class JavaMathBigDecimal;
@class JavaMathBigInteger;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@class JavaUtilLocale;
@protocol JavaLangCharSequence;

/*!
 @brief <strong>[icu enhancement]</strong> ICU's replacement for <code>java.text.NumberFormat</code>.
 &nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
 <code>NumberFormat</code> is the abstract base class for all number
  formats. This class provides the interface for formatting and parsing
  numbers. <code>NumberFormat</code> also provides methods for determining
  which locales have number formats, and what their names are. 
 <code>NumberFormat</code> helps you to format and parse numbers for any locale.
  Your code can be completely independent of the locale conventions for
  decimal points, thousands-separators, or even the particular decimal
  digits used, or whether the number format is even decimal. 
 <p>
  To format a number for the current Locale, use one of the factory
  class methods: 
 <blockquote>
  @code

   myString = NumberFormat.getInstance().format(myNumber); 
  
@endcode
  </blockquote>
  If you are formatting multiple numbers, it is
  more efficient to get the format and use it multiple times so that
  the system doesn't have to fetch the information about the local
  language and country conventions multiple times. 
 <blockquote>
  @code

  NumberFormat nf = NumberFormat.getInstance();
  for (int i = 0; i &lt; a.length; ++i) {
      output.println(nf.format(myNumber[i]) + "; ");
  } 
  
@endcode
  </blockquote>
  To format a number for a different Locale, specify it in the
  call to <code>getInstance</code>.
  <blockquote>
  @code

  NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH); 
  
@endcode
  </blockquote>
  You can also use a <code>NumberFormat</code> to parse numbers: 
 <blockquote>
  @code

  myNumber = nf.parse(myString); 
  
@endcode
  </blockquote>
  Use <code>getInstance</code> or <code>getNumberInstance</code> to get the
  normal number format. Use <code>getIntegerInstance</code> to get an
  integer number format. Use <code>getCurrencyInstance</code> to get the
  currency number format. And use <code>getPercentInstance</code> to get a
  format for displaying percentages. Some factory methods are found within
  subclasses of NumberFormat. With this format, a fraction like
  0.53 is displayed as 53%. 
 <p>
  Starting from ICU 4.2, you can use getInstance() by passing in a 'style'
  as parameter to get the correct instance.
  For example,
  use getInstance(...NUMBERSTYLE) to get the normal number format,
  getInstance(...PERCENTSTYLE) to get a format for displaying percentage,
  getInstance(...SCIENTIFICSTYLE) to get a format for displaying scientific number,
  getInstance(...INTEGERSTYLE) to get an integer number format,
  getInstance(...CURRENCYSTYLE) to get the currency number format,
  in which the currency is represented by its symbol, for example, "$3.00".
  getInstance(...ISOCURRENCYSTYLE)  to get the currency number format,
  in which the currency is represented by its ISO code, for example "USD3.00".
  getInstance(...PLURALCURRENCYSTYLE) to get the currency number format,
  in which the currency is represented by its full name in plural format,
  for example, "3.00 US dollars" or "1.00 US dollar". 
 <p>
  You can also control the display of numbers with such methods as 
 <code>setMinimumFractionDigits</code>.
  If you want even more control over the format or parsing,
  or want to give your users more control,
  you can try casting the <code>NumberFormat</code> you get from the factory methods
  to a <code>DecimalFormat</code>. This will work for the vast majority
  of locales; just remember to put it in a <code>try</code> block in case you
  encounter an unusual one. 
 <p>
  NumberFormat is designed such that some controls
  work for formatting and others work for parsing.  The following is
  the detailed description for each these control methods, 
 <p>
  setParseIntegerOnly : only affects parsing, e.g.
  if true,  "3456.78" -&gt; 3456 (and leaves the parse position just after '6')
  if false, "3456.78" -&gt; 3456.78 (and leaves the parse position just after '8')
  This is independent of formatting.  If you want to not show a decimal point
  where there might be no digits after the decimal point, use
  setDecimalSeparatorAlwaysShown on DecimalFormat. 
 <p>
  You can also use forms of the <code>parse</code> and <code>format</code>
  methods with <code>ParsePosition</code> and <code>FieldPosition</code> to
  allow you to: 
 <ul>
  <li> progressively parse through pieces of a string 
 <li> align the decimal point and other areas 
 </ul>
  For example, you can align numbers in two ways: 
 <ol>
  <li> If you are using a monospaced font with spacing for alignment,
       you can pass the <code>FieldPosition</code> in your format call, with
       <code>field</code> = <code>INTEGER_FIELD</code>. On output,
       <code>getEndIndex</code> will be set to the offset between the
       last character of the integer and the decimal. Add
       (desiredSpaceCount - getEndIndex) spaces at the front of the string. 
 <li> If you are using proportional fonts,
       instead of padding with spaces, measure the width
       of the string in pixels from the start to <code>getEndIndex</code>.
       Then move the pen by
       (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
       It also works where there is no decimal, but possibly additional
       characters at the end, e.g., with parentheses in negative
       numbers: "(12)" for -12. 
 </ol>
  
 <h3>Synchronization</h3>
  <p>
  Number formats are generally not synchronized. It is recommended to create
  separate format instances for each thread. If multiple threads access a format
  concurrently, it must be synchronized externally. 
 <h4>DecimalFormat</h4>
  <p>DecimalFormat is the concrete implementation of NumberFormat, and the
  NumberFormat API is essentially an abstraction from DecimalFormat's API.
  Refer to DecimalFormat for more information about this API.</p>
  see          DecimalFormat
  see          java.text.ChoiceFormat
 @author Mark Davis
 @author Helena Shih
 @author Alan Liu
 */
@interface AndroidIcuTextNumberFormat : AndroidIcuTextUFormat
@property (readonly, class) jint NUMBERSTYLE NS_SWIFT_NAME(NUMBERSTYLE);
@property (readonly, class) jint CURRENCYSTYLE NS_SWIFT_NAME(CURRENCYSTYLE);
@property (readonly, class) jint PERCENTSTYLE NS_SWIFT_NAME(PERCENTSTYLE);
@property (readonly, class) jint SCIENTIFICSTYLE NS_SWIFT_NAME(SCIENTIFICSTYLE);
@property (readonly, class) jint INTEGERSTYLE NS_SWIFT_NAME(INTEGERSTYLE);
@property (readonly, class) jint ISOCURRENCYSTYLE NS_SWIFT_NAME(ISOCURRENCYSTYLE);
@property (readonly, class) jint PLURALCURRENCYSTYLE NS_SWIFT_NAME(PLURALCURRENCYSTYLE);
@property (readonly, class) jint ACCOUNTINGCURRENCYSTYLE NS_SWIFT_NAME(ACCOUNTINGCURRENCYSTYLE);
@property (readonly, class) jint CASHCURRENCYSTYLE NS_SWIFT_NAME(CASHCURRENCYSTYLE);
@property (readonly, class) jint STANDARDCURRENCYSTYLE NS_SWIFT_NAME(STANDARDCURRENCYSTYLE);
@property (readonly, class) jint INTEGER_FIELD NS_SWIFT_NAME(INTEGER_FIELD);
@property (readonly, class) jint FRACTION_FIELD NS_SWIFT_NAME(FRACTION_FIELD);
@property (readonly, class) jint currentSerialVersion NS_SWIFT_NAME(currentSerialVersion);

+ (jint)NUMBERSTYLE;

+ (jint)CURRENCYSTYLE;

+ (jint)PERCENTSTYLE;

+ (jint)SCIENTIFICSTYLE;

+ (jint)INTEGERSTYLE;

+ (jint)ISOCURRENCYSTYLE;

+ (jint)PLURALCURRENCYSTYLE;

+ (jint)ACCOUNTINGCURRENCYSTYLE;

+ (jint)CASHCURRENCYSTYLE;

+ (jint)STANDARDCURRENCYSTYLE;

+ (jint)INTEGER_FIELD;

+ (jint)FRACTION_FIELD;

+ (jint)currentSerialVersion;

#pragma mark Public

/*!
 @brief Empty constructor.Public for API compatibility with historic versions of 
 <code>java.text.NumberFormat</code> which had public constructor even though this is
  an abstract class.
 */
- (instancetype __nonnull)init;

/*!
 @brief Overrides clone.
 */
- (id)java_clone;

/*!
 @brief Overrides equals.
 Two NumberFormats are equal if they are of the same class
  and the settings (groupingUsed, parseIntegerOnly, maximumIntegerDigits, etc.
  are equal.
 @param obj the object to compare against
 @return true if the object is equal to this.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Convenience method to format a BigDecimal.
 */
- (NSString *)formatWithJavaMathBigDecimal:(JavaMathBigDecimal *)number;

/*!
 @brief <strong>[icu]</strong> Convenience method to format an ICU BigDecimal.
 */
- (NSString *)formatWithAndroidIcuMathBigDecimal:(AndroidIcuMathBigDecimal *)number;

/*!
 @brief <strong>[icu]</strong> Formats a BigDecimal.Specialization of format.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithJavaMathBigDecimal:(JavaMathBigDecimal *)number
                              withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief <strong>[icu]</strong> Formats an ICU BigDecimal.Specialization of format.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithAndroidIcuMathBigDecimal:(AndroidIcuMathBigDecimal *)number
                                    withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                                   withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief <strong>[icu]</strong> Convenience method to format a BigInteger.
 */
- (NSString *)formatWithJavaMathBigInteger:(JavaMathBigInteger *)number;

/*!
 @brief <strong>[icu]</strong> Formats a BigInteger.Specialization of format.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithJavaMathBigInteger:(JavaMathBigInteger *)number
                              withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief <strong>[icu]</strong> Convenience method to format a CurrencyAmount.
 */
- (NSString *)formatWithAndroidIcuUtilCurrencyAmount:(AndroidIcuUtilCurrencyAmount *)currAmt;

/*!
 @brief <strong>[icu]</strong> Formats a CurrencyAmount.Specialization of format.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithAndroidIcuUtilCurrencyAmount:(AndroidIcuUtilCurrencyAmount *)currAmt
                                        withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                                       withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Specialization of format.
 - seealso: java.text.Format#format(Object)
 */
- (NSString *)formatWithDouble:(jdouble)number;

/*!
 @brief Specialization of format.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithDouble:(jdouble)number
                  withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                 withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Specialization of format.
 - seealso: java.text.Format#format(Object)
 */
- (NSString *)formatWithLong:(jlong)number;

/*!
 @brief Specialization of format.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithLong:(jlong)number
                withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
               withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Formats a number and appends the resulting text to the given string buffer.
 <strong>[icu] Note:</strong> recognizes <code>BigInteger</code>
  and <code>BigDecimal</code> objects.
 - seealso: java.text.Format#format(Object, StringBuffer, FieldPosition)
 */
- (JavaLangStringBuffer *)formatWithId:(id)number
              withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Returns the list of Locales for which NumberFormats are available.
 @return the available locales
 */
+ (IOSObjectArray *)getAvailableLocales;

/*!
 @brief <strong>[icu]</strong> Returns the list of Locales for which NumberFormats are available.
 @return the available locales
 */
+ (IOSObjectArray *)getAvailableULocales;

/*!
 @brief <strong>[icu]</strong> Get the formatter's DisplayContext value for the specified DisplayContext.Type,
  such as CAPITALIZATION.
 @param type the DisplayContext.Type whose value to return
 @return the current DisplayContext setting for the specified type
 */
- (AndroidIcuTextDisplayContext *)getContextWithAndroidIcuTextDisplayContext_Type:(AndroidIcuTextDisplayContext_Type *)type;

/*!
 @brief Returns the <tt>Currency</tt> object used to display currency
  amounts.This may be null.
 */
- (AndroidIcuUtilCurrency *)getCurrency;

/*!
 @brief Returns a currency format for the current default <code>FORMAT</code> locale.
 @return a number format for currency
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getCurrencyInstance;

/*!
 @brief Returns a currency format for the specified locale.
 @return a number format for currency
 */
+ (AndroidIcuTextNumberFormat *)getCurrencyInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief <strong>[icu]</strong> Returns a currency format for the specified locale.
 @return a number format for currency
 */
+ (AndroidIcuTextNumberFormat *)getCurrencyInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)inLocale;

/*!
 @brief Returns the default number format for the current default <code>FORMAT</code> locale.
 The default format is one of the styles provided by the other
  factory methods: getNumberInstance, getIntegerInstance,
  getCurrencyInstance or getPercentInstance.
  Exactly which one is locale-dependent.
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getInstance;

/*!
 @brief <strong>[icu]</strong> Returns a specific style number format for default <code>FORMAT</code> locale.
 @param style number format style
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getInstanceWithInt:(jint)style;

/*!
 @brief Returns the default number format for the specified locale.
 The default format is one of the styles provided by the other
  factory methods: getNumberInstance, getCurrencyInstance or getPercentInstance.
  Exactly which one is locale-dependent.
 */
+ (AndroidIcuTextNumberFormat *)getInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief <strong>[icu]</strong> Returns a specific style number format for a specific locale.
 @param inLocale the specific locale.
 @param style number format style
 */
+ (AndroidIcuTextNumberFormat *)getInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale
                                                      withInt:(jint)style;

/*!
 @brief <strong>[icu]</strong> Returns the default number format for the specified locale.
 The default format is one of the styles provided by the other
  factory methods: getNumberInstance, getCurrencyInstance or getPercentInstance.
  Exactly which one is locale-dependent.
 */
+ (AndroidIcuTextNumberFormat *)getInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)inLocale;

/*!
 @brief Returns a specific style number format for a specific locale.
 @param desiredLocale the specific locale.
 @param choice number format style
 @throw IllegalArgumentExceptionif choice is not one of
                                    NUMBERSTYLE, CURRENCYSTYLE,
                                    PERCENTSTYLE, SCIENTIFICSTYLE,
                                    INTEGERSTYLE, ISOCURRENCYSTYLE,
                                    PLURALCURRENCYSTYLE, ACCOUNTINGCURRENCYSTYLE.
                                    CASHCURRENCYSTYLE, STANDARDCURRENCYSTYLE.
 */
+ (AndroidIcuTextNumberFormat *)getInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)desiredLocale
                                                             withInt:(jint)choice;

/*!
 @brief Returns an integer number format for the current default <code>FORMAT</code> locale.The
  returned number format is configured to round floating point numbers
  to the nearest integer using IEEE half-even rounding (see <code>ROUND_HALF_EVEN</code>
 ) for formatting,
  and to parse only the integer part of an input string (see <code>isParseIntegerOnly</code>
 ).
 @return a number format for integer values
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getIntegerInstance;

/*!
 @brief Returns an integer number format for the specified locale.The
  returned number format is configured to round floating point numbers
  to the nearest integer using IEEE half-even rounding (see <code>ROUND_HALF_EVEN</code>
 ) for formatting,
  and to parse only the integer part of an input string (see <code>isParseIntegerOnly</code>
 ).
 @param inLocale the locale for which a number format is needed
 @return a number format for integer values
 */
+ (AndroidIcuTextNumberFormat *)getIntegerInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief <strong>[icu]</strong> Returns an integer number format for the specified locale.The
  returned number format is configured to round floating point numbers
  to the nearest integer using IEEE half-even rounding (see <code>ROUND_HALF_EVEN</code>
 ) for formatting,
  and to parse only the integer part of an input string (see <code>isParseIntegerOnly</code>
 ).
 @param inLocale the locale for which a number format is needed
 @return a number format for integer values
 */
+ (AndroidIcuTextNumberFormat *)getIntegerInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)inLocale;

/*!
 @brief Returns the maximum number of digits allowed in the fraction
  portion of a number.The default value is 3, which subclasses
  can override.
 When formatting, the exact behavior when this
  value is exceeded is subclass-specific.  When parsing, this has
  no effect.
 @return the maximum number of fraction digits
 - seealso: #setMaximumFractionDigits
 */
- (jint)getMaximumFractionDigits;

/*!
 @brief Returns the maximum number of digits allowed in the integer portion of a
  number.The default value is 40, which subclasses can override.
 When formatting, the exact behavior when this value is exceeded is
  subclass-specific.  When parsing, this has no effect.
 @return the maximum number of integer digits
 - seealso: #setMaximumIntegerDigits
 */
- (jint)getMaximumIntegerDigits;

/*!
 @brief Returns the minimum number of digits allowed in the fraction portion of a
  number.The default value is 0, which subclasses can override.
 When formatting, if this value is not reached, numbers are padded on
  the right with the locale-specific '0' character to ensure at least
  this number of fraction digits.  When parsing, this has no effect.
 @return the minimum number of fraction digits
 - seealso: #setMinimumFractionDigits
 */
- (jint)getMinimumFractionDigits;

/*!
 @brief Returns the minimum number of digits allowed in the integer portion of a
  number.The default value is 1, which subclasses can override.
 When formatting, if this value is not reached, numbers are padded on the
  left with the locale-specific '0' character to ensure at least this
  number of integer digits.  When parsing, this has no effect.
 @return the minimum number of integer digits
 - seealso: #setMinimumIntegerDigits
 */
- (jint)getMinimumIntegerDigits;

/*!
 @brief Returns a general-purpose number format for the current default <code>FORMAT</code> locale.
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getNumberInstance;

/*!
 @brief Returns a general-purpose number format for the specified locale.
 */
+ (AndroidIcuTextNumberFormat *)getNumberInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief <strong>[icu]</strong> Returns a general-purpose number format for the specified locale.
 */
+ (AndroidIcuTextNumberFormat *)getNumberInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)inLocale;

/*!
 @brief Returns a percentage format for the current default <code>FORMAT</code> locale.
 @return a number format for percents
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getPercentInstance;

/*!
 @brief Returns a percentage format for the specified locale.
 @return a number format for percents
 */
+ (AndroidIcuTextNumberFormat *)getPercentInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief <strong>[icu]</strong> Returns a percentage format for the specified locale.
 @return a number format for percents
 */
+ (AndroidIcuTextNumberFormat *)getPercentInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)inLocale;

/*!
 @brief Returns the rounding mode used in this NumberFormat.The default implementation of
  tis method in NumberFormat always throws <code>UnsupportedOperationException</code>.
 @return A rounding mode, between <code>BigDecimal.ROUND_UP</code>
  and <code>BigDecimal.ROUND_UNNECESSARY</code>.
 - seealso: #setRoundingMode(int)
 */
- (jint)getRoundingMode;

/*!
 @brief <strong>[icu]</strong> Returns a scientific format for the current default <code>FORMAT</code> locale.
 @return a scientific number format
 - seealso: Category#FORMAT
 */
+ (AndroidIcuTextNumberFormat *)getScientificInstance;

/*!
 @brief <strong>[icu]</strong> Returns a scientific format for the specified locale.
 @return a scientific number format
 */
+ (AndroidIcuTextNumberFormat *)getScientificInstanceWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief <strong>[icu]</strong> Returns a scientific format for the specified locale.
 @return a scientific number format
 */
+ (AndroidIcuTextNumberFormat *)getScientificInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)inLocale;

/*!
 @brief Overrides hashCode.
 */
- (NSUInteger)hash;

/*!
 @brief Returns true if grouping is used in this format.For example, in the
  en_US locale, with grouping on, the number 1234567 will be formatted
  as "1,234,567".
 The grouping separator as well as the size of each group
  is locale-dependent and is determined by subclasses of NumberFormat.
  Grouping affects both parsing and formatting.
 @return true if grouping is used
 - seealso: #setGroupingUsed
 */
- (jboolean)isGroupingUsed;

/*!
 @brief Returns true if this format will parse numbers as integers only.
 For example in the English locale, with ParseIntegerOnly true, the
  string "1234." would be parsed as the integer value 1234 and parsing
  would stop at the "." character.  The decimal separator accepted
  by the parse operation is locale-dependent and determined by the
  subclass.
 @return true if this will parse integers only
 */
- (jboolean)isParseIntegerOnly;

/*!
 @brief <strong>[icu]</strong> Returns whether strict parsing is in effect.
 @return true if strict parsing is in effect
 - seealso: #setParseStrict
 */
- (jboolean)isParseStrict;

/*!
 @brief Parses text from the beginning of the given string to produce a number.
 The method might not use the entire text of the given string.
 @param text A String whose beginning should be parsed.
 @return A Number parsed from the string.
 @throw ParseExceptionif the beginning of the specified string
  cannot be parsed.
 - seealso: #format
 */
- (NSNumber *)parseWithNSString:(NSString *)text;

/*!
 @brief Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
  Long.MAX_VALUE] and with no decimals), otherwise a Double.
 If IntegerOnly is set, will stop at a decimal
  point (or equivalent; e.g., for rational numbers "1 2/3", will stop
  after the 1).
  Does not throw an exception; if no object can be parsed, index is
  unchanged!
 - seealso: #isParseIntegerOnly
 - seealso: java.text.Format#parseObject(String, ParsePosition)
 */
- (NSNumber *)parseWithNSString:(NSString *)text
      withJavaTextParsePosition:(JavaTextParsePosition *)parsePosition;

/*!
 @brief Parses text from the given string as a CurrencyAmount.Unlike
  the parse() method, this method will attempt to parse a generic
  currency name, searching for a match of this object's locale's
  currency display names, or for a 3-letter ISO currency code.
 This method will fail if this format is not a currency format,
  that is, if it does not contain the currency pattern symbol
  (U+00A4) in its prefix or suffix.
 @param text the text to parse
 @param pos input-output position; on input, the position within  text to match; must have 0 
  &lt; = pos.getIndex()  &lt;  text.length();  on output, the position after the last matched character. If  the parse fails, the position in unchanged upon output.
 @return a CurrencyAmount, or null upon failure
 */
- (AndroidIcuUtilCurrencyAmount *)parseCurrencyWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                              withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Parses text from a string to produce a number.
 @param source the String to parse
 @param parsePosition the position at which to start the parse
 @return the parsed number, or null
 - seealso: java.text.NumberFormat#parseObject(String, ParsePosition)
 */
- (id)parseObjectWithNSString:(NSString *)source
    withJavaTextParsePosition:(JavaTextParsePosition *)parsePosition;

/*!
 @brief <strong>[icu]</strong> Registers a new NumberFormatFactory.The factory is adopted by
  the service and must not be modified.
 The returned object is a
  key that can be used to unregister this factory. 
 <p>Because ICU may choose to cache NumberFormat objects internally, this must
  be called at application startup, prior to any calls to
  NumberFormat.getInstance to avoid undefined behavior.
 @param factory the factory to register
 @return a key with which to unregister the factory
 */
+ (id)registerFactoryWithAndroidIcuTextNumberFormat_NumberFormatFactory:(AndroidIcuTextNumberFormat_NumberFormatFactory *)factory;

/*!
 @brief <strong>[icu]</strong> Set a particular DisplayContext value in the formatter,
  such as CAPITALIZATION_FOR_STANDALONE.
 @param context The DisplayContext value to set.
 */
- (void)setContextWithAndroidIcuTextDisplayContext:(AndroidIcuTextDisplayContext *)context;

/*!
 @brief Sets the <tt>Currency</tt> object used to display currency
  amounts.This takes effect immediately, if this format is a
  currency format.
 If this format is not a currency format, then
  the currency object is used if and when this object becomes a
  currency format.
 @param theCurrency new currency object to use.  May be null for  some subclasses.
 */
- (void)setCurrencyWithAndroidIcuUtilCurrency:(AndroidIcuUtilCurrency *)theCurrency;

/*!
 @brief Sets whether or not grouping will be used in this format.Grouping
  affects both parsing and formatting.
 - seealso: #isGroupingUsed
 @param newValue true to use grouping.
 */
- (void)setGroupingUsedWithBoolean:(jboolean)newValue;

/*!
 @brief Sets the maximum number of digits allowed in the fraction portion of a
  number.This must be &gt;= minimumFractionDigits.
 If the
  new value for maximumFractionDigits is less than the current value
  of minimumFractionDigits, then minimumFractionDigits will also be set to
  the new value.
 @param newValue the maximum number of fraction digits to be shown; if  less than zero, then zero is used. The concrete subclass may enforce an
   upper limit to this value appropriate to the numeric type being formatted.
 - seealso: #getMaximumFractionDigits
 */
- (void)setMaximumFractionDigitsWithInt:(jint)newValue;

/*!
 @brief Sets the maximum number of digits allowed in the integer portion of a
  number.This must be &gt;= minimumIntegerDigits.
 If the
  new value for maximumIntegerDigits is less than the current value
  of minimumIntegerDigits, then minimumIntegerDigits will also be set to
  the new value.
 @param newValue the maximum number of integer digits to be shown; if  less than zero, then zero is used.  Subclasses might enforce an
   upper limit to this value appropriate to the numeric type being formatted.
 - seealso: #getMaximumIntegerDigits
 */
- (void)setMaximumIntegerDigitsWithInt:(jint)newValue;

/*!
 @brief Sets the minimum number of digits allowed in the fraction portion of a
  number.This must be &lt;= maximumFractionDigits.
 If the
  new value for minimumFractionDigits exceeds the current value
  of maximumFractionDigits, then maximumFractionDigits will also be set to
  the new value.
 @param newValue the minimum number of fraction digits to be shown; if  less than zero, then zero is used.  Subclasses might enforce an
   upper limit to this value appropriate to the numeric type being formatted.
 - seealso: #getMinimumFractionDigits
 */
- (void)setMinimumFractionDigitsWithInt:(jint)newValue;

/*!
 @brief Sets the minimum number of digits allowed in the integer portion of a
  number.This must be &lt;= maximumIntegerDigits.
 If the
  new value for minimumIntegerDigits is more than the current value
  of maximumIntegerDigits, then maximumIntegerDigits will also be set to
  the new value.
 @param newValue the minimum number of integer digits to be shown; if  less than zero, then zero is used. Subclasses might enforce an
   upper limit to this value appropriate to the numeric type being formatted.
 - seealso: #getMinimumIntegerDigits
 */
- (void)setMinimumIntegerDigitsWithInt:(jint)newValue;

/*!
 @brief Sets whether or not numbers should be parsed as integers only.
 @param value true if this should parse integers only
 - seealso: #isParseIntegerOnly
 */
- (void)setParseIntegerOnlyWithBoolean:(jboolean)value;

/*!
 @brief <strong>[icu]</strong> Sets whether strict parsing is in effect.When this is true, the
  following conditions cause a parse failure (examples use the pattern "#,##0.#"):<ul>
  <li>Leading or doubled grouping separators<br>
  ',123' and '1,,234" fail</li>
  <li>Groups of incorrect length when grouping is used<br>
  '1,23' and '1234,567' fail, but '1234' passes</li>
  <li>Grouping separators used in numbers followed by exponents<br>
  '1,234E5' fails, but '1234E5' and '1,234E' pass ('E' is not an exponent when
  not followed by a number)</li>
  </ul>
  When strict parsing is off,  all grouping separators are ignored.
 This is the default behavior.
 @param value True to enable strict parsing.  Default is false.
 - seealso: #isParseStrict
 */
- (void)setParseStrictWithBoolean:(jboolean)value;

/*!
 @brief Set the rounding mode used in this NumberFormat.The default implementation of
  tis method in NumberFormat always throws <code>UnsupportedOperationException</code>.
 @param roundingMode A rounding mode, between  
  <code> BigDecimal.ROUND_UP </code>  and   <code>
  BigDecimal.ROUND_UNNECESSARY </code> .
 - seealso: #getRoundingMode()
 */
- (void)setRoundingModeWithInt:(jint)roundingMode;

/*!
 @brief <strong>[icu]</strong> Unregisters the factory or instance associated with this key (obtained from
  registerInstance or registerFactory).
 @param registryKey a key obtained from registerFactory
 @return true if the object was successfully unregistered
 */
+ (jboolean)unregisterWithId:(id)registryKey;

#pragma mark Protected

/*!
 @brief Returns the currency in effect for this formatter.Subclasses
  should override this method as needed.
 Unlike getCurrency(),
  this method should never return null.
 @return a non-null Currency
 */
- (AndroidIcuUtilCurrency *)getEffectiveCurrency __attribute__((deprecated));

/*!
 @brief Returns the pattern for the provided locale and choice.
 @param forLocale the locale of the data.
 @param choice the pattern format.
 @return the pattern
 */
+ (NSString *)getPatternWithJavaUtilLocale:(JavaUtilLocale *)forLocale
                                   withInt:(jint)choice __attribute__((deprecated));

/*!
 @brief Returns the pattern for the provided locale and choice.
 @param forLocale the locale of the data.
 @param choice the pattern format.
 @return the pattern
 */
+ (NSString *)getPatternWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)forLocale
                                          withInt:(jint)choice;

#pragma mark Package-Private

+ (AndroidIcuTextNumberFormat *)createInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)desiredLocale
                                                                withInt:(jint)choice;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextNumberFormat)

/*!
 @brief <strong>[icu]</strong> Constant to specify normal number style of format.
 */
inline jint AndroidIcuTextNumberFormat_get_NUMBERSTYLE(void);
#define AndroidIcuTextNumberFormat_NUMBERSTYLE 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, NUMBERSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify general currency style of format.Defaults to
  STANDARDCURRENCYSTYLE, using currency symbol, for example "$3.00", with
  non-accounting style for negative values (e.g. minus sign).
 The specific style may be specified using the -cf- locale key.
 */
inline jint AndroidIcuTextNumberFormat_get_CURRENCYSTYLE(void);
#define AndroidIcuTextNumberFormat_CURRENCYSTYLE 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, CURRENCYSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify a style of format to display percent.
 */
inline jint AndroidIcuTextNumberFormat_get_PERCENTSTYLE(void);
#define AndroidIcuTextNumberFormat_PERCENTSTYLE 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, PERCENTSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify a style of format to display scientific number.
 */
inline jint AndroidIcuTextNumberFormat_get_SCIENTIFICSTYLE(void);
#define AndroidIcuTextNumberFormat_SCIENTIFICSTYLE 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, SCIENTIFICSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify a integer number style format.
 */
inline jint AndroidIcuTextNumberFormat_get_INTEGERSTYLE(void);
#define AndroidIcuTextNumberFormat_INTEGERSTYLE 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, INTEGERSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify currency style of format which uses currency
  ISO code to represent currency, for example: "USD3.00".
 */
inline jint AndroidIcuTextNumberFormat_get_ISOCURRENCYSTYLE(void);
#define AndroidIcuTextNumberFormat_ISOCURRENCYSTYLE 5
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, ISOCURRENCYSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify currency style of format which uses currency
  long name with plural format to represent currency, for example,
  "3.00 US Dollars".
 */
inline jint AndroidIcuTextNumberFormat_get_PLURALCURRENCYSTYLE(void);
#define AndroidIcuTextNumberFormat_PLURALCURRENCYSTYLE 6
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, PLURALCURRENCYSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify currency style of format which uses currency symbol
  to represent currency for accounting, for example: "($3.00), instead of
  "-$3.00" (<code>CURRENCYSTYLE</code>).
 Overrides any style specified using -cf- key in locale.
 */
inline jint AndroidIcuTextNumberFormat_get_ACCOUNTINGCURRENCYSTYLE(void);
#define AndroidIcuTextNumberFormat_ACCOUNTINGCURRENCYSTYLE 7
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, ACCOUNTINGCURRENCYSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify currency cash style of format which uses currency
  ISO code to represent currency, for example: "NT$3" instead of "NT$3.23".
 */
inline jint AndroidIcuTextNumberFormat_get_CASHCURRENCYSTYLE(void);
#define AndroidIcuTextNumberFormat_CASHCURRENCYSTYLE 8
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, CASHCURRENCYSTYLE, jint)

/*!
 @brief <strong>[icu]</strong> Constant to specify currency style of format which uses currency symbol
  to represent currency, for example "$3.00", using non-accounting style for
  negative values (e.g.minus sign).
 Overrides any style specified using -cf- key in locale.
 */
inline jint AndroidIcuTextNumberFormat_get_STANDARDCURRENCYSTYLE(void);
#define AndroidIcuTextNumberFormat_STANDARDCURRENCYSTYLE 9
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, STANDARDCURRENCYSTYLE, jint)

/*!
 @brief Field constant used to construct a FieldPosition object.Signifies that
  the position of the integer part of a formatted number should be returned.
 - seealso: java.text.FieldPosition
 */
inline jint AndroidIcuTextNumberFormat_get_INTEGER_FIELD(void);
#define AndroidIcuTextNumberFormat_INTEGER_FIELD 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, INTEGER_FIELD, jint)

/*!
 @brief Field constant used to construct a FieldPosition object.Signifies that
  the position of the fraction part of a formatted number should be returned.
 - seealso: java.text.FieldPosition
 */
inline jint AndroidIcuTextNumberFormat_get_FRACTION_FIELD(void);
#define AndroidIcuTextNumberFormat_FRACTION_FIELD 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, FRACTION_FIELD, jint)

inline jint AndroidIcuTextNumberFormat_get_currentSerialVersion(void);
#define AndroidIcuTextNumberFormat_currentSerialVersion 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat, currentSerialVersion, jint)

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getInstance(void);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getInstanceWithJavaUtilLocale_(JavaUtilLocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getInstanceWithInt_(jint style);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getInstanceWithJavaUtilLocale_withInt_(JavaUtilLocale *inLocale, jint style);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getNumberInstance(void);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getNumberInstanceWithJavaUtilLocale_(JavaUtilLocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getNumberInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getIntegerInstance(void);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getIntegerInstanceWithJavaUtilLocale_(JavaUtilLocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getIntegerInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getCurrencyInstance(void);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getCurrencyInstanceWithJavaUtilLocale_(JavaUtilLocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getCurrencyInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getPercentInstance(void);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getPercentInstanceWithJavaUtilLocale_(JavaUtilLocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getPercentInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getScientificInstance(void);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getScientificInstanceWithJavaUtilLocale_(JavaUtilLocale *inLocale);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getScientificInstanceWithAndroidIcuUtilULocale_(AndroidIcuUtilULocale *inLocale);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuTextNumberFormat_getAvailableLocales(void);

FOUNDATION_EXPORT IOSObjectArray *AndroidIcuTextNumberFormat_getAvailableULocales(void);

FOUNDATION_EXPORT id AndroidIcuTextNumberFormat_registerFactoryWithAndroidIcuTextNumberFormat_NumberFormatFactory_(AndroidIcuTextNumberFormat_NumberFormatFactory *factory);

FOUNDATION_EXPORT jboolean AndroidIcuTextNumberFormat_unregisterWithId_(id registryKey);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_getInstanceWithAndroidIcuUtilULocale_withInt_(AndroidIcuUtilULocale *desiredLocale, jint choice);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat *AndroidIcuTextNumberFormat_createInstanceWithAndroidIcuUtilULocale_withInt_(AndroidIcuUtilULocale *desiredLocale, jint choice);

FOUNDATION_EXPORT NSString *AndroidIcuTextNumberFormat_getPatternWithJavaUtilLocale_withInt_(JavaUtilLocale *forLocale, jint choice);

FOUNDATION_EXPORT NSString *AndroidIcuTextNumberFormat_getPatternWithAndroidIcuUtilULocale_withInt_(AndroidIcuUtilULocale *forLocale, jint choice);

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_init(AndroidIcuTextNumberFormat *self);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNumberFormat)

#endif

#if !defined (AndroidIcuTextNumberFormat_NumberFormatFactory_) && (INCLUDE_ALL_AndroidIcuTextNumberFormat || defined(INCLUDE_AndroidIcuTextNumberFormat_NumberFormatFactory))
#define AndroidIcuTextNumberFormat_NumberFormatFactory_

@class AndroidIcuTextNumberFormat;
@class AndroidIcuUtilULocale;
@class JavaUtilLocale;
@protocol JavaUtilSet;

/*!
 @brief A NumberFormatFactory is used to register new number formats.The factory
  should be able to create any of the predefined formats for each locale it
  supports.
 When registered, the locales it supports extend or override the
  locales already supported by ICU. 
 <p><b>Note:</b> as of ICU4J 3.2, the default API for NumberFormatFactory uses
  ULocale instead of Locale.  Instead of overriding createFormat(Locale, int),
  new implementations should override createFactory(ULocale, int).  Note that
  one of these two methods <b>MUST</b> be overridden or else an infinite
  loop will occur.
 */
@interface AndroidIcuTextNumberFormat_NumberFormatFactory : NSObject
@property (readonly, class) jint FORMAT_NUMBER NS_SWIFT_NAME(FORMAT_NUMBER);
@property (readonly, class) jint FORMAT_CURRENCY NS_SWIFT_NAME(FORMAT_CURRENCY);
@property (readonly, class) jint FORMAT_PERCENT NS_SWIFT_NAME(FORMAT_PERCENT);
@property (readonly, class) jint FORMAT_SCIENTIFIC NS_SWIFT_NAME(FORMAT_SCIENTIFIC);
@property (readonly, class) jint FORMAT_INTEGER NS_SWIFT_NAME(FORMAT_INTEGER);

+ (jint)FORMAT_NUMBER;

+ (jint)FORMAT_CURRENCY;

+ (jint)FORMAT_PERCENT;

+ (jint)FORMAT_SCIENTIFIC;

+ (jint)FORMAT_INTEGER;

#pragma mark Public

/*!
 @brief Returns a number format of the appropriate type.If the locale
  is not supported, return null.
 If the locale is supported, but
  the type is not provided by this service, return null.  Otherwise
  return an appropriate instance of NumberFormat. 
 <b>Note:</b> as of ICU4J 3.2, createFormat(ULocale, int) should be
  overridden instead of this method.  This method is no longer
  abstract and delegates to that method.
 @param loc the locale for which to create the format
 @param formatType the type of format
 @return the NumberFormat, or null.
 */
- (AndroidIcuTextNumberFormat *)createFormatWithJavaUtilLocale:(JavaUtilLocale *)loc
                                                       withInt:(jint)formatType;

/*!
 @brief Returns a number format of the appropriate type.If the locale
  is not supported, return null.
 If the locale is supported, but
  the type is not provided by this service, return null.  Otherwise
  return an appropriate instance of NumberFormat. 
 <b>Note:</b> as of ICU4J 3.2, implementations should override
  this method instead of createFormat(Locale, int).
 @param loc the locale for which to create the format
 @param formatType the type of format
 @return the NumberFormat, or null.
 */
- (AndroidIcuTextNumberFormat *)createFormatWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)loc
                                                              withInt:(jint)formatType;

/*!
 @brief Returns an immutable collection of the locale names directly
  supported by this factory.
 @return the supported locale names.
 */
- (id<JavaUtilSet>)getSupportedLocaleNames;

/*!
 @brief Returns true if this factory is visible.Default is true.
 If not visible, the locales supported by this factory will not
  be listed by getAvailableLocales.  This value must not change.
 @return true if the factory is visible.
 */
- (jboolean)visible;

#pragma mark Protected

/*!
 */
- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextNumberFormat_NumberFormatFactory)

/*!
 @brief Value passed to format requesting a default number format.
 */
inline jint AndroidIcuTextNumberFormat_NumberFormatFactory_get_FORMAT_NUMBER(void);
#define AndroidIcuTextNumberFormat_NumberFormatFactory_FORMAT_NUMBER 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat_NumberFormatFactory, FORMAT_NUMBER, jint)

/*!
 @brief Value passed to format requesting a currency format.
 */
inline jint AndroidIcuTextNumberFormat_NumberFormatFactory_get_FORMAT_CURRENCY(void);
#define AndroidIcuTextNumberFormat_NumberFormatFactory_FORMAT_CURRENCY 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat_NumberFormatFactory, FORMAT_CURRENCY, jint)

/*!
 @brief Value passed to format requesting a percent format.
 */
inline jint AndroidIcuTextNumberFormat_NumberFormatFactory_get_FORMAT_PERCENT(void);
#define AndroidIcuTextNumberFormat_NumberFormatFactory_FORMAT_PERCENT 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat_NumberFormatFactory, FORMAT_PERCENT, jint)

/*!
 @brief Value passed to format requesting a scientific format.
 */
inline jint AndroidIcuTextNumberFormat_NumberFormatFactory_get_FORMAT_SCIENTIFIC(void);
#define AndroidIcuTextNumberFormat_NumberFormatFactory_FORMAT_SCIENTIFIC 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat_NumberFormatFactory, FORMAT_SCIENTIFIC, jint)

/*!
 @brief Value passed to format requesting an integer format.
 */
inline jint AndroidIcuTextNumberFormat_NumberFormatFactory_get_FORMAT_INTEGER(void);
#define AndroidIcuTextNumberFormat_NumberFormatFactory_FORMAT_INTEGER 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat_NumberFormatFactory, FORMAT_INTEGER, jint)

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_NumberFormatFactory_init(AndroidIcuTextNumberFormat_NumberFormatFactory *self);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNumberFormat_NumberFormatFactory)

#endif

#if !defined (AndroidIcuTextNumberFormat_SimpleNumberFormatFactory_) && (INCLUDE_ALL_AndroidIcuTextNumberFormat || defined(INCLUDE_AndroidIcuTextNumberFormat_SimpleNumberFormatFactory))
#define AndroidIcuTextNumberFormat_SimpleNumberFormatFactory_

@class AndroidIcuUtilULocale;
@class JavaUtilLocale;
@protocol JavaUtilSet;

/*!
 @brief A NumberFormatFactory that supports a single locale.It can be visible or invisible.
 */
@interface AndroidIcuTextNumberFormat_SimpleNumberFormatFactory : AndroidIcuTextNumberFormat_NumberFormatFactory {
 @public
  id<JavaUtilSet> localeNames_;
  jboolean visible_;
}

#pragma mark Public

/*!
 @brief Constructs a SimpleNumberFormatFactory with the given locale.
 */
- (instancetype __nonnull)initWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Constructs a SimpleNumberFormatFactory with the given locale and the
  visibility.
 */
- (instancetype __nonnull)initWithJavaUtilLocale:(JavaUtilLocale *)locale
                                     withBoolean:(jboolean)visible;

/*!
 @brief Constructs a SimpleNumberFormatFactory with the given locale.
 */
- (instancetype __nonnull)initWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Constructs a SimpleNumberFormatFactory with the given locale and the
  visibility.
 */
- (instancetype __nonnull)initWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale
                                            withBoolean:(jboolean)visible;

/*!
 */
- (id<JavaUtilSet>)getSupportedLocaleNames;

/*!
 */
- (jboolean)visible;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory)

J2OBJC_FIELD_SETTER(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory, localeNames_, id<JavaUtilSet>)

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_SimpleNumberFormatFactory_initWithJavaUtilLocale_(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory *self, JavaUtilLocale *locale);

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_SimpleNumberFormatFactory_initWithJavaUtilLocale_withBoolean_(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory *self, JavaUtilLocale *locale, jboolean visible);

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_SimpleNumberFormatFactory_initWithAndroidIcuUtilULocale_(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory *self, AndroidIcuUtilULocale *locale);

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_SimpleNumberFormatFactory_initWithAndroidIcuUtilULocale_withBoolean_(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory *self, AndroidIcuUtilULocale *locale, jboolean visible);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNumberFormat_SimpleNumberFormatFactory)

#endif

#if !defined (AndroidIcuTextNumberFormat_NumberFormatShim_) && (INCLUDE_ALL_AndroidIcuTextNumberFormat || defined(INCLUDE_AndroidIcuTextNumberFormat_NumberFormatShim))
#define AndroidIcuTextNumberFormat_NumberFormatShim_

@class AndroidIcuTextNumberFormat;
@class AndroidIcuTextNumberFormat_NumberFormatFactory;
@class AndroidIcuUtilULocale;
@class IOSObjectArray;

@interface AndroidIcuTextNumberFormat_NumberFormatShim : NSObject

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (AndroidIcuTextNumberFormat *)createInstanceWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)l
                                                                withInt:(jint)k;

- (IOSObjectArray *)getAvailableLocales;

- (IOSObjectArray *)getAvailableULocales;

- (id)registerFactoryWithAndroidIcuTextNumberFormat_NumberFormatFactory:(AndroidIcuTextNumberFormat_NumberFormatFactory *)f;

- (jboolean)unregisterWithId:(id)k;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextNumberFormat_NumberFormatShim)

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_NumberFormatShim_init(AndroidIcuTextNumberFormat_NumberFormatShim *self);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNumberFormat_NumberFormatShim)

#endif

#if !defined (AndroidIcuTextNumberFormat_Field_) && (INCLUDE_ALL_AndroidIcuTextNumberFormat || defined(INCLUDE_AndroidIcuTextNumberFormat_Field))
#define AndroidIcuTextNumberFormat_Field_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat_Field 1
#include "java/text/Format.h"

/*!
 @brief The instances of this inner class are used as attribute keys and values
  in AttributedCharacterIterator that
  NumberFormat.formatToCharacterIterator() method returns.
 <p>
  There is no public constructor to this class, the only instances are the
  constants defined here. 
 <p>
 */
@interface AndroidIcuTextNumberFormat_Field : JavaTextFormat_Field
@property (readonly, class) jlong serialVersionUID NS_SWIFT_NAME(serialVersionUID);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *SIGN NS_SWIFT_NAME(SIGN);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *INTEGER NS_SWIFT_NAME(INTEGER);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *FRACTION NS_SWIFT_NAME(FRACTION);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *EXPONENT NS_SWIFT_NAME(EXPONENT);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *EXPONENT_SIGN NS_SWIFT_NAME(EXPONENT_SIGN);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *EXPONENT_SYMBOL NS_SWIFT_NAME(EXPONENT_SYMBOL);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *DECIMAL_SEPARATOR NS_SWIFT_NAME(DECIMAL_SEPARATOR);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *GROUPING_SEPARATOR NS_SWIFT_NAME(GROUPING_SEPARATOR);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *PERCENT NS_SWIFT_NAME(PERCENT);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *PERMILLE NS_SWIFT_NAME(PERMILLE);
@property (readonly, class, strong) AndroidIcuTextNumberFormat_Field *CURRENCY NS_SWIFT_NAME(CURRENCY);

+ (jlong)serialVersionUID;

+ (AndroidIcuTextNumberFormat_Field *)SIGN;

+ (AndroidIcuTextNumberFormat_Field *)INTEGER;

+ (AndroidIcuTextNumberFormat_Field *)FRACTION;

+ (AndroidIcuTextNumberFormat_Field *)EXPONENT;

+ (AndroidIcuTextNumberFormat_Field *)EXPONENT_SIGN;

+ (AndroidIcuTextNumberFormat_Field *)EXPONENT_SYMBOL;

+ (AndroidIcuTextNumberFormat_Field *)DECIMAL_SEPARATOR;

+ (AndroidIcuTextNumberFormat_Field *)GROUPING_SEPARATOR;

+ (AndroidIcuTextNumberFormat_Field *)PERCENT;

+ (AndroidIcuTextNumberFormat_Field *)PERMILLE;

+ (AndroidIcuTextNumberFormat_Field *)CURRENCY;

#pragma mark Protected

/*!
 @brief Constructs a new instance of NumberFormat.Field with the given field
  name.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)fieldName;

/*!
 @brief serizalization method resolve instances to the constant
  NumberFormat.Field values
 */
- (id)readResolve;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextNumberFormat_Field)

inline jlong AndroidIcuTextNumberFormat_Field_get_serialVersionUID(void);
#define AndroidIcuTextNumberFormat_Field_serialVersionUID -4516273749929385842LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNumberFormat_Field, serialVersionUID, jlong)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_SIGN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_SIGN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, SIGN, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_INTEGER(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_INTEGER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, INTEGER, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_FRACTION(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_FRACTION;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, FRACTION, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_EXPONENT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_EXPONENT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, EXPONENT, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_EXPONENT_SIGN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_EXPONENT_SIGN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, EXPONENT_SIGN, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_EXPONENT_SYMBOL(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_EXPONENT_SYMBOL;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, EXPONENT_SYMBOL, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_DECIMAL_SEPARATOR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_DECIMAL_SEPARATOR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, DECIMAL_SEPARATOR, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_GROUPING_SEPARATOR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_GROUPING_SEPARATOR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, GROUPING_SEPARATOR, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_PERCENT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_PERCENT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, PERCENT, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_PERMILLE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_PERMILLE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, PERMILLE, AndroidIcuTextNumberFormat_Field *)

/*!
 */
inline AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_get_CURRENCY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *AndroidIcuTextNumberFormat_Field_CURRENCY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNumberFormat_Field, CURRENCY, AndroidIcuTextNumberFormat_Field *)

FOUNDATION_EXPORT void AndroidIcuTextNumberFormat_Field_initWithNSString_(AndroidIcuTextNumberFormat_Field *self, NSString *fieldName);

FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *new_AndroidIcuTextNumberFormat_Field_initWithNSString_(NSString *fieldName) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextNumberFormat_Field *create_AndroidIcuTextNumberFormat_Field_initWithNSString_(NSString *fieldName);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNumberFormat_Field)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuTextNumberFormat")
