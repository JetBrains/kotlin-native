//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/DecimalFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuTextDecimalFormat")
#ifdef RESTRICT_AndroidIcuTextDecimalFormat
#define INCLUDE_ALL_AndroidIcuTextDecimalFormat 0
#else
#define INCLUDE_ALL_AndroidIcuTextDecimalFormat 1
#endif
#undef RESTRICT_AndroidIcuTextDecimalFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuTextDecimalFormat_) && (INCLUDE_ALL_AndroidIcuTextDecimalFormat || defined(INCLUDE_AndroidIcuTextDecimalFormat))
#define AndroidIcuTextDecimalFormat_

#define RESTRICT_AndroidIcuTextNumberFormat 1
#define INCLUDE_AndroidIcuTextNumberFormat 1
#include "android/icu/text/NumberFormat.h"

@class AndroidIcuMathBigDecimal;
@class AndroidIcuMathMathContext;
@class AndroidIcuTextCurrencyPluralInfo;
@class AndroidIcuTextDecimalFormatSymbols;
@class AndroidIcuTextDecimalFormat_Unit;
@class AndroidIcuTextDigitList;
@class AndroidIcuTextPluralRules_FixedDecimal;
@class AndroidIcuTextUnicodeSet;
@class AndroidIcuUtilCurrency;
@class AndroidIcuUtilCurrencyAmount;
@class AndroidIcuUtilCurrency_CurrencyUsage;
@class JavaLangStringBuffer;
@class JavaMathBigDecimal;
@class JavaMathBigInteger;
@class JavaMathMathContext;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@protocol JavaLangCharSequence;
@protocol JavaTextAttributedCharacterIterator;

/*!
 @brief <strong>[icu enhancement]</strong> ICU's replacement for <code>java.text.DecimalFormat</code>.
 &nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
 <code>DecimalFormat</code> is a concrete subclass of <code>NumberFormat</code> that formats
  decimal numbers. It has a variety of features designed to make it possible to parse and
  format numbers in any locale, including support for Western, Arabic, or Indic digits.
  It also supports different flavors of numbers, including integers ("123"), fixed-point
  numbers ("123.4"), scientific notation ("1.23E4"), percentages ("12%"), and currency
  amounts ("$123.00", "USD123.00", "123.00 US dollars").  All of these flavors can be
  easily localized. 
 <p>To obtain a <code>NumberFormat</code> for a specific locale (including the default
  locale) call one of <code>NumberFormat</code>'s factory methods such as <code>NumberFormat.getInstance</code>
 . Do not call the <code>DecimalFormat</code> constructors
  directly, unless you know what you are doing, since the <code>NumberFormat</code> factory
  methods may return subclasses other than <code>DecimalFormat</code>. If you need to
  customize the format object, do something like this: 
 <blockquote>@code

  NumberFormat f = NumberFormat.getInstance(loc);
  if (f instanceof DecimalFormat) {
      ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
  }
@endcode</blockquote>
  
 <p><strong>Example Usage</strong>
  Print out a number using the localized number, currency, and percent
  format for each locale. 
 <blockquote>@code

  Locale[] locales = NumberFormat.getAvailableLocales();
  double myNumber = -1234.56;
  NumberFormat format;
  for (int j=0; j&lt;3; ++j) {
      System.out.println("FORMAT");
      for (int i = 0; i &lt; locales.length; ++i) {
          if (locales[i].getCountry().length() == 0) {
             // Skip language-only locales
             continue;
          }
          System.out.print(locales[i].getDisplayName());
          switch (j) {
          case 0:
              format = NumberFormat.getInstance(locales[i]); break;
          case 1:
              format = NumberFormat.getCurrencyInstance(locales[i]); break;
          default:
              format = NumberFormat.getPercentInstance(locales[i]); break;
          }
          try {
              // Assume format is a DecimalFormat
              System.out.print(": " + ((DecimalFormat) format).toPattern()
                               + " -&gt; " + form.format(myNumber));
          } catch (Exception e) {}
          try {
              System.out.println(" -&gt; " + format.parse(form.format(myNumber)));
          } catch (ParseException e) {}        }        }
 
@endcode</blockquote>
  
 <p>Another example use getInstance(style).<br>
  Print out a number using the localized number, currency, percent,
  scientific, integer, iso currency, and plural currency format for each locale. 
 <blockquote>@code

  ULocale locale = new ULocale("en_US");
  double myNumber = 1234.56;
  for (int j=NumberFormat.NUMBERSTYLE; j&lt;=NumberFormat.PLURALCURRENCYSTYLE; ++j) {
      NumberFormat format = NumberFormat.getInstance(locale, j);
      try {
          // Assume format is a DecimalFormat
          System.out.print(": " + ((DecimalFormat) format).toPattern()
                           + " -&gt; " + form.format(myNumber));
      } catch (Exception e) {}
      try {
          System.out.println(" -&gt; " + format.parse(form.format(myNumber)));
      } catch (ParseException e) {}    }
 
@endcode</blockquote>
  
 <h3>Patterns</h3>
  
 <p>A <code>DecimalFormat</code> consists of a <em>pattern</em> and a set of 
 <em>symbols</em>.  The pattern may be set directly using <code>applyPattern</code>, or
  indirectly using other API methods which manipulate aspects of the pattern, such as the
  minimum number of integer digits.  The symbols are stored in a <code>DecimalFormatSymbols</code>
  object.  When using the <code>NumberFormat</code> factory methods, the
  pattern and symbols are read from ICU's locale data. 
 <h4>Special Pattern Characters</h4>
  
 <p>Many characters in a pattern are taken literally; they are matched during parsing
  and output unchanged during formatting.  Special characters, on the other hand, stand
  for other characters, strings, or classes of characters.  For example, the '#'
  character is replaced by a localized digit.  Often the replacement character is the
  same as the pattern character; in the U.S. locale, the ',' grouping character is
  replaced by ','.  However, the replacement is still happening, and if the symbols are
  modified, the grouping character changes.  Some special characters affect the behavior
  of the formatter by their presence; for example, if the percent character is seen, then
  the value is multiplied by 100 before being displayed. 
 <p>To insert a special character in a pattern as a literal, that is, without any
  special meaning, the character must be quoted.  There are some exceptions to this which
  are noted below. 
 <p>The characters listed here are used in non-localized patterns.  Localized patterns
  use the corresponding characters taken from this formatter's <code>DecimalFormatSymbols</code>
  object instead, and these characters lose their special status.
  Two exceptions are the currency sign and quote, which are not localized. 
 <blockquote>
  <table border=0 cellspacing=3 cellpadding=0 summary="Chart showing symbol,
  location, localized, and meaning.">
    <tr style="background-color: #ccccff">
      <th align=left>Symbol
      <th align=left>Location
      <th align=left>Localized?
      <th align=left>Meaning
    <tr style="vertical-align: top;">
      <td><code>0</code>
      <td>Number
      <td>Yes
      <td>Digit
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>1-9</code>
      <td>Number
      <td>Yes
      <td>'1' through '9' indicate rounding.
    <tr style="vertical-align: top;">
      <td><code>@@</code>
      <td>Number
      <td>No
      <td>Significant digit
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>#</code>
      <td>Number
      <td>Yes
      <td>Digit, zero shows as absent
    <tr style="vertical-align: top;">
      <td><code>.</code>
      <td>Number
      <td>Yes
      <td>Decimal separator or monetary decimal separator
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>-</code>
      <td>Number
      <td>Yes
      <td>Minus sign
    <tr style="vertical-align: top;">
      <td><code>,</code>
      <td>Number
      <td>Yes
      <td>Grouping separator
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>E</code>
      <td>Number
      <td>Yes
      <td>Separates mantissa and exponent in scientific notation.
          <em>Need not be quoted in prefix or suffix.</em>
    <tr style="vertical-align: top;">
      <td><code>+</code>
      <td>Exponent
      <td>Yes
      <td>Prefix positive exponents with localized plus sign.
          <em>Need not be quoted in prefix or suffix.</em>
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>;</code>
      <td>Subpattern boundary
      <td>Yes
      <td>Separates positive and negative subpatterns
    <tr style="vertical-align: top;">
      <td><code>%</code>
      <td>Prefix or suffix
      <td>Yes
      <td>Multiply by 100 and show as percentage
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>&#92;u2030</code>
      <td>Prefix or suffix
      <td>Yes
      <td>Multiply by 1000 and show as per mille
    <tr style="vertical-align: top;">
      <td><code>&#164;</code> (<code>&#92;u00A4</code>)
      <td>Prefix or suffix
      <td>No
      <td>Currency sign, replaced by currency symbol.  If
          doubled, replaced by international currency symbol.
          If tripled, replaced by currency plural names, for example,
          "US dollar" or "US dollars" for America.
          If present in a pattern, the monetary decimal separator
          is used instead of the decimal separator.   
 <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>'</code>
      <td>Prefix or suffix
      <td>No
      <td>Used to quote special characters in a prefix or suffix,
          for example, <code>"'#'#"</code> formats 123 to
          <code>"#123"</code>.  To create a single quote
          itself, use two in a row: <code>"# o''clock"</code>.
    <tr style="vertical-align: top;">
      <td><code>
 *</code>     <td>Prefix or suffix boundary
      <td>Yes
      <td>Pad escape, precedes pad character 
 </table>
  </blockquote>
  
 <p>A <code>DecimalFormat</code> pattern contains a postive and negative subpattern, for
  example, "#,##0.00;(#,##0.00)".  Each subpattern has a prefix, a numeric part, and a
  suffix.  If there is no explicit negative subpattern, the negative subpattern is the
  localized minus sign prefixed to the positive subpattern. That is, "0.00" alone is
  equivalent to "0.00;-0.00".  If there is an explicit negative subpattern, it serves
  only to specify the negative prefix and suffix; the number of digits, minimal digits,
  and other characteristics are ignored in the negative subpattern. That means that
  "#,##0.0#;(#)" has precisely the same result as "#,##0.0#;(#,##0.0#)". 
 <p>The prefixes, suffixes, and various symbols used for infinity, digits, thousands
  separators, decimal separators, etc. may be set to arbitrary values, and they will
  appear properly during formatting.  However, care must be taken that the symbols and
  strings do not conflict, or parsing will be unreliable.  For example, either the
  positive and negative prefixes or the suffixes must be distinct for <code>parse</code> to
  be able to distinguish positive from negative values.  Another example is that the
  decimal separator and thousands separator should be distinct characters, or parsing
  will be impossible. 
 <p>The <em>grouping separator</em> is a character that separates clusters of integer
  digits to make large numbers more legible.  It commonly used for thousands, but in some
  locales it separates ten-thousands.  The <em>grouping size</em> is the number of digits
  between the grouping separators, such as 3 for "100,000,000" or 4 for "1 0000
  0000". There are actually two different grouping sizes: One used for the least
  significant integer digits, the <em>primary grouping size</em>, and one used for all
  others, the <em>secondary grouping size</em>.  In most locales these are the same, but
  sometimes they are different. For example, if the primary grouping interval is 3, and
  the secondary is 2, then this corresponds to the pattern "#,##,##0", and the number
  123456789 is formatted as "12,34,56,789".  If a pattern contains multiple grouping
  separators, the interval between the last one and the end of the integer defines the
  primary grouping size, and the interval between the last two defines the secondary
  grouping size. All others are ignored, so "#,##,###,####" == "###,###,####" ==
  "##,#,###,####". 
 <p>Illegal patterns, such as "#.#.#" or "#.###,###", will cause 
 <code>DecimalFormat</code> to throw an <code>IllegalArgumentException</code> with a message
  that describes the problem. 
 <h4>Pattern BNF</h4>
  
 @code

  pattern    := subpattern (';' subpattern)?
  subpattern := prefix? number exponent? suffix?
  number     := (integer ('.' fraction)?) | sigDigits
  prefix     := '&#92;u0000'..'&#92;uFFFD' - specialCharacters
  suffix     := '&#92;u0000'..'&#92;uFFFD' - specialCharacters
  integer    := '#'* '0'* '0'
  fraction   := '0'* '#'*
  sigDigits  := '#'* '@@' '@@'* '#'*
  exponent   := 'E' '+'? '0'* '0'
  padSpec    := '*' padChar
  padChar    := '&#92;u0000'..'&#92;uFFFD' - quote 
  &#32;
  Notation:
    X*       0 or more instances of X
    X?       0 or 1 instances of X
    X|Y      either X or Y
    C..D     any character from C up to D, inclusive
    S-T      characters in S, except those in T 
  
@endcode
  The first subpattern is for positive numbers. The second (optional)
  subpattern is for negative numbers. 
 <p>Not indicated in the BNF syntax above: 
 <ul>
  
 <li>The grouping separator ',' can occur inside the integer and sigDigits
  elements, between any two pattern characters of that element, as long as the integer or
  sigDigits element is not followed by the exponent element. 
 <li>Two grouping intervals are recognized: That between the decimal point and the first
  grouping symbol, and that between the first and second grouping symbols. These
  intervals are identical in most locales, but in some locales they differ. For example,
  the pattern &quot;#,##,###&quot; formats the number 123456789 as 
 &quot;12,34,56,789&quot;.
  
 <li>The pad specifier <code>padSpec</code> may appear before the prefix, after the
  prefix, before the suffix, after the suffix, or not at all. 
 <li>In place of '0', the digits '1' through '9' may be used to indicate a rounding
  increment. 
 </ul>
  
 <h4>Parsing</h4>
  
 <p><code>DecimalFormat</code> parses all Unicode characters that represent decimal
  digits, as defined by <code>UCharacter.digit</code>.  In addition, 
 <code>DecimalFormat</code> also recognizes as digits the ten consecutive characters
  starting with the localized zero digit defined in the <code>DecimalFormatSymbols</code>
  object.  During formatting, the <code>DecimalFormatSymbols</code>-based digits are output. 
 <p>During parsing, grouping separators are ignored. 
 <p>For currency parsing, the formatter is able to parse every currency style formats no
  matter which style the formatter is constructed with.  For example, a formatter
  instance gotten from NumberFormat.getInstance(ULocale, NumberFormat.CURRENCYSTYLE) can
  parse formats such as "USD1.00" and "3.00 US dollars". 
 <p>If <code>parse(String, ParsePosition)</code> fails to parse a string, it returns 
 <code>null</code> and leaves the parse position unchanged.  The convenience method 
 <code>parse(String)</code> indicates parse failure by throwing a <code>java.text.ParseException</code>
 .
  
 <p>Parsing an extremely large or small absolute value (such as 1.0E10000 or 1.0E-10000)
  requires huge memory allocation for representing the parsed number. Such input may expose
  a risk of DoS attacks. To prevent huge memory allocation triggered by such inputs, 
 <code>DecimalFormat</code> internally limits of maximum decimal digits to be 1000. Thus,
  an input string resulting more than 1000 digits in plain decimal representation (non-exponent)
  will be treated as either overflow (positive/negative infinite) or underflow (+0.0/-0.0). 
 <h4>Formatting</h4>
  
 <p>Formatting is guided by several parameters, all of which can be specified either
  using a pattern or using the API.  The following description applies to formats that do
  not use <a href="#sci">scientific notation</a> or <a href="#sigdig">significant
  digits</a>.
  
 <ul><li>If the number of actual integer digits exceeds the <em>maximum integer
  digits</em>, then only the least significant digits are shown.  For example, 1997 is
  formatted as "97" if the maximum integer digits is set to 2. 
 <li>If the number of actual integer digits is less than the <em>minimum integer
  digits</em>, then leading zeros are added.  For example, 1997 is formatted as "01997"
  if the minimum integer digits is set to 5. 
 <li>If the number of actual fraction digits exceeds the <em>maximum fraction
  digits</em>, then half-even rounding it performed to the maximum fraction digits.  For
  example, 0.125 is formatted as "0.12" if the maximum fraction digits is 2.  This
  behavior can be changed by specifying a rounding increment and a rounding mode. 
 <li>If the number of actual fraction digits is less than the <em>minimum fraction
  digits</em>, then trailing zeros are added.  For example, 0.125 is formatted as
  "0.1250" if the mimimum fraction digits is set to 4. 
 <li>Trailing fractional zeros are not displayed if they occur <em>j</em> positions
  after the decimal, where <em>j</em> is less than the maximum fraction digits. For
  example, 0.10004 is formatted as "0.1" if the maximum fraction digits is four or less. 
 </ul>
  
 <p><strong>Special Values</strong>
  
 <p><code>NaN</code> is represented as a single character, typically 
 <code>&#92;uFFFD</code>.  This character is determined by the <code>DecimalFormatSymbols</code>
  object.  This is the only value for which the prefixes and
  suffixes are not used. 
 <p>Infinity is represented as a single character, typically <code>&#92;u221E</code>,
  with the positive or negative prefixes and suffixes applied.  The infinity character is
  determined by the <code>DecimalFormatSymbols</code> object. 
 <h4><a name="sci">Scientific Notation</a></h4>
  
 <p>Numbers in scientific notation are expressed as the product of a mantissa and a
  power of ten, for example, 1234 can be expressed as 1.234 x 10<sup>3</sup>. The
  mantissa is typically in the half-open interval [1.0, 10.0) or sometimes [0.0, 1.0),
  but it need not be.  <code>DecimalFormat</code> supports arbitrary mantissas. 
 <code>DecimalFormat</code> can be instructed to use scientific notation through the API
  or through the pattern.  In a pattern, the exponent character immediately followed by
  one or more digit characters indicates scientific notation.  Example: "0.###E0" formats
  the number 1234 as "1.234E3". 
 <ul>
  
 <li>The number of digit characters after the exponent character gives the minimum
  exponent digit count.  There is no maximum.  Negative exponents are formatted using the
  localized minus sign, <em>not</em> the prefix and suffix from the pattern.  This allows
  patterns such as "0.###E0 m/s".  To prefix positive exponents with a localized plus
  sign, specify '+' between the exponent and the digits: "0.###E+0" will produce formats
  "1E+1", "1E+0", "1E-1", etc.  (In localized patterns, use the localized plus sign
  rather than '+'.) 
 <li>The minimum number of integer digits is achieved by adjusting the exponent.
  Example: 0.00123 formatted with "00.###E0" yields "12.3E-4".  This only happens if
  there is no maximum number of integer digits.  If there is a maximum, then the minimum
  number of integer digits is fixed at one. 
 <li>The maximum number of integer digits, if present, specifies the exponent grouping.
  The most common use of this is to generate <em>engineering notation</em>, in which the
  exponent is a multiple of three, e.g., "##0.###E0".  The number 12345 is formatted
  using "##0.####E0" as "12.345E3". 
 <li>When using scientific notation, the formatter controls the digit counts using
  significant digits logic.  The maximum number of significant digits limits the total
  number of integer and fraction digits that will be shown in the mantissa; it does not
  affect parsing.  For example, 12345 formatted with "##0.##E0" is "12.3E3".  See the
  section on significant digits for more details. 
 <li>The number of significant digits shown is determined as follows: If
  areSignificantDigitsUsed() returns false, then the minimum number of significant digits
  shown is one, and the maximum number of significant digits shown is the sum of the 
 <em>minimum integer</em> and <em>maximum fraction</em> digits, and is unaffected by the
  maximum integer digits.  If this sum is zero, then all significant digits are shown.
  If areSignificantDigitsUsed() returns true, then the significant digit counts are
  specified by getMinimumSignificantDigits() and getMaximumSignificantDigits().  In this
  case, the number of integer digits is fixed at one, and there is no exponent grouping. 
 <li>Exponential patterns may not contain grouping separators. 
 </ul>
  
 <h4><a name="sigdig">Significant Digits</a></h4>
  
 <code>DecimalFormat</code> has two ways of controlling how many digits are shows: (a)
  significant digits counts, or (b) integer and fraction digit counts.  Integer and
  fraction digit counts are described above.  When a formatter is using significant
  digits counts, the number of integer and fraction digits is not specified directly, and
  the formatter settings for these counts are ignored.  Instead, the formatter uses
  however many integer and fraction digits are required to display the specified number
  of significant digits.  Examples: 
 <blockquote>
  <table border=0 cellspacing=3 cellpadding=0>
    <tr style="background-color: #ccccff">
      <th align=left>Pattern
      <th align=left>Minimum significant digits
      <th align=left>Maximum significant digits
      <th align=left>Number
      <th align=left>Output of format()
    <tr style="vertical-align: top;">
      <td><code>@@@@@@</code>
      <td>3
      <td>3
      <td>12345
      <td><code>12300</code>
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>@@@@@@</code>
      <td>3
      <td>3
      <td>0.12345
      <td><code>0.123</code>
    <tr style="vertical-align: top;">
      <td><code>@@@@##</code>
      <td>2
      <td>4
      <td>3.14159
      <td><code>3.142</code>
    <tr style="vertical-align: top; background-color: #eeeeff;">
      <td><code>@@@@##</code>
      <td>2
      <td>4
      <td>1.23004
      <td><code>1.23</code>
  </table>
  </blockquote>
  
 <ul>
  
 <li>Significant digit counts may be expressed using patterns that specify a minimum and
  maximum number of significant digits.  These are indicated by the <code>'@@'</code> and 
 <code>'#'</code> characters.  The minimum number of significant digits is the number of 
 <code>'@@'</code> characters.  The maximum number of significant digits is the number of 
 <code>'@@'</code> characters plus the number of <code>'#'</code> characters following on
  the right.  For example, the pattern <code>"@@@@@@"</code> indicates exactly 3 significant
  digits.  The pattern <code>"@@##"</code> indicates from 1 to 3 significant digits.
  Trailing zero digits to the right of the decimal separator are suppressed after the
  minimum number of significant digits have been shown.  For example, the pattern 
 <code>"@@##"</code> formats the number 0.1203 as <code>"0.12"</code>.
  
 <li>If a pattern uses significant digits, it may not contain a decimal separator, nor
  the <code>'0'</code> pattern character.  Patterns such as <code>"@@00"</code> or 
 <code>"@@.###"</code> are disallowed. 
 <li>Any number of <code>'#'</code> characters may be prepended to the left of the
  leftmost <code>'@@'</code> character.  These have no effect on the minimum and maximum
  significant digits counts, but may be used to position grouping separators.  For
  example, <code>"#,#@@#"</code> indicates a minimum of one significant digits, a maximum
  of two significant digits, and a grouping size of three. 
 <li>In order to enable significant digits formatting, use a pattern containing the 
 <code>'@@'</code> pattern character.  Alternatively, call <code>setSignificantDigitsUsed(true)</code>
 .
  
 <li>In order to disable significant digits formatting, use a pattern that does not
  contain the <code>'@@'</code> pattern character. Alternatively, call <code>setSignificantDigitsUsed(false)</code>
 .
  
 <li>The number of significant digits has no effect on parsing. 
 <li>Significant digits may be used together with exponential notation. Such patterns
  are equivalent to a normal exponential pattern with a minimum and maximum integer digit
  count of one, a minimum fraction digit count of <code>getMinimumSignificantDigits() -
  1</code>, and a maximum fraction digit count of <code>getMaximumSignificantDigits() -
  1</code>. For example, the pattern <code>"@@@@###E0"</code> is equivalent to 
 <code>"0.0###E0"</code>.
  
 <li>If signficant digits are in use, then the integer and fraction digit counts, as set
  via the API, are ignored.  If significant digits are not in use, then the signficant
  digit counts, as set via the API, are ignored. 
 </ul>
  
 <h4>Padding</h4>
  
 <p><code>DecimalFormat</code> supports padding the result of <code>format</code> to a
  specific width.  Padding may be specified either through the API or through the pattern
  syntax.  In a pattern the pad escape character, followed by a single pad character,
  causes padding to be parsed and formatted.  The pad escape character is '*' in
  unlocalized patterns, and can be localized using <code>DecimalFormatSymbols.setPadEscape</code>
 .  For example, <code>"$*x#,##0.00"</code> formats
  123 to <code>"$xx123.00"</code>, and 1234 to <code>"$1,234.00"</code>.
  
 <ul>
  
 <li>When padding is in effect, the width of the positive subpattern, including prefix
  and suffix, determines the format width.  For example, in the pattern <code>"* #0
  o''clock"</code>, the format width is 10. 
 <li>The width is counted in 16-bit code units (Java <code>char</code>s).
  
 <li>Some parameters which usually do not matter have meaning when padding is used,
  because the pattern width is significant with padding.  In the pattern "*
  ##,##,#,##0.##", the format width is 14.  The initial characters "##,##," do not affect
  the grouping size or maximum integer digits, but they do affect the format width. 
 <li>Padding may be inserted at one of four locations: before the prefix, after the
  prefix, before the suffix, or after the suffix.  If padding is specified in any other
  location, <code>applyPattern</code> throws an <code>IllegalArgumentException</code>.  If there
  is no prefix, before the prefix and after the prefix are equivalent, likewise for the
  suffix. 
 <li>When specified in a pattern, the 16-bit <code>char</code> immediately following the
  pad escape is the pad character. This may be any character, including a special pattern
  character. That is, the pad escape <em>escapes</em> the following character. If there
  is no character after the pad escape, then the pattern is illegal. 
 </ul>
  
 <p>
  <strong>Rounding</strong>
  
 <p><code>DecimalFormat</code> supports rounding to a specific increment.  For example,
  1230 rounded to the nearest 50 is 1250.  1.234 rounded to the nearest 0.65 is 1.3.  The
  rounding increment may be specified through the API or in a pattern.  To specify a
  rounding increment in a pattern, include the increment in the pattern itself.  "#,#50"
  specifies a rounding increment of 50.  "#,##0.05" specifies a rounding increment of
  0.05. 
 <ul>
  
 <li>Rounding only affects the string produced by formatting.  It does not affect
  parsing or change any numerical values. 
 <li>A <em>rounding mode</em> determines how values are rounded; see the <code>android.icu.math.BigDecimal</code>
  documentation for a description of the modes.  Rounding
  increments specified in patterns use the default mode, <code>android.icu.math.BigDecimal.ROUND_HALF_EVEN</code>
 .
  
 <li>Some locales use rounding in their currency formats to reflect the smallest
  currency denomination. 
 <li>In a pattern, digits '1' through '9' specify rounding, but otherwise behave
  identically to digit '0'. 
 </ul>
  
 <h4>Synchronization</h4>
  
 <p><code>DecimalFormat</code> objects are not synchronized.  Multiple threads should
  not access one formatter concurrently.
 - seealso: java.text.Format
 - seealso: NumberFormat
 @author Mark Davis
 @author Alan Liu
 */
@interface AndroidIcuTextDecimalFormat : AndroidIcuTextNumberFormat {
 @public
  jboolean parseRequireDecimalPoint_;
}
@property (readonly, class, strong) AndroidIcuTextUnicodeSet *minusSigns NS_SWIFT_NAME(minusSigns);
@property (readonly, class, strong) AndroidIcuTextUnicodeSet *plusSigns NS_SWIFT_NAME(plusSigns);
@property (readonly, class) jboolean skipExtendedSeparatorParsing NS_SWIFT_NAME(skipExtendedSeparatorParsing);
@property (readonly, class) jint currentSerialVersion NS_SWIFT_NAME(currentSerialVersion);
@property (readonly, class) jint PAD_BEFORE_PREFIX NS_SWIFT_NAME(PAD_BEFORE_PREFIX);
@property (readonly, class) jint PAD_AFTER_PREFIX NS_SWIFT_NAME(PAD_AFTER_PREFIX);
@property (readonly, class) jint PAD_BEFORE_SUFFIX NS_SWIFT_NAME(PAD_BEFORE_SUFFIX);
@property (readonly, class) jint PAD_AFTER_SUFFIX NS_SWIFT_NAME(PAD_AFTER_SUFFIX);
@property (readonly, class) jchar PATTERN_ZERO_DIGIT NS_SWIFT_NAME(PATTERN_ZERO_DIGIT);
@property (readonly, class) jchar PATTERN_ONE_DIGIT NS_SWIFT_NAME(PATTERN_ONE_DIGIT);
@property (readonly, class) jchar PATTERN_TWO_DIGIT NS_SWIFT_NAME(PATTERN_TWO_DIGIT);
@property (readonly, class) jchar PATTERN_THREE_DIGIT NS_SWIFT_NAME(PATTERN_THREE_DIGIT);
@property (readonly, class) jchar PATTERN_FOUR_DIGIT NS_SWIFT_NAME(PATTERN_FOUR_DIGIT);
@property (readonly, class) jchar PATTERN_FIVE_DIGIT NS_SWIFT_NAME(PATTERN_FIVE_DIGIT);
@property (readonly, class) jchar PATTERN_SIX_DIGIT NS_SWIFT_NAME(PATTERN_SIX_DIGIT);
@property (readonly, class) jchar PATTERN_SEVEN_DIGIT NS_SWIFT_NAME(PATTERN_SEVEN_DIGIT);
@property (readonly, class) jchar PATTERN_EIGHT_DIGIT NS_SWIFT_NAME(PATTERN_EIGHT_DIGIT);
@property (readonly, class) jchar PATTERN_NINE_DIGIT NS_SWIFT_NAME(PATTERN_NINE_DIGIT);
@property (readonly, class) jchar PATTERN_GROUPING_SEPARATOR NS_SWIFT_NAME(PATTERN_GROUPING_SEPARATOR);
@property (readonly, class) jchar PATTERN_DECIMAL_SEPARATOR NS_SWIFT_NAME(PATTERN_DECIMAL_SEPARATOR);
@property (readonly, class) jchar PATTERN_DIGIT NS_SWIFT_NAME(PATTERN_DIGIT);
@property (readonly, class) jchar PATTERN_SIGNIFICANT_DIGIT NS_SWIFT_NAME(PATTERN_SIGNIFICANT_DIGIT);
@property (readonly, class) jchar PATTERN_EXPONENT NS_SWIFT_NAME(PATTERN_EXPONENT);
@property (readonly, class) jchar PATTERN_PLUS_SIGN NS_SWIFT_NAME(PATTERN_PLUS_SIGN);
@property (readonly, class) jchar PATTERN_MINUS_SIGN NS_SWIFT_NAME(PATTERN_MINUS_SIGN);
@property (readonly, class) jchar PATTERN_PAD_ESCAPE NS_SWIFT_NAME(PATTERN_PAD_ESCAPE);
@property (readonly, class) jint DOUBLE_INTEGER_DIGITS NS_SWIFT_NAME(DOUBLE_INTEGER_DIGITS);
@property (readonly, class) jint MAX_INTEGER_DIGITS NS_SWIFT_NAME(MAX_INTEGER_DIGITS);
@property (readonly, class) jint DOUBLE_FRACTION_DIGITS NS_SWIFT_NAME(DOUBLE_FRACTION_DIGITS);
@property (readonly, class) jint MAX_SCIENTIFIC_INTEGER_DIGITS NS_SWIFT_NAME(MAX_SCIENTIFIC_INTEGER_DIGITS);
@property (readonly, class, strong) AndroidIcuTextDecimalFormat_Unit *NULL_UNIT NS_SWIFT_NAME(NULL_UNIT);
@property (readonly, class) jdouble roundingIncrementEpsilon NS_SWIFT_NAME(roundingIncrementEpsilon);

+ (AndroidIcuTextUnicodeSet *)minusSigns;

+ (AndroidIcuTextUnicodeSet *)plusSigns;

+ (jboolean)skipExtendedSeparatorParsing;

+ (jint)currentSerialVersion;

+ (jint)PAD_BEFORE_PREFIX;

+ (jint)PAD_AFTER_PREFIX;

+ (jint)PAD_BEFORE_SUFFIX;

+ (jint)PAD_AFTER_SUFFIX;

+ (jchar)PATTERN_ZERO_DIGIT;

+ (jchar)PATTERN_ONE_DIGIT;

+ (jchar)PATTERN_TWO_DIGIT;

+ (jchar)PATTERN_THREE_DIGIT;

+ (jchar)PATTERN_FOUR_DIGIT;

+ (jchar)PATTERN_FIVE_DIGIT;

+ (jchar)PATTERN_SIX_DIGIT;

+ (jchar)PATTERN_SEVEN_DIGIT;

+ (jchar)PATTERN_EIGHT_DIGIT;

+ (jchar)PATTERN_NINE_DIGIT;

+ (jchar)PATTERN_GROUPING_SEPARATOR;

+ (jchar)PATTERN_DECIMAL_SEPARATOR;

+ (jchar)PATTERN_DIGIT;

+ (jchar)PATTERN_SIGNIFICANT_DIGIT;

+ (jchar)PATTERN_EXPONENT;

+ (jchar)PATTERN_PLUS_SIGN;

+ (jchar)PATTERN_MINUS_SIGN;

+ (jchar)PATTERN_PAD_ESCAPE;

+ (jint)DOUBLE_INTEGER_DIGITS;

+ (jint)MAX_INTEGER_DIGITS;

+ (jint)DOUBLE_FRACTION_DIGITS;

+ (jint)MAX_SCIENTIFIC_INTEGER_DIGITS;

+ (AndroidIcuTextDecimalFormat_Unit *)NULL_UNIT;

+ (jdouble)roundingIncrementEpsilon;

#pragma mark Public

/*!
 @brief Creates a DecimalFormat using the default pattern and symbols for the default 
 <code>FORMAT</code> locale.This is a convenient way to obtain a DecimalFormat when
  internationalization is not the main concern.
 <p>To obtain standard formats for a given locale, use the factory methods on
  NumberFormat such as getNumberInstance.  These factories will return the most
  appropriate sub-class of NumberFormat for a given locale.
 - seealso: NumberFormat#getInstance
 - seealso: NumberFormat#getNumberInstance
 - seealso: NumberFormat#getCurrencyInstance
 - seealso: NumberFormat#getPercentInstance
 - seealso: Category#FORMAT
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a DecimalFormat from the given pattern and the symbols for the default 
 <code>FORMAT</code> locale.This is a convenient way to obtain a DecimalFormat when
  internationalization is not the main concern.
 <p>To obtain standard formats for a given locale, use the factory methods on
  NumberFormat such as getNumberInstance.  These factories will return the most
  appropriate sub-class of NumberFormat for a given locale.
 @param pattern A non-localized pattern string.
 @throw IllegalArgumentExceptionif the given pattern is invalid.
 - seealso: NumberFormat#getInstance
 - seealso: NumberFormat#getNumberInstance
 - seealso: NumberFormat#getCurrencyInstance
 - seealso: NumberFormat#getPercentInstance
 - seealso: Category#FORMAT
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern;

/*!
 @brief Creates a DecimalFormat from the given pattern and symbols.Use this constructor
  when you need to completely customize the behavior of the format.
 <p>To obtain standard formats for a given locale, use the factory methods on
  NumberFormat such as getInstance or getCurrencyInstance. If you need only minor
  adjustments to a standard format, you can modify the format returned by a
  NumberFormat factory method.
 @param pattern a non-localized pattern string
 @param symbols the set of symbols to be used
 @throw IllegalArgumentExceptionif the given pattern is invalid
 - seealso: NumberFormat#getInstance
 - seealso: NumberFormat#getNumberInstance
 - seealso: NumberFormat#getCurrencyInstance
 - seealso: NumberFormat#getPercentInstance
 - seealso: DecimalFormatSymbols
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
    withAndroidIcuTextDecimalFormatSymbols:(AndroidIcuTextDecimalFormatSymbols *)symbols;

/*!
 @brief Creates a DecimalFormat from the given pattern, symbols, information used for
  currency plural format, and format style.Use this constructor when you need to
  completely customize the behavior of the format.
 <p>To obtain standard formats for a given locale, use the factory methods on
  NumberFormat such as getInstance or getCurrencyInstance. 
 <p>If you need only minor adjustments to a standard format, you can modify the
  format returned by a NumberFormat factory method using the setters. 
 <p>If you want to completely customize a decimal format, using your own
  DecimalFormatSymbols (such as group separators) and your own information for
  currency plural formatting (such as plural rule and currency plural patterns), you
  can use this constructor.
 @param pattern a non-localized pattern string
 @param symbols the set of symbols to be used
 @param infoInput the information used for currency plural format, including  currency plural patterns and plural rules.
 @param style the decimal formatting style, it is one of the following values:  NumberFormat.NUMBERSTYLE; NumberFormat.CURRENCYSTYLE; NumberFormat.PERCENTSTYLE;
   NumberFormat.SCIENTIFICSTYLE; NumberFormat.INTEGERSTYLE;
   NumberFormat.ISOCURRENCYSTYLE; NumberFormat.PLURALCURRENCYSTYLE;
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
    withAndroidIcuTextDecimalFormatSymbols:(AndroidIcuTextDecimalFormatSymbols *)symbols
      withAndroidIcuTextCurrencyPluralInfo:(AndroidIcuTextCurrencyPluralInfo *)infoInput
                                   withInt:(jint)style;

/*!
 @brief Applies the given pattern to this Format object.The pattern is assumed to be in a
  localized notation.
 A pattern is a short-hand specification for the various
  formatting properties. These properties can also be changed individually through
  the various setter methods. 
 <p>There is no limit to integer digits are set by this routine, since that is the
  typical end-user desire; use setMaximumInteger if you want to set a real value. For
  negative numbers, use a second pattern, separated by a semicolon 
 <p>Example "#,#00.0#" -&gt; 1,234.56 
 <p>This means a minimum of 2 integer digits, 1 fraction digit, and a maximum of 2
  fraction digits. 
 <p>Example: "#,#00.0#;(#,#00.0#)" for negatives in parantheses. 
 <p>In negative patterns, the minimum and maximum counts are ignored; these are
  presumed to be set in the positive pattern.
 */
- (void)applyLocalizedPatternWithNSString:(NSString *)pattern;

/*!
 @brief Applies the given pattern to this Format object.A pattern is a short-hand
  specification for the various formatting properties.
 These properties can also be
  changed individually through the various setter methods. 
 <p>There is no limit to integer digits are set by this routine, since that is the
  typical end-user desire; use setMaximumInteger if you want to set a real value. For
  negative numbers, use a second pattern, separated by a semicolon 
 <p>Example "#,#00.0#" -&gt; 1,234.56 
 <p>This means a minimum of 2 integer digits, 1 fraction digit, and a maximum of 2
  fraction digits. 
 <p>Example: "#,#00.0#;(#,#00.0#)" for negatives in parentheses. 
 <p>In negative patterns, the minimum and maximum counts are ignored; these are
  presumed to be set in the positive pattern.
 */
- (void)applyPatternWithNSString:(NSString *)pattern;

/*!
 @brief <strong>[icu]</strong> Returns true if significant digits are in use or false if integer and
  fraction digit counts are in use.
 @return true if significant digits are in use
 */
- (jboolean)areSignificantDigitsUsed;

/*!
 @brief Overrides clone.
 */
- (id)java_clone;

/*!
 @brief Overrides equals.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Formats a BigDecimal number.
 */
- (JavaLangStringBuffer *)formatWithJavaMathBigDecimal:(JavaMathBigDecimal *)number
                              withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                             withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 @brief Formats a BigDecimal number.
 */
- (JavaLangStringBuffer *)formatWithAndroidIcuMathBigDecimal:(AndroidIcuMathBigDecimal *)number
                                    withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                                   withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 @brief Formats a BigInteger number.
 */
- (JavaLangStringBuffer *)formatWithJavaMathBigInteger:(JavaMathBigInteger *)number
                              withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                             withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 */
- (JavaLangStringBuffer *)formatWithDouble:(jdouble)number
                  withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                 withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 */
- (JavaLangStringBuffer *)formatWithLong:(jlong)number
                withJavaLangStringBuffer:(JavaLangStringBuffer *)result
               withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 @brief Formats the object to an attributed string, and return the corresponding iterator.
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)obj;

/*!
 @brief <strong>[icu]</strong> Returns a copy of the CurrencyPluralInfo used by this format.It might
  return null if the decimal format is not a plural type currency decimal
  format.
 Plural type currency decimal format means either the pattern in the decimal
  format contains 3 currency signs, or the decimal format is initialized with
  PLURALCURRENCYSTYLE.
 @return desired CurrencyPluralInfo
 - seealso: CurrencyPluralInfo
 */
- (AndroidIcuTextCurrencyPluralInfo *)getCurrencyPluralInfo;

/*!
 @brief Returns the <tt>Currency Usage</tt> object used to display currency
 */
- (AndroidIcuUtilCurrency_CurrencyUsage *)getCurrencyUsage;

/*!
 @brief Returns a copy of the decimal format symbols used by this format.
 @return desired DecimalFormatSymbols
 - seealso: DecimalFormatSymbols
 */
- (AndroidIcuTextDecimalFormatSymbols *)getDecimalFormatSymbols;

/*!
 @brief Returns the width to which the output of <code>format()</code> is padded.The width is
  counted in 16-bit code units.
 @return the format width, or zero if no padding is in effect
 - seealso: #setFormatWidth
 - seealso: #getPadCharacter
 - seealso: #setPadCharacter
 - seealso: #getPadPosition
 - seealso: #setPadPosition
 */
- (jint)getFormatWidth;

/*!
 @brief Returns the grouping size.Grouping size is the number of digits between grouping
  separators in the integer portion of a number.
 For example, in the number
  "123,456.78", the grouping size is 3.
 - seealso: #setGroupingSize
 - seealso: NumberFormat#isGroupingUsed
 - seealso: DecimalFormatSymbols#getGroupingSeparator
 */
- (jint)getGroupingSize;

/*!
 @brief <strong>[icu]</strong> Returns the MathContext used by this format.
 @return desired MathContext
 - seealso: #getMathContext
 */
- (JavaMathMathContext *)getMathContext;

/*!
 @brief <strong>[icu]</strong> Returns the MathContext used by this format.
 @return desired MathContext
 - seealso: #getMathContext
 */
- (AndroidIcuMathMathContext *)getMathContextICU;

/*!
 @brief <strong>[icu]</strong> Returns the maximum number of significant digits that will be
  displayed.This value has no effect unless <code>areSignificantDigitsUsed()</code>
  returns true.
 @return the most significant digits that will be shown
 */
- (jint)getMaximumSignificantDigits;

/*!
 @brief <strong>[icu]</strong> Returns the minimum exponent digits that will be shown.
 @return the minimum exponent digits that will be shown
 - seealso: #setScientificNotation
 - seealso: #isScientificNotation
 - seealso: #setMinimumExponentDigits
 - seealso: #isExponentSignAlwaysShown
 - seealso: #setExponentSignAlwaysShown
 */
- (jbyte)getMinimumExponentDigits;

/*!
 @brief <strong>[icu]</strong> Returns the minimum number of significant digits that will be
  displayed.This value has no effect unless <code>areSignificantDigitsUsed()</code>
  returns true.
 @return the fewest significant digits that will be shown
 */
- (jint)getMinimumSignificantDigits;

/*!
 @brief Returns the multiplier for use in percent, permill, etc.For a percentage, set the
  suffixes to have "%" and the multiplier to be 100.
 (For Arabic, use arabic percent symbol). For a permill, set the suffixes to have "‱" and the multiplier to be 1000. 
 <p>Examples: with 100, 1.23 -&gt; "123", and "123" -&gt; 1.23
 @return the multiplier
 */
- (jint)getMultiplier;

/*!
 @brief Returns the negative prefix.
 <p>Examples: -123, ($123) (with negative suffix), sFr-123
 @return the prefix
 */
- (NSString *)getNegativePrefix;

/*!
 @brief Returns the negative suffix.
 <p>Examples: -123%, ($123) (with positive suffixes)
 @return the suffix
 */
- (NSString *)getNegativeSuffix;

/*!
 @brief <strong>[icu]</strong> Returns the character used to pad to the format width.The default is ' '.
 @return the pad character
 - seealso: #setFormatWidth
 - seealso: #getFormatWidth
 - seealso: #setPadCharacter
 - seealso: #getPadPosition
 - seealso: #setPadPosition
 */
- (jchar)getPadCharacter;

/*!
 @brief <strong>[icu]</strong> Returns the position at which padding will take place.This is the location at
  which padding will be inserted if the result of <code>format()</code> is shorter
  than the format width.
 @return the pad position, one of <code>PAD_BEFORE_PREFIX</code>,
          <code>PAD_AFTER_PREFIX</code>, <code>PAD_BEFORE_SUFFIX</code>, or
          <code>PAD_AFTER_SUFFIX</code>.
 - seealso: #setFormatWidth
 - seealso: #getFormatWidth
 - seealso: #setPadCharacter
 - seealso: #getPadCharacter
 - seealso: #setPadPosition
 - seealso: #PAD_BEFORE_PREFIX
 - seealso: #PAD_AFTER_PREFIX
 - seealso: #PAD_BEFORE_SUFFIX
 - seealso: #PAD_AFTER_SUFFIX
 */
- (jint)getPadPosition;

/*!
 @brief Get the current maximum number of exponent digits when parsing a
  number.
 @return the maximum number of exponent digits for parsing
 */
- (jint)getParseMaxDigits;

/*!
 @brief Returns the positive prefix.
 <p>Examples: +123, $123, sFr123
 @return the prefix
 */
- (NSString *)getPositivePrefix;

/*!
 @brief Returns the positive suffix.
 <p>Example: 123%
 @return the suffix
 */
- (NSString *)getPositiveSuffix;

/*!
 @brief <strong>[icu]</strong> Returns the rounding increment.
 @return A positive rounding increment, or <code>null</code> if a custom rounding
  increment is not in effect.
 - seealso: #setRoundingIncrement
 - seealso: #getRoundingMode
 - seealso: #setRoundingMode
 */
- (JavaMathBigDecimal *)getRoundingIncrement;

/*!
 @brief Returns the rounding mode.
 @return A rounding mode, between <code>BigDecimal.ROUND_UP</code> and 
 <code>BigDecimal.ROUND_UNNECESSARY</code>.
 - seealso: #setRoundingIncrement
 - seealso: #getRoundingIncrement
 - seealso: #setRoundingMode
 - seealso: java.math.BigDecimal
 */
- (jint)getRoundingMode;

/*!
 @brief <strong>[icu]</strong> Returns the secondary grouping size.In some locales one grouping interval
  is used for the least significant integer digits (the primary grouping size), and
  another is used for all others (the secondary grouping size).
 A formatter
  supporting a secondary grouping size will return a positive integer unequal to the
  primary grouping size returned by <code>getGroupingSize()</code>. For example, if
  the primary grouping size is 4, and the secondary grouping size is 2, then the
  number 123456789 formats as "1,23,45,6789", and the pattern appears as "#,##,###0".
 @return the secondary grouping size, or a value less than one if there is none
 - seealso: #setSecondaryGroupingSize
 - seealso: NumberFormat#isGroupingUsed
 - seealso: DecimalFormatSymbols#getGroupingSeparator
 */
- (jint)getSecondaryGroupingSize;

/*!
 @brief Overrides hashCode.
 */
- (NSUInteger)hash;

/*!
 @brief <strong>[icu]</strong> Returns whether the input to parsing must contain a decimal mark if there
  is a decimal mark in the pattern.
 @return true if input must contain a match to decimal mark in pattern
 */
- (jboolean)isDecimalPatternMatchRequired;

/*!
 @brief Returns the behavior of the decimal separator with integers.
 (The decimal
  separator will always appear with decimals.)  <p> Example: Decimal ON: 12345 -&gt;
  12345.; OFF: 12345 -&gt; 12345
 */
- (jboolean)isDecimalSeparatorAlwaysShown;

/*!
 @brief <strong>[icu]</strong> Returns whether the exponent sign is always shown.
 @return true if the exponent is always prefixed with either the localized minus
  sign or the localized plus sign, false if only negative exponents are prefixed with
  the localized minus sign.
 - seealso: #setScientificNotation
 - seealso: #isScientificNotation
 - seealso: #setMinimumExponentDigits
 - seealso: #getMinimumExponentDigits
 - seealso: #setExponentSignAlwaysShown
 */
- (jboolean)isExponentSignAlwaysShown;

/*!
 @brief Returns whether <code>parse(String, ParsePosition)</code> returns BigDecimal.
 @return true if <code>parse(String, ParsePosition)</code> returns BigDecimal.
 */
- (jboolean)isParseBigDecimal;

/*!
 @brief <strong>[icu]</strong> Returns whether or not scientific notation is used.
 @return true if this object formats and parses scientific notation
 - seealso: #setScientificNotation
 - seealso: #getMinimumExponentDigits
 - seealso: #setMinimumExponentDigits
 - seealso: #isExponentSignAlwaysShown
 - seealso: #setExponentSignAlwaysShown
 */
- (jboolean)isScientificNotation;

/*!
 @brief Parses the given string, returning a <code>Number</code> object to represent the
  parsed value.
 <code>Double</code> objects are returned to represent non-integral
  values which cannot be stored in a <code>BigDecimal</code>. These are 
 <code>NaN</code>, infinity, -infinity, and -0.0. If <code>isParseBigDecimal()</code> is
  false (the default), all other values are returned as <code>Long</code>,
  <code>BigInteger</code>, or <code>BigDecimal</code> values, in that order of
  preference. If <code>isParseBigDecimal()</code> is true, all other values are returned
  as <code>BigDecimal</code> valuse. If the parse fails, null is returned.
 @param text the string to be parsed
 @param parsePosition defines the position where parsing is to begin, and upon  return, the position where parsing left off. If the position has not changed upon
   return, then parsing failed.
 @return a <code>Number</code> object with the parsed value or 
 <code>null</code> if the parse failed
 */
- (NSNumber *)parseWithNSString:(NSString *)text
      withJavaTextParsePosition:(JavaTextParsePosition *)parsePosition;

/*!
 @brief Parses text from the given string as a CurrencyAmount.Unlike the parse() method,
  this method will attempt to parse a generic currency name, searching for a match of
  this object's locale's currency display names, or for a 3-letter ISO currency
  code.
 This method will fail if this format is not a currency format, that is, if it
  does not contain the currency pattern symbol (U+00A4) in its prefix or suffix.
 @param text the text to parse
 @param pos input-output position; on input, the position within text to match; must   have 0 
  &lt; = pos.getIndex()  &lt;  text.length(); on output, the position after the last   matched character. If the parse fails, the position in unchanged upon output.
 @return a CurrencyAmount, or null upon failure
 */
- (AndroidIcuUtilCurrencyAmount *)parseCurrencyWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                              withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Sets the <tt>Currency</tt> object used to display currency amounts.This takes
  effect immediately, if this format is a currency format.
 If this format is not a
  currency format, then the currency object is used if and when this object becomes a
  currency format through the application of a new pattern.
 @param theCurrency new currency object to use. Must not be null.
 */
- (void)setCurrencyWithAndroidIcuUtilCurrency:(AndroidIcuUtilCurrency *)theCurrency;

/*!
 @brief <strong>[icu]</strong> Sets the CurrencyPluralInfo used by this format.The format uses a copy of
  the provided information.
 @param newInfo desired CurrencyPluralInfo
 - seealso: CurrencyPluralInfo
 */
- (void)setCurrencyPluralInfoWithAndroidIcuTextCurrencyPluralInfo:(AndroidIcuTextCurrencyPluralInfo *)newInfo;

/*!
 @brief Sets the <tt>Currency Usage</tt> object used to display currency.
 This takes effect immediately, if this format is a
  currency format.
 @param newUsage new currency context object to use.
 */
- (void)setCurrencyUsageWithAndroidIcuUtilCurrency_CurrencyUsage:(AndroidIcuUtilCurrency_CurrencyUsage *)newUsage;

/*!
 @brief Sets the decimal format symbols used by this format.The format uses a copy of the
  provided symbols.
 @param newSymbols desired DecimalFormatSymbols
 - seealso: DecimalFormatSymbols
 */
- (void)setDecimalFormatSymbolsWithAndroidIcuTextDecimalFormatSymbols:(AndroidIcuTextDecimalFormatSymbols *)newSymbols;

/*!
 @brief When decimal match is not required, the input does not have to
  contain a decimal mark when there is a decimal mark specified in the
  pattern.
 @param value true if input must contain a match to decimal mark in pattern  Default is false.
 */
- (void)setDecimalPatternMatchRequiredWithBoolean:(jboolean)value;

/*!
 @brief Sets the behavior of the decimal separator with integers.
 (The decimal separator
  will always appear with decimals.) 
 <p>This only affects formatting, and only where there might be no digits after the
  decimal point, e.g., if true, 3456.00 -&gt; "3,456." if false, 3456.00 -&gt; "3456" This
  is independent of parsing. If you want parsing to stop at the decimal point, use
  setParseIntegerOnly. 
 <p>
  Example: Decimal ON: 12345 -&gt; 12345.; OFF: 12345 -&gt; 12345
 */
- (void)setDecimalSeparatorAlwaysShownWithBoolean:(jboolean)newValue;

/*!
 @brief <strong>[icu]</strong> Sets whether the exponent sign is always shown.This has no effect unless
  scientific notation is in use.
 @param expSignAlways true if the exponent is always prefixed with either the  localized minus sign or the localized plus sign, false if only negative exponents
   are prefixed with the localized minus sign.
 - seealso: #setScientificNotation
 - seealso: #isScientificNotation
 - seealso: #setMinimumExponentDigits
 - seealso: #getMinimumExponentDigits
 - seealso: #isExponentSignAlwaysShown
 */
- (void)setExponentSignAlwaysShownWithBoolean:(jboolean)expSignAlways;

/*!
 @brief Sets the width to which the output of <code>format()</code> is
  padded.The width is counted in 16-bit code units.
 This method
  also controls whether padding is enabled.
 @param width the width to which to pad the result of  
  <code> format() </code> , or zero to disable padding
 @throw IllegalArgumentExceptionif <code>width</code> is &lt; 0
 - seealso: #getFormatWidth
 - seealso: #getPadCharacter
 - seealso: #setPadCharacter
 - seealso: #getPadPosition
 - seealso: #setPadPosition
 */
- (void)setFormatWidthWithInt:(jint)width;

/*!
 @brief Sets the grouping size.Grouping size is the number of digits between grouping
  separators in the integer portion of a number.
 For example, in the number
  "123,456.78", the grouping size is 3.
 - seealso: #getGroupingSize
 - seealso: NumberFormat#setGroupingUsed
 - seealso: DecimalFormatSymbols#setGroupingSeparator
 */
- (void)setGroupingSizeWithInt:(jint)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the MathContext used by this format.
 @param newValue desired MathContext
 - seealso: #getMathContext
 */
- (void)setMathContextWithJavaMathMathContext:(JavaMathMathContext *)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the MathContext used by this format.
 @param newValue desired MathContext
 - seealso: #getMathContext
 */
- (void)setMathContextICUWithAndroidIcuMathMathContext:(AndroidIcuMathMathContext *)newValue;

/*!
 @brief Sets the maximum number of digits allowed in the fraction portion of a number.This
  override limits the fraction digit count to 340.
 - seealso: NumberFormat#setMaximumFractionDigits
 */
- (void)setMaximumFractionDigitsWithInt:(jint)newValue;

/*!
 @brief Sets the maximum number of digits allowed in the integer portion of a number.This
  override limits the integer digit count to 2,000,000,000 to match ICU4C.
 - seealso: NumberFormat#setMaximumIntegerDigits
 */
- (void)setMaximumIntegerDigitsWithInt:(jint)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the maximum number of significant digits that will be displayed.If
  <code>max</code> is less than one then it is set to one.
 If the minimum significant
  digits count is greater than <code>max</code>, then it is set to <code>max</code>.
  This function also enables the use of significant digits by this formatter - 
 <code>areSignificantDigitsUsed()</code> will return true.
 @param max the most significant digits to be shown
 */
- (void)setMaximumSignificantDigitsWithInt:(jint)max;

/*!
 @brief <strong>[icu]</strong> Sets the minimum exponent digits that will be shown.This has no effect
  unless scientific notation is in use.
 @param minExpDig a value  &gt; = 1 indicating the fewest exponent  digits that will be shown
 @throw IllegalArgumentExceptionif <code>minExpDig</code> &lt; 1
 - seealso: #setScientificNotation
 - seealso: #isScientificNotation
 - seealso: #getMinimumExponentDigits
 - seealso: #isExponentSignAlwaysShown
 - seealso: #setExponentSignAlwaysShown
 */
- (void)setMinimumExponentDigitsWithByte:(jbyte)minExpDig;

/*!
 @brief Sets the minimum number of digits allowed in the fraction portion of a number.This
  override limits the fraction digit count to 340.
 - seealso: NumberFormat#setMinimumFractionDigits
 */
- (void)setMinimumFractionDigitsWithInt:(jint)newValue;

/*!
 @brief Sets the minimum number of digits allowed in the integer portion of a number.This
  override limits the integer digit count to 309.
 - seealso: NumberFormat#setMinimumIntegerDigits
 */
- (void)setMinimumIntegerDigitsWithInt:(jint)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the minimum number of significant digits that will be displayed.If
  <code>min</code> is less than one then it is set to one.
 If the maximum significant
  digits count is less than <code>min</code>, then it is set to <code>min</code>.
  This function also enables the use of significant digits by this formatter - 
 <code>areSignificantDigitsUsed()</code> will return true.
 @param min the fewest significant digits to be shown
 */
- (void)setMinimumSignificantDigitsWithInt:(jint)min;

/*!
 @brief Sets the multiplier for use in percent, permill, etc.For a percentage, set the
  suffixes to have "%" and the multiplier to be 100.
 (For Arabic, use arabic percent symbol). For a permill, set the suffixes to have "‱" and the multiplier to be 1000. 
 <p>Examples: with 100, 1.23 -&gt; "123", and "123" -&gt; 1.23
 @param newValue the multiplier
 */
- (void)setMultiplierWithInt:(jint)newValue;

/*!
 @brief Sets the negative prefix.
 <p>Examples: -123, ($123) (with negative suffix), sFr-123
 @param newValue the prefix
 */
- (void)setNegativePrefixWithNSString:(NSString *)newValue;

/*!
 @brief Sets the positive suffix.
 <p>Examples: 123%
 @param newValue the suffix
 */
- (void)setNegativeSuffixWithNSString:(NSString *)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the character used to pad to the format width.If padding is not
  enabled, then this will take effect if padding is later enabled.
 @param padChar the pad character
 - seealso: #setFormatWidth
 - seealso: #getFormatWidth
 - seealso: #getPadCharacter
 - seealso: #getPadPosition
 - seealso: #setPadPosition
 */
- (void)setPadCharacterWithChar:(jchar)padChar;

/*!
 @brief <strong>[icu]</strong> Sets the position at which padding will take place.This is the location at
  which padding will be inserted if the result of <code>format()</code> is shorter
  than the format width.
 This has no effect unless padding is enabled.
 @param padPos the pad position, one of  <code> PAD_BEFORE_PREFIX </code>
  ,   <code> PAD_AFTER_PREFIX </code> ,  <code> PAD_BEFORE_SUFFIX </code>
  , or   <code> PAD_AFTER_SUFFIX </code>
  .
 @throw IllegalArgumentExceptionif the pad position in unrecognized
 - seealso: #setFormatWidth
 - seealso: #getFormatWidth
 - seealso: #setPadCharacter
 - seealso: #getPadCharacter
 - seealso: #getPadPosition
 - seealso: #PAD_BEFORE_PREFIX
 - seealso: #PAD_AFTER_PREFIX
 - seealso: #PAD_BEFORE_SUFFIX
 - seealso: #PAD_AFTER_SUFFIX
 */
- (void)setPadPositionWithInt:(jint)padPos;

/*!
 @brief Sets whether <code>parse(String, ParsePosition)</code> returns BigDecimal.The
  default value is false.
 @param value true if <code>parse(String, ParsePosition)</code>  returns BigDecimal.
 */
- (void)setParseBigDecimalWithBoolean:(jboolean)value;

/*!
 @brief Set the maximum number of exponent digits when parsing a number.
 If the limit is set too high, an OutOfMemoryException may be triggered.
  The default value is 1000.
 @param newValue the new limit
 */
- (void)setParseMaxDigitsWithInt:(jint)newValue;

/*!
 @brief Sets the positive prefix.
 <p>Examples: +123, $123, sFr123
 @param newValue the prefix
 */
- (void)setPositivePrefixWithNSString:(NSString *)newValue;

/*!
 @brief Sets the positive suffix.
 <p>Example: 123%
 @param newValue the suffix
 */
- (void)setPositiveSuffixWithNSString:(NSString *)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the rounding increment.In the absence of a rounding increment, numbers
  will be rounded to the number of digits displayed.
 @param newValue A positive rounding increment, or  <code> null </code>  or
    <code> BigDecimal(0.0) </code>  to use the default rounding increment.
 @throw IllegalArgumentExceptionif <code>newValue</code> is &lt; 0.0
 - seealso: #getRoundingIncrement
 - seealso: #getRoundingMode
 - seealso: #setRoundingMode
 */
- (void)setRoundingIncrementWithJavaMathBigDecimal:(JavaMathBigDecimal *)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the rounding increment.In the absence of a rounding increment, numbers
  will be rounded to the number of digits displayed.
 @param newValue A positive rounding increment, or  <code> null </code>  or
    <code> BigDecimal(0.0) </code>  to use the default rounding increment.
 @throw IllegalArgumentExceptionif <code>newValue</code> is &lt; 0.0
 - seealso: #getRoundingIncrement
 - seealso: #getRoundingMode
 - seealso: #setRoundingMode
 */
- (void)setRoundingIncrementWithAndroidIcuMathBigDecimal:(AndroidIcuMathBigDecimal *)newValue;

/*!
 @brief <strong>[icu]</strong> Sets the rounding increment.In the absence of a rounding increment, numbers
  will be rounded to the number of digits displayed.
 @param newValue A positive rounding increment, or 0.0 to use the default  rounding increment.
 @throw IllegalArgumentExceptionif <code>newValue</code> is &lt; 0.0
 - seealso: #getRoundingIncrement
 - seealso: #getRoundingMode
 - seealso: #setRoundingMode
 */
- (void)setRoundingIncrementWithDouble:(jdouble)newValue;

/*!
 @brief Sets the rounding mode.This has no effect unless the rounding increment is greater
  than zero.
 @param roundingMode A rounding mode, between  <code> BigDecimal.ROUND_UP </code>  and
    <code> BigDecimal.ROUND_UNNECESSARY </code> .
 @throw IllegalArgumentExceptionif <code>roundingMode</code> is unrecognized.
 - seealso: #setRoundingIncrement
 - seealso: #getRoundingIncrement
 - seealso: #getRoundingMode
 - seealso: java.math.BigDecimal
 */
- (void)setRoundingModeWithInt:(jint)roundingMode;

/*!
 @brief <strong>[icu]</strong> Sets whether or not scientific notation is used.When scientific notation is
  used, the effective maximum number of integer digits is &lt;= 8.
 If the maximum number
  of integer digits is set to more than 8, the effective maximum will be 1. This
  allows this call to generate a 'default' scientific number format without
  additional changes.
 @param useScientific true if this object formats and parses scientific notation
 - seealso: #isScientificNotation
 - seealso: #getMinimumExponentDigits
 - seealso: #setMinimumExponentDigits
 - seealso: #isExponentSignAlwaysShown
 - seealso: #setExponentSignAlwaysShown
 */
- (void)setScientificNotationWithBoolean:(jboolean)useScientific;

/*!
 @brief <strong>[icu]</strong> Sets the secondary grouping size.If set to a value less than 1, then
  secondary grouping is turned off, and the primary grouping size is used for all
  intervals, not just the least significant.
 - seealso: #getSecondaryGroupingSize
 - seealso: NumberFormat#setGroupingUsed
 - seealso: DecimalFormatSymbols#setGroupingSeparator
 */
- (void)setSecondaryGroupingSizeWithInt:(jint)newValue;

/*!
 @brief <strong>[icu]</strong> Sets whether significant digits are in use, or integer and fraction digit
  counts are in use.
 @param useSignificantDigits true to use significant digits, or false to use integer  and fraction digit counts
 */
- (void)setSignificantDigitsUsedWithBoolean:(jboolean)useSignificantDigits;

/*!
 @brief Synthesizes a localized pattern string that represents the current state of this
  Format object.
 - seealso: #applyPattern
 */
- (NSString *)toLocalizedPattern;

/*!
 @brief Synthesizes a pattern string that represents the current state of this Format
  object.
 - seealso: #applyPattern
 */
- (NSString *)toPattern;

#pragma mark Protected

/*!
 @brief Returns the currency in effect for this formatter.Subclasses should override this
  method as needed.
 Unlike getCurrency(), this method should never return null.
 */
- (AndroidIcuUtilCurrency *)getEffectiveCurrency __attribute__((deprecated));

#pragma mark Package-Private

/*!
 @brief Creates a DecimalFormat for currency plural format from the given pattern, symbols,
  and style.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
    withAndroidIcuTextDecimalFormatSymbols:(AndroidIcuTextDecimalFormatSymbols *)inputSymbols
                                   withInt:(jint)style;

/*!
 @brief This is a special function used by the CompactDecimalFormat subclass.
 It completes only the rounding portion of the formatting and returns
  the resulting double. CompactDecimalFormat uses the result to compute
  the plural form to use.
 @param number The number to format.
 @return The number rounded to the correct number of significant digits
  with negative sign stripped off.
 */
- (jdouble)adjustNumberAsInFormattingWithDouble:(jdouble)number __attribute__((deprecated));

- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)obj
                                      withAndroidIcuTextDecimalFormat_Unit:(AndroidIcuTextDecimalFormat_Unit *)unit;

/*!
 @brief This is ugly, but don't see a better way to do it without major restructuring of the code.
 */
- (AndroidIcuTextPluralRules_FixedDecimal *)getFixedDecimalWithDouble:(jdouble)number;

- (AndroidIcuTextPluralRules_FixedDecimal *)getFixedDecimalWithDouble:(jdouble)number
                                          withAndroidIcuTextDigitList:(AndroidIcuTextDigitList *)dl;

/*!
 @brief This is a special function used by the CompactDecimalFormat subclass
  to determine if the number to be formatted is negative.
 @param number The number to format.
 @return True if number is negative.
 */
- (jboolean)isNumberNegativeWithDouble:(jdouble)number __attribute__((deprecated));

/*!
 @brief Matches a single character at text[pos] and return the index of the next character
  upon success.Return -1 on failure.
 If ch is a Pattern_White_Space then match a run of
  white space in text.
 */
+ (jint)matchWithNSString:(NSString *)text
                  withInt:(jint)pos
                  withInt:(jint)ch;

/*!
 @brief Matches a string at text[pos] and return the index of the next character upon
  success.Return -1 on failure.
 Match a run of white space in str with a run of
  white space in text.
 */
+ (jint)matchWithNSString:(NSString *)text
                  withInt:(jint)pos
             withNSString:(NSString *)str;

- (AndroidIcuTextDigitList *)toDigitListWithDouble:(jdouble)number __attribute__((deprecated));

@end

J2OBJC_STATIC_INIT(AndroidIcuTextDecimalFormat)

inline AndroidIcuTextUnicodeSet *AndroidIcuTextDecimalFormat_get_minusSigns(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *AndroidIcuTextDecimalFormat_minusSigns;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextDecimalFormat, minusSigns, AndroidIcuTextUnicodeSet *)

inline AndroidIcuTextUnicodeSet *AndroidIcuTextDecimalFormat_get_plusSigns(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextUnicodeSet *AndroidIcuTextDecimalFormat_plusSigns;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextDecimalFormat, plusSigns, AndroidIcuTextUnicodeSet *)

inline jboolean AndroidIcuTextDecimalFormat_get_skipExtendedSeparatorParsing(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jboolean AndroidIcuTextDecimalFormat_skipExtendedSeparatorParsing;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(AndroidIcuTextDecimalFormat, skipExtendedSeparatorParsing, jboolean)

inline jint AndroidIcuTextDecimalFormat_get_currentSerialVersion(void);
#define AndroidIcuTextDecimalFormat_currentSerialVersion 4
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, currentSerialVersion, jint)

/*!
 @brief <strong>[icu]</strong> Constant for <code>getPadPosition()</code> and <code>setPadPosition(int)</code> to
  specify pad characters inserted before the prefix.
 - seealso: #setPadPosition
 - seealso: #getPadPosition
 - seealso: #PAD_AFTER_PREFIX
 - seealso: #PAD_BEFORE_SUFFIX
 - seealso: #PAD_AFTER_SUFFIX
 */
inline jint AndroidIcuTextDecimalFormat_get_PAD_BEFORE_PREFIX(void);
#define AndroidIcuTextDecimalFormat_PAD_BEFORE_PREFIX 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PAD_BEFORE_PREFIX, jint)

/*!
 @brief <strong>[icu]</strong> Constant for <code>getPadPosition()</code> and <code>setPadPosition(int)</code> to
  specify pad characters inserted after the prefix.
 - seealso: #setPadPosition
 - seealso: #getPadPosition
 - seealso: #PAD_BEFORE_PREFIX
 - seealso: #PAD_BEFORE_SUFFIX
 - seealso: #PAD_AFTER_SUFFIX
 */
inline jint AndroidIcuTextDecimalFormat_get_PAD_AFTER_PREFIX(void);
#define AndroidIcuTextDecimalFormat_PAD_AFTER_PREFIX 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PAD_AFTER_PREFIX, jint)

/*!
 @brief <strong>[icu]</strong> Constant for <code>getPadPosition()</code> and <code>setPadPosition(int)</code> to
  specify pad characters inserted before the suffix.
 - seealso: #setPadPosition
 - seealso: #getPadPosition
 - seealso: #PAD_BEFORE_PREFIX
 - seealso: #PAD_AFTER_PREFIX
 - seealso: #PAD_AFTER_SUFFIX
 */
inline jint AndroidIcuTextDecimalFormat_get_PAD_BEFORE_SUFFIX(void);
#define AndroidIcuTextDecimalFormat_PAD_BEFORE_SUFFIX 2
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PAD_BEFORE_SUFFIX, jint)

/*!
 @brief <strong>[icu]</strong> Constant for <code>getPadPosition()</code> and <code>setPadPosition(int)</code> to
  specify pad characters inserted after the suffix.
 - seealso: #setPadPosition
 - seealso: #getPadPosition
 - seealso: #PAD_BEFORE_PREFIX
 - seealso: #PAD_AFTER_PREFIX
 - seealso: #PAD_BEFORE_SUFFIX
 */
inline jint AndroidIcuTextDecimalFormat_get_PAD_AFTER_SUFFIX(void);
#define AndroidIcuTextDecimalFormat_PAD_AFTER_SUFFIX 3
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PAD_AFTER_SUFFIX, jint)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_ZERO_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_ZERO_DIGIT '0'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_ZERO_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_ONE_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_ONE_DIGIT '1'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_ONE_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_TWO_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_TWO_DIGIT '2'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_TWO_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_THREE_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_THREE_DIGIT '3'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_THREE_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_FOUR_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_FOUR_DIGIT '4'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_FOUR_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_FIVE_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_FIVE_DIGIT '5'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_FIVE_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_SIX_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_SIX_DIGIT '6'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_SIX_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_SEVEN_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_SEVEN_DIGIT '7'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_SEVEN_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_EIGHT_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_EIGHT_DIGIT '8'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_EIGHT_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_NINE_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_NINE_DIGIT '9'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_NINE_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_GROUPING_SEPARATOR(void);
#define AndroidIcuTextDecimalFormat_PATTERN_GROUPING_SEPARATOR ','
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_GROUPING_SEPARATOR, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_DECIMAL_SEPARATOR(void);
#define AndroidIcuTextDecimalFormat_PATTERN_DECIMAL_SEPARATOR '.'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_DECIMAL_SEPARATOR, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_DIGIT '#'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_SIGNIFICANT_DIGIT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_SIGNIFICANT_DIGIT '@'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_SIGNIFICANT_DIGIT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_EXPONENT(void);
#define AndroidIcuTextDecimalFormat_PATTERN_EXPONENT 'E'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_EXPONENT, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_PLUS_SIGN(void);
#define AndroidIcuTextDecimalFormat_PATTERN_PLUS_SIGN '+'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_PLUS_SIGN, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_MINUS_SIGN(void);
#define AndroidIcuTextDecimalFormat_PATTERN_MINUS_SIGN '-'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_MINUS_SIGN, jchar)

inline jchar AndroidIcuTextDecimalFormat_get_PATTERN_PAD_ESCAPE(void);
#define AndroidIcuTextDecimalFormat_PATTERN_PAD_ESCAPE '*'
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, PATTERN_PAD_ESCAPE, jchar)

/*!
 @brief Upper limit on integer and fraction digits for a Java double [Richard/GCL]
 */
inline jint AndroidIcuTextDecimalFormat_get_DOUBLE_INTEGER_DIGITS(void);
#define AndroidIcuTextDecimalFormat_DOUBLE_INTEGER_DIGITS 309
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, DOUBLE_INTEGER_DIGITS, jint)

inline jint AndroidIcuTextDecimalFormat_get_MAX_INTEGER_DIGITS(void);
#define AndroidIcuTextDecimalFormat_MAX_INTEGER_DIGITS 2000000000
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, MAX_INTEGER_DIGITS, jint)

inline jint AndroidIcuTextDecimalFormat_get_DOUBLE_FRACTION_DIGITS(void);
#define AndroidIcuTextDecimalFormat_DOUBLE_FRACTION_DIGITS 340
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, DOUBLE_FRACTION_DIGITS, jint)

/*!
 @brief When someone turns on scientific mode, we assume that more than this number of
  digits is due to flipping from some other mode that didn't restrict the maximum,
  and so we force 1 integer digit.We don't bother to track and see if someone is
  using exponential notation with more than this number, it wouldn't make sense
  anyway, and this is just to make sure that someone turning on scientific mode with
  default settings doesn't end up with lots of zeroes.
 */
inline jint AndroidIcuTextDecimalFormat_get_MAX_SCIENTIFIC_INTEGER_DIGITS(void);
#define AndroidIcuTextDecimalFormat_MAX_SCIENTIFIC_INTEGER_DIGITS 8
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, MAX_SCIENTIFIC_INTEGER_DIGITS, jint)

inline AndroidIcuTextDecimalFormat_Unit *AndroidIcuTextDecimalFormat_get_NULL_UNIT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextDecimalFormat_Unit *AndroidIcuTextDecimalFormat_NULL_UNIT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextDecimalFormat, NULL_UNIT, AndroidIcuTextDecimalFormat_Unit *)

inline jdouble AndroidIcuTextDecimalFormat_get_roundingIncrementEpsilon(void);
#define AndroidIcuTextDecimalFormat_roundingIncrementEpsilon 1.0E-9
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextDecimalFormat, roundingIncrementEpsilon, jdouble)

FOUNDATION_EXPORT void AndroidIcuTextDecimalFormat_init(AndroidIcuTextDecimalFormat *self);

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *new_AndroidIcuTextDecimalFormat_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *create_AndroidIcuTextDecimalFormat_init(void);

FOUNDATION_EXPORT void AndroidIcuTextDecimalFormat_initWithNSString_(AndroidIcuTextDecimalFormat *self, NSString *pattern);

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *new_AndroidIcuTextDecimalFormat_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *create_AndroidIcuTextDecimalFormat_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT void AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_(AndroidIcuTextDecimalFormat *self, NSString *pattern, AndroidIcuTextDecimalFormatSymbols *symbols);

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *new_AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_(NSString *pattern, AndroidIcuTextDecimalFormatSymbols *symbols) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *create_AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_(NSString *pattern, AndroidIcuTextDecimalFormatSymbols *symbols);

FOUNDATION_EXPORT void AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_withAndroidIcuTextCurrencyPluralInfo_withInt_(AndroidIcuTextDecimalFormat *self, NSString *pattern, AndroidIcuTextDecimalFormatSymbols *symbols, AndroidIcuTextCurrencyPluralInfo *infoInput, jint style);

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *new_AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_withAndroidIcuTextCurrencyPluralInfo_withInt_(NSString *pattern, AndroidIcuTextDecimalFormatSymbols *symbols, AndroidIcuTextCurrencyPluralInfo *infoInput, jint style) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *create_AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_withAndroidIcuTextCurrencyPluralInfo_withInt_(NSString *pattern, AndroidIcuTextDecimalFormatSymbols *symbols, AndroidIcuTextCurrencyPluralInfo *infoInput, jint style);

FOUNDATION_EXPORT void AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_withInt_(AndroidIcuTextDecimalFormat *self, NSString *pattern, AndroidIcuTextDecimalFormatSymbols *inputSymbols, jint style);

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *new_AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_withInt_(NSString *pattern, AndroidIcuTextDecimalFormatSymbols *inputSymbols, jint style) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat *create_AndroidIcuTextDecimalFormat_initWithNSString_withAndroidIcuTextDecimalFormatSymbols_withInt_(NSString *pattern, AndroidIcuTextDecimalFormatSymbols *inputSymbols, jint style);

FOUNDATION_EXPORT jint AndroidIcuTextDecimalFormat_matchWithNSString_withInt_withInt_(NSString *text, jint pos, jint ch);

FOUNDATION_EXPORT jint AndroidIcuTextDecimalFormat_matchWithNSString_withInt_withNSString_(NSString *text, jint pos, NSString *str);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextDecimalFormat)

#endif

#if !defined (AndroidIcuTextDecimalFormat_Unit_) && (INCLUDE_ALL_AndroidIcuTextDecimalFormat || defined(INCLUDE_AndroidIcuTextDecimalFormat_Unit))
#define AndroidIcuTextDecimalFormat_Unit_

@class JavaLangStringBuffer;

/*!
 @brief Unit is an immutable class for the textual representation of a unit, in
  particular its prefix and suffix.
 @author rocketman
 */
@interface AndroidIcuTextDecimalFormat_Unit : NSObject

#pragma mark Public

- (instancetype __nonnull)initWithNSString:(NSString *)prefix
                              withNSString:(NSString *)suffix;

- (jboolean)isEqual:(id)obj;

- (NSString *)description;

- (void)writePrefixWithJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo;

- (void)writeSuffixWithJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextDecimalFormat_Unit)

FOUNDATION_EXPORT void AndroidIcuTextDecimalFormat_Unit_initWithNSString_withNSString_(AndroidIcuTextDecimalFormat_Unit *self, NSString *prefix, NSString *suffix);

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat_Unit *new_AndroidIcuTextDecimalFormat_Unit_initWithNSString_withNSString_(NSString *prefix, NSString *suffix) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextDecimalFormat_Unit *create_AndroidIcuTextDecimalFormat_Unit_initWithNSString_withNSString_(NSString *prefix, NSString *suffix);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextDecimalFormat_Unit)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuTextDecimalFormat")
