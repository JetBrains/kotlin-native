//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/Normalizer.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuTextNormalizer")
#ifdef RESTRICT_AndroidIcuTextNormalizer
#define INCLUDE_ALL_AndroidIcuTextNormalizer 0
#else
#define INCLUDE_ALL_AndroidIcuTextNormalizer 1
#endif
#undef RESTRICT_AndroidIcuTextNormalizer

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuTextNormalizer_) && (INCLUDE_ALL_AndroidIcuTextNormalizer || defined(INCLUDE_AndroidIcuTextNormalizer))
#define AndroidIcuTextNormalizer_

@class AndroidIcuTextNormalizer_Mode;
@class AndroidIcuTextNormalizer_QuickCheckResult;
@class AndroidIcuTextUCharacterIterator;
@class IOSCharArray;
@class JavaLangStringBuffer;
@protocol JavaLangCharSequence;
@protocol JavaTextCharacterIterator;

/*!
 @brief Old Unicode normalization API.
 <p>This API has been replaced by the <code>Normalizer2</code> class and is only available
  for backward compatibility. This class simply delegates to the Normalizer2 class.
  There are two exceptions: The new API does not provide a replacement for 
 <code>QuickCheckResult</code> and <code>compare()</code>.
  
 <p><code>normalize</code> transforms Unicode text into an equivalent composed or
  decomposed form, allowing for easier sorting and searching of text. 
 <code>normalize</code> supports the standard normalization forms described in 
 <a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
  Unicode Standard Annex #15 &mdash; Unicode Normalization Forms</a>.
  
 <p>Characters with accents or other adornments can be encoded in
  several different ways in Unicode.  For example, take the character A-acute.
  In Unicode, this can be encoded as a single character (the
  "composed" form): 
 @code

       00C1    LATIN CAPITAL LETTER A WITH ACUTE 
  
@endcode
  or as two separate characters (the "decomposed" form): 
 @code

       0041    LATIN CAPITAL LETTER A
       0301    COMBINING ACUTE ACCENT 
  
@endcode
  
 <p>To a user of your program, however, both of these sequences should be
  treated as the same "user-level" character "A with acute accent".  When you
  are searching or comparing text, you must ensure that these two sequences are
  treated equivalently.  In addition, you must handle characters with more than
  one accent.  Sometimes the order of a character's combining accents is
  significant, while in other cases accent sequences in different orders are
  really equivalent. 
 <p>Similarly, the string "ffi" can be encoded as three separate letters: 
 @code

       0066    LATIN SMALL LETTER F      0066    LATIN SMALL LETTER F
       0069    LATIN SMALL LETTER I 
  
@endcode
  or as the single character 
 @code

       FB03    LATIN SMALL LIGATURE FFI 
  
@endcode
  
 <p>The ffi ligature is not a distinct semantic character, and strictly speaking
  it shouldn't be in Unicode at all, but it was included for compatibility
  with existing character sets that already provided it.  The Unicode standard
  identifies such characters by giving them "compatibility" decompositions
  into the corresponding semantic characters.  When sorting and searching, you
  will often want to use these mappings. 
 <p><code>normalize</code> helps solve these problems by transforming text into
  the canonical composed and decomposed forms as shown in the first example
  above. In addition, you can have it perform compatibility decompositions so
  that you can treat compatibility characters the same as their equivalents.
  Finally, <code>normalize</code> rearranges accents into the proper canonical
  order, so that you do not have to worry about accent rearrangement on your
  own. 
 <p>Form FCD, "Fast C or D", is also designed for collation.
  It allows to work on strings that are not necessarily normalized
  with an algorithm (like in collation) that works under "canonical closure",
  i.e., it treats precomposed characters and their decomposed equivalents the
  same. 
 <p>It is not a normalization form because it does not provide for uniqueness of
  representation. Multiple strings may be canonically equivalent (their NFDs
  are identical) and may all conform to FCD without being identical themselves. 
 <p>The form is defined such that the "raw decomposition", the recursive
  canonical decomposition of each character, results in a string that is
  canonically ordered. This means that precomposed characters are allowed for
  as long as their decompositions do not need canonical reordering. 
 <p>Its advantage for a process like collation is that all NFD and most NFC texts
  - and many unnormalized texts - already conform to FCD and do not need to be
  normalized (NFD) for such a process. The FCD quick check will return YES for
  most strings in practice. 
 <p>normalize(FCD) may be implemented with NFD. 
 <p>For more details on FCD see Unicode Technical Note #5 (Canonical Equivalence in Applications):
  http://www.unicode.org/notes/tn5/#FCD 
 <p>ICU collation performs either NFD or FCD normalization automatically if
  normalization is turned on for the collator object. Beyond collation and
  string search, normalized strings may be useful for string equivalence
  comparisons, transliteration/transcription, unique representations, etc. 
 <p>The W3C generally recommends to exchange texts in NFC.
  Note also that most legacy character encodings use only precomposed forms and
  often do not encode any combining marks by themselves. For conversion to such
  character encodings the Unicode text needs to be normalized to NFC.
  For more usage examples, see the Unicode Standard Annex. 
 <p>Note: The Normalizer class also provides API for iterative normalization.
  While the setIndex() and getIndex() refer to indices in the
  underlying Unicode input text, the next() and previous() methods
  iterate through characters in the normalized output.
  This means that there is not necessarily a one-to-one correspondence
  between characters returned by next() and previous() and the indices
  passed to and returned from setIndex() and getIndex().
  It is for this reason that Normalizer does not implement the CharacterIterator interface.
 */
@interface AndroidIcuTextNormalizer : NSObject < NSCopying >
@property (readonly, class) jint UNICODE_3_2 NS_SWIFT_NAME(UNICODE_3_2);
@property (readonly, class) jint DONE NS_SWIFT_NAME(DONE);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *NONE NS_SWIFT_NAME(NONE);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *NFD NS_SWIFT_NAME(NFD);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *NFKD NS_SWIFT_NAME(NFKD);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *NFC NS_SWIFT_NAME(NFC);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *DEFAULT NS_SWIFT_NAME(DEFAULT);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *NFKC NS_SWIFT_NAME(NFKC);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *FCD NS_SWIFT_NAME(FCD);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *NO_OP NS_SWIFT_NAME(NO_OP);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *COMPOSE NS_SWIFT_NAME(COMPOSE);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *COMPOSE_COMPAT NS_SWIFT_NAME(COMPOSE_COMPAT);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *DECOMP NS_SWIFT_NAME(DECOMP);
@property (readonly, class, strong) AndroidIcuTextNormalizer_Mode *DECOMP_COMPAT NS_SWIFT_NAME(DECOMP_COMPAT);
@property (readonly, class) jint IGNORE_HANGUL NS_SWIFT_NAME(IGNORE_HANGUL);
@property (readonly, class, strong) AndroidIcuTextNormalizer_QuickCheckResult *NO_ NS_SWIFT_NAME(NO_);
@property (readonly, class, strong) AndroidIcuTextNormalizer_QuickCheckResult *YES_ NS_SWIFT_NAME(YES_);
@property (readonly, class, strong) AndroidIcuTextNormalizer_QuickCheckResult *MAYBE NS_SWIFT_NAME(MAYBE);
@property (readonly, class) jint FOLD_CASE_DEFAULT NS_SWIFT_NAME(FOLD_CASE_DEFAULT);
@property (readonly, class) jint INPUT_IS_FCD NS_SWIFT_NAME(INPUT_IS_FCD);
@property (readonly, class) jint COMPARE_IGNORE_CASE NS_SWIFT_NAME(COMPARE_IGNORE_CASE);
@property (readonly, class) jint COMPARE_CODE_POINT_ORDER NS_SWIFT_NAME(COMPARE_CODE_POINT_ORDER);
@property (readonly, class) jint FOLD_CASE_EXCLUDE_SPECIAL_I NS_SWIFT_NAME(FOLD_CASE_EXCLUDE_SPECIAL_I);
@property (readonly, class) jint COMPARE_NORM_OPTIONS_SHIFT NS_SWIFT_NAME(COMPARE_NORM_OPTIONS_SHIFT);

+ (jint)UNICODE_3_2;

+ (jint)DONE;

+ (AndroidIcuTextNormalizer_Mode *)NONE;

+ (AndroidIcuTextNormalizer_Mode *)NFD;

+ (AndroidIcuTextNormalizer_Mode *)NFKD;

+ (AndroidIcuTextNormalizer_Mode *)NFC;

+ (AndroidIcuTextNormalizer_Mode *)DEFAULT;

+ (AndroidIcuTextNormalizer_Mode *)NFKC;

+ (AndroidIcuTextNormalizer_Mode *)FCD;

+ (AndroidIcuTextNormalizer_Mode *)NO_OP;

+ (AndroidIcuTextNormalizer_Mode *)COMPOSE;

+ (AndroidIcuTextNormalizer_Mode *)COMPOSE_COMPAT;

+ (AndroidIcuTextNormalizer_Mode *)DECOMP;

+ (AndroidIcuTextNormalizer_Mode *)DECOMP_COMPAT;

+ (jint)IGNORE_HANGUL;

+ (AndroidIcuTextNormalizer_QuickCheckResult *)NO_;

+ (AndroidIcuTextNormalizer_QuickCheckResult *)YES_;

+ (AndroidIcuTextNormalizer_QuickCheckResult *)MAYBE;

+ (jint)FOLD_CASE_DEFAULT;

+ (jint)INPUT_IS_FCD;

+ (jint)COMPARE_IGNORE_CASE;

+ (jint)COMPARE_CODE_POINT_ORDER;

+ (jint)FOLD_CASE_EXCLUDE_SPECIAL_I;

+ (jint)COMPARE_NORM_OPTIONS_SHIFT;

#pragma mark Public

/*!
 @brief Creates a new <tt>Normalizer</tt> object for iterating over the
  normalized form of the given text.
 <p>
 @param iter The input text to be normalized.  The normalization               will start at the beginning of the string.
 @param mode The normalization mode.
 @param opt Any optional features to be enabled.             Currently the only available option is 
 <code>UNICODE_3_2</code> .             If you want the default behavior corresponding to one of the
              standard Unicode Normalization Forms, use 0 for this argument.
 */
- (instancetype __nonnull)initWithJavaTextCharacterIterator:(id<JavaTextCharacterIterator>)iter
                          withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                                                    withInt:(jint)opt __attribute__((deprecated));

/*!
 @brief Creates a new <tt>Normalizer</tt> object for iterating over the
  normalized form of a given string.
 <p>
  The <tt>options</tt> parameter specifies which optional 
 <tt>Normalizer</tt> features are to be enabled for this object. 
 <p>
 @param str The string to be normalized.  The normalization               will start at the beginning of the string.
 @param mode The normalization mode.
 @param opt Any optional features to be enabled.             Currently the only available option is 
 <code>UNICODE_3_2</code> .             If you want the default behavior corresponding to one of the
              standard Unicode Normalization Forms, use 0 for this argument.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)str
         withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                                   withInt:(jint)opt __attribute__((deprecated));

/*!
 @brief Creates a new <tt>Normalizer</tt> object for iterating over the
  normalized form of the given text.
 <p>
 @param iter The input text to be normalized.  The normalization               will start at the beginning of the string.
 @param mode The normalization mode.
 @param options The normalization options, ORed together (0 for no options).
 */
- (instancetype __nonnull)initWithAndroidIcuTextUCharacterIterator:(AndroidIcuTextUCharacterIterator *)iter
                                 withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                                                           withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Clones this <tt>Normalizer</tt> object.All properties of this
  object are duplicated in the new object, including the cloning of any 
 <code>CharacterIterator</code> that was passed in to the constructor
  or to <code>setText</code>.
 However, the text storage underlying the 
 <tt>CharacterIterator</tt> is not duplicated unless the
  iterator's <tt>clone</tt> method does so.
 */
- (id)java_clone __attribute__((deprecated));

/*!
 @brief Compare two strings for canonical equivalence.
 Further options include case-insensitive comparison and
  code point order (as opposed to code unit order).
  Convenience method.
 @param s1 First source string.
 @param s2 Second source string.
 @param options A bit set of options:    - FOLD_CASE_DEFAULT or 0 is used for default options:
       Case-sensitive comparison in code unit order, and the input strings
       are quick-checked for FCD.
     - INPUT_IS_FCD      Set if the caller knows that both s1 and s2 fulfill the FCD
       conditions. If not set, the function will quickCheck for FCD
       and normalize if necessary.    - COMPARE_CODE_POINT_ORDER
       Set to choose code point order instead of code unit order
     - COMPARE_IGNORE_CASE      Set to compare strings case-insensitively using case folding,
       instead of case-sensitively.
       If set, then the following case folding options are used.
 @return &lt;0 or 0 or &gt;0 as usual for string comparisons
 - seealso: #normalize
 - seealso: #FCD
 */
+ (jint)compareWithCharArray:(IOSCharArray *)s1
               withCharArray:(IOSCharArray *)s2
                     withInt:(jint)options;

/*!
 @brief Compare two strings for canonical equivalence.
 Further options include case-insensitive comparison and
  code point order (as opposed to code unit order).
  Canonical equivalence between two strings is defined as their normalized
  forms (NFD or NFC) being identical.
  This function compares strings incrementally instead of normalizing
  (and optionally case-folding) both strings entirely,
  improving performance significantly.
  Bulk normalization is only necessary if the strings do not fulfill the
  FCD conditions. Only in this case, and only if the strings are relatively
  long, is memory allocated temporarily.
  For FCD strings and short non-FCD strings there is no memory allocation.
  Semantically, this is equivalent to
    strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2)))
  where code point order and foldCase are all optional.
 @param s1 First source character array.
 @param s1Start start index of source
 @param s1Limit limit of the source
 @param s2 Second source character array.
 @param s2Start start index of the source
 @param s2Limit limit of the source
 @param options A bit set of options:    - FOLD_CASE_DEFAULT or 0 is used for default options:
       Case-sensitive comparison in code unit order, and the input strings
       are quick-checked for FCD.
     - INPUT_IS_FCD      Set if the caller knows that both s1 and s2 fulfill the FCD
       conditions.If not set, the function will quickCheck for FCD
       and normalize if necessary.    - COMPARE_CODE_POINT_ORDER
       Set to choose code point order instead of code unit order
     - COMPARE_IGNORE_CASE      Set to compare strings case-insensitively using case folding,
       instead of case-sensitively.
       If set, then the following case folding options are used.
 @return &lt;0 or 0 or &gt;0 as usual for string comparisons
 - seealso: #normalize
 - seealso: #FCD
 */
+ (jint)compareWithCharArray:(IOSCharArray *)s1
                     withInt:(jint)s1Start
                     withInt:(jint)s1Limit
               withCharArray:(IOSCharArray *)s2
                     withInt:(jint)s2Start
                     withInt:(jint)s2Limit
                     withInt:(jint)options;

/*!
 @brief Convenience method that can have faster implementation
  by not allocating buffers.
 @param char32a the first code point to be checked against the
 @param char32b the second code point
 @param options A bit set of options
 */
+ (jint)compareWithInt:(jint)char32a
               withInt:(jint)char32b
               withInt:(jint)options;

/*!
 @brief Convenience method that can have faster implementation
  by not allocating buffers.
 @param char32a the first code point to be checked against
 @param str2 the second string
 @param options A bit set of options
 */
+ (jint)compareWithInt:(jint)char32a
          withNSString:(NSString *)str2
               withInt:(jint)options;

/*!
 @brief Compare two strings for canonical equivalence.
 Further options include case-insensitive comparison and
  code point order (as opposed to code unit order).
  Canonical equivalence between two strings is defined as their normalized
  forms (NFD or NFC) being identical.
  This function compares strings incrementally instead of normalizing
  (and optionally case-folding) both strings entirely,
  improving performance significantly.
  Bulk normalization is only necessary if the strings do not fulfill the
  FCD conditions. Only in this case, and only if the strings are relatively
  long, is memory allocated temporarily.
  For FCD strings and short non-FCD strings there is no memory allocation.
  Semantically, this is equivalent to
    strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2)))
  where code point order and foldCase are all optional.
 @param s1 First source string.
 @param s2 Second source string.
 @param options A bit set of options:    - FOLD_CASE_DEFAULT or 0 is used for default options:
       Case-sensitive comparison in code unit order, and the input strings
       are quick-checked for FCD.
     - INPUT_IS_FCD      Set if the caller knows that both s1 and s2 fulfill the FCD
       conditions. If not set, the function will quickCheck for FCD
       and normalize if necessary.    - COMPARE_CODE_POINT_ORDER
       Set to choose code point order instead of code unit order
     - COMPARE_IGNORE_CASE      Set to compare strings case-insensitively using case folding,
       instead of case-sensitively.
       If set, then the following case folding options are used.
 @return &lt;0 or 0 or &gt;0 as usual for string comparisons
 - seealso: #normalize
 - seealso: #FCD
 */
+ (jint)compareWithNSString:(NSString *)s1
               withNSString:(NSString *)s2
                    withInt:(jint)options;

/*!
 @brief Compose a string.
 The string will be composed to according to the specified mode.
 @param source The char array to compose.
 @param target A char buffer to receive the normalized text.
 @param compat If true the char array will be composed according to                 NFKC rules and if false will be composed according to
                  NFC rules.
 @param options The normalization options, ORed together (0 for no options).
 @return int   The total buffer size needed;if greater than length of
                 result, the output was truncated.
 @throw IndexOutOfBoundsExceptionif target.length is less than the
              required length
 */
+ (jint)composeWithCharArray:(IOSCharArray *)source
               withCharArray:(IOSCharArray *)target
                 withBoolean:(jboolean)compat
                     withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Compose a string.
 The string will be composed to according to the specified mode.
 @param src The char array to compose.
 @param srcStart Start index of the source
 @param srcLimit Limit index of the source
 @param dest The char buffer to fill in
 @param destStart Start index of the destination buffer
 @param destLimit End index of the destination buffer
 @param compat If true the char array will be composed according to                 NFKC rules and if false will be composed according to
                  NFC rules.
 @param options The normalization options, ORed together (0 for no options).
 @return int   The total buffer size needed;if greater than length of
                 result, the output was truncated.
 @throw IndexOutOfBoundsExceptionif target.length is less than the
              required length
 */
+ (jint)composeWithCharArray:(IOSCharArray *)src
                     withInt:(jint)srcStart
                     withInt:(jint)srcLimit
               withCharArray:(IOSCharArray *)dest
                     withInt:(jint)destStart
                     withInt:(jint)destLimit
                 withBoolean:(jboolean)compat
                     withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Compose a string.
 The string will be composed to according to the specified mode.
 @param str The string to compose.
 @param compat If true the string will be composed according to                     NFKC rules and if false will be composed according to
                      NFC rules.
 @return String    The composed string
 */
+ (NSString *)composeWithNSString:(NSString *)str
                      withBoolean:(jboolean)compat __attribute__((deprecated));

/*!
 @brief Compose a string.
 The string will be composed to according to the specified mode.
 @param str The string to compose.
 @param compat If true the string will be composed according to                     NFKC rules and if false will be composed according to
                      NFC rules.
 @param options The only recognized option is UNICODE_3_2
 @return String    The composed string
 */
+ (NSString *)composeWithNSString:(NSString *)str
                      withBoolean:(jboolean)compat
                          withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Concatenate normalized strings, making sure that the result is normalized
  as well.
 If both the left and the right strings are in
  the normalization form according to "mode",
  then the result will be 
 <code>
      dest=normalize(left+right, mode) 
 </code>
  For details see concatenate
 @param left Left source string.
 @param right Right source string.
 @param mode The normalization mode.
 @param options The normalization options, ORed together (0 for no options).
 @return result
 - seealso: #concatenate
 - seealso: #normalize
 - seealso: #next
 - seealso: #previous
 - seealso: #concatenate
 */
+ (NSString *)concatenateWithCharArray:(IOSCharArray *)left
                         withCharArray:(IOSCharArray *)right
     withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                               withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Concatenate normalized strings, making sure that the result is normalized
  as well.
 If both the left and the right strings are in
  the normalization form according to "mode",
  then the result will be 
 <code>
      dest=normalize(left+right, mode) 
 </code>
  With the input strings already being normalized,
  this function will use next() and previous()
  to find the adjacent end pieces of the input strings.
  Only the concatenation of these end pieces will be normalized and
  then concatenated with the remaining parts of the input strings.
  It is allowed to have dest==left to avoid copying the entire left string.
 @param left Left source array, may be same as dest.
 @param leftStart start in the left array.
 @param leftLimit limit in the left array (==length)
 @param right Right source array.
 @param rightStart start in the right array.
 @param rightLimit limit in the right array (==length)
 @param dest The output buffer; can be null if destStart==destLimit==0               for pure preflighting.
 @param destStart start in the destination array
 @param destLimit limit in the destination array (==length)
 @param mode The normalization mode.
 @param options The normalization options, ORed together (0 for no options).
 @return Length of output (number of chars) when successful or
           IndexOutOfBoundsException
 @throw IndexOutOfBoundsExceptionwhose message has the string
              representation of destination capacity required.
 - seealso: #normalize
 - seealso: #next
 - seealso: #previous
 @throw IndexOutOfBoundsExceptionif target capacity is less than the
              required length
 */
+ (jint)concatenateWithCharArray:(IOSCharArray *)left
                         withInt:(jint)leftStart
                         withInt:(jint)leftLimit
                   withCharArray:(IOSCharArray *)right
                         withInt:(jint)rightStart
                         withInt:(jint)rightLimit
                   withCharArray:(IOSCharArray *)dest
                         withInt:(jint)destStart
                         withInt:(jint)destLimit
withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                         withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Concatenate normalized strings, making sure that the result is normalized
  as well.
 If both the left and the right strings are in
  the normalization form according to "mode",
  then the result will be 
 <code>
      dest=normalize(left+right, mode) 
 </code>
  With the input strings already being normalized,
  this function will use next() and previous()
  to find the adjacent end pieces of the input strings.
  Only the concatenation of these end pieces will be normalized and
  then concatenated with the remaining parts of the input strings.
 @param left Left source string.
 @param right Right source string.
 @param mode The normalization mode.
 @param options The normalization options, ORed together (0 for no options).
 @return result
 - seealso: #concatenate
 - seealso: #normalize
 - seealso: #next
 - seealso: #previous
 - seealso: #concatenate
 */
+ (NSString *)concatenateWithNSString:(NSString *)left
                         withNSString:(NSString *)right
    withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                              withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Return the current character in the normalized text.
 @return The codepoint as an int
 */
- (jint)current __attribute__((deprecated));

/*!
 @brief Decompose a string.
 The string will be decomposed to according to the specified mode.
 @param source The char array to decompose.
 @param target A char buffer to receive the normalized text.
 @param compat If true the char array will be decomposed according to NFKD                 rules and if false will be decomposed according to
                  NFD rules.
 @return int   The total buffer size needed;if greater than length of
                 result,the output was truncated.
 @param options The normalization options, ORed together (0 for no options).
 @throw IndexOutOfBoundsExceptionif the target capacity is less than
              the required length
 */
+ (jint)decomposeWithCharArray:(IOSCharArray *)source
                 withCharArray:(IOSCharArray *)target
                   withBoolean:(jboolean)compat
                       withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Decompose a string.
 The string will be decomposed to according to the specified mode.
 @param src The char array to compose.
 @param srcStart Start index of the source
 @param srcLimit Limit index of the source
 @param dest The char buffer to fill in
 @param destStart Start index of the destination buffer
 @param destLimit End index of the destination buffer
 @param compat If true the char array will be decomposed according to NFKD                 rules and if false will be decomposed according to
                  NFD rules.
 @param options The normalization options, ORed together (0 for no options).
 @return int   The total buffer size needed;if greater than length of
                 result,the output was truncated.
 @throw IndexOutOfBoundsExceptionif the target capacity is less than
              the required length
 */
+ (jint)decomposeWithCharArray:(IOSCharArray *)src
                       withInt:(jint)srcStart
                       withInt:(jint)srcLimit
                 withCharArray:(IOSCharArray *)dest
                       withInt:(jint)destStart
                       withInt:(jint)destLimit
                   withBoolean:(jboolean)compat
                       withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Decompose a string.
 The string will be decomposed to according to the specified mode.
 @param str The string to decompose.
 @param compat If true the string will be decomposed according to NFKD                    rules and if false will be decomposed according to NFD
                     rules.
 @return String   The decomposed string
 */
+ (NSString *)decomposeWithNSString:(NSString *)str
                        withBoolean:(jboolean)compat __attribute__((deprecated));

/*!
 @brief Decompose a string.
 The string will be decomposed to according to the specified mode.
 @param str The string to decompose.
 @param compat If true the string will be decomposed according to NFKD                  rules and if false will be decomposed according to NFD
                   rules.
 @param options The normalization options, ORed together (0 for no options).
 @return String The decomposed string
 */
+ (NSString *)decomposeWithNSString:(NSString *)str
                        withBoolean:(jboolean)compat
                            withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Retrieve the index of the end of the input text.This is the end index
  of the <tt>CharacterIterator</tt> or the length of the <tt>String</tt>
  over which this <tt>Normalizer</tt> is iterating
 @return The current iteration position
 */
- (jint)endIndex __attribute__((deprecated));

/*!
 @brief Return the first character in the normalized text.This resets
  the <tt>Normalizer's</tt> position to the beginning of the text.
 @return The codepoint as an int
 */
- (jint)first __attribute__((deprecated));

/*!
 @brief Retrieve the index of the start of the input text.This is the begin
  index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the 
 <tt>String</tt> over which this <tt>Normalizer</tt> is iterating
 @return The codepoint as an int
 - seealso: #startIndex
 */
- (jint)getBeginIndex __attribute__((deprecated));

/*!
 @brief Retrieve the index of the end of the input text.This is the end index
  of the <tt>CharacterIterator</tt> or the length of the <tt>String</tt>
  over which this <tt>Normalizer</tt> is iterating
 @return The codepoint as an int
 - seealso: #endIndex
 */
- (jint)getEndIndex __attribute__((deprecated));

/*!
 @brief Gets the FC_NFKC closure value.
 @param c The code point whose closure value is to be retrieved
 @return String representation of the closure value; "" if there is none
 */
+ (NSString *)getFC_NFKC_ClosureWithInt:(jint)c __attribute__((deprecated));

/*!
 @brief Gets the FC_NFKC closure value.
 @param c The code point whose closure value is to be retrieved
 @param dest The char array to receive the closure value
 @return the length of the closure value; 0 if there is none
 */
+ (jint)getFC_NFKC_ClosureWithInt:(jint)c
                    withCharArray:(IOSCharArray *)dest __attribute__((deprecated));

/*!
 @brief Retrieve the current iteration position in the input text that is
  being normalized.This method is useful in applications such as
  searching, where you need to be able to determine the position in
  the input text that corresponds to a given normalized output character.
 <p>
  <b>Note:</b> This method sets the position in the <em>input</em>, while 
 <code>next</code> and <code>previous</code> iterate through characters in the 
 <em>output</em>.  This means that there is not necessarily a one-to-one
  correspondence between characters returned by <tt>next</tt> and 
 <tt>previous</tt> and the indices passed to and returned from 
 <tt>setIndex</tt> and <code>getIndex</code>.
 @return The current iteration position
 */
- (jint)getIndex __attribute__((deprecated));

/*!
 @brief Gets the length of underlying text storage
 @return the length
 */
- (jint)getLength __attribute__((deprecated));

/*!
 @brief Return the basic operation performed by this <tt>Normalizer</tt>
 - seealso: #setMode
 */
- (AndroidIcuTextNormalizer_Mode *)getMode __attribute__((deprecated));

/*!
 @brief Determine whether an option is turned on or off.
 <p>
 - seealso: #setOption
 */
- (jint)getOptionWithInt:(jint)option __attribute__((deprecated));

/*!
 @brief Returns the text under iteration as a string
 @return a copy of the text under iteration.
 */
- (NSString *)getText __attribute__((deprecated));

/*!
 @brief Gets the underlying text storage
 @param fillIn the char buffer to fill the UTF-16 units.          The length of the buffer should be equal to the length of the
           underlying text storage
 @throw IndexOutOfBoundsExceptionIf the index passed for the array is invalid.
 - seealso: #getLength
 */
- (jint)getTextWithCharArray:(IOSCharArray *)fillIn __attribute__((deprecated));

/*!
 @brief Test if a string is in a given normalization form.
 This is semantically equivalent to source.equals(normalize(source, mode)).
  Unlike quickCheck(), this function returns a definitive result,
  never a "maybe".
  For NFD, NFKD, and FCD, both functions work exactly the same.
  For NFC and NFKC where quickCheck may return "maybe", this function will
  perform further tests to arrive at a true/false result.
 @param src The input array of characters to be checked to see if                    it is normalized
 @param start The strart index in the source
 @param limit The limit index in the source
 @param mode the normalization mode
 @param options Options for use with exclusion set and tailored Normalization                                    The only option that is currently recognized is UNICODE_3_2
 @return Boolean value indicating whether the source string is in the
          "mode" normalization form
 */
+ (jboolean)isNormalizedWithCharArray:(IOSCharArray *)src
                              withInt:(jint)start
                              withInt:(jint)limit
    withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                              withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Convenience Method
 @param char32 the input code point to be checked to see if it is                    normalized
 @param mode the normalization mode
 @param options Options for use with exclusion set and tailored Normalization                   The only option that is currently recognized is UNICODE_3_2
 - seealso: #isNormalized
 */
+ (jboolean)isNormalizedWithInt:(jint)char32
withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                        withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Test if a string is in a given normalization form.
 This is semantically equivalent to source.equals(normalize(source, mode)).
  Unlike quickCheck(), this function returns a definitive result,
  never a "maybe".
  For NFD, NFKD, and FCD, both functions work exactly the same.
  For NFC and NFKC where quickCheck may return "maybe", this function will
  perform further tests to arrive at a true/false result.
 @param str the input string to be checked to see if it is                    normalized
 @param mode the normalization mode
 @param options Options for use with exclusion set and tailored Normalization                   The only option that is currently recognized is UNICODE_3_2
 - seealso: #isNormalized
 */
+ (jboolean)isNormalizedWithNSString:(NSString *)str
   withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                             withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Return the last character in the normalized text.This resets
  the <tt>Normalizer's</tt> position to be just before the
  the input text corresponding to that normalized character.
 @return The codepoint as an int
 */
- (jint)last __attribute__((deprecated));

/*!
 @brief Return the next character in the normalized text and advance
  the iteration position by one.If the end
  of the text has already been reached, <code>DONE</code> is returned.
 @return The codepoint as an int
 */
- (jint)next __attribute__((deprecated));

/*!
 @brief Normalize a string.
 The string will be normalized according to the specified normalization
  mode and options.
 @param source The char array to normalize.
 @param target A char buffer to receive the normalized text.
 @param mode The normalization mode; one of Normalizer.NONE,                 Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
                  Normalizer.NFKD, Normalizer.DEFAULT
 @param options The normalization options, ORed together (0 for no options).
 @return int   The total buffer size needed;if greater than length of
                 result, the output was truncated.
 @throw IndexOutOfBoundsExceptionif the target capacity is less
                 than the required length
 */
+ (jint)normalizeWithCharArray:(IOSCharArray *)source
                 withCharArray:(IOSCharArray *)target
withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                       withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Normalize a string.
 The string will be normalized according to the specified normalization
  mode and options.
 @param src The char array to compose.
 @param srcStart Start index of the source
 @param srcLimit Limit index of the source
 @param dest The char buffer to fill in
 @param destStart Start index of the destination buffer
 @param destLimit End index of the destination buffer
 @param mode The normalization mode; one of Normalizer.NONE,                    Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
                     Normalizer.NFKD, Normalizer.DEFAULT
 @param options The normalization options, ORed together (0 for no options).
 @return int      The total buffer size needed;if greater than length of
                    result, the output was truncated.
 @throw IndexOutOfBoundsExceptionif the target capacity is
                    less than the required length
 */
+ (jint)normalizeWithCharArray:(IOSCharArray *)src
                       withInt:(jint)srcStart
                       withInt:(jint)srcLimit
                 withCharArray:(IOSCharArray *)dest
                       withInt:(jint)destStart
                       withInt:(jint)destLimit
withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                       withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Convenience method to normalize a codepoint according to the given mode
 @param char32 The input string to be normalized.
 @param mode The normalization mode
 @return String   The normalized string
 */
+ (NSString *)normalizeWithInt:(jint)char32
withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode __attribute__((deprecated));

/*!
 @brief Normalize a codepoint according to the given mode
 @param char32 The input string to be normalized.
 @param mode The normalization mode
 @param options Options for use with exclusion set and tailored Normalization                                    The only option that is currently recognized is UNICODE_3_2
 @return String   The normalized string
 - seealso: #UNICODE_3_2
 */
+ (NSString *)normalizeWithInt:(jint)char32
withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                       withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Normalize a string.
 The string will be normalized according to the specified normalization
  mode and options.
 @param src The string to normalize.
 @param mode The normalization mode; one of Normalizer.NONE,                     Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
                      Normalizer.NFKD, Normalizer.DEFAULT
 @return the normalized string
 */
+ (NSString *)normalizeWithNSString:(NSString *)src
  withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode __attribute__((deprecated));

/*!
 @brief Normalizes a <tt>String</tt> using the given normalization operation.
 <p>
  The <tt>options</tt> parameter specifies which optional 
 <tt>Normalizer</tt> features are to be enabled for this operation.
  Currently the only available option is <code>UNICODE_3_2</code>.
  If you want the default behavior corresponding to one of the standard
  Unicode Normalization Forms, use 0 for this argument. 
 <p>
 @param str the input string to be normalized.
 @param mode the normalization mode
 @param options the optional features to be enabled.
 @return String   the normalized string
 */
+ (NSString *)normalizeWithNSString:(NSString *)str
  withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                            withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Return the previous character in the normalized text and decrement
  the iteration position by one.If the beginning
  of the text has already been reached, <code>DONE</code> is returned.
 @return The codepoint as an int
 */
- (jint)previous __attribute__((deprecated));

/*!
 @brief Performing quick check on a string, to quickly determine if the string is
  in a particular normalization format.
 Three types of result can be returned Normalizer.YES, Normalizer.NO or
  Normalizer.MAYBE. Result Normalizer.YES indicates that the argument
  string is in the desired normalized format, Normalizer.NO determines that
  argument string is not in the desired normalized format. A
  Normalizer.MAYBE result indicates that a more thorough check is required,
  the user may have to put the string in its normalized form and compare
  the results.
 @param source string for determining if it is in a normalized format
 @param start the start index of the source
 @param limit the limit index of the source it is equal to the length
 @param mode normalization format (Normalizer.NFC,Normalizer.NFD,                    Normalizer.NFKC,Normalizer.NFKD)
 @param options Options for use with exclusion set and tailored Normalization                                    The only option that is currently recognized is UNICODE_3_2
 @return Return code to specify if the text is normalized or not
                    (Normalizer.YES, Normalizer.NO or
                    Normalizer.MAYBE)
 */
+ (AndroidIcuTextNormalizer_QuickCheckResult *)quickCheckWithCharArray:(IOSCharArray *)source
                                                               withInt:(jint)start
                                                               withInt:(jint)limit
                                     withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                                                               withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Convenience method.
 @param source Array of characters for determining if it is in a                 normalized format
 @param mode normalization format (Normalizer.NFC,Normalizer.NFD,                 Normalizer.NFKC,Normalizer.NFKD)
 @param options Options for use with exclusion set and tailored Normalization                                    The only option that is currently recognized is UNICODE_3_2
 @return Return code to specify if the text is normalized or not
                 (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)
 */
+ (AndroidIcuTextNormalizer_QuickCheckResult *)quickCheckWithCharArray:(IOSCharArray *)source
                                     withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                                                               withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Convenience method.
 @param source string for determining if it is in a normalized format
 @param mode normalization format (Normalizer.NFC,Normalizer.NFD,                   Normalizer.NFKC,Normalizer.NFKD)
 @return Return code to specify if the text is normalized or not
                      (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)
 */
+ (AndroidIcuTextNormalizer_QuickCheckResult *)quickCheckWithNSString:(NSString *)source
                                    withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode __attribute__((deprecated));

/*!
 @brief Performing quick check on a string, to quickly determine if the string is
  in a particular normalization format.
 Three types of result can be returned Normalizer.YES, Normalizer.NO or
  Normalizer.MAYBE. Result Normalizer.YES indicates that the argument
  string is in the desired normalized format, Normalizer.NO determines that
  argument string is not in the desired normalized format. A
  Normalizer.MAYBE result indicates that a more thorough check is required,
  the user may have to put the string in its normalized form and compare
  the results.
 @param source string for determining if it is in a normalized format
 @param mode normalization format (Normalizer.NFC,Normalizer.NFD,                   Normalizer.NFKC,Normalizer.NFKD)
 @param options Options for use with exclusion set and tailored Normalization                                    The only option that is currently recognized is UNICODE_3_2
 @return Return code to specify if the text is normalized or not
                      (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)
 */
+ (AndroidIcuTextNormalizer_QuickCheckResult *)quickCheckWithNSString:(NSString *)source
                                    withAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)mode
                                                              withInt:(jint)options __attribute__((deprecated));

/*!
 @brief Reset the index to the beginning of the text.
 This is equivalent to setIndexOnly(startIndex)).
 */
- (void)reset __attribute__((deprecated));

/*!
 @brief Set the iteration position in the input text that is being normalized
  and return the first normalized character at that position.
 <p>
  <b>Note:</b> This method sets the position in the <em>input</em> text,
  while <code>next</code> and <code>previous</code> iterate through characters
  in the normalized <em>output</em>.  This means that there is not
  necessarily a one-to-one correspondence between characters returned
  by <tt>next</tt> and <tt>previous</tt> and the indices passed to and
  returned from <tt>setIndex</tt> and <code>getIndex</code>.
  <p>
 @param index the desired index in the input text.
 @return the first normalized character that is the result of iterating
             forward starting at the given index.
 @throw IllegalArgumentExceptionif the given index is less than
           <code>getBeginIndex</code> or greater than <code>getEndIndex</code>.
 */
- (jint)setIndexWithInt:(jint)index __attribute__((deprecated));

/*!
 @brief Set the iteration position in the input text that is being normalized,
  without any immediate normalization.
 After setIndexOnly(), getIndex() will return the same index that is
  specified here.
 @param index the desired index in the input text.
 */
- (void)setIndexOnlyWithInt:(jint)index __attribute__((deprecated));

/*!
 @brief Set the normalization mode for this object.
 <p>
  <b>Note:</b>If the normalization mode is changed while iterating
  over a string, calls to <code>next</code> and <code>previous</code> may
  return previously buffers characters in the old normalization mode
  until the iteration is able to re-sync at the next base character.
  It is safest to call <code>setText()</code>, <code>first</code>,
  <code>last</code>, etc. after calling <tt>setMode</tt>.
  <p>
 @param newMode the new mode for this  <tt> Normalizer </tt>
  .  The supported modes are:   <ul>
     <li>
 <code>NFC</code>     - Unicode canonical decompositiion                         followed by canonical composition.
     <li><code>NFKC</code>
     - Unicode compatibility decompositiion                         follwed by canonical composition.
     <li><code>NFD</code>     - Unicode canonical decomposition
     <li><code>NFKD</code>    - Unicode compatibility decomposition.
     <li><code>NONE</code>    - Do nothing but return characters
                          from the underlying input text.
    </ul>
 - seealso: #getMode
 */
- (void)setModeWithAndroidIcuTextNormalizer_Mode:(AndroidIcuTextNormalizer_Mode *)newMode __attribute__((deprecated));

/*!
 @brief Set options that affect this <tt>Normalizer</tt>'s operation.
 Options do not change the basic composition or decomposition operation
  that is being performed , but they control whether
  certain optional portions of the operation are done.
  Currently the only available option is: 
 <ul>
    <li><code>UNICODE_3_2</code> - Use Normalization conforming to Unicode version 3.2. 
 </ul>
 @param option the option whose value is to be set.
 @param value the new setting for the option.  Use  <tt> true </tt>  to
                    turn the option on and  <tt> false </tt>  to turn it off.
 - seealso: #getOption
 */
- (void)setOptionWithInt:(jint)option
             withBoolean:(jboolean)value __attribute__((deprecated));

/*!
 @brief Set the input text over which this <tt>Normalizer</tt> will iterate.
 The iteration position is set to the beginning of the input text.
 @param newText The new string to be normalized.
 */
- (void)setTextWithCharArray:(IOSCharArray *)newText __attribute__((deprecated));

/*!
 @brief Set the input text over which this <tt>Normalizer</tt> will iterate.
 The iteration position is set to the beginning of the input text.
 @param newText The new string to be normalized.
 */
- (void)setTextWithJavaTextCharacterIterator:(id<JavaTextCharacterIterator>)newText __attribute__((deprecated));

/*!
 @brief Set the input text over which this <tt>Normalizer</tt> will iterate.
 The iteration position is set to the beginning of the input text.
 @param newText The new string to be normalized.
 */
- (void)setTextWithNSString:(NSString *)newText __attribute__((deprecated));

/*!
 @brief Set the input text over which this <tt>Normalizer</tt> will iterate.
 The iteration position is set to the beginning of the input text.
 @param newText The new string to be normalized.
 */
- (void)setTextWithJavaLangStringBuffer:(JavaLangStringBuffer *)newText __attribute__((deprecated));

/*!
 @brief Set the input text over which this <tt>Normalizer</tt> will iterate.
 The iteration position is set to the beginning of the string.
 @param newText The new string to be normalized.
 */
- (void)setTextWithAndroidIcuTextUCharacterIterator:(AndroidIcuTextUCharacterIterator *)newText __attribute__((deprecated));

/*!
 @brief Retrieve the index of the start of the input text.This is the begin
  index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the 
 <tt>String</tt> over which this <tt>Normalizer</tt> is iterating
 @return The current iteration position
 */
- (jint)startIndex __attribute__((deprecated));

#pragma mark Package-Private

+ (jint)cmpEquivFoldWithJavaLangCharSequence:(id<JavaLangCharSequence>)cs1
                    withJavaLangCharSequence:(id<JavaLangCharSequence>)cs2
                                     withInt:(jint)options;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextNormalizer)

/*!
 @brief Options bit set value to select Unicode 3.2 normalization
  (except NormalizationCorrections).
 At most one Unicode version can be selected at a time.
 */
inline jint AndroidIcuTextNormalizer_get_UNICODE_3_2(void);
#define AndroidIcuTextNormalizer_UNICODE_3_2 32
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, UNICODE_3_2, jint)

/*!
 @brief Constant indicating that the end of the iteration has been reached.
 This is guaranteed to have the same value as <code>UCharacterIterator.DONE</code>.
 */
inline jint AndroidIcuTextNormalizer_get_DONE(void);
#define AndroidIcuTextNormalizer_DONE -1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, DONE, jint)

/*!
 @brief No decomposition/composition.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_NONE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_NONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NONE, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Canonical decomposition.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_NFD(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_NFD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NFD, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Compatibility decomposition.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_NFKD(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_NFKD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NFKD, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Canonical decomposition followed by canonical composition.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_NFC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_NFC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NFC, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Default normalization.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_DEFAULT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, DEFAULT, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Compatibility decomposition followed by canonical composition.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_NFKC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_NFKC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NFKC, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief "Fast C or D" form.
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_FCD(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_FCD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, FCD, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Null operation for use with the <code>constructors</code>
  and the static <code>normalize</code> method.This value tells
  the <tt>Normalizer</tt> to do nothing but return unprocessed characters
  from the underlying String or CharacterIterator.
 If you have code which
  requires raw text at some times and normalized text at others, you can
  use <tt>NO_OP</tt> for the cases where you want raw text, rather
  than having a separate code path that bypasses <tt>Normalizer</tt>
  altogether. 
 <p>
 - seealso: #setMode
 - seealso: #NONE
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_NO_OP(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_NO_OP;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NO_OP, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Canonical decomposition followed by canonical composition.Used with the 
 <code>constructors</code> and the static 
 <code>normalize</code> method to determine the operation to be
  performed.
 <p>
  If all optional features (<i>e.g.</i> <code>IGNORE_HANGUL</code>) are turned
  off, this operation produces output that is in 
 <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
  Form</a>
  <b>C</b>.
  <p>
 - seealso: #setMode
 - seealso: #NFC
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_COMPOSE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_COMPOSE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, COMPOSE, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Compatibility decomposition followed by canonical composition.
 Used with the <code>constructors</code> and the static 
 <code>normalize</code> method to determine the operation to be
  performed. 
 <p>
  If all optional features (<i>e.g.</i> <code>IGNORE_HANGUL</code>) are turned
  off, this operation produces output that is in 
 <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
  Form</a>
  <b>KC</b>.
  <p>
 - seealso: #setMode
 - seealso: #NFKC
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_COMPOSE_COMPAT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_COMPOSE_COMPAT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, COMPOSE_COMPAT, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Canonical decomposition.This value is passed to the 
 <code>constructors</code> and the static 
 <code>normalize</code>
  method to determine the operation to be performed.
 <p>
  If all optional features (<i>e.g.</i> <code>IGNORE_HANGUL</code>) are turned
  off, this operation produces output that is in 
 <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
  Form</a>
  <b>D</b>.
  <p>
 - seealso: #setMode
 - seealso: #NFD
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_DECOMP(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_DECOMP;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, DECOMP, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Compatibility decomposition.This value is passed to the 
 <code>constructors</code> and the static 
 <code>normalize</code>
  method to determine the operation to be performed.
 <p>
  If all optional features (<i>e.g.</i> <code>IGNORE_HANGUL</code>) are turned
  off, this operation produces output that is in 
 <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
  Form</a>
  <b>KD</b>.
  <p>
 - seealso: #setMode
 - seealso: #NFKD
 */
inline AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_get_DECOMP_COMPAT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_Mode *AndroidIcuTextNormalizer_DECOMP_COMPAT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, DECOMP_COMPAT, AndroidIcuTextNormalizer_Mode *)

/*!
 @brief Option to disable Hangul/Jamo composition and decomposition.
 This option applies to Korean text,
  which can be represented either in the Jamo alphabet or in Hangul
  characters, which are really just two or three Jamo combined
  into one visual glyph.  Since Jamo takes up more storage space than
  Hangul, applications that process only Hangul text may wish to turn
  this option on when decomposing text. 
 <p>
  The Unicode standard treates Hangul to Jamo conversion as a
  canonical decomposition, so this option must be turned <b>off</b> if you
  wish to transform strings into one of the standard 
 <a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
  Unicode Normalization Forms</a>.
  <p>
 - seealso: #setOption
 */
inline jint AndroidIcuTextNormalizer_get_IGNORE_HANGUL(void);
#define AndroidIcuTextNormalizer_IGNORE_HANGUL 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, IGNORE_HANGUL, jint)

/*!
 @brief Indicates that string is not in the normalized format
 */
inline AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_get_NO(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_NO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, NO, AndroidIcuTextNormalizer_QuickCheckResult *)

/*!
 @brief Indicates that string is in the normalized format
 */
inline AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_get_YES(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_YES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, YES, AndroidIcuTextNormalizer_QuickCheckResult *)

/*!
 @brief Indicates it cannot be determined if string is in the normalized
  format without further thorough checks.
 */
inline AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_get_MAYBE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_MAYBE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextNormalizer, MAYBE, AndroidIcuTextNormalizer_QuickCheckResult *)

/*!
 @brief Option bit for compare:
  Case sensitively compare the strings
 */
inline jint AndroidIcuTextNormalizer_get_FOLD_CASE_DEFAULT(void);
#define AndroidIcuTextNormalizer_FOLD_CASE_DEFAULT 0
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, FOLD_CASE_DEFAULT, jint)

/*!
 @brief Option bit for compare:
  Both input strings are assumed to fulfill FCD conditions.
 */
inline jint AndroidIcuTextNormalizer_get_INPUT_IS_FCD(void);
#define AndroidIcuTextNormalizer_INPUT_IS_FCD 131072
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, INPUT_IS_FCD, jint)

/*!
 @brief Option bit for compare:
  Perform case-insensitive comparison.
 */
inline jint AndroidIcuTextNormalizer_get_COMPARE_IGNORE_CASE(void);
#define AndroidIcuTextNormalizer_COMPARE_IGNORE_CASE 65536
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, COMPARE_IGNORE_CASE, jint)

/*!
 @brief Option bit for compare:
  Compare strings in code point order instead of code unit order.
 */
inline jint AndroidIcuTextNormalizer_get_COMPARE_CODE_POINT_ORDER(void);
#define AndroidIcuTextNormalizer_COMPARE_CODE_POINT_ORDER 32768
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, COMPARE_CODE_POINT_ORDER, jint)

/*!
 @brief Option value for case folding:
  Use the modified set of mappings provided in CaseFolding.txt to handle dotted I
  and dotless i appropriately for Turkic languages (tr, az).
 - seealso: UCharacter#FOLD_CASE_EXCLUDE_SPECIAL_I
 */
inline jint AndroidIcuTextNormalizer_get_FOLD_CASE_EXCLUDE_SPECIAL_I(void);
#define AndroidIcuTextNormalizer_FOLD_CASE_EXCLUDE_SPECIAL_I 1
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, FOLD_CASE_EXCLUDE_SPECIAL_I, jint)

/*!
 @brief Lowest-order bit number of compare() options bits corresponding to
  normalization options bits.
 The options parameter for compare() uses most bits for
  itself and for various comparison and folding flags.
  The most significant bits, however, are shifted down and passed on
  to the normalization implementation.
  (That is, from compare(..., options, ...), options
 &gt;&gt;COMPARE_NORM_OPTIONS_SHIFT will be passed on to the
  internal normalization functions.)
 - seealso: #compare
 */
inline jint AndroidIcuTextNormalizer_get_COMPARE_NORM_OPTIONS_SHIFT(void);
#define AndroidIcuTextNormalizer_COMPARE_NORM_OPTIONS_SHIFT 20
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextNormalizer, COMPARE_NORM_OPTIONS_SHIFT, jint)

FOUNDATION_EXPORT void AndroidIcuTextNormalizer_initWithNSString_withAndroidIcuTextNormalizer_Mode_withInt_(AndroidIcuTextNormalizer *self, NSString *str, AndroidIcuTextNormalizer_Mode *mode, jint opt);

FOUNDATION_EXPORT AndroidIcuTextNormalizer *new_AndroidIcuTextNormalizer_initWithNSString_withAndroidIcuTextNormalizer_Mode_withInt_(NSString *str, AndroidIcuTextNormalizer_Mode *mode, jint opt) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextNormalizer *create_AndroidIcuTextNormalizer_initWithNSString_withAndroidIcuTextNormalizer_Mode_withInt_(NSString *str, AndroidIcuTextNormalizer_Mode *mode, jint opt);

FOUNDATION_EXPORT void AndroidIcuTextNormalizer_initWithJavaTextCharacterIterator_withAndroidIcuTextNormalizer_Mode_withInt_(AndroidIcuTextNormalizer *self, id<JavaTextCharacterIterator> iter, AndroidIcuTextNormalizer_Mode *mode, jint opt);

FOUNDATION_EXPORT AndroidIcuTextNormalizer *new_AndroidIcuTextNormalizer_initWithJavaTextCharacterIterator_withAndroidIcuTextNormalizer_Mode_withInt_(id<JavaTextCharacterIterator> iter, AndroidIcuTextNormalizer_Mode *mode, jint opt) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextNormalizer *create_AndroidIcuTextNormalizer_initWithJavaTextCharacterIterator_withAndroidIcuTextNormalizer_Mode_withInt_(id<JavaTextCharacterIterator> iter, AndroidIcuTextNormalizer_Mode *mode, jint opt);

FOUNDATION_EXPORT void AndroidIcuTextNormalizer_initWithAndroidIcuTextUCharacterIterator_withAndroidIcuTextNormalizer_Mode_withInt_(AndroidIcuTextNormalizer *self, AndroidIcuTextUCharacterIterator *iter, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT AndroidIcuTextNormalizer *new_AndroidIcuTextNormalizer_initWithAndroidIcuTextUCharacterIterator_withAndroidIcuTextNormalizer_Mode_withInt_(AndroidIcuTextUCharacterIterator *iter, AndroidIcuTextNormalizer_Mode *mode, jint options) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextNormalizer *create_AndroidIcuTextNormalizer_initWithAndroidIcuTextUCharacterIterator_withAndroidIcuTextNormalizer_Mode_withInt_(AndroidIcuTextUCharacterIterator *iter, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_composeWithNSString_withBoolean_(NSString *str, jboolean compat);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_composeWithNSString_withBoolean_withInt_(NSString *str, jboolean compat, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_composeWithCharArray_withCharArray_withBoolean_withInt_(IOSCharArray *source, IOSCharArray *target, jboolean compat, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_composeWithCharArray_withInt_withInt_withCharArray_withInt_withInt_withBoolean_withInt_(IOSCharArray *src, jint srcStart, jint srcLimit, IOSCharArray *dest, jint destStart, jint destLimit, jboolean compat, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_decomposeWithNSString_withBoolean_(NSString *str, jboolean compat);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_decomposeWithNSString_withBoolean_withInt_(NSString *str, jboolean compat, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_decomposeWithCharArray_withCharArray_withBoolean_withInt_(IOSCharArray *source, IOSCharArray *target, jboolean compat, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_decomposeWithCharArray_withInt_withInt_withCharArray_withInt_withInt_withBoolean_withInt_(IOSCharArray *src, jint srcStart, jint srcLimit, IOSCharArray *dest, jint destStart, jint destLimit, jboolean compat, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_normalizeWithNSString_withAndroidIcuTextNormalizer_Mode_withInt_(NSString *str, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_normalizeWithNSString_withAndroidIcuTextNormalizer_Mode_(NSString *src, AndroidIcuTextNormalizer_Mode *mode);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_normalizeWithCharArray_withCharArray_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *source, IOSCharArray *target, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_normalizeWithCharArray_withInt_withInt_withCharArray_withInt_withInt_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *src, jint srcStart, jint srcLimit, IOSCharArray *dest, jint destStart, jint destLimit, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_normalizeWithInt_withAndroidIcuTextNormalizer_Mode_withInt_(jint char32, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_normalizeWithInt_withAndroidIcuTextNormalizer_Mode_(jint char32, AndroidIcuTextNormalizer_Mode *mode);

FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_quickCheckWithNSString_withAndroidIcuTextNormalizer_Mode_(NSString *source, AndroidIcuTextNormalizer_Mode *mode);

FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_quickCheckWithNSString_withAndroidIcuTextNormalizer_Mode_withInt_(NSString *source, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_quickCheckWithCharArray_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *source, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT AndroidIcuTextNormalizer_QuickCheckResult *AndroidIcuTextNormalizer_quickCheckWithCharArray_withInt_withInt_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *source, jint start, jint limit, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT jboolean AndroidIcuTextNormalizer_isNormalizedWithCharArray_withInt_withInt_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *src, jint start, jint limit, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT jboolean AndroidIcuTextNormalizer_isNormalizedWithNSString_withAndroidIcuTextNormalizer_Mode_withInt_(NSString *str, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT jboolean AndroidIcuTextNormalizer_isNormalizedWithInt_withAndroidIcuTextNormalizer_Mode_withInt_(jint char32, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_compareWithCharArray_withInt_withInt_withCharArray_withInt_withInt_withInt_(IOSCharArray *s1, jint s1Start, jint s1Limit, IOSCharArray *s2, jint s2Start, jint s2Limit, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_compareWithNSString_withNSString_withInt_(NSString *s1, NSString *s2, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_compareWithCharArray_withCharArray_withInt_(IOSCharArray *s1, IOSCharArray *s2, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_compareWithInt_withInt_withInt_(jint char32a, jint char32b, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_compareWithInt_withNSString_withInt_(jint char32a, NSString *str2, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_concatenateWithCharArray_withInt_withInt_withCharArray_withInt_withInt_withCharArray_withInt_withInt_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *left, jint leftStart, jint leftLimit, IOSCharArray *right, jint rightStart, jint rightLimit, IOSCharArray *dest, jint destStart, jint destLimit, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_concatenateWithCharArray_withCharArray_withAndroidIcuTextNormalizer_Mode_withInt_(IOSCharArray *left, IOSCharArray *right, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_concatenateWithNSString_withNSString_withAndroidIcuTextNormalizer_Mode_withInt_(NSString *left, NSString *right, AndroidIcuTextNormalizer_Mode *mode, jint options);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_getFC_NFKC_ClosureWithInt_withCharArray_(jint c, IOSCharArray *dest);

FOUNDATION_EXPORT NSString *AndroidIcuTextNormalizer_getFC_NFKC_ClosureWithInt_(jint c);

FOUNDATION_EXPORT jint AndroidIcuTextNormalizer_cmpEquivFoldWithJavaLangCharSequence_withJavaLangCharSequence_withInt_(id<JavaLangCharSequence> cs1, id<JavaLangCharSequence> cs2, jint options);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNormalizer)

#endif

#if !defined (AndroidIcuTextNormalizer_Mode_) && (INCLUDE_ALL_AndroidIcuTextNormalizer || defined(INCLUDE_AndroidIcuTextNormalizer_Mode))
#define AndroidIcuTextNormalizer_Mode_

@class AndroidIcuTextNormalizer2;

/*!
 @brief Constants for normalization modes.
 <p>
  The Mode class is not intended for public subclassing.
  Only the Mode constants provided by the Normalizer class should be used,
  and any fields or methods should not be called or overridden by users.
 */
__attribute__((deprecated))
@interface AndroidIcuTextNormalizer_Mode : NSObject

#pragma mark Protected

/*!
 @brief Sole constructor
 */
- (instancetype __nonnull)init __attribute__((deprecated));

/*!
 */
- (AndroidIcuTextNormalizer2 *)getNormalizer2WithInt:(jint)options __attribute__((deprecated));

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextNormalizer_Mode)

FOUNDATION_EXPORT void AndroidIcuTextNormalizer_Mode_init(AndroidIcuTextNormalizer_Mode *self);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNormalizer_Mode)

#endif

#if !defined (AndroidIcuTextNormalizer_QuickCheckResult_) && (INCLUDE_ALL_AndroidIcuTextNormalizer || defined(INCLUDE_AndroidIcuTextNormalizer_QuickCheckResult))
#define AndroidIcuTextNormalizer_QuickCheckResult_

/*!
 @brief Result values for quickCheck().
 For details see Unicode Technical Report 15.
 */
@interface AndroidIcuTextNormalizer_QuickCheckResult : NSObject

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextNormalizer_QuickCheckResult)

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextNormalizer_QuickCheckResult)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuTextNormalizer")
