//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/SelectFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuTextSelectFormat")
#ifdef RESTRICT_AndroidIcuTextSelectFormat
#define INCLUDE_ALL_AndroidIcuTextSelectFormat 0
#else
#define INCLUDE_ALL_AndroidIcuTextSelectFormat 1
#endif
#undef RESTRICT_AndroidIcuTextSelectFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuTextSelectFormat_) && (INCLUDE_ALL_AndroidIcuTextSelectFormat || defined(INCLUDE_AndroidIcuTextSelectFormat))
#define AndroidIcuTextSelectFormat_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat 1
#include "java/text/Format.h"

@class AndroidIcuTextMessagePattern;
@class JavaLangStringBuffer;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;

/*!
 @brief <p><code>SelectFormat</code> supports the creation of  internationalized
  messages by selecting phrases based on keywords.
 The pattern  specifies
  how to map keywords to phrases and provides a default phrase. The
  object provided to the format method is a string that's matched
  against the keywords. If there is a match, the corresponding phrase
  is selected; otherwise, the default phrase is used. 
 <h3>Using <code>SelectFormat</code> for Gender Agreement</h3>
  
 <p>Note: Typically, select formatting is done via <code>MessageFormat</code>
  with a <code>select</code> argument type,
  rather than using a stand-alone <code>SelectFormat</code>.
  
 <p>The main use case for the select format is gender based  inflection.
  When names or nouns are inserted into sentences, their gender can  affect pronouns,
  verb forms, articles, and adjectives. Special care needs to be
  taken for the case where the gender cannot be determined.
  The impact varies between languages: 
 <ul>
  <li>English has three genders, and unknown gender is handled as a  special
  case. Names use the gender of the named person (if known), nouns  referring
  to people use natural gender, and inanimate objects are usually  neutral.
  The gender only affects pronouns: "he", "she", "it", "they". 
 <li>German differs from English in that the gender of nouns is  rather
  arbitrary, even for nouns referring to people ("M&#xE4;dchen", girl, is  neutral).
  The gender affects pronouns ("er", "sie", "es"), articles ("der",  "die",
  "das"), and adjective forms ("guter Mann", "gute Frau", "gutes  M&#xE4;dchen").
  
 <li>French has only two genders; as in German the gender of nouns
  is rather arbitrary - for sun and moon, the genders
  are the opposite of those in German. The gender affects
  pronouns ("il", "elle"), articles ("le", "la"),
  adjective forms ("bon", "bonne"), and sometimes
  verb forms ("all&#xE9;", "all&#xE9;e").
  
 <li>Polish distinguishes five genders (or noun classes),
  human masculine, animate non-human masculine, inanimate masculine,
  feminine, and neuter. 
 </ul>
  
 <p>Some other languages have noun classes that are not related to  gender,
  but similar in grammatical use.
  Some African languages have around 20 noun classes. 
 <p><b>Note:</b>For the gender of a <i>person</i> in a given sentence,
  we usually need to distinguish only between female, male and other/unknown. 
 <p>To enable localizers to create sentence patterns that take their
  language's gender dependencies into consideration, software has to  provide
  information about the gender associated with a noun or name to 
 <code>MessageFormat</code>.
  Two main cases can be distinguished: 
 <ul>
  <li>For people, natural gender information should be maintained  for each person.
  Keywords like "male", "female", "mixed" (for groups of people)
  and "unknown" could be used. 
 <li>For nouns, grammatical gender information should be maintained  for
  each noun and per language, e.g., in resource bundles.
  The keywords "masculine", "feminine", and "neuter" are commonly  used,
  but some languages may require other keywords. 
 </ul>
  
 <p>The resulting keyword is provided to <code>MessageFormat</code>  as a
  parameter separate from the name or noun it's associated with. For  example,
  to generate a message such as "Jean went to Paris", three separate  arguments
  would be provided: The name of the person as argument 0, the  gender of
  the person as argument 1, and the name of the city as argument 2.
  The sentence pattern for English, where the gender of the person has
  no impact on this simple sentence, would not refer to argument 1  at all: 
 @code
{0} went to {2}.
@endcode
  
 <p><b>Note:</b> The entire sentence should be included (and partially repeated)
  inside each phrase. Otherwise translators would have to be trained on how to
  move bits of the sentence in and out of the select argument of a message.
  (The examples below do not follow this recommendation!)  
 <p>The sentence pattern for French, where the gender of the person affects
  the form of the participle, uses a select format based on argument 1: 
 @code
{0} est {1, select, female {all&#xE9;e} other {all&#xE9;}} &#xE0; {2}.
@endcode
  
 <p>Patterns can be nested, so that it's possible to handle  interactions of
  number and gender where necessary. For example, if the above  sentence should
  allow for the names of several people to be inserted, the  following sentence
  pattern can be used (with argument 0 the list of people's names,  
  argument 1 the number of people, argument 2 their combined gender, and  
  argument 3 the city name): 
 @code
{0} {1, plural, 
  one {est {2, select, female {all&#xE9;e} other  {all&#xE9;}}}
  other {sont {2, select, female {all&#xE9;es} other {all&#xE9;s}}}
  }&#xE0; {3}.
@endcode
  
 <h4>Patterns and Their Interpretation</h4>
  
 <p>The <code>SelectFormat</code> pattern string defines the phrase  output
  for each user-defined keyword.
  The pattern is a sequence of (keyword, message) pairs.
  A keyword is a "pattern identifier": [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+ 
 <p>Each message is a MessageFormat pattern string enclosed in {curly braces}. 
 <p>You always have to define a phrase for the default keyword 
 <code>other</code>; this phrase is returned when the keyword  
  provided to
  the <code>format</code> method matches no other keyword.
  If a pattern does not provide a phrase for <code>other</code>, the  method
  it's provided to returns the error  <code>U_DEFAULT_KEYWORD_MISSING</code>.
  <br>
  Pattern_White_Space between keywords and messages is ignored.
  Pattern_White_Space within a message is preserved and output. 
 @code
Example:
  MessageFormat msgFmt = new MessageFormat("{0} est " +
      "{1, select, female {all&#xE9;e} other {all&#xE9;}} &#xE0; Paris.",
      new ULocale("fr"));
  Object args[] = {"Kirti","female"};
  System.out.println(msgFmt.format(args)); 
  
@endcode
  <p>
  Produces the output:<br>
  <code>Kirti est all&#xE9;e &#xE0; Paris.</code>
 */
@interface AndroidIcuTextSelectFormat : JavaTextFormat

#pragma mark Public

/*!
 @brief Creates a new <code>SelectFormat</code> for a given pattern string.
 @param pattern the pattern for this  <code> SelectFormat </code>
  .
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern;

/*!
 @brief Sets the pattern used by this select format.
 Patterns and their interpretation are specified in the class description.
 @param pattern the pattern for this select format.
 @throw IllegalArgumentExceptionwhen the pattern is not a valid select format pattern.
 */
- (void)applyPatternWithNSString:(NSString *)pattern;

/*!
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Selects the phrase for the given keyword.
 and appends the formatted message to the given <code>StringBuffer</code>.
 @param keyword a phrase selection keyword.
 @param toAppendTo the selected phrase will be appended to this         
  <code> StringBuffer </code> .
 @param pos will be ignored by this method.
 @throw IllegalArgumentExceptionwhen the given keyword is not a String
          or not a "pattern identifier"
 @return the string buffer passed in as toAppendTo, with formatted text
          appended.
 */
- (JavaLangStringBuffer *)formatWithId:(id)keyword
              withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Selects the phrase for the given keyword.
 @param keyword a phrase selection keyword.
 @return the string containing the formatted select message.
 @throw IllegalArgumentExceptionwhen the given keyword is not a "pattern identifier"
 */
- (NSString *)formatWithNSString:(NSString *)keyword;

/*!
 */
- (NSUInteger)hash;

/*!
 @brief This method is not supported by <code>SelectFormat</code>.
 @param source the string to be parsed.
 @param pos defines the position where parsing is to begin,  and upon return, the position where parsing left off.  If the position
   has not changed upon return, then parsing failed.
 @return nothing because this method is not supported.
 @throw UnsupportedOperationExceptionthrown always.
 */
- (id)parseObjectWithNSString:(NSString *)source
    withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Returns the pattern for this <code>SelectFormat</code>
 @return the pattern string
 */
- (NSString *)toPattern;

/*!
 */
- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Finds the SelectFormat sub-message for the given keyword, or the "other" sub-message.
 @param pattern A MessagePattern.
 @param partIndex the index of the first SelectFormat argument style part.
 @param keyword a keyword to be matched to one of the SelectFormat argument's keywords.
 @return the sub-message start part index.
 */
+ (jint)findSubMessageWithAndroidIcuTextMessagePattern:(AndroidIcuTextMessagePattern *)pattern
                                               withInt:(jint)partIndex
                                          withNSString:(NSString *)keyword;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidIcuTextSelectFormat)

FOUNDATION_EXPORT void AndroidIcuTextSelectFormat_initWithNSString_(AndroidIcuTextSelectFormat *self, NSString *pattern);

FOUNDATION_EXPORT AndroidIcuTextSelectFormat *new_AndroidIcuTextSelectFormat_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextSelectFormat *create_AndroidIcuTextSelectFormat_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT jint AndroidIcuTextSelectFormat_findSubMessageWithAndroidIcuTextMessagePattern_withInt_withNSString_(AndroidIcuTextMessagePattern *pattern, jint partIndex, NSString *keyword);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextSelectFormat)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuTextSelectFormat")
