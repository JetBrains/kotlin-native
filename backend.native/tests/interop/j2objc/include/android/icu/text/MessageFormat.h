//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/external/icu/android_icu4j/src/main/java/android/icu/text/MessageFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AndroidIcuTextMessageFormat")
#ifdef RESTRICT_AndroidIcuTextMessageFormat
#define INCLUDE_ALL_AndroidIcuTextMessageFormat 0
#else
#define INCLUDE_ALL_AndroidIcuTextMessageFormat 1
#endif
#undef RESTRICT_AndroidIcuTextMessageFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (AndroidIcuTextMessageFormat_) && (INCLUDE_ALL_AndroidIcuTextMessageFormat || defined(INCLUDE_AndroidIcuTextMessageFormat))
#define AndroidIcuTextMessageFormat_

#define RESTRICT_AndroidIcuTextUFormat 1
#define INCLUDE_AndroidIcuTextUFormat 1
#include "android/icu/text/UFormat.h"

@class AndroidIcuTextMessagePattern_ApostropheMode;
@class AndroidIcuUtilULocale;
@class IOSObjectArray;
@class JavaLangStringBuffer;
@class JavaTextFieldPosition;
@class JavaTextFormat;
@class JavaTextParsePosition;
@class JavaUtilLocale;
@protocol JavaTextAttributedCharacterIterator;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/*!
 @brief <strong>[icu enhancement]</strong> ICU's replacement for <code>java.text.MessageFormat</code>.
 &nbsp;Methods, fields, and other functionality specific to ICU are labeled '<strong>[icu]</strong>'.
 <p>MessageFormat prepares strings for display to users,
  with optional arguments (variables/placeholders).
  The arguments can occur in any order, which is necessary for translation
  into languages with different grammars. 
 <p>A MessageFormat is constructed from a <em>pattern</em> string
  with arguments in {curly braces} which will be replaced by formatted values. 
 <p><code>MessageFormat</code> differs from the other <code>Format</code>
  classes in that you create a <code>MessageFormat</code> object with one
  of its constructors (not with a <code>getInstance</code> style factory
  method). Factory methods aren't necessary because <code>MessageFormat</code>
  itself doesn't implement locale-specific behavior. Any locale-specific
  behavior is defined by the pattern that you provide and the
  subformats used for inserted arguments. 
 <p>Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers).
  Some of the API methods work only with argument numbers and throw an exception
  if the pattern has named arguments (see <code>usesNamedArguments()</code>).
  
 <p>An argument might not specify any format type. In this case,
  a Number value is formatted with a default (for the locale) NumberFormat,
  a Date value is formatted with a default (for the locale) DateFormat,
  and for any other value its toString() value is used. 
 <p>An argument might specify a "simple" type for which the specified
  Format object is created, cached and used. 
 <p>An argument might have a "complex" type with nested MessageFormat sub-patterns.
  During formatting, one of these sub-messages is selected according to the argument value
  and recursively formatted. 
 <p>After construction, a custom Format object can be set for
  a top-level argument, overriding the default formatting and parsing behavior
  for that argument.
  However, custom formatting can be achieved more simply by writing
  a typeless argument in the pattern string
  and supplying it with a preformatted string value. 
 <p>When formatting, MessageFormat takes a collection of argument values
  and writes an output string.
  The argument values may be passed as an array
  (when the pattern contains only numbered arguments)
  or as a Map (which works for both named and numbered arguments). 
 <p>Each argument is matched with one of the input values by array index or map key
  and formatted according to its pattern specification
  (or using a custom Format object if one was set).
  A numbered pattern argument is matched with a map key that contains that number
  as an ASCII-decimal-digit string (without leading zero). 
 <h3><a name="patterns">Patterns and Their Interpretation</a></h3>
  
 <code>MessageFormat</code> uses patterns of the following form: 
 <blockquote>@code

  message = messageText (argument messageText)*
  argument = noneArg | simpleArg | complexArg
  complexArg = choiceArg | pluralArg | selectArg | selectordinalArg
  noneArg = '{' argNameOrNumber '}'
  simpleArg = '{' argNameOrNumber ',' argType [',' argStyle] '}'
  choiceArg = '{' argNameOrNumber ',' "choice" ',' choiceStyle '}'
  pluralArg = '{' argNameOrNumber ',' "plural" ',' pluralStyle '}'
  selectArg = '{' argNameOrNumber ',' "select" ',' selectStyle '}'
  selectordinalArg = '{' argNameOrNumber ',' "selectordinal" ',' pluralStyle '}'
  choiceStyle: see <code>ChoiceFormat</code>
  pluralStyle: see <code>PluralFormat</code>
  selectStyle: see <code>SelectFormat</code>
  argNameOrNumber = argName | argNumber
  argName = [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+
  argNumber = '0' | ('1'..'9' ('0'..'9')*)
  argType = "number" | "date" | "time" | "spellout" | "ordinal" | "duration"
  argStyle = "short" | "medium" | "long" | "full" | "integer" | "currency" | "percent" | argStyleText 
  
@endcode</blockquote>
  
 <ul>
    <li>messageText can contain quoted literal strings including syntax characters.
        A quoted literal string begins with an ASCII apostrophe and a syntax character
        (usually a {curly brace}) and continues until the next single apostrophe.
        A double ASCII apostrohpe inside or outside of a quoted string represents
        one literal apostrophe.   
 <li>Quotable syntax characters are the {curly braces} in all messageText parts,
        plus the '#' sign in a messageText immediately inside a pluralStyle,
        and the '|' symbol in a messageText immediately inside a choiceStyle.   
 <li>See also <code>MessagePattern.ApostropheMode</code>
    <li>In argStyleText, every single ASCII apostrophe begins and ends quoted literal text,
        and unquoted {curly braces} must occur in matched pairs. 
 </ul>
  
 <p>Recommendation: Use the real apostrophe (single quote) character â€™ for human-readable text, and use the ASCII apostrophe (' ' )
  only in program syntax, like quoting in MessageFormat.
  See the annotations for U+0027 Apostrophe in The Unicode Standard. 
 <p>The <code>choice</code> argument type is deprecated.
  Use <code>plural</code> arguments for proper plural selection,
  and <code>select</code> arguments for simple selection among a fixed set of choices. 
 <p>The <code>argType</code> and <code>argStyle</code> values are used to create
  a <code>Format</code> instance for the format element. The following
  table shows how the values map to Format instances. Combinations not
  shown in the table are illegal. Any <code>argStyleText</code> must
  be a valid pattern string for the Format subclass used. 
 <table border=1>
     <tr>
        <th>argType
        <th>argStyle
        <th>resulting Format object
     <tr>
        <td colspan=2><i>(none)</i>
        <td><code>null</code>
     <tr>
        <td rowspan=5><code>number</code>
        <td><i>(none)</i>
        <td><code>NumberFormat.getInstance(getLocale())</code>
     <tr>
        <td><code>integer</code>
        <td><code>NumberFormat.getIntegerInstance(getLocale())</code>
     <tr>
        <td><code>currency</code>
        <td><code>NumberFormat.getCurrencyInstance(getLocale())</code>
     <tr>
        <td><code>percent</code>
        <td><code>NumberFormat.getPercentInstance(getLocale())</code>
     <tr>
        <td><i>argStyleText</i>
        <td><code>new DecimalFormat(argStyleText, new DecimalFormatSymbols(getLocale()))</code>
     <tr>
        <td rowspan=6><code>date</code>
        <td><i>(none)</i>
        <td><code>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</code>
     <tr>
        <td><code>short</code>
        <td><code>DateFormat.getDateInstance(DateFormat.SHORT, getLocale())</code>
     <tr>
        <td><code>medium</code>
        <td><code>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</code>
     <tr>
        <td><code>long</code>
        <td><code>DateFormat.getDateInstance(DateFormat.LONG, getLocale())</code>
     <tr>
        <td><code>full</code>
        <td><code>DateFormat.getDateInstance(DateFormat.FULL, getLocale())</code>
     <tr>
        <td><i>argStyleText</i>
        <td><code>new SimpleDateFormat(argStyleText, getLocale())</code>
     <tr>
        <td rowspan=6><code>time</code>
        <td><i>(none)</i>
        <td><code>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</code>
     <tr>
        <td><code>short</code>
        <td><code>DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())</code>
     <tr>
        <td><code>medium</code>
        <td><code>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</code>
     <tr>
        <td><code>long</code>
        <td><code>DateFormat.getTimeInstance(DateFormat.LONG, getLocale())</code>
     <tr>
        <td><code>full</code>
        <td><code>DateFormat.getTimeInstance(DateFormat.FULL, getLocale())</code>
     <tr>
        <td><i>argStyleText</i>
        <td><code>new SimpleDateFormat(argStyleText, getLocale())</code>
     <tr>
        <td><code>spellout</code>
        <td><i>argStyleText (optional)</i>
        <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.SPELLOUT)
            <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>
     <tr>
        <td><code>ordinal</code>
        <td><i>argStyleText (optional)</i>
        <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.ORDINAL)
            <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>
     <tr>
        <td><code>duration</code>
        <td><i>argStyleText (optional)</i>
        <td><code>new RuleBasedNumberFormat(getLocale(), RuleBasedNumberFormat.DURATION)
            <br>&nbsp;&nbsp;&nbsp;&nbsp;.setDefaultRuleset(argStyleText);</code>
  </table>
  
 <h4><a name="diffsjdk">Differences from java.text.MessageFormat</a></h4>
  
 <p>The ICU MessageFormat supports both named and numbered arguments,
  while the JDK MessageFormat only supports numbered arguments.
  Named arguments make patterns more readable. 
 <p>ICU implements a more user-friendly apostrophe quoting syntax.
  In message text, an apostrophe only begins quoting literal text
  if it immediately precedes a syntax character (mostly {curly braces}).<br>
  In the JDK MessageFormat, an apostrophe always begins quoting,
  which requires common text like "don't" and "aujourd'hui"
  to be written with doubled apostrophes like "don''t" and "aujourd''hui".
  For more details see <code>MessagePattern.ApostropheMode</code>.
  
 <p>ICU does not create a ChoiceFormat object for a choiceArg, pluralArg or selectArg
  but rather handles such arguments itself.
  The JDK MessageFormat does create and use a ChoiceFormat object
  (<code>new ChoiceFormat(argStyleText)</code>).
  The JDK does not support plural and select arguments at all. 
 <h4>Usage Information</h4>
  
 <p>Here are some examples of usage: 
 <blockquote>
  @code

  Object[] arguments = {
      7,
      new Date(System.currentTimeMillis()),
      "a disturbance in the Force"
  };
  String result = MessageFormat.format(
      "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
      arguments); 
  <em>output</em>: At 12:30 PM on Jul 3, 2053, there was a disturbance
            in the Force on planet 7. 
  
@endcode
  </blockquote>
  Typically, the message format will come from resources, and the
  arguments will be dynamically set at runtime. 
 <p>Example 2: 
 <blockquote>
  @code

  Object[] testArgs = { 3, "MyDisk" };
  MessageFormat form = new MessageFormat(
      "The disk \"{1}\" contains {0} file(s).");
  System.out.println(form.format(testArgs));
  // output, with different testArgs 
  <em>output</em>: The disk "MyDisk" contains 0 file(s). 
  <em>output</em>: The disk "MyDisk" contains 1 file(s). 
  <em>output</em>: The disk "MyDisk" contains 1,273 file(s). 
  
@endcode
  </blockquote>
  
 <p>For messages that include plural forms, you can use a plural argument: 
 @code

  MessageFormat msgFmt = new MessageFormat(
      "{num_files, plural, " +
      "=0{There are no files on disk \"{disk_name}\".}" +
      "=1{There is one file on disk \"{disk_name}\".}" +
      "other{There are # files on disk \"{disk_name}\".}}",
      ULocale.ENGLISH);
  Map args = new HashMap();
  args.put("num_files", 0);
  args.put("disk_name", "MyDisk");
  System.out.println(msgFmt.format(args));
  args.put("num_files", 3);
  System.out.println(msgFmt.format(args)); 
  <em>output</em>:
  There are no files on disk "MyDisk".
  There are 3 files on "MyDisk". 
  
@endcode
  See <code>PluralFormat</code> and <code>PluralRules</code> for details. 
 <h4><a name="synchronization">Synchronization</a></h4>
  
 <p>MessageFormats are not synchronized.
  It is recommended to create separate format instances for each thread.
  If multiple threads access a format concurrently, it must be synchronized
  externally.
 - seealso: java.util.Locale
 - seealso: Format
 - seealso: NumberFormat
 - seealso: DecimalFormat
 - seealso: ChoiceFormat
 - seealso: PluralFormat
 - seealso: SelectFormat
 @author Mark Davis
 @author Markus Scherer
 */
@interface AndroidIcuTextMessageFormat : AndroidIcuTextUFormat
@property (readonly, class) jlong serialVersionUID NS_SWIFT_NAME(serialVersionUID);

+ (jlong)serialVersionUID;

#pragma mark Public

/*!
 @brief Constructs a MessageFormat for the default <code>FORMAT</code> locale and the
  specified pattern.
 Sets the locale and calls applyPattern(pattern).
 @param pattern the pattern for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 - seealso: Category#FORMAT
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern;

/*!
 @brief Constructs a MessageFormat for the specified locale and
  pattern.
 Sets the locale and calls applyPattern(pattern).
 @param pattern the pattern for this message format
 @param locale the locale for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                        withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Constructs a MessageFormat for the specified locale and
  pattern.
 Sets the locale and calls applyPattern(pattern).
 @param pattern the pattern for this message format
 @param locale the locale for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                 withAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Sets the pattern used by this message format.
 Parses the pattern and caches Format objects for simple argument types.
  Patterns and their interpretation are specified in the 
 <a href="#patterns">class description</a>.
 @param pttrn the pattern for this message format
 @throw IllegalArgumentExceptionif the pattern is invalid
 */
- (void)applyPatternWithNSString:(NSString *)pttrn;

/*!
 @brief <strong>[icu]</strong> Sets the ApostropheMode and the pattern used by this message format.
 Parses the pattern and caches Format objects for simple argument types.
  Patterns and their interpretation are specified in the 
 <a href="#patterns">class description</a>.
  <p>
  This method is best used only once on a given object to avoid confusion about the mode,
  and after constructing the object with an empty pattern string to minimize overhead.
 @param pattern the pattern for this message format
 @param aposMode the new ApostropheMode
 @throw IllegalArgumentExceptionif the pattern is invalid
 - seealso: MessagePattern.ApostropheMode
 */
- (void)applyPatternWithNSString:(NSString *)pattern
withAndroidIcuTextMessagePattern_ApostropheMode:(AndroidIcuTextMessagePattern_ApostropheMode *)aposMode;

/*!
 @brief <strong>[icu]</strong> Converts an 'apostrophe-friendly' pattern into a standard
  pattern.
 <em>This is obsolete for ICU 4.8 and higher MessageFormat pattern strings.</em>
  It can still be useful together with <code>java.text.MessageFormat</code>.
  
 <p>See the class description for more about apostrophes and quoting,
  and differences between ICU and <code>java.text.MessageFormat</code>.
  
 <p><code>java.text.MessageFormat</code> and ICU 4.6 and earlier MessageFormat
  treat all ASCII apostrophes as
  quotes, which is problematic in some languages, e.g.
  French, where apostrophe is commonly used.  This utility
  assumes that only an unpaired apostrophe immediately before
  a brace is a true quote.  Other unpaired apostrophes are paired,
  and the resulting standard pattern string is returned. 
 <p><b>Note</b>: It is not guaranteed that the returned pattern
  is indeed a valid pattern.  The only effect is to convert
  between patterns having different quoting semantics. 
 <p><b>Note</b>: This method only works on top-level messageText,
  not messageText nested inside a complexArg.
 @param pattern the 'apostrophe-friendly' pattern to convert
 @return the standard equivalent of the original pattern
 */
+ (NSString *)autoQuoteApostropheWithNSString:(NSString *)pattern;

/*!
 */
- (id)java_clone;

/*!
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Formats a map of objects and appends the <code>MessageFormat</code>'s
  pattern, with arguments replaced by the formatted objects, to the
  provided <code>StringBuffer</code>.
 <p>
  The text substituted for the individual format elements is derived from
  the current subformat of the format element and the 
 <code>arguments</code> value corresopnding to the format element's
  argument name. 
 <p>
  A numbered pattern argument is matched with a map key that contains that number
  as an ASCII-decimal-digit string (without leading zero). 
 <p>
  An argument is <i>unavailable</i> if <code>arguments</code> is 
 <code>null</code> or does not have a value corresponding to an argument
  name in the pattern.  When an argument is unavailable no substitution
  is performed.
 @param arguments a map of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired.             On output: the offsets of the alignment field.
 @throw IllegalArgumentExceptionif a value in the
          <code>arguments</code> array is not of the type
          expected by the corresponding argument or custom Format object.
 @return the passed-in StringBuffer
 */
- (JavaLangStringBuffer *)formatWithJavaUtilMap:(id<JavaUtilMap>)arguments
                       withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                      withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Formats a map or array of objects and appends the <code>MessageFormat</code>'s
  pattern, with format elements replaced by the formatted objects, to the
  provided <code>StringBuffer</code>.
 This is equivalent to either of 
 <blockquote>
      <code><code>format</code>
 ((Object[]) arguments, result, pos)</code>
      <code><code>format</code>
 ((Map) arguments, result, pos)</code>
  </blockquote>
  A map must be provided if this format uses named arguments, otherwise
  an IllegalArgumentException will be thrown.
 @param arguments a map or array of objects to be formatted
 @param result where text is appended
 @param pos On input: an alignment field, if desired             On output: the offsets of the alignment field
 @throw IllegalArgumentExceptionif an argument in
          <code>arguments</code> is not of the type
          expected by the format element(s) that use it
 @throw IllegalArgumentExceptionif <code>arguments</code> is
          an array of Object and this format uses named arguments
 */
- (JavaLangStringBuffer *)formatWithId:(id)arguments
              withJavaLangStringBuffer:(JavaLangStringBuffer *)result
             withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Formats an array of objects and appends the <code>MessageFormat</code>'s
  pattern, with arguments replaced by the formatted objects, to the
  provided <code>StringBuffer</code>.
 <p>
  The text substituted for the individual format elements is derived from
  the current subformat of the format element and the 
 <code>arguments</code> element at the format element's argument index
  as indicated by the first matching line of the following table. An
  argument is <i>unavailable</i> if <code>arguments</code> is 
 <code>null</code> or has fewer than argumentIndex+1 elements.  When
  an argument is unavailable no substitution is performed. 
 <table border=1>
     <tr>
        <th>argType or Format
        <th>value object
        <th>Formatted Text
     <tr>
        <td><i>any</i>
        <td><i>unavailable</i>
        <td><code>"{" + argNameOrNumber + "}"</code>
     <tr>
        <td><i>any</i>
        <td><code>null</code>
        <td><code>"null"</code>
     <tr>
        <td>custom Format <code>!= null</code>
        <td><i>any</i>
        <td><code>customFormat.format(argument)</code>
     <tr>
        <td>noneArg, or custom Format <code>== null</code>
        <td><code>instanceof Number</code>
        <td><code>NumberFormat.getInstance(getLocale()).format(argument)</code>
     <tr>
        <td>noneArg, or custom Format <code>== null</code>
        <td><code>instanceof Date</code>
        <td><code>DateFormat.getDateTimeInstance(DateFormat.SHORT,
            DateFormat.SHORT, getLocale()).format(argument)</code>
     <tr>
        <td>noneArg, or custom Format <code>== null</code>
        <td><code>instanceof String</code>
        <td><code>argument</code>
     <tr>
        <td>noneArg, or custom Format <code>== null</code>
        <td><i>any</i>
        <td><code>argument.toString()</code>
     <tr>
        <td>complexArg
        <td><i>any</i>
        <td>result of recursive formatting of a selected sub-message 
 </table>
  <p>
  If <code>pos</code> is non-null, and refers to 
 <code>Field.ARGUMENT</code>, the location of the first formatted
  string will be returned.
  This method is only supported when the format does not use named
  arguments, otherwise an IllegalArgumentException is thrown.
 @param arguments an array of objects to be formatted and substituted.
 @param result where text is appended.
 @param pos On input: an alignment field, if desired.             On output: the offsets of the alignment field.
 @throw IllegalArgumentExceptionif a value in the
          <code>arguments</code> array is not of the type
          expected by the corresponding argument or custom Format object.
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
- (JavaLangStringBuffer *)formatWithNSObjectArray:(IOSObjectArray *)arguments
                         withJavaLangStringBuffer:(JavaLangStringBuffer *)result
                        withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Creates a MessageFormat with the given pattern and uses it to
  format the given arguments.The pattern must identifyarguments
  by name instead of by number.
 <p>
 @throw IllegalArgumentExceptionif the pattern is invalid
 @throw IllegalArgumentExceptionif a value in the
          <code>arguments</code> array is not of the type
          expected by the corresponding argument or custom Format object.
 - seealso: #format(Map, StringBuffer, FieldPosition)
 - seealso: #format(String, Object[])
 */
+ (NSString *)formatWithNSString:(NSString *)pattern
                 withJavaUtilMap:(id<JavaUtilMap>)arguments;

/*!
 @brief Creates a MessageFormat with the given pattern and uses it
  to format the given arguments.This is equivalent to 
 <blockquote>
      <code>(new <code>MessageFormat</code>(pattern)).
 <code>format</code>
 (arguments, new StringBuffer(), null).toString()</code>
  </blockquote>
 @throw IllegalArgumentExceptionif the pattern is invalid
 @throw IllegalArgumentExceptionif a value in the
          <code>arguments</code> array is not of the type
          expected by the corresponding argument or custom Format object.
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
+ (NSString *)formatWithNSString:(NSString *)pattern
               withNSObjectArray:(IOSObjectArray *)arguments;

/*!
 @brief Formats an array of objects and inserts them into the 
 <code>MessageFormat</code>'s pattern, producing an 
 <code>AttributedCharacterIterator</code>.
 You can use the returned <code>AttributedCharacterIterator</code>
  to build the resulting String, as well as to determine information
  about the resulting String. 
 <p>
  The text of the returned <code>AttributedCharacterIterator</code> is
  the same that would be returned by 
 <blockquote>
      <code><code>format</code>
 (arguments, new StringBuffer(), null).toString()</code>
  </blockquote>
  <p>
  In addition, the <code>AttributedCharacterIterator</code> contains at
  least attributes indicating where text was generated from an
  argument in the <code>arguments</code> array. The keys of these attributes are of
  type <code>MessageFormat.Field</code>, their values are 
 <code>Integer</code> objects indicating the index in the <code>arguments</code>
  array of the argument from which the text was generated. 
 <p>
  The attributes/value from the underlying <code>Format</code>
  instances that <code>MessageFormat</code> uses will also be
  placed in the resulting <code>AttributedCharacterIterator</code>.
  This allows you to not only find where an argument is placed in the
  resulting String, but also which fields it contains in turn.
 @param arguments an array of objects to be formatted and substituted.
 @return AttributedCharacterIterator describing the formatted value.
 @throw NullPointerExceptionif <code>arguments</code> is null.
 @throw IllegalArgumentExceptionif a value in the
          <code>arguments</code> array is not of the type
          expected by the corresponding argument or custom Format object.
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)arguments;

/*!
 @brief <strong>[icu]</strong>
 @return this instance's ApostropheMode.
 */
- (AndroidIcuTextMessagePattern_ApostropheMode *)getApostropheMode;

/*!
 @brief <strong>[icu]</strong> Returns the top-level argument names.For more details, see 
 <code>setFormatByArgumentName(String, Format)</code>.
 @return a Set of argument names
 */
- (id<JavaUtilSet>)getArgumentNames;

/*!
 @brief <strong>[icu]</strong> Returns the first top-level format associated with the given argument name.
 For more details, see <code>setFormatByArgumentName(String, Format)</code>.
 @param argumentName The name of the desired argument.
 @return the Format associated with the name, or null if there isn't one.
 */
- (JavaTextFormat *)getFormatByArgumentNameWithNSString:(NSString *)argumentName;

/*!
 @brief Returns the Format objects used for the format elements in the
  previously set pattern string.
 The order of formats in the returned array corresponds to
  the order of format elements in the pattern string. 
 <p>
  Since the order of format elements in a pattern string often
  changes during localization, it's generally better to use the 
 <code>getFormatsByArgumentIndex()</code>
  method, which assumes an order of formats corresponding to the
  order of elements in the <code>arguments</code> array passed to
  the <code>format</code> methods or the result array returned by the 
 <code>parse</code> methods.
  This method is only supported when exclusively numbers are used for
  argument names. Otherwise an IllegalArgumentException is thrown.
 @return the formats used for the format elements in the pattern
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
- (IOSObjectArray *)getFormats;

/*!
 @brief Returns the Format objects used for the values passed into 
 <code>format</code> methods or returned from <code>parse</code>
  methods.The indices of elements in the returned array
  correspond to the argument indices used in the previously set
  pattern string.
 The order of formats in the returned array thus corresponds to
  the order of elements in the <code>arguments</code> array passed
  to the <code>format</code> methods or the result array returned
  by the <code>parse</code> methods. 
 <p>
  If an argument index is used for more than one format element
  in the pattern string, then the format used for the last such
  format element is returned in the array. If an argument index
  is not used for any format element in the pattern string, then
  null is returned in the array.
  This method is only supported when exclusively numbers are used for
  argument names. Otherwise an IllegalArgumentException is thrown.
 @return the formats used for the arguments within the pattern
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
- (IOSObjectArray *)getFormatsByArgumentIndex;

/*!
 @brief Returns the locale that's used when creating or comparing subformats.
 @return the locale used when creating or comparing subformats
 */
- (JavaUtilLocale *)getLocale;

/*!
 @brief <strong>[icu]</strong> Returns the locale that's used when creating argument Format objects.
 @return the locale used when creating or comparing subformats
 */
- (AndroidIcuUtilULocale *)getULocale;

/*!
 */
- (NSUInteger)hash;

/*!
 @brief Parses text from the beginning of the given string to produce an object
  array.
 The method may not use the entire text of the given string. 
 <p>
  See the <code>parse(String, ParsePosition)</code> method for more information
  on message parsing.
 @param source A  <code> String </code>  whose beginning should be parsed.
 @return An <code>Object</code> array parsed from the string.
 @throw ParseExceptionif the beginning of the specified string cannot be parsed.
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
- (IOSObjectArray *)parseWithNSString:(NSString *)source;

/*!
 @brief Parses the string.
 <p>Caveats: The parse may fail in a number of circumstances.
  For example: 
 <ul>
  <li>If one of the arguments does not occur in the pattern. 
 <li>If the format of an argument loses information, such as
      with a choice format where a large number formats to "many". 
 <li>Does not yet handle recursion (where
      the substituted strings contain {n} references.) 
 <li>Will not always find a match (or the correct match)
      if some part of the parse is ambiguous.
      For example, if the pattern "{1},{2}" is used with the
      string arguments {"a,b", "c"}, it will format as "a,b,c".
      When the result is parsed, it will return {"a", "b,c"}. 
 <li>If a single argument is parsed more than once in the string,
      then the later parse wins. 
 </ul>
  When the parse fails, use ParsePosition.getErrorIndex() to find out
  where in the string did the parsing failed. The returned error
  index is the starting offset of the sub-patterns that the string
  is comparing with. For example, if the parsing string "AAA {0} BBB"
  is comparing against the pattern "AAD {0} BBB", the error index is
  0. When an error occurs, the call to this method will return null.
  If the source is null, return an empty array.
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
- (IOSObjectArray *)parseWithNSString:(NSString *)source
            withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Parses text from a string to produce an object array or Map.
 <p>
  The method attempts to parse text starting at the index given by 
 <code>pos</code>.
  If parsing succeeds, then the index of <code>pos</code> is updated
  to the index after the last character used (parsing does not necessarily
  use all characters up to the end of the string), and the parsed
  object array is returned. The updated <code>pos</code> can be used to
  indicate the starting point for the next call to this method.
  If an error occurs, then the index of <code>pos</code> is not
  changed, the error index of <code>pos</code> is set to the index of
  the character where the error occurred, and null is returned. 
 <p>
  See the <code>parse(String, ParsePosition)</code> method for more information
  on message parsing.
 @param source A  <code> String </code> , part of which should be parsed.
 @param pos A  <code> ParsePosition </code>  object with index and error
              index information as described above.
 @return An <code>Object</code> parsed from the string, either an
          array of Object, or a Map, depending on whether named
          arguments are used.  This can be queried using <code>usesNamedArguments</code>.
          In case of error, returns null.
 @throw NullPointerExceptionif <code>pos</code> is null.
 */
- (id)parseObjectWithNSString:(NSString *)source
    withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief <strong>[icu]</strong> Parses text from the beginning of the given string to produce a map from
  argument to values.The method may not use the entire text of the given string.
 <p>See the <code>parse(String, ParsePosition)</code> method for more information on
  message parsing.
 @param source A  <code> String </code>  whose beginning should be parsed.
 @return A <code>Map</code> parsed from the string.
 @throw ParseExceptionif the beginning of the specified string cannot
          be parsed.
 - seealso: #parseToMap(String, ParsePosition)
 */
- (id<JavaUtilMap>)parseToMapWithNSString:(NSString *)source;

/*!
 @brief <strong>[icu]</strong> Parses the string, returning the results in a Map.
 This is similar to the version that returns an array
  of Object.  This supports both named and numbered
  arguments-- if numbered, the keys in the map are the
  corresponding ASCII-decimal-digit strings (e.g. "0", "1", "2"...).
 @param source the text to parse
 @param pos the position at which to start parsing.  on return,         contains the result of the parse.
 @return a Map containing key/value pairs for each parsed argument.
 */
- (id<JavaUtilMap>)parseToMapWithNSString:(NSString *)source
                withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Sets the Format object to use for the format element with the given
  format element index within the previously set pattern string.
 The format element index is the zero-based number of the format
  element counting from the start of the pattern string. 
 <p>
  Since the order of format elements in a pattern string often
  changes during localization, it is generally better to use the 
 <code>setFormatByArgumentIndex</code>
  method, which accesses format elements based on the argument
  index they specify.
 @param formatElementIndex the index of a format element within the pattern
 @param newFormat the format to use for the specified format element
 @throw ArrayIndexOutOfBoundsExceptionif formatElementIndex is equal to or
             larger than the number of format elements in the pattern string
 */
- (void)setFormatWithInt:(jint)formatElementIndex
      withJavaTextFormat:(JavaTextFormat *)newFormat;

/*!
 @brief Sets the Format object to use for the format elements within the
  previously set pattern string that use the given argument
  index.
 The argument index is part of the format element definition and
  represents an index into the <code>arguments</code> array passed
  to the <code>format</code> methods or the result array returned
  by the <code>parse</code> methods. 
 <p>
  If the argument index is used for more than one format element
  in the pattern string, then the new format is used for all such
  format elements. If the argument index is not used for any format
  element in the pattern string, then the new format is ignored.
  This method is only supported when exclusively numbers are used for
  argument names. Otherwise an IllegalArgumentException is thrown.
 @param argumentIndex the argument index for which to use the new format
 @param newFormat the new format to use
 @throw IllegalArgumentExceptionif this format uses named arguments
 */
- (void)setFormatByArgumentIndexWithInt:(jint)argumentIndex
                     withJavaTextFormat:(JavaTextFormat *)newFormat;

/*!
 @brief <strong>[icu]</strong> Sets the Format object to use for the format elements within the
  previously set pattern string that use the given argument
  name.
 <p>
  If the argument name is used for more than one format element
  in the pattern string, then the new format is used for all such
  format elements. If the argument name is not used for any format
  element in the pattern string, then the new format is ignored. 
 <p>
  This API may be used on formats that do not use named arguments.
  In this case <code>argumentName</code> should be a String that names
  an argument index, e.g. "0", "1", "2"... etc.  If it does not name
  a valid index, the format will be ignored.  No error is thrown.
 @param argumentName the name of the argument to change
 @param newFormat the new format to use
 */
- (void)setFormatByArgumentNameWithNSString:(NSString *)argumentName
                         withJavaTextFormat:(JavaTextFormat *)newFormat;

/*!
 @brief Sets the Format objects to use for the format elements in the
  previously set pattern string.
 The order of formats in <code>newFormats</code> corresponds to
  the order of format elements in the pattern string. 
 <p>
  If more formats are provided than needed by the pattern string,
  the remaining ones are ignored. If fewer formats are provided
  than needed, then only the first <code>newFormats.length</code>
  formats are replaced. 
 <p>
  Since the order of format elements in a pattern string often
  changes during localization, it is generally better to use the 
 <code>setFormatsByArgumentIndex</code>
  method, which assumes an order of formats corresponding to the
  order of elements in the <code>arguments</code> array passed to
  the <code>format</code> methods or the result array returned by the 
 <code>parse</code> methods.
 @param newFormats the new formats to use
 @throw NullPointerExceptionif <code>newFormats</code> is null
 */
- (void)setFormatsWithJavaTextFormatArray:(IOSObjectArray *)newFormats;

/*!
 @brief Sets the Format objects to use for the values passed into 
 <code>format</code> methods or returned from <code>parse</code>
  methods.The indices of elements in <code>newFormats</code>
  correspond to the argument indices used in the previously set
  pattern string.
 The order of formats in <code>newFormats</code> thus corresponds to
  the order of elements in the <code>arguments</code> array passed
  to the <code>format</code> methods or the result array returned
  by the <code>parse</code> methods. 
 <p>
  If an argument index is used for more than one format element
  in the pattern string, then the corresponding new format is used
  for all such format elements. If an argument index is not used
  for any format element in the pattern string, then the
  corresponding new format is ignored. If fewer formats are provided
  than needed, then only the formats for argument indices less than 
 <code>newFormats.length</code> are replaced.
  This method is only supported if the format does not use
  named arguments, otherwise an IllegalArgumentException is thrown.
 @param newFormats the new formats to use
 @throw NullPointerExceptionif <code>newFormats</code> is null
 @throw IllegalArgumentExceptionif this formatter uses named arguments
 */
- (void)setFormatsByArgumentIndexWithJavaTextFormatArray:(IOSObjectArray *)newFormats;

/*!
 @brief <strong>[icu]</strong> Sets the Format objects to use for the values passed into 
 <code>format</code> methods or returned from <code>parse</code>
  methods.The keys in <code>newFormats</code> are the argument
  names in the previously set pattern string, and the values
  are the formats.
 <p>
  Only argument names from the pattern string are considered.
  Extra keys in <code>newFormats</code> that do not correspond
  to an argument name are ignored.  Similarly, if there is no
  format in newFormats for an argument name, the formatter
  for that argument remains unchanged. 
 <p>
  This may be called on formats that do not use named arguments.
  In this case the map will be queried for key Strings that
  represent argument indices, e.g. "0", "1", "2" etc.
 @param newFormats a map from String to Format providing new         formats for named arguments.
 */
- (void)setFormatsByArgumentNameWithJavaUtilMap:(id<JavaUtilMap>)newFormats;

/*!
 @brief Sets the locale to be used for creating argument Format objects.
 This affects subsequent calls to the <code>applyPattern</code>
  method as well as to the <code>format</code> and 
 <code>formatToCharacterIterator</code> methods.
 @param locale the locale to be used when creating or comparing subformats
 */
- (void)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Sets the locale to be used for creating argument Format objects.
 This affects subsequent calls to the <code>applyPattern</code>
  method as well as to the <code>format</code> and 
 <code>formatToCharacterIterator</code> methods.
 @param locale the locale to be used when creating or comparing subformats
 */
- (void)setLocaleWithAndroidIcuUtilULocale:(AndroidIcuUtilULocale *)locale;

/*!
 @brief Returns the applied pattern string.
 @return the pattern string
 @throw IllegalStateExceptionafter custom Format objects have been set
          via setFormat() or similar APIs
 */
- (NSString *)toPattern;

/*!
 @brief <strong>[icu]</strong> Returns true if this MessageFormat uses named arguments,
  and false otherwise.See class description.
 @return true if named arguments are used.
 */
- (jboolean)usesNamedArguments;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextMessageFormat)

inline jlong AndroidIcuTextMessageFormat_get_serialVersionUID(void);
#define AndroidIcuTextMessageFormat_serialVersionUID 7136212545847378652LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidIcuTextMessageFormat, serialVersionUID, jlong)

FOUNDATION_EXPORT void AndroidIcuTextMessageFormat_initWithNSString_(AndroidIcuTextMessageFormat *self, NSString *pattern);

FOUNDATION_EXPORT AndroidIcuTextMessageFormat *new_AndroidIcuTextMessageFormat_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextMessageFormat *create_AndroidIcuTextMessageFormat_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT void AndroidIcuTextMessageFormat_initWithNSString_withJavaUtilLocale_(AndroidIcuTextMessageFormat *self, NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT AndroidIcuTextMessageFormat *new_AndroidIcuTextMessageFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextMessageFormat *create_AndroidIcuTextMessageFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT void AndroidIcuTextMessageFormat_initWithNSString_withAndroidIcuUtilULocale_(AndroidIcuTextMessageFormat *self, NSString *pattern, AndroidIcuUtilULocale *locale);

FOUNDATION_EXPORT AndroidIcuTextMessageFormat *new_AndroidIcuTextMessageFormat_initWithNSString_withAndroidIcuUtilULocale_(NSString *pattern, AndroidIcuUtilULocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextMessageFormat *create_AndroidIcuTextMessageFormat_initWithNSString_withAndroidIcuUtilULocale_(NSString *pattern, AndroidIcuUtilULocale *locale);

FOUNDATION_EXPORT NSString *AndroidIcuTextMessageFormat_formatWithNSString_withNSObjectArray_(NSString *pattern, IOSObjectArray *arguments);

FOUNDATION_EXPORT NSString *AndroidIcuTextMessageFormat_formatWithNSString_withJavaUtilMap_(NSString *pattern, id<JavaUtilMap> arguments);

FOUNDATION_EXPORT NSString *AndroidIcuTextMessageFormat_autoQuoteApostropheWithNSString_(NSString *pattern);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextMessageFormat)

#endif

#if !defined (AndroidIcuTextMessageFormat_Field_) && (INCLUDE_ALL_AndroidIcuTextMessageFormat || defined(INCLUDE_AndroidIcuTextMessageFormat_Field))
#define AndroidIcuTextMessageFormat_Field_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat_Field 1
#include "java/text/Format.h"

/*!
 @brief Defines constants that are used as attribute keys in the 
 <code>AttributedCharacterIterator</code> returned
  from <code>MessageFormat.formatToCharacterIterator</code>.
 */
@interface AndroidIcuTextMessageFormat_Field : JavaTextFormat_Field
@property (readonly, class, strong) AndroidIcuTextMessageFormat_Field *ARGUMENT NS_SWIFT_NAME(ARGUMENT);

+ (AndroidIcuTextMessageFormat_Field *)ARGUMENT;

#pragma mark Protected

/*!
 @brief Create a <code>Field</code> with the specified name.
 @param name The name of the attribute
 */
- (instancetype __nonnull)initWithNSString:(NSString *)name;

/*!
 @brief Resolves instances being deserialized to the predefined constants.
 @return resolved MessageFormat.Field constant
 @throw InvalidObjectExceptionif the constant could not be resolved.
 */
- (id)readResolve;

@end

J2OBJC_STATIC_INIT(AndroidIcuTextMessageFormat_Field)

/*!
 @brief Constant identifying a portion of a message that was generated
  from an argument passed into <code>formatToCharacterIterator</code>.
 The value associated with the key will be an <code>Integer</code>
  indicating the index in the <code>arguments</code> array of the
  argument from which the text was generated.
 */
inline AndroidIcuTextMessageFormat_Field *AndroidIcuTextMessageFormat_Field_get_ARGUMENT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT AndroidIcuTextMessageFormat_Field *AndroidIcuTextMessageFormat_Field_ARGUMENT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidIcuTextMessageFormat_Field, ARGUMENT, AndroidIcuTextMessageFormat_Field *)

FOUNDATION_EXPORT void AndroidIcuTextMessageFormat_Field_initWithNSString_(AndroidIcuTextMessageFormat_Field *self, NSString *name);

FOUNDATION_EXPORT AndroidIcuTextMessageFormat_Field *new_AndroidIcuTextMessageFormat_Field_initWithNSString_(NSString *name) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT AndroidIcuTextMessageFormat_Field *create_AndroidIcuTextMessageFormat_Field_initWithNSString_(NSString *name);

J2OBJC_TYPE_LITERAL_HEADER(AndroidIcuTextMessageFormat_Field)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_AndroidIcuTextMessageFormat")
