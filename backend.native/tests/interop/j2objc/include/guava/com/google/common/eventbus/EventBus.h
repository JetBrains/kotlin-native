//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/eventbus/EventBus.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonEventbusEventBus")
#ifdef RESTRICT_ComGoogleCommonEventbusEventBus
#define INCLUDE_ALL_ComGoogleCommonEventbusEventBus 0
#else
#define INCLUDE_ALL_ComGoogleCommonEventbusEventBus 1
#endif
#undef RESTRICT_ComGoogleCommonEventbusEventBus

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonEventbusEventBus_) && (INCLUDE_ALL_ComGoogleCommonEventbusEventBus || defined(INCLUDE_ComGoogleCommonEventbusEventBus))
#define ComGoogleCommonEventbusEventBus_

@class ComGoogleCommonEventbusDispatcher;
@class ComGoogleCommonEventbusSubscriberExceptionContext;
@class JavaLangThrowable;
@protocol ComGoogleCommonEventbusSubscriberExceptionHandler;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief Dispatches events to listeners, and provides ways for listeners to register themselves.
 <p>The EventBus allows publish-subscribe-style communication between components without requiring
  the components to explicitly register with one another (and thus be aware of each other). It is
  designed exclusively to replace traditional Java in-process event distribution using explicit
  registration. It is <em>not</em> a general-purpose publish-subscribe system, nor is it intended
  for interprocess communication. 
 <h2>Receiving Events</h2>
  
 <p>To receive events, an object should: 
 <ol>
    <li>Expose a public method, known as the <i>event subscriber</i>, which accepts a single
        argument of the type of event desired;   
 <li>Mark it with a <code>Subscribe</code> annotation;
    <li>Pass itself to an EventBus instance's <code>register(Object)</code> method. 
 </ol>
  
 <h2>Posting Events</h2>
  
 <p>To post an event, simply provide the event object to the <code>post(Object)</code> method. The
  EventBus instance will determine the type of event and route it to all registered listeners. 
 <p>Events are routed based on their type &mdash; an event will be delivered to any subscriber for
  any type to which the event is <em>assignable.</em> This includes implemented interfaces, all
  superclasses, and all interfaces implemented by superclasses. 
 <p>When <code>post</code> is called, all registered subscribers for an event are run in sequence, so
  subscribers should be reasonably quick. If an event may trigger an extended process (such as a
  database load), spawn a thread or queue it for later. (For a convenient way to do this, use an 
 <code>AsyncEventBus</code>.)
  
 <h2>Subscriber Methods</h2>
  
 <p>Event subscriber methods must accept only one argument: the event. 
 <p>Subscribers should not, in general, throw. If they do, the EventBus will catch and log the
  exception. This is rarely the right solution for error handling and should not be relied upon; it
  is intended solely to help find problems during development. 
 <p>The EventBus guarantees that it will not call a subscriber method from multiple threads
  simultaneously, unless the method explicitly allows it by bearing the <code>AllowConcurrentEvents</code>
  annotation. If this annotation is not present, subscriber methods need not
  worry about being reentrant, unless also called from outside the EventBus. 
 <h2>Dead Events</h2>
  
 <p>If an event is posted, but no registered subscribers can accept it, it is considered "dead."
  To give the system a second chance to handle dead events, they are wrapped in an instance of 
 <code>DeadEvent</code> and reposted. 
 <p>If a subscriber for a supertype of all events (such as Object) is registered, no event will
  ever be considered dead, and no DeadEvents will be generated. Accordingly, while DeadEvent
  extends <code>Object</code>, a subscriber registered to receive any Object will never receive a
  DeadEvent. 
 <p>This class is safe for concurrent use. 
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/EventBusExplained">
 <code>EventBus</code></a>.
 @author Cliff Biffle
 @since 10.0
 */
@interface ComGoogleCommonEventbusEventBus : NSObject

#pragma mark Public

/*!
 @brief Creates a new EventBus named "default".
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a new EventBus with the given <code>identifier</code>.
 @param identifier a brief name for this bus, for logging purposes. Should be a valid Java      identifier.
 */
- (instancetype __nonnull)initWithNSString:(NSString * __nonnull)identifier;

/*!
 @brief Creates a new EventBus with the given <code>SubscriberExceptionHandler</code>.
 @param exceptionHandler Handler for subscriber exceptions.
 @since 16.0
 */
- (instancetype __nonnull)initWithComGoogleCommonEventbusSubscriberExceptionHandler:(id<ComGoogleCommonEventbusSubscriberExceptionHandler> __nonnull)exceptionHandler;

/*!
 @brief Returns the identifier for this event bus.
 @since 19.0
 */
- (NSString *)identifier;

/*!
 @brief Posts an event to all registered subscribers.This method will return successfully after the
  event has been posted to all subscribers, and regardless of any exceptions thrown by
  subscribers.
 <p>If no subscribers have been subscribed for <code>event</code>'s class, and <code>event</code> is not
  already a <code>DeadEvent</code>, it will be wrapped in a DeadEvent and reposted.
 @param event event to post.
 */
- (void)postWithId:(id __nonnull)event;

/*!
 @brief Registers all subscriber methods on <code>object</code> to receive events.
 @param object object whose subscriber methods should be registered.
 */
- (void)register__WithId:(id __nonnull)object;

- (NSString *)description;

/*!
 @brief Unregisters all subscriber methods on a registered <code>object</code>.
 @param object object whose subscriber methods should be unregistered.
 @throw IllegalArgumentExceptionif the object was not previously registered.
 */
- (void)unregisterWithId:(id __nonnull)object;

#pragma mark Package-Private

- (instancetype __nonnull)initWithNSString:(NSString * __nonnull)identifier
            withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor
     withComGoogleCommonEventbusDispatcher:(ComGoogleCommonEventbusDispatcher * __nonnull)dispatcher
withComGoogleCommonEventbusSubscriberExceptionHandler:(id<ComGoogleCommonEventbusSubscriberExceptionHandler> __nonnull)exceptionHandler;

/*!
 @brief Returns the default executor this event bus uses for dispatching events to subscribers.
 */
- (id<JavaUtilConcurrentExecutor>)executor;

/*!
 @brief Handles the given exception thrown by a subscriber with the given context.
 */
- (void)handleSubscriberExceptionWithJavaLangThrowable:(JavaLangThrowable * __nonnull)e
 withComGoogleCommonEventbusSubscriberExceptionContext:(ComGoogleCommonEventbusSubscriberExceptionContext * __nonnull)context;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonEventbusEventBus)

FOUNDATION_EXPORT void ComGoogleCommonEventbusEventBus_init(ComGoogleCommonEventbusEventBus *self);

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *new_ComGoogleCommonEventbusEventBus_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *create_ComGoogleCommonEventbusEventBus_init(void);

FOUNDATION_EXPORT void ComGoogleCommonEventbusEventBus_initWithNSString_(ComGoogleCommonEventbusEventBus *self, NSString *identifier);

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *new_ComGoogleCommonEventbusEventBus_initWithNSString_(NSString *identifier) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *create_ComGoogleCommonEventbusEventBus_initWithNSString_(NSString *identifier);

FOUNDATION_EXPORT void ComGoogleCommonEventbusEventBus_initWithComGoogleCommonEventbusSubscriberExceptionHandler_(ComGoogleCommonEventbusEventBus *self, id<ComGoogleCommonEventbusSubscriberExceptionHandler> exceptionHandler);

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *new_ComGoogleCommonEventbusEventBus_initWithComGoogleCommonEventbusSubscriberExceptionHandler_(id<ComGoogleCommonEventbusSubscriberExceptionHandler> exceptionHandler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *create_ComGoogleCommonEventbusEventBus_initWithComGoogleCommonEventbusSubscriberExceptionHandler_(id<ComGoogleCommonEventbusSubscriberExceptionHandler> exceptionHandler);

FOUNDATION_EXPORT void ComGoogleCommonEventbusEventBus_initWithNSString_withJavaUtilConcurrentExecutor_withComGoogleCommonEventbusDispatcher_withComGoogleCommonEventbusSubscriberExceptionHandler_(ComGoogleCommonEventbusEventBus *self, NSString *identifier, id<JavaUtilConcurrentExecutor> executor, ComGoogleCommonEventbusDispatcher *dispatcher, id<ComGoogleCommonEventbusSubscriberExceptionHandler> exceptionHandler);

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *new_ComGoogleCommonEventbusEventBus_initWithNSString_withJavaUtilConcurrentExecutor_withComGoogleCommonEventbusDispatcher_withComGoogleCommonEventbusSubscriberExceptionHandler_(NSString *identifier, id<JavaUtilConcurrentExecutor> executor, ComGoogleCommonEventbusDispatcher *dispatcher, id<ComGoogleCommonEventbusSubscriberExceptionHandler> exceptionHandler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus *create_ComGoogleCommonEventbusEventBus_initWithNSString_withJavaUtilConcurrentExecutor_withComGoogleCommonEventbusDispatcher_withComGoogleCommonEventbusSubscriberExceptionHandler_(NSString *identifier, id<JavaUtilConcurrentExecutor> executor, ComGoogleCommonEventbusDispatcher *dispatcher, id<ComGoogleCommonEventbusSubscriberExceptionHandler> exceptionHandler);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonEventbusEventBus)

#endif

#if !defined (ComGoogleCommonEventbusEventBus_LoggingHandler_) && (INCLUDE_ALL_ComGoogleCommonEventbusEventBus || defined(INCLUDE_ComGoogleCommonEventbusEventBus_LoggingHandler))
#define ComGoogleCommonEventbusEventBus_LoggingHandler_

#define RESTRICT_ComGoogleCommonEventbusSubscriberExceptionHandler 1
#define INCLUDE_ComGoogleCommonEventbusSubscriberExceptionHandler 1
#include "com/google/common/eventbus/SubscriberExceptionHandler.h"

@class ComGoogleCommonEventbusSubscriberExceptionContext;
@class JavaLangThrowable;

/*!
 @brief Simple logging handler for subscriber exceptions.
 */
@interface ComGoogleCommonEventbusEventBus_LoggingHandler : NSObject < ComGoogleCommonEventbusSubscriberExceptionHandler >
@property (readonly, class, strong) ComGoogleCommonEventbusEventBus_LoggingHandler *INSTANCE NS_SWIFT_NAME(INSTANCE);

+ (ComGoogleCommonEventbusEventBus_LoggingHandler *)INSTANCE;

#pragma mark Public

- (void)handleExceptionWithJavaLangThrowable:(JavaLangThrowable * __nonnull)exception
withComGoogleCommonEventbusSubscriberExceptionContext:(ComGoogleCommonEventbusSubscriberExceptionContext * __nonnull)context;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonEventbusEventBus_LoggingHandler)

inline ComGoogleCommonEventbusEventBus_LoggingHandler *ComGoogleCommonEventbusEventBus_LoggingHandler_get_INSTANCE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus_LoggingHandler *ComGoogleCommonEventbusEventBus_LoggingHandler_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComGoogleCommonEventbusEventBus_LoggingHandler, INSTANCE, ComGoogleCommonEventbusEventBus_LoggingHandler *)

FOUNDATION_EXPORT void ComGoogleCommonEventbusEventBus_LoggingHandler_init(ComGoogleCommonEventbusEventBus_LoggingHandler *self);

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus_LoggingHandler *new_ComGoogleCommonEventbusEventBus_LoggingHandler_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonEventbusEventBus_LoggingHandler *create_ComGoogleCommonEventbusEventBus_LoggingHandler_init(void);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonEventbusEventBus_LoggingHandler)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonEventbusEventBus")
