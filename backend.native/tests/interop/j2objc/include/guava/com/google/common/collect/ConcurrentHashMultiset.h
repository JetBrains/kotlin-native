//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/collect/ConcurrentHashMultiset.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonCollectConcurrentHashMultiset")
#ifdef RESTRICT_ComGoogleCommonCollectConcurrentHashMultiset
#define INCLUDE_ALL_ComGoogleCommonCollectConcurrentHashMultiset 0
#else
#define INCLUDE_ALL_ComGoogleCommonCollectConcurrentHashMultiset 1
#endif
#undef RESTRICT_ComGoogleCommonCollectConcurrentHashMultiset

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonCollectConcurrentHashMultiset_) && (INCLUDE_ALL_ComGoogleCommonCollectConcurrentHashMultiset || defined(INCLUDE_ComGoogleCommonCollectConcurrentHashMultiset))
#define ComGoogleCommonCollectConcurrentHashMultiset_

#define RESTRICT_ComGoogleCommonCollectAbstractMultiset 1
#define INCLUDE_ComGoogleCommonCollectAbstractMultiset 1
#include "com/google/common/collect/AbstractMultiset.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@protocol JavaLangIterable;
@protocol JavaUtilConcurrentConcurrentMap;
@protocol JavaUtilIterator;
@protocol JavaUtilSet;

/*!
 @brief A multiset that supports concurrent modifications and that provides atomic versions of most 
 <code>Multiset</code> operations (exceptions where noted).Null elements are not supported.
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset">
  <code>Multiset</code>
 </a>.
 @author Cliff L. Biffle
 @author mike nonemacher
 @since 2.0
 */
@interface ComGoogleCommonCollectConcurrentHashMultiset : ComGoogleCommonCollectAbstractMultiset < JavaIoSerializable >

#pragma mark Public

/*!
 @brief Adds a number of occurrences of the specified element to this multiset.
 @param element the element to add
 @param occurrences the number of occurrences to add
 @return the previous count of the element before the operation; possibly zero
 @throw IllegalArgumentExceptionif <code>occurrences</code> is negative, or if the resulting amount
      would exceed <code>Integer.MAX_VALUE</code>
 */
- (jint)addWithId:(id)element
          withInt:(jint)occurrences;

- (void)clear;

/*!
 @brief Returns the number of occurrences of <code>element</code> in this multiset.
 @param element the element to look for
 @return the nonnegative number of occurrences of the element
 */
- (jint)countWithId:(id __nullable)element;

/*!
 @brief Creates a new, empty <code>ConcurrentHashMultiset</code> using the default initial capacity, load
  factor, and concurrency settings.
 */
+ (ComGoogleCommonCollectConcurrentHashMultiset *)create;

/*!
 @brief Creates a new, empty <code>ConcurrentHashMultiset</code> using <code>countMap</code> as the internal
  backing map.
 <p>This instance will assume ownership of <code>countMap</code>, and other code should not maintain
  references to the map or modify it in any way. 
 <p>The returned multiset is serializable if the input map is.
 @param countMap backing map for storing the elements in the multiset and their counts. It must      be empty.
 @throw IllegalArgumentExceptionif <code>countMap</code> is not empty
 @since 20.0
 */
+ (ComGoogleCommonCollectConcurrentHashMultiset *)createWithJavaUtilConcurrentConcurrentMap:(id<JavaUtilConcurrentConcurrentMap>)countMap;

/*!
 @brief Creates a new <code>ConcurrentHashMultiset</code> containing the specified elements, using the
  default initial capacity, load factor, and concurrency settings.
 <p>This implementation is highly efficient when <code>elements</code> is itself a <code>Multiset</code>.
 @param elements the elements that the multiset should contain
 */
+ (ComGoogleCommonCollectConcurrentHashMultiset *)createWithJavaLangIterable:(id<JavaLangIterable>)elements;

/*!
 */
- (id<JavaUtilSet>)createEntrySet __attribute__((deprecated));

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

/*!
 @brief Removes a number of occurrences of the specified element from this multiset.If the multiset
  contains fewer than this number of occurrences to begin with, all occurrences will be removed.
 @param element the element whose occurrences should be removed
 @param occurrences the number of occurrences of the element to remove
 @return the count of the element before the operation; possibly zero
 @throw IllegalArgumentExceptionif <code>occurrences</code> is negative
 */
- (jint)removeWithId:(id __nullable)element
             withInt:(jint)occurrences;

/*!
 @brief Removes exactly the specified number of occurrences of <code>element</code>, or makes no change if
  this is not possible.
 <p>This method, in contrast to <code>remove(Object, int)</code>, has no effect when the element
  count is smaller than <code>occurrences</code>.
 @param element the element to remove
 @param occurrences the number of occurrences of <code>element</code>  to remove
 @return <code>true</code> if the removal was possible (including if <code>occurrences</code> is zero)
 @throw IllegalArgumentExceptionif <code>occurrences</code> is negative
 */
- (jboolean)removeExactlyWithId:(id __nullable)element
                        withInt:(jint)occurrences;

/*!
 @brief Adds or removes occurrences of <code>element</code> such that the <code>count</code> of the element
  becomes <code>count</code>.
 @return the count of <code>element</code> in the multiset before this call
 @throw IllegalArgumentExceptionif <code>count</code> is negative
 */
- (jint)setCountWithId:(id)element
               withInt:(jint)count;

/*!
 @brief Sets the number of occurrences of <code>element</code> to <code>newCount</code>, but only if the count is
  currently <code>expectedOldCount</code>.If <code>element</code> does not appear in the multiset exactly 
 <code>expectedOldCount</code> times, no changes will be made.
 @return <code>true</code> if the change was successful. This usually indicates that the multiset has
      been modified, but not always: in the case that <code>expectedOldCount == newCount</code>, the
      method will return <code>true</code> if the condition was met.
 @throw IllegalArgumentExceptionif <code>expectedOldCount</code> or <code>newCount</code> is negative
 */
- (jboolean)setCountWithId:(id)element
                   withInt:(jint)expectedOldCount
                   withInt:(jint)newCount;

/*!
 @brief <p>If the data in the multiset is modified by any other threads during this method, it is
  undefined which (if any) of these modifications will be reflected in the result.
 */
- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)array;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilConcurrentConcurrentMap:(id<JavaUtilConcurrentConcurrentMap>)countMap;

- (id<JavaUtilSet>)createElementSet;

- (jint)distinctElements;

- (id<JavaUtilIterator>)elementIterator;

- (id<JavaUtilIterator>)entryIterator;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initPackagePrivate NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectConcurrentHashMultiset)

FOUNDATION_EXPORT ComGoogleCommonCollectConcurrentHashMultiset *ComGoogleCommonCollectConcurrentHashMultiset_create(void);

FOUNDATION_EXPORT ComGoogleCommonCollectConcurrentHashMultiset *ComGoogleCommonCollectConcurrentHashMultiset_createWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT ComGoogleCommonCollectConcurrentHashMultiset *ComGoogleCommonCollectConcurrentHashMultiset_createWithJavaUtilConcurrentConcurrentMap_(id<JavaUtilConcurrentConcurrentMap> countMap);

FOUNDATION_EXPORT void ComGoogleCommonCollectConcurrentHashMultiset_initWithJavaUtilConcurrentConcurrentMap_(ComGoogleCommonCollectConcurrentHashMultiset *self, id<JavaUtilConcurrentConcurrentMap> countMap);

FOUNDATION_EXPORT ComGoogleCommonCollectConcurrentHashMultiset *new_ComGoogleCommonCollectConcurrentHashMultiset_initWithJavaUtilConcurrentConcurrentMap_(id<JavaUtilConcurrentConcurrentMap> countMap) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonCollectConcurrentHashMultiset *create_ComGoogleCommonCollectConcurrentHashMultiset_initWithJavaUtilConcurrentConcurrentMap_(id<JavaUtilConcurrentConcurrentMap> countMap);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectConcurrentHashMultiset)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonCollectConcurrentHashMultiset")
