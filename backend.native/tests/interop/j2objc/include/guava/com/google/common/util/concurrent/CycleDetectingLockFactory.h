//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/util/concurrent/CycleDetectingLockFactory.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock
#define INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock
#define INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException
#define INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering
#define INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies
#define INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_

@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering;
@class IOSClass;
@class JavaUtilConcurrentLocksReentrantLock;
@class JavaUtilConcurrentLocksReentrantReadWriteLock;
@protocol ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy;
@protocol JavaUtilMap;

/*!
 @brief The <code>CycleDetectingLockFactory</code> creates <code>ReentrantLock</code> instances and <code>ReentrantReadWriteLock</code>
  instances that detect potential deadlock by checking for cycles in lock
  acquisition order.
 <p>Potential deadlocks detected when calling the <code>lock()</code>, <code>lockInterruptibly()</code>, or 
 <code>tryLock()</code> methods will result in the execution of the <code>Policy</code> specified when
  creating the factory. The currently available policies are: 
 <ul>
    <li>DISABLED
    <li>WARN
    <li>THROW
  </ul>
  
 <p>The locks created by a factory instance will detect lock acquisition cycles with locks created
  by other <code>CycleDetectingLockFactory</code> instances (except those with <code>Policy.DISABLED</code>).
  A lock's behavior when a cycle is detected, however, is defined by the <code>Policy</code> of the
  factory that created it. This allows detection of cycles across components while delegating
  control over lock behavior to individual components. 
 <p>Applications are encouraged to use a <code>CycleDetectingLockFactory</code> to create any locks for
  which external/unmanaged code is executed while the lock is held. (See caveats under 
 <strong>Performance</strong>).
  
 <p><strong>Cycle Detection</strong>
  
 <p>Deadlocks can arise when locks are acquired in an order that forms a cycle. In a simple
  example involving two locks and two threads, deadlock occurs when one thread acquires Lock A, and
  then Lock B, while another thread acquires Lock B, and then Lock A: 
 @code

  Thread1: acquire(LockA) --X acquire(LockB)
  Thread2: acquire(LockB) --X acquire(LockA) 
  
@endcode
  
 <p>Neither thread will progress because each is waiting for the other. In more complex
  applications, cycles can arise from interactions among more than 2 locks: 
 @code

  Thread1: acquire(LockA) --X acquire(LockB)
  Thread2: acquire(LockB) --X acquire(LockC)
  ...
  ThreadN: acquire(LockN) --X acquire(LockA) 
  
@endcode
  
 <p>The implementation detects cycles by constructing a directed graph in which each lock
  represents a node and each edge represents an acquisition ordering between two locks. 
 <ul>
    <li>Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired locks when the
        Thread acquires its first hold (and releases its last remaining hold).   
 <li>Before the lock is acquired, the lock is checked against the current set of acquired
        locks---to each of the acquired locks, an edge from the soon-to-be-acquired lock is either
        verified or created.   
 <li>If a new edge needs to be created, the outgoing edges of the acquired locks are traversed
        to check for a cycle that reaches the lock to be acquired. If no cycle is detected, a new
        "safe" edge is created.   
 <li>If a cycle is detected, an "unsafe" (cyclic) edge is created to represent a potential
        deadlock situation, and the appropriate Policy is executed. 
 </ul>
  
 <p>Note that detection of potential deadlock does not necessarily indicate that deadlock will
  happen, as it is possible that higher level application logic prevents the cyclic lock
  acquisition from occurring. One example of a false positive is: 
 @code

  LockA -&gt; LockB -&gt; LockC
  LockA -&gt; LockC -&gt; LockB 
  
@endcode
  
 <p><strong>ReadWriteLocks</strong>
  
 <p>While <code>ReadWriteLock</code> instances have different properties and can form cycles without
  potential deadlock, this class treats <code>ReadWriteLock</code> instances as equivalent to
  traditional exclusive locks. Although this increases the false positives that the locks detect
  (i.e. cycles that will not actually result in deadlock), it simplifies the algorithm and
  implementation considerably. The assumption is that a user of this factory wishes to eliminate
  any cyclic acquisition ordering. 
 <p><strong>Explicit Lock Acquisition Ordering</strong>
  
 <p>The <code>CycleDetectingLockFactory.WithExplicitOrdering</code> class can be used to enforce an
  application-specific ordering in addition to performing general cycle detection. 
 <p><strong>Garbage Collection</strong>
  
 <p>In order to allow proper garbage collection of unused locks, the edges of the lock graph are
  weak references. 
 <p><strong>Performance</strong>
  
 <p>The extra bookkeeping done by cycle detecting locks comes at some cost to performance.
  Benchmarks (as of December 2011) show that: 
 <ul>
    <li>for an unnested <code>lock()</code> and <code>unlock()</code>, a cycle detecting lock takes 38ns as
        opposed to the 24ns taken by a plain lock.   
 <li>for nested locking, the cost increases with the depth of the nesting:
        <ul>
          <li>2 levels: average of 64ns per lock()/unlock()
          <li>3 levels: average of 77ns per lock()/unlock()
          <li>4 levels: average of 99ns per lock()/unlock()
          <li>5 levels: average of 103ns per lock()/unlock()
          <li>10 levels: average of 184ns per lock()/unlock()
          <li>20 levels: average of 393ns per lock()/unlock()
        </ul>
  </ul>
  
 <p>As such, the CycleDetectingLockFactory may not be suitable for performance-critical
  applications which involve tightly-looped or deeply-nested locking algorithms.
 @author Darick Tong
 @since 13.0
 */
@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory : NSObject {
 @public
  id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> policy_;
}

#pragma mark Public

/*!
 @brief Creates a new factory with the specified policy.
 */
+ (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory *)newInstanceWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy:(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> __nonnull)policy OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>CycleDetectingLockFactory.WithExplicitOrdering<E></code>.
 */
+ (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering *)newInstanceWithExplicitOrderingWithIOSClass:(IOSClass * __nonnull)enumClass
                                                           withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy:(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> __nonnull)policy OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Equivalent to <code>newReentrantLock(lockName, false)</code>.
 */
- (JavaUtilConcurrentLocksReentrantLock *)newReentrantLockWithNSString:(NSString * __nonnull)lockName OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>ReentrantLock</code> with the given fairness policy.The <code>lockName</code> is used in
  the warning or exception output to help identify the locks involved in the detected deadlock.
 */
- (JavaUtilConcurrentLocksReentrantLock *)newReentrantLockWithNSString:(NSString * __nonnull)lockName
                                                           withBoolean:(jboolean)fair OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Equivalent to <code>newReentrantReadWriteLock(lockName, false)</code>.
 */
- (JavaUtilConcurrentLocksReentrantReadWriteLock *)newReentrantReadWriteLockWithNSString:(NSString * __nonnull)lockName OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>ReentrantReadWriteLock</code> with the given fairness policy.The <code>lockName</code>
  is used in the warning or exception output to help identify the locks involved in the detected
  deadlock.
 */
- (JavaUtilConcurrentLocksReentrantReadWriteLock *)newReentrantReadWriteLockWithNSString:(NSString * __nonnull)lockName
                                                                             withBoolean:(jboolean)fair OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

/*!
 @brief For a given Enum type, creates an immutable map from each of the Enum's values to a
  corresponding LockGraphNode, with the <code>allowedPriorLocks</code> and <code>disallowedPriorLocks</code>
  prepopulated with nodes according to the natural ordering of the
  associated Enum values.
 */
+ (id<JavaUtilMap>)createNodesWithIOSClass:(IOSClass * __nonnull)clazz;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory)

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory, policy_, id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy>)

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_newInstanceWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> policy);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_newInstanceWithExplicitOrderingWithIOSClass_withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_(IOSClass *enumClass, id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> policy);

FOUNDATION_EXPORT id<JavaUtilMap> ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_createNodesWithIOSClass_(IOSClass *clazz);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_

@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException;

/*!
 @brief Encapsulates the action to be taken when a potential deadlock is encountered.Clients can use
  one of the predefined <code>Policies</code> or specify a custom implementation.
 Implementations must
  be thread-safe.
 @since 13.0
 */
@protocol ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy < JavaObject >

/*!
 @brief Called when a potential deadlock is encountered.Implementations can throw the given <code>exception</code>
  and/or execute other desired logic.
 <p>Note that the method will be called even upon an invocation of <code>tryLock()</code>. Although 
 <code>tryLock()</code> technically recovers from deadlock by eventually timing out, this behavior
  is chosen based on the assumption that it is the application's wish to prohibit any cyclical
  lock acquisitions.
 */
- (void)handlePotentialDeadlockWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException:(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException * __nonnull)exception;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_Enum) {
  ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_Enum_THROW = 0,
  ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_Enum_WARN = 1,
  ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_Enum_DISABLED = 2,
};

/*!
 @brief Pre-defined <code>Policy</code> implementations.
 @since 13.0
 */
@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies : JavaLangEnum < ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy >

@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *THROW NS_SWIFT_NAME(THROW);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *WARN NS_SWIFT_NAME(WARN);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *DISABLED NS_SWIFT_NAME(DISABLED);
+ (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies * __nonnull)THROW;

+ (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies * __nonnull)WARN;

+ (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies * __nonnull)DISABLED;

#pragma mark Public

+ (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *)valueOfWithNSString:(NSString * __nonnull)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_values_[];

/*!
 @brief When potential deadlock is detected, this policy results in the throwing of the <code>PotentialDeadlockException</code>
  indicating the potential deadlock, which includes stack traces
  illustrating the cycle in lock acquisition order.
 */
inline ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_get_THROW(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies, THROW)

/*!
 @brief When potential deadlock is detected, this policy results in the logging of a <code>Level.SEVERE</code>
  message indicating the potential deadlock, which includes stack traces
  illustrating the cycle in lock acquisition order.
 */
inline ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_get_WARN(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies, WARN)

/*!
 @brief Disables cycle detection.This option causes the factory to return unmodified lock
  implementations provided by the JDK, and is provided to allow applications to easily
  parameterize when cycle detection is enabled.
 <p>Note that locks created by a factory with this policy will <em>not</em> participate the
  cycle detection performed by locks created by other factories.
 */
inline ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_get_DISABLED(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies, DISABLED)

FOUNDATION_EXPORT IOSObjectArray *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_values(void);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policies)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering_

@class JavaLangEnum;
@class JavaUtilConcurrentLocksReentrantLock;
@class JavaUtilConcurrentLocksReentrantReadWriteLock;
@protocol ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy;
@protocol JavaUtilMap;

/*!
 @brief A <code>CycleDetectingLockFactory.WithExplicitOrdering</code> provides the additional enforcement of
  an application-specified ordering of lock acquisitions.The application defines the allowed
  ordering with an <code>Enum</code> whose values each correspond to a lock type.
 The order in which
  the values are declared dictates the allowed order of lock acquisition. In other words, locks
  corresponding to smaller values of <code>Enum.ordinal()</code> should only be acquired before locks
  with larger ordinals. Example: 
 @code
 enum MyLockOrder {
    FIRST, SECOND, THIRD;
  }
  CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory =
    CycleDetectingLockFactory.newInstanceWithExplicitOrdering(Policies.THROW);
  Lock lock1 = factory.newReentrantLock(MyLockOrder.FIRST);
  Lock lock2 = factory.newReentrantLock(MyLockOrder.SECOND);
  Lock lock3 = factory.newReentrantLock(MyLockOrder.THIRD);
  lock1.lock();
  lock3.lock();
  lock2.lock();  // will throw an IllegalStateException 
 
@endcode
  
 <p>As with all locks created by instances of <code>CycleDetectingLockFactory</code> explicitly
  ordered locks participate in general cycle detection with all other cycle detecting locks, and
  a lock's behavior when detecting a cyclic lock acquisition is defined by the <code>Policy</code> of
  the factory that created it. 
 <p>Note, however, that although multiple locks can be created for a given Enum value, whether
  it be through separate factory instances or through multiple calls to the same factory,
  attempting to acquire multiple locks with the same Enum value (within the same thread) will
  result in an IllegalStateException regardless of the factory's policy. For example: 
 @code
 CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory1 =
    CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);
  CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory2 =
    CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...);
  Lock lockA = factory1.newReentrantLock(MyLockOrder.FIRST);
  Lock lockB = factory1.newReentrantLock(MyLockOrder.FIRST);
  Lock lockC = factory2.newReentrantLock(MyLockOrder.FIRST);
  lockA.lock();
  lockB.lock();  // will throw an IllegalStateException
  lockC.lock();  // will throw an IllegalStateException
  lockA.lock();  // reentrant acquisition is okay 
 
@endcode
  
 <p>It is the responsibility of the application to ensure that multiple lock instances with the
  same rank are never acquired in the same thread.
 @since 13.0
 */
@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering : ComGoogleCommonUtilConcurrentCycleDetectingLockFactory

#pragma mark Public

/*!
 @brief Equivalent to <code>newReentrantLock(rank, false)</code>.
 */
- (JavaUtilConcurrentLocksReentrantLock *)newReentrantLockWithJavaLangEnum:(JavaLangEnum * __nonnull)rank OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>ReentrantLock</code> with the given fairness policy and rank.The values returned
  by <code>Enum.getDeclaringClass()</code> and <code>Enum.name()</code> are used to describe the lock in
  warning or exception output.
 @throw IllegalStateExceptionIf the factory has already created a <code>Lock</code> with the
      specified rank.
 */
- (JavaUtilConcurrentLocksReentrantLock *)newReentrantLockWithJavaLangEnum:(JavaLangEnum * __nonnull)rank
                                                               withBoolean:(jboolean)fair OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Equivalent to <code>newReentrantReadWriteLock(rank, false)</code>.
 */
- (JavaUtilConcurrentLocksReentrantReadWriteLock *)newReentrantReadWriteLockWithJavaLangEnum:(JavaLangEnum * __nonnull)rank OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>ReentrantReadWriteLock</code> with the given fairness policy and rank.The values
  returned by <code>Enum.getDeclaringClass()</code> and <code>Enum.name()</code> are used to describe the
  lock in warning or exception output.
 @throw IllegalStateExceptionIf the factory has already created a <code>Lock</code> with the
      specified rank.
 */
- (JavaUtilConcurrentLocksReentrantReadWriteLock *)newReentrantReadWriteLockWithJavaLangEnum:(JavaLangEnum * __nonnull)rank
                                                                                 withBoolean:(jboolean)fair OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy:(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> __nonnull)policy
                                                                                withJavaUtilMap:(id<JavaUtilMap> __nonnull)lockGraphNodes;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering_initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_withJavaUtilMap_(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering *self, id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> policy, id<JavaUtilMap> lockGraphNodes);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering *new_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering_initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_withJavaUtilMap_(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> policy, id<JavaUtilMap> lockGraphNodes) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering *create_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering_initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy_withJavaUtilMap_(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> policy, id<JavaUtilMap> lockGraphNodes);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_WithExplicitOrdering)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_

#define RESTRICT_JavaLangIllegalStateException 1
#define INCLUDE_JavaLangIllegalStateException 1
#include "java/lang/IllegalStateException.h"

@class ComGoogleCommonCollectImmutableSet;
@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode;
@class IOSObjectArray;

/*!
 @brief A Throwable used to record a stack trace that illustrates an example of a specific lock
  acquisition ordering.The top of the stack trace is truncated such that it starts with the
  acquisition of the lock in question, e.g.
 @code

  com...ExampleStackTrace: LockB -&gt; LockC
    at com...CycleDetectingReentrantLock.lock(CycleDetectingLockFactory.java:443)
    at ...   at ...
    at com...MyClass.someMethodThatAcquiresLockB(MyClass.java:123) 
  
@endcode
 */
@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace : JavaLangIllegalStateException
@property (readonly, class, strong) IOSObjectArray *EMPTY_STACK_TRACE NS_SWIFT_NAME(EMPTY_STACK_TRACE);
@property (readonly, class, strong) ComGoogleCommonCollectImmutableSet *EXCLUDED_CLASS_NAMES NS_SWIFT_NAME(EXCLUDED_CLASS_NAMES);

+ (IOSObjectArray *)EMPTY_STACK_TRACE;

+ (ComGoogleCommonCollectImmutableSet *)EXCLUDED_CLASS_NAMES;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode:(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode * __nonnull)node1
                              withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode:(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode * __nonnull)node2;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace)

inline IOSObjectArray *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_get_EMPTY_STACK_TRACE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_EMPTY_STACK_TRACE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace, EMPTY_STACK_TRACE, IOSObjectArray *)

inline ComGoogleCommonCollectImmutableSet *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_get_EXCLUDED_CLASS_NAMES(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT ComGoogleCommonCollectImmutableSet *ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_EXCLUDED_CLASS_NAMES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace, EXCLUDED_CLASS_NAMES, ComGoogleCommonCollectImmutableSet *)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace *self, ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *node1, ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *node2);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace *new_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *node1, ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *node2) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace *create_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace_initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *node1, ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *node2);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException_

@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace;
@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode;

/*!
 @brief Represents a detected cycle in lock acquisition ordering.The exception includes a causal chain
  of <code>ExampleStackTrace</code> instances to illustrate the cycle, e.g.
 @code

  com....PotentialDeadlockException: Potential Deadlock from LockC -&gt; ReadWriteA
    at ...   at ...
  Caused by: com...ExampleStackTrace: LockB -&gt; LockC
    at ...   at ...
  Caused by: com...ExampleStackTrace: ReadWriteA -&gt; LockB
    at ...   at ... 
  
@endcode
  
 <p>Instances are logged for the <code>Policies.WARN</code>, and thrown for <code>Policies.THROW</code>.
 @since 13.0
 */
@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException : ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace

#pragma mark Public

- (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_ExampleStackTrace *)getConflictingStackTrace;

/*!
 @brief Appends the chain of messages from the <code>conflictingStackTrace</code> to the original <code>message</code>
 .
 */
- (NSString *)getMessage;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode:(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode * __nonnull)arg0
                              withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode:(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode * __nonnull)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_PotentialDeadlockException)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock_

@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode;

/*!
 @brief Internal Lock implementations implement the <code>CycleDetectingLock</code> interface, allowing the
  detection logic to treat all locks in the same manner.
 */
@protocol ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock < JavaObject >

/*!
 @return the <code>LockGraphNode</code> associated with this lock.
 */
- (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *)getLockGraphNode;

/*!
 @return <code>true</code> if the current thread has acquired this lock.
 */
- (jboolean)isAcquiredByCurrentThread;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_

@protocol ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy;
@protocol JavaUtilList;
@protocol JavaUtilMap;

/*!
 @brief A <code>LockGraphNode</code> associated with each lock instance keeps track of the directed edges in
  the lock acquisition graph.
 */
@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode : NSObject {
 @public
  /*!
   @brief The map tracking the locks that are known to be acquired before this lock, each associated
  with an example stack trace.Locks are weakly keyed to allow proper garbage collection when
  they are no longer referenced.
   */
  id<JavaUtilMap> allowedPriorLocks_;
  /*!
   @brief The map tracking lock nodes that can cause a lock acquisition cycle if acquired before this
  node.
   */
  id<JavaUtilMap> disallowedPriorLocks_;
  NSString *lockName_;
}

#pragma mark Package-Private

- (instancetype __nonnull)initWithNSString:(NSString * __nonnull)lockName;

/*!
 @brief Checks the acquisition-ordering between <code>this</code>, which is about to be acquired, and the
  specified <code>acquiredLock</code>.
 <p>When this method returns, the <code>acquiredLock</code> should be in either the <code>preAcquireLocks</code>
  map, for the case in which it is safe to acquire <code>this</code> after the 
 <code>acquiredLock</code>, or in the <code>disallowedPriorLocks</code> map, in which case it is not
  safe.
 */
- (void)checkAcquiredLockWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy:(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> __nonnull)policy
                  withComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode:(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode * __nonnull)acquiredLock;

- (void)checkAcquiredLocksWithComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy:(id<ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_Policy> __nonnull)policy
                                                                           withJavaUtilList:(id<JavaUtilList> __nonnull)acquiredLocks;

- (NSString *)getLockName;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode)

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode, allowedPriorLocks_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode, disallowedPriorLocks_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode, lockName_, NSString *)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_initWithNSString_(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *self, NSString *lockName);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *new_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_initWithNSString_(NSString *lockName) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *create_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode_initWithNSString_(NSString *lockName);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock_

#define RESTRICT_JavaUtilConcurrentLocksReentrantLock 1
#define INCLUDE_JavaUtilConcurrentLocksReentrantLock 1
#include "java/util/concurrent/locks/ReentrantLock.h"

@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode;
@class JavaUtilConcurrentTimeUnit;

@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock : JavaUtilConcurrentLocksReentrantLock < ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock >

#pragma mark Public

- (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *)getLockGraphNode;

- (jboolean)isAcquiredByCurrentThread;

- (void)lock;

- (void)lockInterruptibly;

- (jboolean)tryLock;

- (jboolean)tryLockWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

- (void)unlock;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

- (instancetype __nonnull)initWithBoolean:(jboolean)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantLock)

#endif

#if !defined (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory || defined(INCLUDE_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock))
#define ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock_

#define RESTRICT_JavaUtilConcurrentLocksReentrantReadWriteLock 1
#define INCLUDE_JavaUtilConcurrentLocksReentrantReadWriteLock 1
#include "java/util/concurrent/locks/ReentrantReadWriteLock.h"

@class ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode;
@class JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock;
@class JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock;

@interface ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock : JavaUtilConcurrentLocksReentrantReadWriteLock < ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingLock >

#pragma mark Public

- (ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_LockGraphNode *)getLockGraphNode;

- (jboolean)isAcquiredByCurrentThread;

- (JavaUtilConcurrentLocksReentrantReadWriteLock_ReadLock *)readLock;

- (JavaUtilConcurrentLocksReentrantReadWriteLock_WriteLock *)writeLock;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

- (instancetype __nonnull)initWithBoolean:(jboolean)arg0 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentCycleDetectingLockFactory_CycleDetectingReentrantReadWriteLock)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentCycleDetectingLockFactory")
