//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/util/concurrent/AbstractScheduledService.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentAbstractScheduledService
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentAbstractScheduledService
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler
#define INCLUDE_ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentAbstractScheduledService_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService || defined(INCLUDE_ComGoogleCommonUtilConcurrentAbstractScheduledService))
#define ComGoogleCommonUtilConcurrentAbstractScheduledService_

#define RESTRICT_ComGoogleCommonUtilConcurrentService 1
#define INCLUDE_ComGoogleCommonUtilConcurrentService 1
#include "com/google/common/util/concurrent/Service.h"

@class ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler;
@class ComGoogleCommonUtilConcurrentService_Listener;
@class ComGoogleCommonUtilConcurrentService_State;
@class JavaLangThrowable;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilConcurrentScheduledExecutorService;

/*!
 @brief Base class for services that can implement <code>startUp</code> and <code>shutDown</code> but while in
  the "running" state need to perform a periodic task.Subclasses can implement <code>startUp</code>,
  <code>shutDown</code> and also a <code>runOneIteration</code> method that will be executed periodically.
 <p>This class uses the <code>ScheduledExecutorService</code> returned from <code>executor</code> to run
  the <code>startUp</code> and <code>shutDown</code> methods and also uses that service to schedule the 
 <code>runOneIteration</code> that will be executed periodically as specified by its <code>Scheduler</code>
 . When this service is asked to stop via <code>stopAsync</code> it will cancel the periodic
  task (but not interrupt it) and wait for it to stop before running the <code>shutDown</code> method. 
 <p>Subclasses are guaranteed that the life cycle methods (<code>runOneIteration</code>, <code>startUp</code>
  and <code>shutDown</code>) will never run concurrently. Notably, if any execution of <code>runOneIteration</code>
  takes longer than its schedule defines, then subsequent executions may start
  late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify
  shared state without additional synchronization necessary for visibility to later executions of
  the life cycle methods. 
 <h3>Usage Example</h3>
  
 <p>Here is a sketch of a service which crawls a website and uses the scheduling capabilities to
  rate limit itself. 
 @code
 class CrawlingService extends AbstractScheduledService {
    private Set<Uri> visited;
    private Queue<Uri> toCrawl;
    protected void startUp() throws Exception {
      toCrawl = readStartingUris();
    }
    protected void runOneIteration() throws Exception {
      Uri uri = toCrawl.remove();
      Collection<Uri> newUris = crawl(uri);
      visited.add(uri);
      for (Uri newUri : newUris) {
        if (!visited.contains(newUri)) { toCrawl.add(newUri); }
      }    }
    protected void shutDown() throws Exception {
      saveUris(toCrawl);
    }
    protected Scheduler scheduler() {
      return Scheduler.newFixedRateSchedule(0, 1, TimeUnit.SECONDS);
    }  }  
 
@endcode
  
 <p>This class uses the life cycle methods to read in a list of starting URIs and save the set of
  outstanding URIs when shutting down. Also, it takes advantage of the scheduling functionality to
  rate limit the number of queries we perform.
 @author Luke Sandberg
 @since 11.0
 */
@interface ComGoogleCommonUtilConcurrentAbstractScheduledService : NSObject < ComGoogleCommonUtilConcurrentService >

#pragma mark Public

/*!
 @since 13.0
 */
- (void)addListenerWithComGoogleCommonUtilConcurrentService_Listener:(ComGoogleCommonUtilConcurrentService_Listener * __nonnull)listener
                                      withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @since 15.0
 */
- (void)awaitRunning;

/*!
 @since 15.0
 */
- (void)awaitRunningWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @since 15.0
 */
- (void)awaitTerminated;

/*!
 @since 15.0
 */
- (void)awaitTerminatedWithLong:(jlong)timeout
 withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @since 14.0
 */
- (JavaLangThrowable *)failureCause;

- (jboolean)isRunning;

/*!
 @since 15.0
 */
- (id<ComGoogleCommonUtilConcurrentService>)startAsync;

- (ComGoogleCommonUtilConcurrentService_State *)state;

/*!
 @since 15.0
 */
- (id<ComGoogleCommonUtilConcurrentService>)stopAsync;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Constructor for use by subclasses.
 */
- (instancetype __nonnull)init;

/*!
 @brief Returns the <code>ScheduledExecutorService</code> that will be used to execute the <code>startUp</code>,
  <code>runOneIteration</code> and <code>shutDown</code> methods.If this method is overridden the
  executor will not be shutdown when this service 
 terminates or fails
 .
 Subclasses may override this method to supply a custom <code>ScheduledExecutorService</code>
  instance. This method is guaranteed to only be called once. 
 <p>By default this returns a new <code>ScheduledExecutorService</code> with a single thread thread
  pool that sets the name of the thread to the service name. Also,
  the pool will be shut down when the service 
 terminates or fails
 .
 */
- (id<JavaUtilConcurrentScheduledExecutorService>)executor;

/*!
 @brief Run one iteration of the scheduled task.If any invocation of this method throws an exception,
  the service will transition to the <code>Service.State.FAILED</code> state and this method will no
  longer be called.
 */
- (void)runOneIteration;

/*!
 @brief Returns the <code>Scheduler</code> object used to configure this service.This method will only be
  called once.
 */
- (ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler *)scheduler;

/*!
 @brief Returns the name of this service.
 <code>AbstractScheduledService</code> may include the name in
  debugging output.
 @since 14.0
 */
- (NSString *)serviceName;

/*!
 @brief Stop the service.This is guaranteed not to run concurrently with <code>runOneIteration</code>.
 <p>By default this method does nothing.
 */
- (void)shutDown;

/*!
 @brief Start the service.
 <p>By default this method does nothing.
 */
- (void)startUp;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentAbstractScheduledService)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentAbstractScheduledService_init(ComGoogleCommonUtilConcurrentAbstractScheduledService *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentAbstractScheduledService)

#endif

#if !defined (ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService || defined(INCLUDE_ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler))
#define ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler_

@class ComGoogleCommonUtilConcurrentAbstractService;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentFuture;
@protocol JavaUtilConcurrentScheduledExecutorService;

/*!
 @brief A scheduler defines the policy for how the <code>AbstractScheduledService</code> should run its
  task.
 <p>Consider using the <code>newFixedDelaySchedule</code> and <code>newFixedRateSchedule</code> factory
  methods, these provide <code>Scheduler</code> instances for the common use case of running the
  service with a fixed schedule. If more flexibility is needed then consider subclassing <code>CustomScheduler</code>
 .
 @author Luke Sandberg
 @since 11.0
 */
@interface ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler : NSObject

#pragma mark Public

/*!
 @brief Returns a <code>Scheduler</code> that schedules the task using the <code>ScheduledExecutorService.scheduleWithFixedDelay</code>
  method.
 @param initialDelay the time to delay first execution
 @param delay the delay between the termination of one execution and the commencement of the      next
 @param unit the time unit of the initialDelay and delay parameters
 */
+ (ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler *)newFixedDelayScheduleWithLong:(jlong)initialDelay
                                                                                          withLong:(jlong)delay
                                                                    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a <code>Scheduler</code> that schedules the task using the <code>ScheduledExecutorService.scheduleAtFixedRate</code>
  method.
 @param initialDelay the time to delay first execution
 @param period the period between successive executions of the task
 @param unit the time unit of the initialDelay and period parameters
 */
+ (ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler *)newFixedRateScheduleWithLong:(jlong)initialDelay
                                                                                         withLong:(jlong)period
                                                                   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

/*!
 @brief Schedules the task to run on the provided executor on behalf of the service.
 */
- (id<JavaUtilConcurrentFuture>)scheduleWithComGoogleCommonUtilConcurrentAbstractService:(ComGoogleCommonUtilConcurrentAbstractService * __nonnull)service
                                          withJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService> __nonnull)executor
                                                                    withJavaLangRunnable:(id<JavaLangRunnable> __nonnull)runnable;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler)

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler *ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler_newFixedDelayScheduleWithLong_withLong_withJavaUtilConcurrentTimeUnit_(jlong initialDelay, jlong delay, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler *ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler_newFixedRateScheduleWithLong_withLong_withJavaUtilConcurrentTimeUnit_(jlong initialDelay, jlong period, JavaUtilConcurrentTimeUnit *unit);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler)

#endif

#if !defined (ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService || defined(INCLUDE_ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler))
#define ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_

@class ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule;
@class ComGoogleCommonUtilConcurrentAbstractService;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentFuture;
@protocol JavaUtilConcurrentScheduledExecutorService;

/*!
 @brief A <code>Scheduler</code> that provides a convenient way for the <code>AbstractScheduledService</code> to
  use a dynamically changing schedule.After every execution of the task, assuming it hasn't been
  cancelled, the <code>getNextSchedule</code> method will be called.
 @author Luke Sandberg
 @since 11.0
 */
@interface ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler : ComGoogleCommonUtilConcurrentAbstractScheduledService_Scheduler

#pragma mark Public

- (instancetype __nonnull)init;

#pragma mark Protected

/*!
 @brief Calculates the time at which to next invoke the task.
 <p>This is guaranteed to be called immediately after the task has completed an iteration and
  on the same thread as the previous execution of <code>AbstractScheduledService.runOneIteration</code>
 .
 @return a schedule that defines the delay before the next execution.
 */
- (ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule *)getNextSchedule;

#pragma mark Package-Private

- (id<JavaUtilConcurrentFuture>)scheduleWithComGoogleCommonUtilConcurrentAbstractService:(ComGoogleCommonUtilConcurrentAbstractService * __nonnull)service
                                          withJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService> __nonnull)executor
                                                                    withJavaLangRunnable:(id<JavaLangRunnable> __nonnull)runnable;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_init(ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler)

#endif

#if !defined (ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService || defined(INCLUDE_ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule))
#define ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule_

@class JavaUtilConcurrentTimeUnit;

/*!
 @brief A value object that represents an absolute delay until a task should be invoked.
 @author Luke Sandberg
 @since 11.0
 */
@interface ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule : NSObject

#pragma mark Public

/*!
 @param delay the time from now to delay execution
 @param unit the time unit of the delay parameter
 */
- (instancetype __nonnull)initWithLong:(jlong)delay
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule_initWithLong_withJavaUtilConcurrentTimeUnit_(ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule *self, jlong delay, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule *new_ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule_initWithLong_withJavaUtilConcurrentTimeUnit_(jlong delay, JavaUtilConcurrentTimeUnit *unit) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule *create_ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule_initWithLong_withJavaUtilConcurrentTimeUnit_(jlong delay, JavaUtilConcurrentTimeUnit *unit);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentAbstractScheduledService_CustomScheduler_Schedule)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractScheduledService")
