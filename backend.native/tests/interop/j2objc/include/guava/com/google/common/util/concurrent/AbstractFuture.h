//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/util/concurrent/AbstractFuture.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractFuture")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentAbstractFuture
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractFuture 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractFuture 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentAbstractFuture
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture
#define INCLUDE_ComGoogleCommonUtilConcurrentAbstractFuture 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentAbstractFuture_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentAbstractFuture))
#define ComGoogleCommonUtilConcurrentAbstractFuture_

#define RESTRICT_ComGoogleCommonUtilConcurrentFluentFuture 1
#define INCLUDE_ComGoogleCommonUtilConcurrentFluentFuture 1
#include "com/google/common/util/concurrent/FluentFuture.h"

@class JavaLangThrowable;
@class JavaUtilConcurrentTimeUnit;
@protocol ComGoogleCommonUtilConcurrentListenableFuture;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;
@protocol JavaUtilConcurrentFuture;

/*!
 @brief An abstract implementation of <code>ListenableFuture</code>, intended for advanced users only.More
  common ways to create a <code>ListenableFuture</code> include instantiating a <code>SettableFuture</code>,
  submitting a task to a <code>ListeningExecutorService</code>, and deriving a <code>Future</code> from an
  existing one, typically using methods like <code>Futures.transform</code>
  and <code>Futures.catching</code>
 .
 <p>This class implements all methods in <code>ListenableFuture</code>. Subclasses should provide a way
  to set the result of the computation through the protected methods <code>set(Object)</code>, <code>setFuture(ListenableFuture)</code>
  and <code>setException(Throwable)</code>. Subclasses may also override 
 <code>afterDone()</code>, which will be invoked automatically when the future completes. Subclasses
  should rarely override other methods.
 @author Sven Mawson
 @author Luke Sandberg
 @since 1.0
 */
@interface ComGoogleCommonUtilConcurrentAbstractFuture : ComGoogleCommonUtilConcurrentFluentFuture

#pragma mark Public

/*!
 @since 10.0
 */
- (void)addListenerWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)listener
         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief <p>If a cancellation attempt succeeds on a <code>Future</code> that had previously been set asynchronously
 , then the cancellation will also be propagated to the delegate 
 <code>Future</code> that was supplied in the <code>setFuture</code> call.
 <p>Rather than override this method to perform additional cancellation work or cleanup,
  subclasses should override <code>afterDone</code>, consulting <code>isCancelled</code> and <code>wasInterrupted</code>
  as necessary. This ensures that the work is done even if the future is
  cancelled without a call to <code>cancel</code>, such as by calling <code>setFuture(cancelledFuture)</code>
 .
 */
- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

/*!
 @brief <p>The default <code>AbstractFuture</code> implementation throws <code>InterruptedException</code> if the
  current thread is interrupted during the call, even if the value is already available.
 @throw CancellationException
 */
- (id)get;

/*!
 @brief <p>The default <code>AbstractFuture</code> implementation throws <code>InterruptedException</code> if the
  current thread is interrupted during the call, even if the value is already available.
 @throw CancellationException
 */
- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

- (jboolean)isCancelled;

- (jboolean)isDone;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Constructor for use by subclasses.
 */
- (instancetype __nonnull)init;

/*!
 @brief Callback method that is called exactly once after the future is completed.
 <p>If <code>interruptTask</code> is also run during completion, <code>afterDone</code> runs after it. 
 <p>The default implementation of this method in <code>AbstractFuture</code> does nothing. This is
  intended for very lightweight cleanup work, for example, timing statistics or clearing fields.
  If your task does anything heavier consider, just using a listener with an executor.
 @since 20.0
 */
- (void)afterDone;

/*!
 @brief Subclasses can override this method to implement interruption of the future's computation.The
  method is invoked automatically by a successful call to <code>cancel(true)</code>.
 <p>The default implementation does nothing. 
 <p>This method is likely to be deprecated. Prefer to override <code>afterDone</code>, checking 
 <code>wasInterrupted</code> to decide whether to interrupt your task.
 @since 10.0
 */
- (void)interruptTask;

/*!
 @brief Provide a human-readable explanation of why this future has not yet completed.
 @return null if an explanation cannot be provided because the future is done.
 @since 23.0
 */
- (NSString * __nullable)pendingToString;

/*!
 @brief Sets the result of this <code>Future</code> unless this <code>Future</code> has already been cancelled or
  set (including set asynchronously).When a call to this method returns,
  the <code>Future</code> is guaranteed to be done <b>only if</b> the call was
  accepted (in which case it returns <code>true</code>).
 If it returns <code>false</code>, the <code>Future</code>
  may have previously been set asynchronously, in which case its result may not be known
  yet. That result, though not yet known, cannot be overridden by a call to a <code>set*</code>
  method, only by a call to <code>cancel</code>.
 @param value the value to be used as the result
 @return true if the attempt was accepted, completing the <code>Future</code>
 */
- (jboolean)setWithId:(id __nonnull)value;

/*!
 @brief Sets the failed result of this <code>Future</code> unless this <code>Future</code> has already been
  cancelled or set (including set asynchronously).When a call to this
  method returns, the <code>Future</code> is guaranteed to be done <b>only if</b>
  the call was accepted (in which case it returns <code>true</code>).
 If it returns <code>false</code>, the 
 <code>Future</code> may have previously been set asynchronously, in which case its result may not be
  known yet. That result, though not yet known, cannot be overridden by a call to a <code>set*</code>
  method, only by a call to <code>cancel</code>.
 @param throwable the exception to be used as the failed result
 @return true if the attempt was accepted, completing the <code>Future</code>
 */
- (jboolean)setExceptionWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable;

/*!
 @brief Sets the result of this <code>Future</code> to match the supplied input <code>Future</code> once the
  supplied <code>Future</code> is done, unless this <code>Future</code> has already been cancelled or set
  (including "set asynchronously," defined below).
 <p>If the supplied future is done when this method is called and the call
  is accepted, then this future is guaranteed to have been completed with the supplied future by
  the time this method returns. If the supplied future is not done and the call is accepted, then
  the future will be <i>set asynchronously</i>. Note that such a result, though not yet known,
  cannot be overridden by a call to a <code>set*</code> method, only by a call to <code>cancel</code>.
  
 <p>If the call <code>setFuture(delegate)</code> is accepted and this <code>Future</code> is later
  cancelled, cancellation will be propagated to <code>delegate</code>. Additionally, any call to 
 <code>setFuture</code> after any cancellation will propagate cancellation to the supplied <code>Future</code>
 .
  
 <p>Note that, even if the supplied future is cancelled and it causes this future to complete,
  it will never trigger interruption behavior. In particular, it will not cause this future to
  invoke the <code>interruptTask</code> method, and the <code>wasInterrupted</code> method will not
  return <code>true</code>.
 @param future the future to delegate to
 @return true if the attempt was accepted, indicating that the <code>Future</code> was not previously
      cancelled or set.
 @since 19.0
 */
- (jboolean)setFutureWithComGoogleCommonUtilConcurrentListenableFuture:(id<ComGoogleCommonUtilConcurrentListenableFuture> __nonnull)future;

/*!
 @brief Returns true if this future was cancelled with <code>mayInterruptIfRunning</code> set to <code>true</code>
 .
 @since 14.0
 */
- (jboolean)wasInterrupted;

#pragma mark Package-Private

/*!
 @brief If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts)
  the given future (if available).
 */
- (void)maybePropagateCancellationToWithJavaUtilConcurrentFuture:(id<JavaUtilConcurrentFuture> __nullable)related;

/*!
 @brief Returns the exception that this <code>Future</code> completed with.This includes completion through
  a call to <code>setException</code> or <code>setFuture</code><code>(failedFuture)</code> but not
  cancellation.
 @throw RuntimeExceptionif the <code>Future</code> has not failed
 */
- (JavaLangThrowable *)trustedGetException;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentAbstractFuture)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentAbstractFuture_init(ComGoogleCommonUtilConcurrentAbstractFuture *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentAbstractFuture)

#endif

#if !defined (ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture))
#define ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture_

@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A less abstract subclass of AbstractFuture.This can be used to optimize setFuture by ensuring
  that <code>get</code> calls exactly the implementation of <code>AbstractFuture.get</code>.
 */
@interface ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture : ComGoogleCommonUtilConcurrentAbstractFuture

#pragma mark Public

- (void)addListenerWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)listener
         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

- (id)get;

- (id)getWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

- (jboolean)isCancelled;

- (jboolean)isDone;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture_init(ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentAbstractFuture_TrustedFuture)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentAbstractFuture")
