//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/collect/Sets.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonCollectSets")
#ifdef RESTRICT_ComGoogleCommonCollectSets
#define INCLUDE_ALL_ComGoogleCommonCollectSets 0
#else
#define INCLUDE_ALL_ComGoogleCommonCollectSets 1
#endif
#undef RESTRICT_ComGoogleCommonCollectSets

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonCollectSets_) && (INCLUDE_ALL_ComGoogleCommonCollectSets || defined(INCLUDE_ComGoogleCommonCollectSets))
#define ComGoogleCommonCollectSets_

@class ComGoogleCommonCollectImmutableSet;
@class ComGoogleCommonCollectRange;
@class ComGoogleCommonCollectSets_SetView;
@class IOSClass;
@class IOSObjectArray;
@class JavaLangEnum;
@class JavaUtilConcurrentCopyOnWriteArraySet;
@class JavaUtilEnumSet;
@class JavaUtilHashSet;
@class JavaUtilLinkedHashSet;
@class JavaUtilTreeSet;
@protocol ComGoogleCommonBasePredicate;
@protocol JavaLangIterable;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilIterator;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSet;
@protocol JavaUtilSortedSet;
@protocol JavaUtilStreamCollector;

/*!
 @brief Static utility methods pertaining to <code>Set</code> instances.Also see this class's counterparts 
 <code>Lists</code>, <code>Maps</code> and <code>Queues</code>.
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#sets">
  <code>Sets</code></a>.
 @author Kevin Bourrillion
 @author Jared Levy
 @author Chris Povirk
 @since 2.0
 */
@interface ComGoogleCommonCollectSets : NSObject

#pragma mark Public

/*!
 @brief Returns every possible list that can be formed by choosing one element from each of the given
  sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
  product</a>" of the sets.For example: 
 @code
 Sets.cartesianProduct(ImmutableList.of(
      ImmutableSet.of(1, 2),
      ImmutableSet.of("A", "B", "C"))) 
 
@endcode
  
 <p>returns a set containing six lists: 
 <ul>
    <li><code>ImmutableList.of(1, "A")</code>
    <li><code>ImmutableList.of(1, "B")</code>
    <li><code>ImmutableList.of(1, "C")</code>
    <li><code>ImmutableList.of(2, "A")</code>
    <li><code>ImmutableList.of(2, "B")</code>
    <li><code>ImmutableList.of(2, "C")</code>
  </ul>
  
 <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
  products that you would get from nesting for loops: 
 @code
 for (B b0 : sets.get(0)) {
    for (B b1 : sets.get(1)) {
      ...
 ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
      // operate on tuple
    }  }  
 
@endcode
  
 <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
  all are provided (an empty list), the resulting Cartesian product has one element, an empty
  list (counter-intuitive, but mathematically consistent). 
 <p><i>Performance notes:</i> while the cartesian product of sets of size <code>m, n, p</code> is a
  set of size <code>m x n x p</code>, its actual memory consumption is much smaller. When the
  cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
  iterated are the individual lists created, and these are not retained after iteration.
 @param sets the sets to choose elements from, in the order that the elements chosen from those      sets should appear in the resulting lists
 @return the Cartesian product, as an immutable set containing immutable lists
 @throw NullPointerExceptionif <code>sets</code>, any one of the <code>sets</code>, or any element of a
      provided set is null
 @since 2.0
 */
+ (id<JavaUtilSet>)cartesianProductWithJavaUtilList:(id<JavaUtilList>)sets;

/*!
 @brief Returns every possible list that can be formed by choosing one element from each of the given
  sets in order; the "n-ary <a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian
  product</a>" of the sets.For example: 
 @code
 Sets.cartesianProduct(
      ImmutableSet.of(1, 2),
      ImmutableSet.of("A", "B", "C")) 
 
@endcode
  
 <p>returns a set containing six lists: 
 <ul>
    <li><code>ImmutableList.of(1, "A")</code>
    <li><code>ImmutableList.of(1, "B")</code>
    <li><code>ImmutableList.of(1, "C")</code>
    <li><code>ImmutableList.of(2, "A")</code>
    <li><code>ImmutableList.of(2, "B")</code>
    <li><code>ImmutableList.of(2, "C")</code>
  </ul>
  
 <p>The result is guaranteed to be in the "traditional", lexicographical order for Cartesian
  products that you would get from nesting for loops: 
 @code
 for (B b0 : sets.get(0)) {
    for (B b1 : sets.get(1)) {
      ...
 ImmutableList<B> tuple = ImmutableList.of(b0, b1, ...);
      // operate on tuple
    }  }  
 
@endcode
  
 <p>Note that if any input set is empty, the Cartesian product will also be empty. If no sets at
  all are provided (an empty list), the resulting Cartesian product has one element, an empty
  list (counter-intuitive, but mathematically consistent). 
 <p><i>Performance notes:</i> while the cartesian product of sets of size <code>m, n, p</code> is a
  set of size <code>m x n x p</code>, its actual memory consumption is much smaller. When the
  cartesian set is constructed, the input sets are merely copied. Only as the resulting set is
  iterated are the individual lists created, and these are not retained after iteration.
 @param sets the sets to choose elements from, in the order that the elements chosen from those      sets should appear in the resulting lists
 @return the Cartesian product, as an immutable set containing immutable lists
 @throw NullPointerExceptionif <code>sets</code>, any one of the <code>sets</code>, or any element of a
      provided set is null
 @since 2.0
 */
+ (id<JavaUtilSet>)cartesianProductWithJavaUtilSetArray:(IOSObjectArray *)sets;

/*!
 @brief Returns the set of all subsets of <code>set</code> of size <code>size</code>.For example, <code>combinations(ImmutableSet.of(1, 2, 3), 2)</code>
  returns the set <code>{{1, 2}, {1, 3}, {2, 3}}</code>.
 <p>Elements appear in these subsets in the same iteration order as they appeared in the input
  set. The order in which these subsets appear in the outer set is undefined. 
 <p>The returned set and its constituent sets use <code>equals</code> to decide whether two elements
  are identical, even if the input set uses a different concept of equivalence. 
 <p><i>Performance notes:</i> the memory usage of the returned set is only <code>O(n)</code>. When
  the result set is constructed, the input set is merely copied. Only as the result set is
  iterated are the individual subsets created. Each of these subsets occupies an additional O(n)
  memory but only for as long as the user retains a reference to it. That is, the set returned by 
 <code>combinations</code> does not retain the individual subsets.
 @param set the set of elements to take combinations of
 @param size the number of elements per combination
 @return the set of all combinations of <code>size</code> elements from <code>set</code>
 @throw IllegalArgumentExceptionif <code>size</code> is not between 0 and <code>set.size()</code>
      inclusive
 @throw NullPointerExceptionif <code>set</code> is or contains <code>null</code>
 @since 23.0
 */
+ (id<JavaUtilSet>)combinationsWithJavaUtilSet:(id<JavaUtilSet>)set
                                       withInt:(jint)size;

/*!
 @brief Creates an <code>EnumSet</code> consisting of all enum values that are not in the specified
  collection.If the collection is an <code>EnumSet</code>, this method has the same behavior as 
 <code>EnumSet.complementOf</code>.
 Otherwise, the specified collection must contain at least one
  element, in order to determine the element type. If the collection could be empty, use <code>complementOf(Collection, Class)</code>
  instead of this method.
 @param collection the collection whose complement should be stored in the enum set
 @return a new, modifiable <code>EnumSet</code> containing all values of the enum that aren't present
      in the given collection
 @throw IllegalArgumentExceptionif <code>collection</code> is not an <code>EnumSet</code> instance and
      contains no elements
 */
+ (JavaUtilEnumSet *)complementOfWithJavaUtilCollection:(id<JavaUtilCollection>)collection;

/*!
 @brief Creates an <code>EnumSet</code> consisting of all enum values that are not in the specified
  collection.This is equivalent to <code>EnumSet.complementOf</code>, but can act on any input
  collection, as long as the elements are of enum type.
 @param collection the collection whose complement should be stored in the <code>EnumSet</code>
 @param type the type of the elements in the set
 @return a new, modifiable <code>EnumSet</code> initially containing all the values of the enum not
      present in the given collection
 */
+ (JavaUtilEnumSet *)complementOfWithJavaUtilCollection:(id<JavaUtilCollection>)collection
                                           withIOSClass:(IOSClass *)type;

/*!
 @brief Returns an unmodifiable <b>view</b> of the difference of two sets.The returned set contains
  all elements that are contained by <code>set1</code> and not contained by <code>set2</code>.
 <code>set2</code>
  may also contain elements not present in <code>set1</code>; these are simply ignored. The iteration
  order of the returned set matches that of <code>set1</code>.
  
 <p>Results are undefined if <code>set1</code> and <code>set2</code> are sets based on different
  equivalence relations (as <code>HashSet</code>, <code>TreeSet</code>, and the keySet of an <code>IdentityHashMap</code>
  all are).
 */
+ (ComGoogleCommonCollectSets_SetView *)differenceWithJavaUtilSet:(id<JavaUtilSet>)set1
                                                  withJavaUtilSet:(id<JavaUtilSet>)set2;

/*!
 @brief Returns the elements of a <code>NavigableSet</code>, <code>unfiltered</code>, that satisfy a predicate.
 The returned set is a live view of <code>unfiltered</code>; changes to one affect the other. 
 <p>The resulting set's iterator does not support <code>remove()</code>, but all other set methods
  are supported. When given an element that doesn't satisfy the predicate, the set's <code>add()</code>
  and <code>addAll()</code> methods throw an <code>IllegalArgumentException</code>. When methods
  such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered set, only elements
  that satisfy the filter will be removed from the underlying set. 
 <p>The returned set isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered set's methods, such as <code>size()</code>, iterate across every element in
  the underlying set and determine which elements satisfy the filter. When a live view is 
 <i>not</i> needed, it may be faster to copy <code>Iterables.filter(unfiltered, predicate)</code> and
  use the copy. 
 <p><b>Warning:</b> <code>predicate</code> must be <i>consistent with equals</i>, as documented at 
 <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals. (See <code>Iterables.filter(Iterable, Class)</code>
  for related functionality.)
 @since 14.0
 */
+ (id<JavaUtilNavigableSet>)filterWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)unfiltered
                          withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)predicate;

/*!
 @brief Returns the elements of <code>unfiltered</code> that satisfy a predicate.The returned set is a live
  view of <code>unfiltered</code>; changes to one affect the other.
 <p>The resulting set's iterator does not support <code>remove()</code>, but all other set methods
  are supported. When given an element that doesn't satisfy the predicate, the set's <code>add()</code>
  and <code>addAll()</code> methods throw an <code>IllegalArgumentException</code>. When methods
  such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered set, only elements
  that satisfy the filter will be removed from the underlying set. 
 <p>The returned set isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered set's methods, such as <code>size()</code>, iterate across every element in
  the underlying set and determine which elements satisfy the filter. When a live view is 
 <i>not</i> needed, it may be faster to copy <code>Iterables.filter(unfiltered, predicate)</code> and
  use the copy. 
 <p><b>Warning:</b> <code>predicate</code> must be <i>consistent with equals</i>, as documented at 
 <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals. (See <code>Iterables.filter(Iterable, Class)</code>
  for related functionality.) 
 <p><b>Java 8 users:</b> many use cases for this method are better addressed by <code>java.util.stream.Stream.filter</code>
 . This method is not being deprecated, but we gently encourage
  you to migrate to streams.
 */
+ (id<JavaUtilSet>)filterWithJavaUtilSet:(id<JavaUtilSet>)unfiltered
        withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)predicate;

/*!
 @brief Returns the elements of a <code>SortedSet</code>, <code>unfiltered</code>, that satisfy a predicate.The
  returned set is a live view of <code>unfiltered</code>; changes to one affect the other.
 <p>The resulting set's iterator does not support <code>remove()</code>, but all other set methods
  are supported. When given an element that doesn't satisfy the predicate, the set's <code>add()</code>
  and <code>addAll()</code> methods throw an <code>IllegalArgumentException</code>. When methods
  such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered set, only elements
  that satisfy the filter will be removed from the underlying set. 
 <p>The returned set isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered set's methods, such as <code>size()</code>, iterate across every element in
  the underlying set and determine which elements satisfy the filter. When a live view is 
 <i>not</i> needed, it may be faster to copy <code>Iterables.filter(unfiltered, predicate)</code> and
  use the copy. 
 <p><b>Warning:</b> <code>predicate</code> must be <i>consistent with equals</i>, as documented at 
 <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals. (See <code>Iterables.filter(Iterable, Class)</code>
  for related functionality.)
 @since 11.0
 */
+ (id<JavaUtilSortedSet>)filterWithJavaUtilSortedSet:(id<JavaUtilSortedSet>)unfiltered
                    withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)predicate;

/*!
 @brief Returns an immutable set instance containing the given enum elements.Internally, the returned
  set will be backed by an <code>EnumSet</code>.
 <p>The iteration order of the returned set follows the enum's iteration order, not the order in
  which the elements are provided to the method.
 @param anElement one of the elements the set should contain
 @param otherElements the rest of the elements the set should contain
 @return an immutable set containing those elements, minus duplicates
 */
+ (ComGoogleCommonCollectImmutableSet *)immutableEnumSetWithJavaLangEnum:(JavaLangEnum *)anElement
                                                   withJavaLangEnumArray:(IOSObjectArray *)otherElements;

/*!
 @brief Returns an immutable set instance containing the given enum elements.Internally, the returned
  set will be backed by an <code>EnumSet</code>.
 <p>The iteration order of the returned set follows the enum's iteration order, not the order in
  which the elements appear in the given collection.
 @param elements the elements, all of the same <code>enum</code>  type, that the set should contain
 @return an immutable set containing those elements, minus duplicates
 */
+ (ComGoogleCommonCollectImmutableSet *)immutableEnumSetWithJavaLangIterable:(id<JavaLangIterable>)elements;

/*!
 @brief Returns an unmodifiable <b>view</b> of the intersection of two sets.The returned set contains
  all elements that are contained by both backing sets.
 The iteration order of the returned set
  matches that of <code>set1</code>.
  
 <p>Results are undefined if <code>set1</code> and <code>set2</code> are sets based on different
  equivalence relations (as <code>HashSet</code>, <code>TreeSet</code>, and the keySet of an <code>IdentityHashMap</code>
  all are). 
 <p><b>Note:</b> The returned view performs slightly better when <code>set1</code> is the smaller of
  the two sets. If you have reason to believe one of your sets will generally be smaller than the
  other, pass it first. Unfortunately, since this method sets the generic type of the returned
  set based on the type of the first set passed, this could in rare cases force you to make a
  cast, for example: 
 @code
 Set<Object> aFewBadObjects = ...
  Set<String> manyBadStrings = ...
  // impossible for a non-String to be in the intersection
  SuppressWarnings("unchecked")
  Set<String> badStrings = (Set) Sets.intersection(
      aFewBadObjects, manyBadStrings); 
 
@endcode
  
 <p>This is unfortunate, but should come up only very rarely.
 */
+ (ComGoogleCommonCollectSets_SetView *)intersectionWithJavaUtilSet:(id<JavaUtilSet>)set1
                                                    withJavaUtilSet:(id<JavaUtilSet>)set2;

/*!
 @brief Creates a thread-safe set backed by a hash map.The set is backed by a <code>ConcurrentHashMap</code>
  instance, and thus carries the same concurrency guarantees.
 <p>Unlike <code>HashSet</code>, this class does NOT allow <code>null</code> to be used as an element. The
  set is serializable.
 @return a new, empty thread-safe <code>Set</code>
 @since 15.0
 */
+ (id<JavaUtilSet>)newConcurrentHashSet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a thread-safe set backed by a hash map and containing the given elements.The set is
  backed by a <code>ConcurrentHashMap</code> instance, and thus carries the same concurrency
  guarantees.
 <p>Unlike <code>HashSet</code>, this class does NOT allow <code>null</code> to be used as an element. The
  set is serializable.
 @param elements the elements that the set should contain
 @return a new thread-safe set containing those elements (minus duplicates)
 @throw NullPointerExceptionif <code>elements</code> or any of its contents is null
 @since 15.0
 */
+ (id<JavaUtilSet>)newConcurrentHashSetWithJavaLangIterable:(id<JavaLangIterable>)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates an empty <code>CopyOnWriteArraySet</code> instance.
 <p><b>Note:</b> if you need an immutable empty <code>Set</code>, use <code>Collections.emptySet</code>
  instead.
 @return a new, empty <code>CopyOnWriteArraySet</code>
 @since 12.0
 */
+ (JavaUtilConcurrentCopyOnWriteArraySet *)newCopyOnWriteArraySet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>CopyOnWriteArraySet</code> instance containing the given elements.
 @param elements the elements that the set should contain, in order
 @return a new <code>CopyOnWriteArraySet</code> containing those elements
 @since 12.0
 */
+ (JavaUtilConcurrentCopyOnWriteArraySet *)newCopyOnWriteArraySetWithJavaLangIterable:(id<JavaLangIterable>)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a new, <i>mutable</i> <code>EnumSet</code> instance containing the given elements in their
  natural order.This method behaves identically to <code>EnumSet.copyOf(Collection)</code>, but also
  accepts non-<code>Collection</code> iterables and empty iterables.
 */
+ (JavaUtilEnumSet *)newEnumSetWithJavaLangIterable:(id<JavaLangIterable>)iterable
                                       withIOSClass:(IOSClass *)elementType OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i>, initially empty <code>HashSet</code> instance.
 <p><b>Note:</b> if mutability is not required, use <code>ImmutableSet.of()</code> instead. If <code>E</code>
  is an <code>Enum</code> type, use <code>EnumSet.noneOf</code> instead. Otherwise, strongly consider
  using a <code>LinkedHashSet</code> instead, at the cost of increased memory footprint, to get
  deterministic iteration behavior. 
 <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as
  deprecated. Instead, use the <code>HashSet</code> constructor directly, taking advantage of the new 
 <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
 */
+ (JavaUtilHashSet *)newHashSet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i> <code>HashSet</code> instance initially containing the given elements.
 <p><b>Note:</b> if elements are non-null and won't be added or removed after this point, use 
 <code>ImmutableSet.of()</code> or <code>ImmutableSet.copyOf(Object[])</code> instead. If <code>E</code> is an 
 <code>Enum</code> type, use <code>EnumSet.of(Enum, Enum[])</code> instead. Otherwise, strongly consider
  using a <code>LinkedHashSet</code> instead, at the cost of increased memory footprint, to get
  deterministic iteration behavior. 
 <p>This method is just a small convenience, either for <code>newHashSet(</code><code>asList</code>
 <code>(...))</code>, or for creating an empty set then calling <code>Collections.addAll</code>.
  This method is not actually very useful and will likely be deprecated in the future.
 */
+ (JavaUtilHashSet *)newHashSetWithNSObjectArray:(IOSObjectArray *)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i> <code>HashSet</code> instance containing the given elements.A very thin
  convenience for creating an empty set then calling <code>Collection.addAll</code> or <code>Iterables.addAll</code>
 .
 <p><b>Note:</b> if mutability is not required and the elements are non-null, use <code>ImmutableSet.copyOf(Iterable)</code>
  instead. (Or, change <code>elements</code> to be a <code>FluentIterable</code>
  and call <code>elements.toSet()</code>.)
  
 <p><b>Note:</b> if <code>E</code> is an <code>Enum</code> type, use <code>newEnumSet(Iterable, Class)</code>
  instead. 
 <p><b>Note for Java 7 and later:</b> if <code>elements</code> is a <code>Collection</code>, you don't
  need this method. Instead, use the <code>HashSet</code> constructor directly, taking advantage of
  the new <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
  
 <p>Overall, this method is not very useful and will likely be deprecated in the future.
 */
+ (JavaUtilHashSet *)newHashSetWithJavaLangIterable:(id<JavaLangIterable>)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i> <code>HashSet</code> instance containing the given elements.A very thin
  convenience for creating an empty set and then calling <code>Iterators.addAll</code>.
 <p><b>Note:</b> if mutability is not required and the elements are non-null, use <code>ImmutableSet.copyOf(Iterator)</code>
  instead. 
 <p><b>Note:</b> if <code>E</code> is an <code>Enum</code> type, you should create an <code>EnumSet</code>
  instead. 
 <p>Overall, this method is not very useful and will likely be deprecated in the future.
 */
+ (JavaUtilHashSet *)newHashSetWithJavaUtilIterator:(id<JavaUtilIterator>)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a new hash set using the smallest initial table size that can hold <code>expectedSize</code>
  elements without resizing.Note that this is not what <code>HashSet.HashSet(int)</code> does, but it
  is what most users want and expect it to do.
 <p>This behavior can't be broadly guaranteed, but has been tested with OpenJDK 1.7 and 1.8.
 @param expectedSize the number of elements you expect to add to the returned set
 @return a new, empty hash set with enough capacity to hold <code>expectedSize</code> elements
      without resizing
 @throw IllegalArgumentExceptionif <code>expectedSize</code> is negative
 */
+ (JavaUtilHashSet *)newHashSetWithExpectedSizeWithInt:(jint)expectedSize OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates an empty <code>Set</code> that uses identity to determine equality.It compares object
  references, instead of calling <code>equals</code>, to determine whether a provided object matches
  an element in the set.
 For example, <code>contains</code> returns <code>false</code> when passed an
  object that equals a set member, but isn't the same instance. This behavior is similar to the
  way <code>IdentityHashMap</code> handles key lookups.
 @since 8.0
 */
+ (id<JavaUtilSet>)newIdentityHashSet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i>, empty <code>LinkedHashSet</code> instance.
 <p><b>Note:</b> if mutability is not required, use <code>ImmutableSet.of()</code> instead. 
 <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as
  deprecated. Instead, use the <code>LinkedHashSet</code> constructor directly, taking advantage of
  the new <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
 @return a new, empty <code>LinkedHashSet</code>
 */
+ (JavaUtilLinkedHashSet *)newLinkedHashSet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i> <code>LinkedHashSet</code> instance containing the given elements in order.
 <p><b>Note:</b> if mutability is not required and the elements are non-null, use <code>ImmutableSet.copyOf(Iterable)</code>
  instead. 
 <p><b>Note for Java 7 and later:</b> if <code>elements</code> is a <code>Collection</code>, you don't
  need this method. Instead, use the <code>LinkedHashSet</code> constructor directly, taking advantage
  of the new <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
  
 <p>Overall, this method is not very useful and will likely be deprecated in the future.
 @param elements the elements that the set should contain, in order
 @return a new <code>LinkedHashSet</code> containing those elements (minus duplicates)
 */
+ (JavaUtilLinkedHashSet *)newLinkedHashSetWithJavaLangIterable:(id<JavaLangIterable>)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <code>LinkedHashSet</code> instance, with a high enough "initial capacity" that it 
 <i>should</i> hold <code>expectedSize</code> elements without growth.This behavior cannot be
  broadly guaranteed, but it is observed to be true for OpenJDK 1.7.
 It also can't be guaranteed
  that the method isn't inadvertently <i>oversizing</i> the returned set.
 @param expectedSize the number of elements you expect to add to the returned set
 @return a new, empty <code>LinkedHashSet</code> with enough capacity to hold <code>expectedSize</code>
      elements without resizing
 @throw IllegalArgumentExceptionif <code>expectedSize</code> is negative
 @since 11.0
 */
+ (JavaUtilLinkedHashSet *)newLinkedHashSetWithExpectedSizeWithInt:(jint)expectedSize OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a set backed by the specified map.The resulting set displays the same ordering,
  concurrency, and performance characteristics as the backing map.
 In essence, this factory
  method provides a <code>Set</code> implementation corresponding to any <code>Map</code> implementation.
  There is no need to use this method on a <code>Map</code> implementation that already has a
  corresponding <code>Set</code> implementation (such as <code>java.util.HashMap</code> or <code>java.util.TreeMap</code>
 ).
  
 <p>Each method invocation on the set returned by this method results in exactly one method
  invocation on the backing map or its <code>keySet</code> view, with one exception. The <code>addAll</code>
  method is implemented as a sequence of <code>put</code> invocations on the backing map. 
 <p>The specified map must be empty at the time this method is invoked, and should not be
  accessed directly after this method returns. These conditions are ensured if the map is created
  empty, passed directly to this method, and no reference to the map is retained, as illustrated
  in the following code fragment: 
 @code
 Set<Object> identityHashSet = Sets.newSetFromMap(
      new IdentityHashMap<Object, Boolean>()); 
 
@endcode
  
 <p>The returned set is serializable if the backing map is.
 @param map the backing map
 @return the set backed by the map
 @throw IllegalArgumentExceptionif <code>map</code> is not empty
 */
+ (id<JavaUtilSet>)newSetFromMapWithJavaUtilMap:(id<JavaUtilMap>)map OBJC_METHOD_FAMILY_NONE __attribute__((deprecated));

/*!
 @brief Creates a <i>mutable</i>, empty <code>TreeSet</code> instance sorted by the natural sort ordering of
  its elements.
 <p><b>Note:</b> if mutability is not required, use <code>ImmutableSortedSet.of()</code> instead. 
 <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as
  deprecated. Instead, use the <code>TreeSet</code> constructor directly, taking advantage of the new 
 <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
 @return a new, empty <code>TreeSet</code>
 */
+ (JavaUtilTreeSet *)newTreeSet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i>, empty <code>TreeSet</code> instance with the given comparator.
 <p><b>Note:</b> if mutability is not required, use <code>ImmutableSortedSet.orderedBy(comparator).build()</code>
  instead. 
 <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as
  deprecated. Instead, use the <code>TreeSet</code> constructor directly, taking advantage of the new 
 <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>. One caveat to this is that the <code>TreeSet</code>
  constructor uses a null <code>Comparator</code> to mean "natural ordering," whereas this
  factory rejects null. Clean your code accordingly.
 @param comparator the comparator to use to sort the set
 @return a new, empty <code>TreeSet</code>
 @throw NullPointerExceptionif <code>comparator</code> is null
 */
+ (JavaUtilTreeSet *)newTreeSetWithJavaUtilComparator:(id<JavaUtilComparator>)comparator OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a <i>mutable</i> <code>TreeSet</code> instance containing the given elements sorted by their
  natural ordering.
 <p><b>Note:</b> if mutability is not required, use <code>ImmutableSortedSet.copyOf(Iterable)</code>
  instead. 
 <p><b>Note:</b> If <code>elements</code> is a <code>SortedSet</code> with an explicit comparator, this
  method has different behavior than <code>TreeSet.TreeSet(SortedSet)</code>, which returns a <code>TreeSet</code>
  with that comparator. 
 <p><b>Note for Java 7 and later:</b> this method is now unnecessary and should be treated as
  deprecated. Instead, use the <code>TreeSet</code> constructor directly, taking advantage of the new 
 <a href="http://goo.gl/iz2Wi">"diamond" syntax</a>.
  
 <p>This method is just a small convenience for creating an empty set and then calling <code>Iterables.addAll</code>
 . This method is not very useful and will likely be deprecated in the future.
 @param elements the elements that the set should contain
 @return a new <code>TreeSet</code> containing those elements (minus duplicates)
 */
+ (JavaUtilTreeSet *)newTreeSetWithJavaLangIterable:(id<JavaLangIterable>)elements OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns the set of all possible subsets of <code>set</code>.For example, <code>powerSet(ImmutableSet.of(1, 2))</code>
  returns the set <code>{{}, {1}, {2}, {1, 2}}</code>.
 <p>Elements appear in these subsets in the same iteration order as they appeared in the input
  set. The order in which these subsets appear in the outer set is undefined. Note that the power
  set of the empty set is not the empty set, but a one-element set containing the empty set. 
 <p>The returned set and its constituent sets use <code>equals</code> to decide whether two elements
  are identical, even if the input set uses a different concept of equivalence. 
 <p><i>Performance notes:</i> while the power set of a set with size <code>n</code> is of size <code>2^n</code>
 , its memory usage is only <code>O(n)</code>. When the power set is constructed, the input set
  is merely copied. Only as the power set is iterated are the individual subsets created, and
  these subsets themselves occupy only a small constant amount of memory.
 @param set the set of elements to construct a power set from
 @return the power set, as an immutable set of immutable sets
 @throw IllegalArgumentExceptionif <code>set</code> has more than 30 unique elements (causing the
      power set size to exceed the <code>int</code> range)
 @throw NullPointerExceptionif <code>set</code> is or contains <code>null</code>
 - seealso: <a href="http://en.wikipedia.org/wiki/Power_set">Power set article at Wikipedia</a>
 @since 4.0
 */
+ (id<JavaUtilSet>)powerSetWithJavaUtilSet:(id<JavaUtilSet>)set;

/*!
 @brief Returns a view of the portion of <code>set</code> whose elements are contained by <code>range</code>.
 <p>This method delegates to the appropriate methods of <code>NavigableSet</code> (namely <code>subSet()</code>
 , <code>tailSet()</code>
 , and <code>headSet()</code>
 ) to actually construct the view. Consult these methods for a full
  description of the returned view's behavior. 
 <p><b>Warning:</b> <code>Range</code>s always represent a range of values using the values' natural
  ordering. <code>NavigableSet</code> on the other hand can specify a custom ordering via a <code>Comparator</code>
 , which can violate the natural ordering. Using this method (or in general using 
 <code>Range</code>) with unnaturally-ordered sets can lead to unexpected and undefined behavior.
 @since 20.0
 */
+ (id<JavaUtilNavigableSet>)subSetWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)set
                           withComGoogleCommonCollectRange:(ComGoogleCommonCollectRange *)range;

/*!
 @brief Returns an unmodifiable <b>view</b> of the symmetric difference of two sets.The returned set
  contains all elements that are contained in either <code>set1</code> or <code>set2</code> but not in
  both.
 The iteration order of the returned set is undefined. 
 <p>Results are undefined if <code>set1</code> and <code>set2</code> are sets based on different
  equivalence relations (as <code>HashSet</code>, <code>TreeSet</code>, and the keySet of an <code>IdentityHashMap</code>
  all are).
 @since 3.0
 */
+ (ComGoogleCommonCollectSets_SetView *)symmetricDifferenceWithJavaUtilSet:(id<JavaUtilSet>)set1
                                                           withJavaUtilSet:(id<JavaUtilSet>)set2;

/*!
 @brief Returns a synchronized (thread-safe) navigable set backed by the specified navigable set.In
  order to guarantee serial access, it is critical that <b>all</b> access to the backing
  navigable set is accomplished through the returned navigable set (or its views).
 <p>It is imperative that the user manually synchronize on the returned sorted set when
  iterating over it or any of its <code>descendingSet</code>, <code>subSet</code>, <code>headSet</code>, or 
 <code>tailSet</code> views. 
 @code
 NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());
   ...
  synchronized (set) {
    // Must be in the synchronized block
    Iterator<E> it = set.iterator();
    while (it.hasNext()) {
      foo(it.next());
    }  }  
 
@endcode
  
 <p>or:
  
 @code
 NavigableSet<E> set = synchronizedNavigableSet(new TreeSet<E>());
  NavigableSet<E> set2 = set.descendingSet().headSet(foo);
   ...
  synchronized (set) { // Note: set, not set2!!!
    // Must be in the synchronized block
    Iterator<E> it = set2.descendingIterator();
    while (it.hasNext())
      foo(it.next());
    } 
  }
@endcode
  
 <p>Failure to follow this advice may result in non-deterministic behavior. 
 <p>The returned navigable set will be serializable if the specified navigable set is
  serializable.
 @param navigableSet the navigable set to be "wrapped" in a synchronized navigable set.
 @return a synchronized view of the specified navigable set.
 @since 13.0
 */
+ (id<JavaUtilNavigableSet>)synchronizedNavigableSetWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)navigableSet;

/*!
 @brief Returns a <code>Collector</code> that accumulates the input elements into a new <code>ImmutableSet</code>
  with an implementation specialized for enums.Unlike <code>ImmutableSet.toImmutableSet</code>, the
  resulting set will iterate over elements in their enum definition order, not encounter order.
 @since 21.0
 */
+ (id<JavaUtilStreamCollector>)toImmutableEnumSet;

/*!
 @brief Returns an unmodifiable <b>view</b> of the union of two sets.The returned set contains all
  elements that are contained in either backing set.
 Iterating over the returned set iterates
  first over all the elements of <code>set1</code>, then over each element of <code>set2</code>, in order,
  that is not contained in <code>set1</code>.
  
 <p>Results are undefined if <code>set1</code> and <code>set2</code> are sets based on different
  equivalence relations (as <code>HashSet</code>, <code>TreeSet</code>, and the <code>Map.keySet</code> of an 
 <code>IdentityHashMap</code> all are).
 */
+ (ComGoogleCommonCollectSets_SetView *)union__WithJavaUtilSet:(id<JavaUtilSet>)set1
                                               withJavaUtilSet:(id<JavaUtilSet>)set2;

/*!
 @brief Returns an unmodifiable view of the specified navigable set.This method allows modules to
  provide users with "read-only" access to internal navigable sets.
 Query operations on the
  returned set "read through" to the specified set, and attempts to modify the returned set,
  whether direct or via its collection views, result in an <code>UnsupportedOperationException</code>.
  
 <p>The returned navigable set will be serializable if the specified navigable set is
  serializable.
 @param set the navigable set for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified navigable set
 @since 12.0
 */
+ (id<JavaUtilNavigableSet>)unmodifiableNavigableSetWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)set;

#pragma mark Package-Private

/*!
 @brief An implementation for <code>Set.equals(Object)</code>.
 */
+ (jboolean)equalsImplWithJavaUtilSet:(id<JavaUtilSet>)s
                               withId:(id __nullable)object;

/*!
 @brief An implementation for <code>Set.hashCode()</code>.
 */
+ (jint)hashCodeImplWithJavaUtilSet:(id<JavaUtilSet>)s;

+ (jboolean)removeAllImplWithJavaUtilSet:(id<JavaUtilSet>)set
                  withJavaUtilCollection:(id<JavaUtilCollection>)collection;

/*!
 @brief Remove each element in an iterable from a set.
 */
+ (jboolean)removeAllImplWithJavaUtilSet:(id<JavaUtilSet>)set
                    withJavaUtilIterator:(id<JavaUtilIterator>)iterator;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectSets)

FOUNDATION_EXPORT ComGoogleCommonCollectImmutableSet *ComGoogleCommonCollectSets_immutableEnumSetWithJavaLangEnum_withJavaLangEnumArray_(JavaLangEnum *anElement, IOSObjectArray *otherElements);

FOUNDATION_EXPORT ComGoogleCommonCollectImmutableSet *ComGoogleCommonCollectSets_immutableEnumSetWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> ComGoogleCommonCollectSets_toImmutableEnumSet(void);

FOUNDATION_EXPORT JavaUtilEnumSet *ComGoogleCommonCollectSets_newEnumSetWithJavaLangIterable_withIOSClass_(id<JavaLangIterable> iterable, IOSClass *elementType);

FOUNDATION_EXPORT JavaUtilHashSet *ComGoogleCommonCollectSets_newHashSet(void);

FOUNDATION_EXPORT JavaUtilHashSet *ComGoogleCommonCollectSets_newHashSetWithNSObjectArray_(IOSObjectArray *elements);

FOUNDATION_EXPORT JavaUtilHashSet *ComGoogleCommonCollectSets_newHashSetWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT JavaUtilHashSet *ComGoogleCommonCollectSets_newHashSetWithJavaUtilIterator_(id<JavaUtilIterator> elements);

FOUNDATION_EXPORT JavaUtilHashSet *ComGoogleCommonCollectSets_newHashSetWithExpectedSizeWithInt_(jint expectedSize);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_newConcurrentHashSet(void);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_newConcurrentHashSetWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT JavaUtilLinkedHashSet *ComGoogleCommonCollectSets_newLinkedHashSet(void);

FOUNDATION_EXPORT JavaUtilLinkedHashSet *ComGoogleCommonCollectSets_newLinkedHashSetWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT JavaUtilLinkedHashSet *ComGoogleCommonCollectSets_newLinkedHashSetWithExpectedSizeWithInt_(jint expectedSize);

FOUNDATION_EXPORT JavaUtilTreeSet *ComGoogleCommonCollectSets_newTreeSet(void);

FOUNDATION_EXPORT JavaUtilTreeSet *ComGoogleCommonCollectSets_newTreeSetWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT JavaUtilTreeSet *ComGoogleCommonCollectSets_newTreeSetWithJavaUtilComparator_(id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_newIdentityHashSet(void);

FOUNDATION_EXPORT JavaUtilConcurrentCopyOnWriteArraySet *ComGoogleCommonCollectSets_newCopyOnWriteArraySet(void);

FOUNDATION_EXPORT JavaUtilConcurrentCopyOnWriteArraySet *ComGoogleCommonCollectSets_newCopyOnWriteArraySetWithJavaLangIterable_(id<JavaLangIterable> elements);

FOUNDATION_EXPORT JavaUtilEnumSet *ComGoogleCommonCollectSets_complementOfWithJavaUtilCollection_(id<JavaUtilCollection> collection);

FOUNDATION_EXPORT JavaUtilEnumSet *ComGoogleCommonCollectSets_complementOfWithJavaUtilCollection_withIOSClass_(id<JavaUtilCollection> collection, IOSClass *type);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_newSetFromMapWithJavaUtilMap_(id<JavaUtilMap> map);

FOUNDATION_EXPORT ComGoogleCommonCollectSets_SetView *ComGoogleCommonCollectSets_union__WithJavaUtilSet_withJavaUtilSet_(id<JavaUtilSet> set1, id<JavaUtilSet> set2);

FOUNDATION_EXPORT ComGoogleCommonCollectSets_SetView *ComGoogleCommonCollectSets_intersectionWithJavaUtilSet_withJavaUtilSet_(id<JavaUtilSet> set1, id<JavaUtilSet> set2);

FOUNDATION_EXPORT ComGoogleCommonCollectSets_SetView *ComGoogleCommonCollectSets_differenceWithJavaUtilSet_withJavaUtilSet_(id<JavaUtilSet> set1, id<JavaUtilSet> set2);

FOUNDATION_EXPORT ComGoogleCommonCollectSets_SetView *ComGoogleCommonCollectSets_symmetricDifferenceWithJavaUtilSet_withJavaUtilSet_(id<JavaUtilSet> set1, id<JavaUtilSet> set2);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_filterWithJavaUtilSet_withComGoogleCommonBasePredicate_(id<JavaUtilSet> unfiltered, id<ComGoogleCommonBasePredicate> predicate);

FOUNDATION_EXPORT id<JavaUtilSortedSet> ComGoogleCommonCollectSets_filterWithJavaUtilSortedSet_withComGoogleCommonBasePredicate_(id<JavaUtilSortedSet> unfiltered, id<ComGoogleCommonBasePredicate> predicate);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> ComGoogleCommonCollectSets_filterWithJavaUtilNavigableSet_withComGoogleCommonBasePredicate_(id<JavaUtilNavigableSet> unfiltered, id<ComGoogleCommonBasePredicate> predicate);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_cartesianProductWithJavaUtilList_(id<JavaUtilList> sets);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_cartesianProductWithJavaUtilSetArray_(IOSObjectArray *sets);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_powerSetWithJavaUtilSet_(id<JavaUtilSet> set);

FOUNDATION_EXPORT id<JavaUtilSet> ComGoogleCommonCollectSets_combinationsWithJavaUtilSet_withInt_(id<JavaUtilSet> set, jint size);

FOUNDATION_EXPORT jint ComGoogleCommonCollectSets_hashCodeImplWithJavaUtilSet_(id<JavaUtilSet> s);

FOUNDATION_EXPORT jboolean ComGoogleCommonCollectSets_equalsImplWithJavaUtilSet_withId_(id<JavaUtilSet> s, id object);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> ComGoogleCommonCollectSets_unmodifiableNavigableSetWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> set);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> ComGoogleCommonCollectSets_synchronizedNavigableSetWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> navigableSet);

FOUNDATION_EXPORT jboolean ComGoogleCommonCollectSets_removeAllImplWithJavaUtilSet_withJavaUtilIterator_(id<JavaUtilSet> set, id<JavaUtilIterator> iterator);

FOUNDATION_EXPORT jboolean ComGoogleCommonCollectSets_removeAllImplWithJavaUtilSet_withJavaUtilCollection_(id<JavaUtilSet> set, id<JavaUtilCollection> collection);

FOUNDATION_EXPORT id<JavaUtilNavigableSet> ComGoogleCommonCollectSets_subSetWithJavaUtilNavigableSet_withComGoogleCommonCollectRange_(id<JavaUtilNavigableSet> set, ComGoogleCommonCollectRange *range);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectSets)

#endif

#if !defined (ComGoogleCommonCollectSets_ImprovedAbstractSet_) && (INCLUDE_ALL_ComGoogleCommonCollectSets || defined(INCLUDE_ComGoogleCommonCollectSets_ImprovedAbstractSet))
#define ComGoogleCommonCollectSets_ImprovedAbstractSet_

#define RESTRICT_JavaUtilAbstractSet 1
#define INCLUDE_JavaUtilAbstractSet 1
#include "java/util/AbstractSet.h"

@protocol JavaUtilCollection;

/*!
 @brief <code>AbstractSet</code> substitute without the potentially-quadratic <code>removeAll</code>
  implementation.
 */
@interface ComGoogleCommonCollectSets_ImprovedAbstractSet : JavaUtilAbstractSet

#pragma mark Public

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

#pragma mark Package-Private

- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectSets_ImprovedAbstractSet)

FOUNDATION_EXPORT void ComGoogleCommonCollectSets_ImprovedAbstractSet_init(ComGoogleCommonCollectSets_ImprovedAbstractSet *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectSets_ImprovedAbstractSet)

#endif

#if !defined (ComGoogleCommonCollectSets_SetView_) && (INCLUDE_ALL_ComGoogleCommonCollectSets || defined(INCLUDE_ComGoogleCommonCollectSets_SetView))
#define ComGoogleCommonCollectSets_SetView_

#define RESTRICT_JavaUtilAbstractSet 1
#define INCLUDE_JavaUtilAbstractSet 1
#include "java/util/AbstractSet.h"

@class ComGoogleCommonCollectImmutableSet;
@class ComGoogleCommonCollectUnmodifiableIterator;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilSet;

/*!
 @brief An unmodifiable view of a set which may be backed by other sets; this view will change as the
  backing sets do.Contains methods to copy the data into a new set which will then remain
  stable.
 There is usually no reason to retain a reference of type <code>SetView</code>; typically,
  you either use it as a plain <code>Set</code>, or immediately invoke <code>immutableCopy</code> or 
 <code>copyInto</code> and forget the <code>SetView</code> itself.
 @since 2.0
 */
@interface ComGoogleCommonCollectSets_SetView : JavaUtilAbstractSet

#pragma mark Public

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (jboolean)addWithId:(id)e __attribute__((deprecated));

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)newElements __attribute__((deprecated));

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (void)clear __attribute__((deprecated));

/*!
 @brief Copies the current contents of this set view into an existing set.This method has equivalent
  behavior to <code>set.addAll(this)</code>, assuming that all the sets involved are based on the
  same notion of equivalence.
 @return a reference to <code>set</code>, for convenience
 */
- (id<JavaUtilSet>)copyIntoWithJavaUtilSet:(id<JavaUtilSet>)set OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns an immutable copy of the current contents of this set view.Does not support null
  elements.
 <p><b>Warning:</b> this may have unexpected results if a backing set of this view uses a
  nonstandard notion of equivalence, for example if it is a <code>TreeSet</code> using a comparator
  that is inconsistent with <code>Object.equals(Object)</code>.
 */
- (ComGoogleCommonCollectImmutableSet *)immutableCopy;

/*!
 @brief Scope the return type to <code>UnmodifiableIterator</code> to ensure this is an unmodifiable view.
 @since 20.0 (present with return type <code>Iterator</code> since 2.0)
 */
- (ComGoogleCommonCollectUnmodifiableIterator *)iterator;

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (jboolean)removeWithId:(id)object __attribute__((deprecated));

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)oldElements __attribute__((deprecated));

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter __attribute__((deprecated));

/*!
 @brief Guaranteed to throw an exception and leave the collection unmodified.
 @throw UnsupportedOperationExceptionalways
 */
- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)elementsToKeep __attribute__((deprecated));

#pragma mark Package-Private

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectSets_SetView)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectSets_SetView)

#endif

#if !defined (ComGoogleCommonCollectSets_UnmodifiableNavigableSet_) && (INCLUDE_ALL_ComGoogleCommonCollectSets || defined(INCLUDE_ComGoogleCommonCollectSets_UnmodifiableNavigableSet))
#define ComGoogleCommonCollectSets_UnmodifiableNavigableSet_

#define RESTRICT_ComGoogleCommonCollectForwardingSortedSet 1
#define INCLUDE_ComGoogleCommonCollectForwardingSortedSet 1
#include "com/google/common/collect/ForwardingSortedSet.h"

#define RESTRICT_JavaUtilNavigableSet 1
#define INCLUDE_JavaUtilNavigableSet 1
#include "java/util/NavigableSet.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilFunctionPredicate;
@protocol JavaUtilIterator;
@protocol JavaUtilSortedSet;
@protocol JavaUtilStreamStream;

@interface ComGoogleCommonCollectSets_UnmodifiableNavigableSet : ComGoogleCommonCollectForwardingSortedSet < JavaUtilNavigableSet, JavaIoSerializable >

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (id)floorWithId:(id)e;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)action;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (id)lowerWithId:(id)e;

- (id<JavaUtilStreamStream>)parallelStream;

- (id)pollFirst;

- (id)pollLast;

- (jboolean)removeIfWithJavaUtilFunctionPredicate:(id<JavaUtilFunctionPredicate>)filter;

- (id<JavaUtilStreamStream>)stream;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

#pragma mark Protected

- (id<JavaUtilSortedSet>)delegate;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)delegate;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectSets_UnmodifiableNavigableSet)

FOUNDATION_EXPORT void ComGoogleCommonCollectSets_UnmodifiableNavigableSet_initWithJavaUtilNavigableSet_(ComGoogleCommonCollectSets_UnmodifiableNavigableSet *self, id<JavaUtilNavigableSet> delegate);

FOUNDATION_EXPORT ComGoogleCommonCollectSets_UnmodifiableNavigableSet *new_ComGoogleCommonCollectSets_UnmodifiableNavigableSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> delegate) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonCollectSets_UnmodifiableNavigableSet *create_ComGoogleCommonCollectSets_UnmodifiableNavigableSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> delegate);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectSets_UnmodifiableNavigableSet)

#endif

#if !defined (ComGoogleCommonCollectSets_DescendingSet_) && (INCLUDE_ALL_ComGoogleCommonCollectSets || defined(INCLUDE_ComGoogleCommonCollectSets_DescendingSet))
#define ComGoogleCommonCollectSets_DescendingSet_

#define RESTRICT_ComGoogleCommonCollectForwardingNavigableSet 1
#define INCLUDE_ComGoogleCommonCollectForwardingNavigableSet 1
#include "com/google/common/collect/ForwardingNavigableSet.h"

@class IOSObjectArray;
@protocol JavaUtilComparator;
@protocol JavaUtilIterator;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSortedSet;

@interface ComGoogleCommonCollectSets_DescendingSet : ComGoogleCommonCollectForwardingNavigableSet

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (id<JavaUtilComparator>)comparator;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (id)first;

- (id)floorWithId:(id)e;

- (id<JavaUtilSortedSet>)headSetWithId:(id)toElement;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (id<JavaUtilIterator>)iterator;

- (id)last;

- (id)lowerWithId:(id)e;

- (id)pollFirst;

- (id)pollLast;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilSortedSet>)subSetWithId:(id)fromElement
                               withId:(id)toElement;

- (id<JavaUtilSortedSet>)tailSetWithId:(id)fromElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)array;

- (NSString *)description;

#pragma mark Protected

- (id<JavaUtilNavigableSet>)delegate;

#pragma mark Package-Private

- (instancetype __nonnull)initWithJavaUtilNavigableSet:(id<JavaUtilNavigableSet>)forward;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectSets_DescendingSet)

FOUNDATION_EXPORT void ComGoogleCommonCollectSets_DescendingSet_initWithJavaUtilNavigableSet_(ComGoogleCommonCollectSets_DescendingSet *self, id<JavaUtilNavigableSet> forward);

FOUNDATION_EXPORT ComGoogleCommonCollectSets_DescendingSet *new_ComGoogleCommonCollectSets_DescendingSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> forward) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonCollectSets_DescendingSet *create_ComGoogleCommonCollectSets_DescendingSet_initWithJavaUtilNavigableSet_(id<JavaUtilNavigableSet> forward);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectSets_DescendingSet)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonCollectSets")
