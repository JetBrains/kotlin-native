//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/math/BigIntegerMath.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonMathBigIntegerMath")
#ifdef RESTRICT_ComGoogleCommonMathBigIntegerMath
#define INCLUDE_ALL_ComGoogleCommonMathBigIntegerMath 0
#else
#define INCLUDE_ALL_ComGoogleCommonMathBigIntegerMath 1
#endif
#undef RESTRICT_ComGoogleCommonMathBigIntegerMath

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonMathBigIntegerMath_) && (INCLUDE_ALL_ComGoogleCommonMathBigIntegerMath || defined(INCLUDE_ComGoogleCommonMathBigIntegerMath))
#define ComGoogleCommonMathBigIntegerMath_

@class JavaMathBigInteger;
@class JavaMathRoundingMode;
@protocol JavaUtilList;

/*!
 @brief A class for arithmetic on values of type <code>BigInteger</code>.
 <p>The implementations of many methods in this class are based on material from Henry S. Warren,
  Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002). 
 <p>Similar functionality for <code>int</code> and for <code>long</code> can be found in <code>IntMath</code> and 
 <code>LongMath</code> respectively.
 @author Louis Wasserman
 @since 11.0
 */
@interface ComGoogleCommonMathBigIntegerMath : NSObject
@property (readonly, class) jint SQRT2_PRECOMPUTE_THRESHOLD NS_SWIFT_NAME(SQRT2_PRECOMPUTE_THRESHOLD);
@property (readonly, class, strong) JavaMathBigInteger *SQRT2_PRECOMPUTED_BITS NS_SWIFT_NAME(SQRT2_PRECOMPUTED_BITS);

+ (jint)SQRT2_PRECOMPUTE_THRESHOLD;

+ (JavaMathBigInteger *)SQRT2_PRECOMPUTED_BITS;

#pragma mark Public

/*!
 @brief Returns <code>n</code> choose <code>k</code>, also known as the binomial coefficient of <code>n</code> and 
 <code>k</code>, that is, <code>n!
 / (k! (n - k)!)</code>.
 <p><b>Warning:</b> the result can take as much as <i>O(k log n)</i> space.
 @throw IllegalArgumentExceptionif <code>n < 0</code>, <code>k < 0</code>, or <code>k > n</code>
 */
+ (JavaMathBigInteger *)binomialWithInt:(jint)n
                                withInt:(jint)k;

/*!
 @brief Returns the smallest power of two greater than or equal to <code>x</code>.This is equivalent to 
 <code>BigInteger.valueOf(2).pow(log2(x, CEILING))</code>.
 @throw IllegalArgumentExceptionif <code>x <= 0</code>
 @since 20.0
 */
+ (JavaMathBigInteger *)ceilingPowerOfTwoWithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x;

/*!
 @brief Returns the result of dividing <code>p</code> by <code>q</code>, rounding using the specified <code>RoundingMode</code>
 .
 @throw ArithmeticExceptionif <code>q == 0</code>, or if <code>mode == UNNECESSARY</code> and <code>a</code>
      is not an integer multiple of <code>b</code>
 */
+ (JavaMathBigInteger *)divideWithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)p
                              withJavaMathBigInteger:(JavaMathBigInteger * __nonnull)q
                            withJavaMathRoundingMode:(JavaMathRoundingMode * __nonnull)mode;

/*!
 @brief Returns <code>n!
 </code>, that is, the product of the first <code>n</code> positive integers, or <code>1</code>
  if <code>n == 0</code>.
 <p><b>Warning:</b> the result takes <i>O(n log n)</i> space, so use cautiously. 
 <p>This uses an efficient binary recursive algorithm to compute the factorial with balanced
  multiplies. It also removes all the 2s from the intermediate products (shifting them back in at
  the end).
 @throw IllegalArgumentExceptionif <code>n < 0</code>
 */
+ (JavaMathBigInteger *)factorialWithInt:(jint)n;

/*!
 @brief Returns the largest power of two less than or equal to <code>x</code>.This is equivalent to <code>BigInteger.valueOf(2).pow(log2(x, FLOOR))</code>
 .
 @throw IllegalArgumentExceptionif <code>x <= 0</code>
 @since 20.0
 */
+ (JavaMathBigInteger *)floorPowerOfTwoWithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x;

/*!
 @brief Returns <code>true</code> if <code>x</code> represents a power of two.
 */
+ (jboolean)isPowerOfTwoWithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x;

/*!
 @brief Returns the base-10 logarithm of <code>x</code>, rounded according to the specified rounding mode.
 @throw IllegalArgumentExceptionif <code>x <= 0</code>
 @throw ArithmeticExceptionif <code>mode</code> is <code>RoundingMode.UNNECESSARY</code> and <code>x</code>
      is not a power of ten
 */
+ (jint)log10WithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x
           withJavaMathRoundingMode:(JavaMathRoundingMode * __nonnull)mode;

/*!
 @brief Returns the base-2 logarithm of <code>x</code>, rounded according to the specified rounding mode.
 @throw IllegalArgumentExceptionif <code>x <= 0</code>
 @throw ArithmeticExceptionif <code>mode</code> is <code>RoundingMode.UNNECESSARY</code> and <code>x</code>
      is not a power of two
 */
+ (jint)log2WithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x
          withJavaMathRoundingMode:(JavaMathRoundingMode * __nonnull)mode;

/*!
 @brief Returns the square root of <code>x</code>, rounded with the specified rounding mode.
 @throw IllegalArgumentExceptionif <code>x < 0</code>
 @throw ArithmeticExceptionif <code>mode</code> is <code>RoundingMode.UNNECESSARY</code> and <code>sqrt(x)</code>
  is not an integer
 */
+ (JavaMathBigInteger *)sqrtWithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x
                          withJavaMathRoundingMode:(JavaMathRoundingMode * __nonnull)mode;

#pragma mark Package-Private

+ (jboolean)fitsInLongWithJavaMathBigInteger:(JavaMathBigInteger * __nonnull)x;

+ (JavaMathBigInteger *)listProductWithJavaUtilList:(id<JavaUtilList> __nonnull)nums;

+ (JavaMathBigInteger *)listProductWithJavaUtilList:(id<JavaUtilList> __nonnull)nums
                                            withInt:(jint)start
                                            withInt:(jint)end;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonMathBigIntegerMath)

inline jint ComGoogleCommonMathBigIntegerMath_get_SQRT2_PRECOMPUTE_THRESHOLD(void);
#define ComGoogleCommonMathBigIntegerMath_SQRT2_PRECOMPUTE_THRESHOLD 256
J2OBJC_STATIC_FIELD_CONSTANT(ComGoogleCommonMathBigIntegerMath, SQRT2_PRECOMPUTE_THRESHOLD, jint)

inline JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_get_SQRT2_PRECOMPUTED_BITS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_SQRT2_PRECOMPUTED_BITS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComGoogleCommonMathBigIntegerMath, SQRT2_PRECOMPUTED_BITS, JavaMathBigInteger *)

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_ceilingPowerOfTwoWithJavaMathBigInteger_(JavaMathBigInteger *x);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_floorPowerOfTwoWithJavaMathBigInteger_(JavaMathBigInteger *x);

FOUNDATION_EXPORT jboolean ComGoogleCommonMathBigIntegerMath_isPowerOfTwoWithJavaMathBigInteger_(JavaMathBigInteger *x);

FOUNDATION_EXPORT jint ComGoogleCommonMathBigIntegerMath_log2WithJavaMathBigInteger_withJavaMathRoundingMode_(JavaMathBigInteger *x, JavaMathRoundingMode *mode);

FOUNDATION_EXPORT jint ComGoogleCommonMathBigIntegerMath_log10WithJavaMathBigInteger_withJavaMathRoundingMode_(JavaMathBigInteger *x, JavaMathRoundingMode *mode);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_sqrtWithJavaMathBigInteger_withJavaMathRoundingMode_(JavaMathBigInteger *x, JavaMathRoundingMode *mode);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_divideWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathRoundingMode_(JavaMathBigInteger *p, JavaMathBigInteger *q, JavaMathRoundingMode *mode);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_factorialWithInt_(jint n);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_listProductWithJavaUtilList_(id<JavaUtilList> nums);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_listProductWithJavaUtilList_withInt_withInt_(id<JavaUtilList> nums, jint start, jint end);

FOUNDATION_EXPORT JavaMathBigInteger *ComGoogleCommonMathBigIntegerMath_binomialWithInt_withInt_(jint n, jint k);

FOUNDATION_EXPORT jboolean ComGoogleCommonMathBigIntegerMath_fitsInLongWithJavaMathBigInteger_(JavaMathBigInteger *x);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonMathBigIntegerMath)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonMathBigIntegerMath")
