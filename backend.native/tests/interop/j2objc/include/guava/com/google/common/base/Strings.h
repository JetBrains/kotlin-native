//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/base/Strings.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonBaseStrings")
#ifdef RESTRICT_ComGoogleCommonBaseStrings
#define INCLUDE_ALL_ComGoogleCommonBaseStrings 0
#else
#define INCLUDE_ALL_ComGoogleCommonBaseStrings 1
#endif
#undef RESTRICT_ComGoogleCommonBaseStrings

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonBaseStrings_) && (INCLUDE_ALL_ComGoogleCommonBaseStrings || defined(INCLUDE_ComGoogleCommonBaseStrings))
#define ComGoogleCommonBaseStrings_

@class IOSObjectArray;
@protocol JavaLangCharSequence;

/*!
 @brief Static utility methods pertaining to <code>String</code> or <code>CharSequence</code> instances.
 @author Kevin Bourrillion
 @since 3.0
 */
@interface ComGoogleCommonBaseStrings : NSObject

#pragma mark Public

/*!
 @brief Returns the longest string <code>prefix</code> such that <code>a.toString().startsWith(prefix) &&
  b.toString().startsWith(prefix)</code>
 , taking care not to split surrogate pairs.If <code>a</code> and 
 <code>b</code> have no common prefix, returns the empty string.
 @since 11.0
 */
+ (NSString *)commonPrefixWithJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)a
                          withJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)b;

/*!
 @brief Returns the longest string <code>suffix</code> such that <code>a.toString().endsWith(suffix) &&
  b.toString().endsWith(suffix)</code>
 , taking care not to split surrogate pairs.If <code>a</code> and 
 <code>b</code> have no common suffix, returns the empty string.
 @since 11.0
 */
+ (NSString *)commonSuffixWithJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)a
                          withJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)b;

/*!
 @brief Returns the given string if it is nonempty; <code>null</code> otherwise.
 @param string the string to test and possibly return
 @return <code>string</code> itself if it is nonempty; <code>null</code> if it is empty or null
 */
+ (NSString * __nullable)emptyToNullWithNSString:(NSString * __nullable)string;

/*!
 @brief Returns <code>true</code> if the given string is null or is the empty string.
 <p>Consider normalizing your string references with <code>nullToEmpty</code>. If you do, you can
  use <code>String.isEmpty()</code> instead of this method, and you won't need special null-safe forms
  of methods like <code>String.toUpperCase</code> either. Or, if you'd like to normalize "in the other
  direction," converting empty strings to <code>null</code>, you can use <code>emptyToNull</code>.
 @param string a string reference to check
 @return <code>true</code> if the string is null or is the empty string
 */
+ (jboolean)isNullOrEmptyWithNSString:(NSString * __nullable)string;

/*!
 @brief Returns the given <code>template</code> string with each occurrence of <code>"%s"</code> replaced with
  the corresponding argument value from <code>args</code>; or, if the placeholder and argument counts
  do not match, returns a best-effort form of that string.Will not throw an exception under any
  circumstances (as long as all arguments' <code>toString</code> methods successfully return).
 <p><b>Note:</b> For most string-formatting needs, use <code>String.format</code>, <code>PrintWriter.format</code>
 , and related methods. These support the full range of format specifiers
 , and alert you to usage errors by throwing <code>InvalidFormatException</code>
 .
  
 <p>In certain cases, such as outputting debugging information or constructing a message to be
  used for another unchecked exception, an exception during string formatting would serve little
  purpose except to supplant the real information you were trying to provide. These are the cases
  this method is made for; it instead generates a best-effort string with all supplied argument
  values present. This method is also useful in environments such as GWT where <code>String.format</code>
  is not available. As an example, method implementations of the <code>Preconditions</code>
  class use this formatter, for both of the reasons just discussed. 
 <p><b>Warning:</b> Only the exact two-character placeholder sequence <code>"%s"</code> is
  recognized.
 @param template_ a string containing zero or more <code>"%s"</code>  placeholder sequences. <code>null</code>
   is treated as the four-character string <code>"null"</code>
  .
 @param args the arguments to be substituted into the message template. The first argument      specified is substituted for the first occurrence of 
 <code>"%s"</code>  in the template, and so      forth. A 
 <code>null</code>  argument is converted to the four-character string <code>"null"</code> ;      non-null values are converted to strings using 
 <code>Object.toString()</code> .
 @since 25.1
 */
+ (NSString *)lenientFormatWithNSString:(NSString * __nullable)template_
                      withNSObjectArray:(IOSObjectArray * __nonnull)args;

/*!
 @brief Returns the given string if it is non-null; the empty string otherwise.
 @param string the string to test and possibly return
 @return <code>string</code> itself if it is non-null; <code>""</code> if it is null
 */
+ (NSString *)nullToEmptyWithNSString:(NSString * __nullable)string;

/*!
 @brief Returns a string, of length at least <code>minLength</code>, consisting of <code>string</code> appended
  with as many copies of <code>padChar</code> as are necessary to reach that length.For example, 
 <ul>
    <li><code>padEnd("4
 .", 5, '0')</code> returns <code>"4.000"</code>
    <li><code>padEnd("2010", 3, '!')</code> returns <code>"2010"</code>
  </ul>
  
 <p>See <code>java.util.Formatter</code> for a richer set of formatting capabilities.
 @param string the string which should appear at the beginning of the result
 @param minLength the minimum length the resulting string must have. Can be zero or negative, in      which case the input string is always returned.
 @param padChar the character to append to the end of the result until the minimum length is      reached
 @return the padded string
 */
+ (NSString *)padEndWithNSString:(NSString * __nonnull)string
                         withInt:(jint)minLength
                        withChar:(jchar)padChar;

/*!
 @brief Returns a string, of length at least <code>minLength</code>, consisting of <code>string</code> prepended
  with as many copies of <code>padChar</code> as are necessary to reach that length.For example, 
 <ul>
    <li><code>padStart("7", 3, '0')</code> returns <code>"007"</code>
    <li><code>padStart("2010", 3, '0')</code> returns <code>"2010"</code>
  </ul>
  
 <p>See <code>java.util.Formatter</code> for a richer set of formatting capabilities.
 @param string the string which should appear at the end of the result
 @param minLength the minimum length the resulting string must have. Can be zero or negative, in      which case the input string is always returned.
 @param padChar the character to insert at the beginning of the result until the minimum length      is reached
 @return the padded string
 */
+ (NSString *)padStartWithNSString:(NSString * __nonnull)string
                           withInt:(jint)minLength
                          withChar:(jchar)padChar;

/*!
 @brief Returns a string consisting of a specific number of concatenated copies of an input string.For
  example, <code>repeat("hey", 3)</code> returns the string <code>"heyheyhey"</code>.
 @param string any non-null string
 @param count the number of times to repeat it; a nonnegative integer
 @return a string containing <code>string</code> repeated <code>count</code> times (the empty string if
      <code>count</code> is zero)
 @throw IllegalArgumentExceptionif <code>count</code> is negative
 */
+ (NSString *)repeatWithNSString:(NSString * __nonnull)string
                         withInt:(jint)count;

#pragma mark Package-Private

/*!
 @brief True when a valid surrogate pair starts at the given <code>index</code> in the given <code>string</code>.
 Out-of-range indexes return false.
 */
+ (jboolean)validSurrogatePairAtWithJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)string
                                                 withInt:(jint)index;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonBaseStrings)

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_nullToEmptyWithNSString_(NSString *string);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_emptyToNullWithNSString_(NSString *string);

FOUNDATION_EXPORT jboolean ComGoogleCommonBaseStrings_isNullOrEmptyWithNSString_(NSString *string);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_padStartWithNSString_withInt_withChar_(NSString *string, jint minLength, jchar padChar);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_padEndWithNSString_withInt_withChar_(NSString *string, jint minLength, jchar padChar);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_repeatWithNSString_withInt_(NSString *string, jint count);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_commonPrefixWithJavaLangCharSequence_withJavaLangCharSequence_(id<JavaLangCharSequence> a, id<JavaLangCharSequence> b);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_commonSuffixWithJavaLangCharSequence_withJavaLangCharSequence_(id<JavaLangCharSequence> a, id<JavaLangCharSequence> b);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseStrings_lenientFormatWithNSString_withNSObjectArray_(NSString *template_, IOSObjectArray *args);

FOUNDATION_EXPORT jboolean ComGoogleCommonBaseStrings_validSurrogatePairAtWithJavaLangCharSequence_withInt_(id<JavaLangCharSequence> string, jint index);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonBaseStrings)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonBaseStrings")
