//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/collect/Multimap.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonCollectMultimap")
#ifdef RESTRICT_ComGoogleCommonCollectMultimap
#define INCLUDE_ALL_ComGoogleCommonCollectMultimap 0
#else
#define INCLUDE_ALL_ComGoogleCommonCollectMultimap 1
#endif
#undef RESTRICT_ComGoogleCommonCollectMultimap

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonCollectMultimap_) && (INCLUDE_ALL_ComGoogleCommonCollectMultimap || defined(INCLUDE_ComGoogleCommonCollectMultimap))
#define ComGoogleCommonCollectMultimap_

@protocol ComGoogleCommonCollectMultiset;
@protocol JavaLangIterable;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/*!
 @brief A collection that maps keys to values, similar to <code>Map</code>, but in which each key may be
  associated with <i>multiple</i> values.You can visualize the contents of a multimap either as a
  map from keys to <i>nonempty</i> collections of values: 
 <ul>
    <li>a → 1, 2
    <li>b → 3 
 </ul>
  ... or as a single "flattened" collection of key-value pairs: 
 <ul>
    <li>a → 1
    <li>a → 2
    <li>b → 3 
 </ul>
  
 <p><b>Important:</b> although the first interpretation resembles how most multimaps are 
 <i>implemented</i>, the design of the <code>Multimap</code> API is based on the <i>second</i> form.
 So, using the multimap shown above as an example, the <code>size</code> is <code>3</code>, not <code>2</code>,
  and the <code>values</code> collection is <code>[1, 2, 3]</code>, not <code>[[1, 2], [3]]</code>. For those
  times when the first style is more useful, use the multimap's <code>asMap</code> view (or create a 
 <code>Map<K, Collection<V>></code> in the first place). 
 <h3>Example</h3>
  
 <p>The following code: 
 @code
 ListMultimap<String, String> multimap = ArrayListMultimap.create();
  for (President pres : US_PRESIDENTS_IN_ORDER) {
    multimap.put(pres.firstName(), pres.lastName());
  }
  for (String firstName : multimap.keySet()) {
    List<String> lastNames = multimap.get(firstName);
    out.println(firstName + ": " + lastNames);
  } 
 
@endcode
  ... produces output such as: 
 @code
 Zachary: [Taylor]
  John: [Adams, Adams, Tyler, Kennedy]  // Remember, Quincy!
  George: [Washington, Bush, Bush]
  Grover: [Cleveland, Cleveland]        // Two, non-consecutive terms, rep'ing NJ!
  ... 
 
@endcode
  
 <h3>Views</h3>
  
 <p>Much of the power of the multimap API comes from the <i>view collections</i> it provides.
  These always reflect the latest state of the multimap itself. When they support modification, the
  changes are <i>write-through</i> (they automatically update the backing multimap). These view
  collections are: 
 <ul>
    <li><code>asMap</code>, mentioned above
    <li><code>keys</code>, <code>keySet</code>, <code>values</code>, <code>entries</code>, which are similar to the
        corresponding view collections of <code>Map</code>
    <li>and, notably, even the collection returned by <code>get(key)</code> is an active view of
        the values corresponding to <code>key</code>
  </ul>
  
 <p>The collections returned by the <code>replaceValues</code> and <code>removeAll</code>
  methods, which contain values that have just been removed from the multimap, are
  naturally <i>not</i> views. 
 <h3>Subinterfaces</h3>
  
 <p>Instead of using the <code>Multimap</code> interface directly, prefer the subinterfaces <code>ListMultimap</code>
  and <code>SetMultimap</code>. These take their names from the fact that the collections
  they return from <code>get</code> behave like (and, of course, implement) <code>List</code> and <code>Set</code>
 , respectively. 
 <p>For example, the "presidents" code snippet above used a <code>ListMultimap</code>; if it had used a 
 <code>SetMultimap</code> instead, two presidents would have vanished, and last names might or might
  not appear in chronological order. 
 <p><b>Warning:</b> instances of type <code>Multimap</code> may not implement <code>Object.equals</code> in
  the way you expect. Multimaps containing the same key-value pairs, even in the same order, may or
  may not be equal and may or may not have the same <code>hashCode</code>. The recommended subinterfaces
  provide much stronger guarantees. 
 <h3>Comparison to a map of collections</h3>
  
 <p>Multimaps are commonly used in places where a <code>Map<K, Collection<V>></code> would otherwise
  have appeared. The differences include: 
 <ul>
    <li>There is no need to populate an empty collection before adding an entry with <code>put</code>
 .
    <li><code>get</code> never returns <code>null</code>, only an empty collection.
    <li>A key is contained in the multimap if and only if it maps to at least one value. Any
        operation that causes a key to have zero associated values has the effect of       
 <i>removing</i> that key from the multimap.
    <li>The total entry count is available as <code>size</code>.
    <li>Many complex operations become easier; for example, <code>Collections.min(multimap.values())</code>
  finds the smallest value across all keys. 
 </ul>
  
 <h3>Implementations</h3>
  
 <p>As always, prefer the immutable implementations, <code>ImmutableListMultimap</code> and <code>ImmutableSetMultimap</code>
 . General-purpose mutable implementations are listed above under "All Known
  Implementing Classes". You can also create a <i>custom</i> multimap, backed by any <code>Map</code>
  and <code>Collection</code> types, using the <code>Multimaps.newMultimap</code>
  family of methods. Finally, another popular way to obtain a multimap is using <code>Multimaps.index</code>
 . See the <code>Multimaps</code> class for these and other static
  utilities related to multimaps. 
 <h3>Other Notes</h3>
  
 <p>As with <code>Map</code>, the behavior of a <code>Multimap</code> is not specified if key objects
  already present in the multimap change in a manner that affects <code>equals</code> comparisons. Use
  caution if mutable objects are used as keys in a <code>Multimap</code>.
  
 <p>All methods that modify the multimap are optional. The view collections returned by the
  multimap may or may not be modifiable. Any modification method that is not supported will throw 
 <code>UnsupportedOperationException</code>.
  
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#multimap">
  <code>Multimap</code>
 </a>.
 @author Jared Levy
 @since 2.0
 */
@protocol ComGoogleCommonCollectMultimap < JavaObject >

/*!
 @brief Returns the number of key-value pairs in this multimap.
 <p><b>Note:</b> this method does not return the number of <i>distinct keys</i> in the multimap,
  which is given by <code>keySet().size()</code> or <code>asMap().size()</code>. See the opening section of the 
 <code>Multimap</code> class documentation for clarification.
 */
- (jint)size;

/*!
 @brief Returns <code>true</code> if this multimap contains no key-value pairs.Equivalent to <code>size()
  == 0</code>
 , but can in some cases be more efficient.
 */
- (jboolean)isEmpty;

/*!
 @brief Returns <code>true</code> if this multimap contains at least one key-value pair with the key <code>key</code>
 .
 */
- (jboolean)containsKeyWithId:(id __nullable)key;

/*!
 @brief Returns <code>true</code> if this multimap contains at least one key-value pair with the value 
 <code>value</code>.
 */
- (jboolean)containsValueWithId:(id __nullable)value;

/*!
 @brief Returns <code>true</code> if this multimap contains at least one key-value pair with the key <code>key</code>
  and the value <code>value</code>.
 */
- (jboolean)containsEntryWithId:(id __nullable)key
                         withId:(id __nullable)value;

/*!
 @brief Stores a key-value pair in this multimap.
 <p>Some multimap implementations allow duplicate key-value pairs, in which case <code>put</code>
  always adds a new key-value pair and increases the multimap size by 1. Other implementations
  prohibit duplicates, and storing a key-value pair that's already in the multimap has no effect.
 @return <code>true</code> if the method increased the size of the multimap, or <code>false</code> if the
      multimap already contained the key-value pair and doesn't allow duplicates
 */
- (jboolean)putWithId:(id)key
               withId:(id)value;

/*!
 @brief Removes a single key-value pair with the key <code>key</code> and the value <code>value</code> from this
  multimap, if such exists.If multiple key-value pairs in the multimap fit this description,
  which one is removed is unspecified.
 @return <code>true</code> if the multimap changed
 */
- (jboolean)removeWithId:(id __nullable)key
                  withId:(id __nullable)value;

/*!
 @brief Stores a key-value pair in this multimap for each of <code>values</code>, all using the same key, 
 <code>key</code>.Equivalent to (but expected to be more efficient than): 
 @code
 for (V value : values) {
    put(key, value);
  } 
 
@endcode
  
 <p>In particular, this is a no-op if <code>values</code> is empty.
 @return <code>true</code> if the multimap changed
 */
- (jboolean)putAllWithId:(id)key
    withJavaLangIterable:(id<JavaLangIterable>)values;

/*!
 @brief Stores all key-value pairs of <code>multimap</code> in this multimap, in the order returned by 
 <code>multimap.entries()</code>.
 @return <code>true</code> if the multimap changed
 */
- (jboolean)putAllWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)multimap;

/*!
 @brief Stores a collection of values with the same key, replacing any existing values for that key.
 <p>If <code>values</code> is empty, this is equivalent to <code>removeAll(key)</code>.
 @return the collection of replaced values, or an empty collection if no values were previously
      associated with the key. The collection <i>may</i> be modifiable, but updating it will have
      no effect on the multimap.
 */
- (id<JavaUtilCollection>)replaceValuesWithId:(id)key
                         withJavaLangIterable:(id<JavaLangIterable>)values;

/*!
 @brief Removes all values associated with the key <code>key</code>.
 <p>Once this method returns, <code>key</code> will not be mapped to any values, so it will not
  appear in <code>keySet()</code>, <code>asMap()</code>, or any other views.
 @return the values that were removed (possibly empty). The returned collection <i>may</i> be
      modifiable, but updating it will have no effect on the multimap.
 */
- (id<JavaUtilCollection>)removeAllWithId:(id __nullable)key;

/*!
 @brief Removes all key-value pairs from the multimap, leaving it empty.
 */
- (void)clear;

/*!
 @brief Returns a view collection of the values associated with <code>key</code> in this multimap, if any.
 Note that when <code>containsKey(key)</code> is false, this returns an empty collection, not <code>null</code>
 .
  
 <p>Changes to the returned collection will update the underlying multimap, and vice versa.
 */
- (id<JavaUtilCollection>)getWithId:(id)key;

/*!
 @brief Returns a view collection of all <i>distinct</i> keys contained in this multimap.Note that the
  key set contains a key if and only if this multimap maps that key to at least one value.
 <p>Changes to the returned set will update the underlying multimap, and vice versa. However, 
 <i>adding</i> to the returned set is not possible.
 */
- (id<JavaUtilSet>)keySet;

/*!
 @brief Returns a view collection containing the key from each key-value pair in this multimap, 
 <i>without</i> collapsing duplicates.This collection has the same size as this multimap, and 
 <code>keys().count(k) == get(k).size()</code> for all <code>k</code>.
 <p>Changes to the returned multiset will update the underlying multimap, and vice versa.
  However, <i>adding</i> to the returned collection is not possible.
 */
- (id<ComGoogleCommonCollectMultiset>)keys;

/*!
 @brief Returns a view collection containing the <i>value</i> from each key-value pair contained in
  this multimap, without collapsing duplicates (so <code>values().size() == size()</code>).
 <p>Changes to the returned collection will update the underlying multimap, and vice versa.
  However, <i>adding</i> to the returned collection is not possible.
 */
- (id<JavaUtilCollection>)values;

/*!
 @brief Returns a view collection of all key-value pairs contained in this multimap, as <code>Entry</code>
  instances.
 <p>Changes to the returned collection or the entries it contains will update the underlying
  multimap, and vice versa. However, <i>adding</i> to the returned collection is not possible.
 */
- (id<JavaUtilCollection>)entries;

/*!
 @brief Performs the given action for all key-value pairs contained in this multimap.If an ordering is
  specified by the <code>Multimap</code> implementation, actions will be performed in the order of
  iteration of <code>entries()</code>.
 Exceptions thrown by the action are relayed to the caller. 
 <p>To loop over all keys and their associated value collections, write <code>Multimaps.asMap(multimap).forEach((key, valueCollection) -> action())</code>
 .
 @since 21.0
 */
- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief Returns a view of this multimap as a <code>Map</code> from each distinct key to the nonempty
  collection of that key's associated values.Note that <code>this.asMap().get(k)</code> is equivalent
  to <code>this.get(k)</code> only when <code>k</code> is a key contained in the multimap; otherwise it
  returns <code>null</code> as opposed to an empty collection.
 <p>Changes to the returned map or the collections that serve as its values will update the
  underlying multimap, and vice versa. The map does not support <code>put</code> or <code>putAll</code>,
  nor do its entries support <code>setValue</code>.
 */
- (id<JavaUtilMap>)asMap;

/*!
 @brief Compares the specified object with this multimap for equality.Two multimaps are equal when
  their map views, as returned by <code>asMap</code>, are also equal.
 <p>In general, two multimaps with identical key-value mappings may or may not be equal,
  depending on the implementation. For example, two <code>SetMultimap</code> instances with the same
  key-value mappings are equal, but equality of two <code>ListMultimap</code> instances depends on the
  ordering of the values for each key. 
 <p>A non-empty <code>SetMultimap</code> cannot be equal to a non-empty <code>ListMultimap</code>, since
  their <code>asMap</code> views contain unequal collections as values. However, any two empty
  multimaps are equal, because they both have empty <code>asMap</code> views.
 */
- (jboolean)isEqual:(id __nullable)obj;

/*!
 @brief Returns the hash code for this multimap.
 <p>The hash code of a multimap is defined as the hash code of the map view, as returned by 
 <code>Multimap.asMap</code>.
  
 <p>In general, two multimaps with identical key-value mappings may or may not have the same
  hash codes, depending on the implementation. For example, two <code>SetMultimap</code> instances
  with the same key-value mappings will have the same <code>hashCode</code>, but the <code>hashCode</code>
  of <code>ListMultimap</code> instances depends on the ordering of the values for each key.
 */
- (NSUInteger)hash;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectMultimap)

FOUNDATION_EXPORT void ComGoogleCommonCollectMultimap_forEachWithJavaUtilFunctionBiConsumer_(id<ComGoogleCommonCollectMultimap> self, id<JavaUtilFunctionBiConsumer> action);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectMultimap)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonCollectMultimap")
