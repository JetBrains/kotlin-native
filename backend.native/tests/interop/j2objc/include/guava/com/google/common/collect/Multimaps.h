//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/collect/Multimaps.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonCollectMultimaps")
#ifdef RESTRICT_ComGoogleCommonCollectMultimaps
#define INCLUDE_ALL_ComGoogleCommonCollectMultimaps 0
#else
#define INCLUDE_ALL_ComGoogleCommonCollectMultimaps 1
#endif
#undef RESTRICT_ComGoogleCommonCollectMultimaps

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonCollectMultimaps_) && (INCLUDE_ALL_ComGoogleCommonCollectMultimaps || defined(INCLUDE_ComGoogleCommonCollectMultimaps))
#define ComGoogleCommonCollectMultimaps_

@class ComGoogleCommonCollectImmutableListMultimap;
@class ComGoogleCommonCollectImmutableMultimap;
@class ComGoogleCommonCollectImmutableSetMultimap;
@protocol ComGoogleCommonBaseFunction;
@protocol ComGoogleCommonBasePredicate;
@protocol ComGoogleCommonBaseSupplier;
@protocol ComGoogleCommonCollectListMultimap;
@protocol ComGoogleCommonCollectMaps_EntryTransformer;
@protocol ComGoogleCommonCollectMultimap;
@protocol ComGoogleCommonCollectSetMultimap;
@protocol ComGoogleCommonCollectSortedSetMultimap;
@protocol JavaLangIterable;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionSupplier;
@protocol JavaUtilIterator;
@protocol JavaUtilMap;
@protocol JavaUtilStreamCollector;

/*!
 @brief Provides static methods acting on or generating a <code>Multimap</code>.
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#multimaps">
  <code>Multimaps</code>
 </a>.
 @author Jared Levy
 @author Robert Konigsberg
 @author Mike Bostock
 @author Louis Wasserman
 @since 2.0
 */
@interface ComGoogleCommonCollectMultimaps : NSObject

#pragma mark Public

/*!
 @brief Returns <code>multimap.asMap()</code>, with its type corrected from <code>Map<K,
  Collection<V>></code>
  to <code>Map<K, List<V>></code>.
 @since 15.0
 */
+ (id<JavaUtilMap>)asMapWithComGoogleCommonCollectListMultimap:(id<ComGoogleCommonCollectListMultimap>)multimap;

/*!
 @brief Returns <code>multimap.asMap()</code>.This is provided for parity with the other
  more strongly-typed <code>asMap()</code> implementations.
 @since 15.0
 */
+ (id<JavaUtilMap>)asMapWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)multimap;

/*!
 @brief Returns <code>multimap.asMap()</code>, with its type corrected from <code>Map<K,
  Collection<V>></code>
  to <code>Map<K, Set<V>></code>.
 @since 15.0
 */
+ (id<JavaUtilMap>)asMapWithComGoogleCommonCollectSetMultimap:(id<ComGoogleCommonCollectSetMultimap>)multimap;

/*!
 @brief Returns <code>multimap.asMap()</code>, with its type corrected from <code>Map<K, Collection<V>></code>
  to <code>Map<K, SortedSet<V>></code>.
 @since 15.0
 */
+ (id<JavaUtilMap>)asMapWithComGoogleCommonCollectSortedSetMultimap:(id<ComGoogleCommonCollectSortedSetMultimap>)multimap;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> that satisfy a predicate.The
  returned multimap is a live view of <code>unfiltered</code>; changes to one affect the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a key/value pair that
  doesn't satisfy the predicate, multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose keys satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>entryPredicate</code> must be <i>consistent with equals</i>, as documented
  at <code>Predicate.apply</code>.
 @since 11.0
 */
+ (id<ComGoogleCommonCollectMultimap>)filterEntriesWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)unfiltered
                                                     withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)entryPredicate;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> that satisfy a predicate.The
  returned multimap is a live view of <code>unfiltered</code>; changes to one affect the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a key/value pair that
  doesn't satisfy the predicate, multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose keys satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>entryPredicate</code> must be <i>consistent with equals</i>, as documented
  at <code>Predicate.apply</code>.
 @since 14.0
 */
+ (id<ComGoogleCommonCollectSetMultimap>)filterEntriesWithComGoogleCommonCollectSetMultimap:(id<ComGoogleCommonCollectSetMultimap>)unfiltered
                                                           withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)entryPredicate;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> whose keys satisfy a
  predicate.The returned multimap is a live view of <code>unfiltered</code>; changes to one affect
  the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a key that doesn't
  satisfy the predicate, the multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose keys satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>keyPredicate</code> must be <i>consistent with equals</i>, as documented at 
 <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals.
 @since 14.0
 */
+ (id<ComGoogleCommonCollectListMultimap>)filterKeysWithComGoogleCommonCollectListMultimap:(id<ComGoogleCommonCollectListMultimap>)unfiltered
                                                          withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)keyPredicate;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> whose keys satisfy a
  predicate.The returned multimap is a live view of <code>unfiltered</code>; changes to one affect
  the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a key that doesn't
  satisfy the predicate, the multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose keys satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>keyPredicate</code> must be <i>consistent with equals</i>, as documented at 
 <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals.
 @since 11.0
 */
+ (id<ComGoogleCommonCollectMultimap>)filterKeysWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)unfiltered
                                                  withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)keyPredicate;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> whose keys satisfy a
  predicate.The returned multimap is a live view of <code>unfiltered</code>; changes to one affect
  the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a key that doesn't
  satisfy the predicate, the multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose keys satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>keyPredicate</code> must be <i>consistent with equals</i>, as documented at 
 <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals.
 @since 14.0
 */
+ (id<ComGoogleCommonCollectSetMultimap>)filterKeysWithComGoogleCommonCollectSetMultimap:(id<ComGoogleCommonCollectSetMultimap>)unfiltered
                                                        withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)keyPredicate;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> whose values satisfy a
  predicate.The returned multimap is a live view of <code>unfiltered</code>; changes to one affect
  the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a value that doesn't
  satisfy the predicate, the multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose value satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>valuePredicate</code> must be <i>consistent with equals</i>, as documented
  at <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals.
 @since 11.0
 */
+ (id<ComGoogleCommonCollectMultimap>)filterValuesWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)unfiltered
                                                    withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)valuePredicate;

/*!
 @brief Returns a multimap containing the mappings in <code>unfiltered</code> whose values satisfy a
  predicate.The returned multimap is a live view of <code>unfiltered</code>; changes to one affect
  the other.
 <p>The resulting multimap's views have iterators that don't support <code>remove()</code>, but all
  other methods are supported by the multimap and its views. When adding a value that doesn't
  satisfy the predicate, the multimap's <code>put()</code>, <code>putAll()</code>, and <code>replaceValues()</code>
  methods throw an <code>IllegalArgumentException</code>.
  
 <p>When methods such as <code>removeAll()</code> and <code>clear()</code> are called on the filtered
  multimap or its views, only mappings whose value satisfy the filter will be removed from the
  underlying multimap. 
 <p>The returned multimap isn't threadsafe or serializable, even if <code>unfiltered</code> is. 
 <p>Many of the filtered multimap's methods, such as <code>size()</code>, iterate across every
  key/value mapping in the underlying multimap and determine which satisfy the filter. When a
  live view is <i>not</i> needed, it may be faster to copy the filtered multimap and use the
  copy. 
 <p><b>Warning:</b> <code>valuePredicate</code> must be <i>consistent with equals</i>, as documented
  at <code>Predicate.apply</code>. Do not provide a predicate such as <code>Predicates.instanceOf(ArrayList.class)</code>
 , which is inconsistent with equals.
 @since 14.0
 */
+ (id<ComGoogleCommonCollectSetMultimap>)filterValuesWithComGoogleCommonCollectSetMultimap:(id<ComGoogleCommonCollectSetMultimap>)unfiltered
                                                          withComGoogleCommonBasePredicate:(id<ComGoogleCommonBasePredicate>)valuePredicate;

/*!
 @brief Returns a <code>Collector</code> accumulating entries into a <code>Multimap</code> generated from the
  specified supplier.Each input element is mapped to a key and a stream of values, each of which
  are put into the resulting <code>Multimap</code>, in the encounter order of the stream and the
  encounter order of the streams of values.
 <p>Example:
  
 @code
 static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP =
      Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
          .collect(
              flatteningToMultimap(
                   str -> str.charAt(0),
                   str -> str.substring(1).chars().mapToObj(c -> (char) c),
                   MultimapBuilder.linkedHashKeys().arrayListValues()::build));
  // is equivalent to
  static final ListMultimap<Character, Character> FIRST_LETTER_MULTIMAP;
  static {
      FIRST_LETTER_MULTIMAP = MultimapBuilder.linkedHashKeys().arrayListValues().build();
      FIRST_LETTER_MULTIMAP.putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'));
      FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('p', 'p', 'l', 'e'));
      FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'));
      FIRST_LETTER_MULTIMAP.putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'));
      FIRST_LETTER_MULTIMAP.putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'));
  } 
 
@endcode
 @since 21.0
 */
+ (id<JavaUtilStreamCollector>)flatteningToMultimapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyFunction
                                                   withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueFunction
                                                   withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)multimapSupplier;

/*!
 @brief Returns a multimap view of the specified map.The multimap is backed by the map, so changes to
  the map are reflected in the multimap, and vice versa.
 If the map is modified while an
  iteration over one of the multimap's collection views is in progress (except through the
  iterator's own <code>remove</code> operation, or through the <code>setValue</code> operation on a map
  entry returned by the iterator), the results of the iteration are undefined. 
 <p>The multimap supports mapping removal, which removes the corresponding mapping from the map.
  It does not support any operations which might add mappings, such as <code>put</code>, <code>putAll</code>
  or <code>replaceValues</code>.
  
 <p>The returned multimap will be serializable if the specified map is serializable.
 @param map the backing map for the returned multimap view
 */
+ (id<ComGoogleCommonCollectSetMultimap>)forMapWithJavaUtilMap:(id<JavaUtilMap>)map;

/*!
 @brief Creates an index <code>ImmutableListMultimap</code> that contains the results of applying a
  specified function to each item in an <code>Iterable</code> of values.Each value will be stored as
  a value in the resulting multimap, yielding a multimap with the same size as the input
  iterable.
 The key used to store that value in the multimap will be the result of calling the
  function on that value. The resulting multimap is created as an immutable snapshot. In the
  returned multimap, keys appear in the order they are first encountered, and the values
  corresponding to each key appear in the same order as they are encountered. 
 <p>For example, 
 @code
 List<String> badGuys =
      Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
  Function<String, Integer> stringLengthFunction = ...;
  Multimap<Integer, String> index =
      Multimaps.index(badGuys, stringLengthFunction);
  System.out.println(index); 
 
@endcode
  
 <p>prints
  
 @code
 {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]} 
 
@endcode
  
 <p>The returned multimap is serializable if its keys and values are all serializable.
 @param values the values to use when constructing the <code>ImmutableListMultimap</code>
 @param keyFunction the function used to produce the key for each value
 @return <code>ImmutableListMultimap</code> mapping the result of evaluating the function <code>keyFunction</code>
  on each value in the input collection to that value
 @throw NullPointerExceptionif any element of <code>values</code> is <code>null</code>, or if <code>keyFunction</code>
  produces <code>null</code> for any key
 */
+ (ComGoogleCommonCollectImmutableListMultimap *)indexWithJavaLangIterable:(id<JavaLangIterable>)values
                                           withComGoogleCommonBaseFunction:(id<ComGoogleCommonBaseFunction>)keyFunction;

/*!
 @brief Creates an index <code>ImmutableListMultimap</code> that contains the results of applying a
  specified function to each item in an <code>Iterator</code> of values.Each value will be stored as
  a value in the resulting multimap, yielding a multimap with the same size as the input
  iterator.
 The key used to store that value in the multimap will be the result of calling the
  function on that value. The resulting multimap is created as an immutable snapshot. In the
  returned multimap, keys appear in the order they are first encountered, and the values
  corresponding to each key appear in the same order as they are encountered. 
 <p>For example, 
 @code
 List<String> badGuys =
      Arrays.asList("Inky", "Blinky", "Pinky", "Pinky", "Clyde");
  Function<String, Integer> stringLengthFunction = ...;
  Multimap<Integer, String> index =
      Multimaps.index(badGuys.iterator(), stringLengthFunction);
  System.out.println(index); 
 
@endcode
  
 <p>prints
  
 @code
 {4=[Inky], 6=[Blinky], 5=[Pinky, Pinky, Clyde]} 
 
@endcode
  
 <p>The returned multimap is serializable if its keys and values are all serializable.
 @param values the values to use when constructing the <code>ImmutableListMultimap</code>
 @param keyFunction the function used to produce the key for each value
 @return <code>ImmutableListMultimap</code> mapping the result of evaluating the function <code>keyFunction</code>
  on each value in the input collection to that value
 @throw NullPointerExceptionif any element of <code>values</code> is <code>null</code>, or if <code>keyFunction</code>
  produces <code>null</code> for any key
 @since 10.0
 */
+ (ComGoogleCommonCollectImmutableListMultimap *)indexWithJavaUtilIterator:(id<JavaUtilIterator>)values
                                           withComGoogleCommonBaseFunction:(id<ComGoogleCommonBaseFunction>)keyFunction;

/*!
 @brief Copies each key-value mapping in <code>source</code> into <code>dest</code>, with its key and value
  reversed.
 <p>If <code>source</code> is an <code>ImmutableMultimap</code>, consider using <code>ImmutableMultimap.inverse</code>
  instead.
 @param source any multimap
 @param dest the multimap to copy into; usually empty
 @return <code>dest</code>
 */
+ (id<ComGoogleCommonCollectMultimap>)invertFromWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)source
                                                withComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)dest;

/*!
 @brief Creates a new <code>ListMultimap</code> that uses the provided map and factory.It can generate a
  multimap based on arbitrary <code>Map</code> and <code>List</code> classes.
 <p>The <code>factory</code>-generated and <code>map</code> classes determine the multimap iteration
  order. They also specify the behavior of the <code>equals</code>, <code>hashCode</code>, and <code>toString</code>
  methods for the multimap and its returned views. The multimap's <code>get</code>, <code>removeAll</code>
 , and <code>replaceValues</code> methods return <code>RandomAccess</code> lists if the factory
  does. However, the multimap's <code>get</code> method returns instances of a different class than
  does <code>factory.get()</code>.
  
 <p>The multimap is serializable if <code>map</code>, <code>factory</code>, the lists generated by <code>factory</code>
 , and the multimap contents are all serializable. 
 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if 
 <code>map</code> and the instances generated by <code>factory</code> are. Concurrent read operations will
  work correctly. To allow concurrent update operations, wrap the multimap with a call to <code>synchronizedListMultimap</code>
 .
  
 <p>Call this method only when the simpler methods <code>ArrayListMultimap.create()</code> and <code>LinkedListMultimap.create()</code>
  won't suffice. 
 <p>Note: the multimap assumes complete ownership over of <code>map</code> and the lists returned by 
 <code>factory</code>. Those objects should not be manually updated, they should be empty when
  provided, and they should not use soft, weak, or phantom references.
 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty lists that will each hold all values for a given key
 @throw IllegalArgumentExceptionif <code>map</code> is not empty
 */
+ (id<ComGoogleCommonCollectListMultimap>)newListMultimapWithJavaUtilMap:(id<JavaUtilMap>)map
                                         withComGoogleCommonBaseSupplier:(id<ComGoogleCommonBaseSupplier>)factory OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new <code>Multimap</code> backed by <code>map</code>, whose internal value collections are
  generated by <code>factory</code>.
 <p><b>Warning: do not use</b> this method when the collections returned by <code>factory</code>
  implement either <code>List</code> or <code>Set</code>! Use the more specific method <code>newListMultimap</code>
 , <code>newSetMultimap</code> or <code>newSortedSetMultimap</code> instead, to avoid
  very surprising behavior from <code>Multimap.equals</code>.
  
 <p>The <code>factory</code>-generated and <code>map</code> classes determine the multimap iteration
  order. They also specify the behavior of the <code>equals</code>, <code>hashCode</code>, and <code>toString</code>
  methods for the multimap and its returned views. However, the multimap's <code>get</code>
  method returns instances of a different class than <code>factory.get()</code> does. 
 <p>The multimap is serializable if <code>map</code>, <code>factory</code>, the collections generated by 
 <code>factory</code>, and the multimap contents are all serializable. 
 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if 
 <code>map</code> and the instances generated by <code>factory</code> are. Concurrent read operations will
  work correctly. To allow concurrent update operations, wrap the multimap with a call to <code>synchronizedMultimap</code>
 .
  
 <p>Call this method only when the simpler methods <code>ArrayListMultimap.create()</code>, <code>HashMultimap.create()</code>
 , <code>LinkedHashMultimap.create()</code>, <code>LinkedListMultimap.create()</code>
 , <code>TreeMultimap.create()</code>, and <code>TreeMultimap.create(Comparator, Comparator)</code>
  won't suffice. 
 <p>Note: the multimap assumes complete ownership over of <code>map</code> and the collections
  returned by <code>factory</code>. Those objects should not be manually updated and they should not
  use soft, weak, or phantom references.
 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty collections that will each hold all values for a given      key
 @throw IllegalArgumentExceptionif <code>map</code> is not empty
 */
+ (id<ComGoogleCommonCollectMultimap>)newMultimapWithJavaUtilMap:(id<JavaUtilMap>)map
                                 withComGoogleCommonBaseSupplier:(id<ComGoogleCommonBaseSupplier>)factory OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new <code>SetMultimap</code> that uses the provided map and factory.It can generate a
  multimap based on arbitrary <code>Map</code> and <code>Set</code> classes.
 <p>The <code>factory</code>-generated and <code>map</code> classes determine the multimap iteration
  order. They also specify the behavior of the <code>equals</code>, <code>hashCode</code>, and <code>toString</code>
  methods for the multimap and its returned views. However, the multimap's <code>get</code>
  method returns instances of a different class than <code>factory.get()</code> does. 
 <p>The multimap is serializable if <code>map</code>, <code>factory</code>, the sets generated by <code>factory</code>
 , and the multimap contents are all serializable. 
 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if 
 <code>map</code> and the instances generated by <code>factory</code> are. Concurrent read operations will
  work correctly. To allow concurrent update operations, wrap the multimap with a call to <code>synchronizedSetMultimap</code>
 .
  
 <p>Call this method only when the simpler methods <code>HashMultimap.create()</code>, <code>LinkedHashMultimap.create()</code>
 , <code>TreeMultimap.create()</code>, and <code>TreeMultimap.create(Comparator, Comparator)</code>
  won't suffice. 
 <p>Note: the multimap assumes complete ownership over of <code>map</code> and the sets returned by 
 <code>factory</code>. Those objects should not be manually updated and they should not use soft,
  weak, or phantom references.
 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty sets that will each hold all values for a given key
 @throw IllegalArgumentExceptionif <code>map</code> is not empty
 */
+ (id<ComGoogleCommonCollectSetMultimap>)newSetMultimapWithJavaUtilMap:(id<JavaUtilMap>)map
                                       withComGoogleCommonBaseSupplier:(id<ComGoogleCommonBaseSupplier>)factory OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new <code>SortedSetMultimap</code> that uses the provided map and factory.It can generate
  a multimap based on arbitrary <code>Map</code> and <code>SortedSet</code> classes.
 <p>The <code>factory</code>-generated and <code>map</code> classes determine the multimap iteration
  order. They also specify the behavior of the <code>equals</code>, <code>hashCode</code>, and <code>toString</code>
  methods for the multimap and its returned views. However, the multimap's <code>get</code>
  method returns instances of a different class than <code>factory.get()</code> does. 
 <p>The multimap is serializable if <code>map</code>, <code>factory</code>, the sets generated by <code>factory</code>
 , and the multimap contents are all serializable. 
 <p>The multimap is not threadsafe when any concurrent operations update the multimap, even if 
 <code>map</code> and the instances generated by <code>factory</code> are. Concurrent read operations will
  work correctly. To allow concurrent update operations, wrap the multimap with a call to <code>synchronizedSortedSetMultimap</code>
 .
  
 <p>Call this method only when the simpler methods <code>TreeMultimap.create()</code> and <code>TreeMultimap.create(Comparator, Comparator)</code>
  won't suffice. 
 <p>Note: the multimap assumes complete ownership over of <code>map</code> and the sets returned by 
 <code>factory</code>. Those objects should not be manually updated and they should not use soft,
  weak, or phantom references.
 @param map place to store the mapping from each key to its corresponding values
 @param factory supplier of new, empty sorted sets that will each hold all values for a given      key
 @throw IllegalArgumentExceptionif <code>map</code> is not empty
 */
+ (id<ComGoogleCommonCollectSortedSetMultimap>)newSortedSetMultimapWithJavaUtilMap:(id<JavaUtilMap>)map
                                                   withComGoogleCommonBaseSupplier:(id<ComGoogleCommonBaseSupplier>)factory OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a synchronized (thread-safe) <code>ListMultimap</code> backed by the specified multimap.
 <p>You must follow the warnings described in <code>synchronizedMultimap</code>.
 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap
 */
+ (id<ComGoogleCommonCollectListMultimap>)synchronizedListMultimapWithComGoogleCommonCollectListMultimap:(id<ComGoogleCommonCollectListMultimap>)multimap;

/*!
 @brief Returns a synchronized (thread-safe) multimap backed by the specified multimap.In order to
  guarantee serial access, it is critical that <b>all</b> access to the backing multimap is
  accomplished through the returned multimap.
 <p>It is imperative that the user manually synchronize on the returned multimap when accessing
  any of its collection views: 
 @code
 Multimap<K, V> multimap = Multimaps.synchronizedMultimap(
      HashMultimap.<K, V>create());
  ...
  Collection<V> values = multimap.get(key);  // Needn't be in synchronized block
  ...
  synchronized (multimap) {  // Synchronizing on multimap, not values!
    Iterator<V> i = values.iterator(); // Must be in synchronized block
    while (i.hasNext()) {
      foo(i.next());
    }  }  
 
@endcode
  
 <p>Failure to follow this advice may result in non-deterministic behavior. 
 <p>Note that the generated multimap's <code>Multimap.removeAll</code> and <code>Multimap.replaceValues</code>
  methods return collections that aren't synchronized. 
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param multimap the multimap to be wrapped in a synchronized view
 @return a synchronized view of the specified multimap
 */
+ (id<ComGoogleCommonCollectMultimap>)synchronizedMultimapWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)multimap;

/*!
 @brief Returns a synchronized (thread-safe) <code>SetMultimap</code> backed by the specified multimap.
 <p>You must follow the warnings described in <code>synchronizedMultimap</code>.
  
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap
 */
+ (id<ComGoogleCommonCollectSetMultimap>)synchronizedSetMultimapWithComGoogleCommonCollectSetMultimap:(id<ComGoogleCommonCollectSetMultimap>)multimap;

/*!
 @brief Returns a synchronized (thread-safe) <code>SortedSetMultimap</code> backed by the specified
  multimap.
 <p>You must follow the warnings described in <code>synchronizedMultimap</code>.
  
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param multimap the multimap to be wrapped
 @return a synchronized view of the specified multimap
 */
+ (id<ComGoogleCommonCollectSortedSetMultimap>)synchronizedSortedSetMultimapWithComGoogleCommonCollectSortedSetMultimap:(id<ComGoogleCommonCollectSortedSetMultimap>)multimap;

/*!
 @brief Returns a <code>Collector</code> accumulating entries into a <code>Multimap</code> generated from the
  specified supplier.The keys and values of the entries are the result of applying the provided
  mapping functions to the input elements, accumulated in the encounter order of the stream.
 <p>Example:
  
 @code
 static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP =
      Stream.of("banana", "apple", "carrot", "asparagus", "cherry")
          .collect(
              toMultimap(
                   str -> str.charAt(0),
                   str -> str.substring(1),
                   MultimapBuilder.treeKeys().arrayListValues()::build));
  // is equivalent to
  static final ListMultimap<Character, String> FIRST_LETTER_MULTIMAP;
  static {
      FIRST_LETTER_MULTIMAP = MultimapBuilder.treeKeys().arrayListValues().build();
      FIRST_LETTER_MULTIMAP.put('b', "anana");
      FIRST_LETTER_MULTIMAP.put('a', "pple");
      FIRST_LETTER_MULTIMAP.put('a', "sparagus");
      FIRST_LETTER_MULTIMAP.put('c', "arrot");
      FIRST_LETTER_MULTIMAP.put('c', "herry");
  } 
 
@endcode
 @since 21.0
 */
+ (id<JavaUtilStreamCollector>)toMultimapWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)keyFunction
                                         withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)valueFunction
                                         withJavaUtilFunctionSupplier:(id<JavaUtilFunctionSupplier>)multimapSupplier;

/*!
 @brief Returns a view of a <code>ListMultimap</code> whose values are derived from the original multimap's
  entries.In contrast to <code>transformValues(ListMultimap, Function)</code>, this method's
  entry-transformation logic may depend on the key as well as the value.
 <p>All other properties of the transformed multimap, such as iteration order, are left intact.
  For example, the code: 
 @code
 Multimap<String, Integer> multimap =
      ImmutableMultimap.of("a", 1, "a", 4, "b", 6);
  EntryTransformer<String, Integer, String> transformer =
      new EntryTransformer<String, Integer, String>() {
        public String transformEntry(String key, Integer value) {
          return key + value;
        }
      };
  Multimap<String, String> transformed =
      Multimaps.transformEntries(multimap, transformer);
  System.out.println(transformed); 
 
@endcode
  ... prints <code>{"a"=["a1", "a4"], "b"=["b6"]}</code>.
  
 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
  supports removal operations, and these are reflected in the underlying multimap. 
 <p>It's acceptable for the underlying multimap to contain null keys and null values provided
  that the transformer is capable of accepting null inputs. The transformed multimap might
  contain null values if the transformer sometimes gives a null result. 
 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
  is. 
 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
  multimap to be a view, but it means that the transformer will be applied many times for bulk
  operations like <code>Multimap.containsValue</code> and <code>Object.toString</code>. For this to perform
  well, <code>transformer</code> should be fast. To avoid lazy evaluation when the returned multimap
  doesn't need to be a view, copy the returned multimap into a new multimap of your choosing. 
 <p><b>Warning:</b> This method assumes that for any instance <code>k</code> of <code>EntryTransformer</code>
  key type <code>K</code>, <code>k.equals(k2)</code> implies that <code>k2</code> is also of
  type <code>K</code>. Using an <code>EntryTransformer</code> key type for which this may not hold, such as 
 <code>ArrayList</code>, may risk a <code>ClassCastException</code> when calling methods on the
  transformed multimap.
 @since 7.0
 */
+ (id<ComGoogleCommonCollectListMultimap>)transformEntriesWithComGoogleCommonCollectListMultimap:(id<ComGoogleCommonCollectListMultimap>)fromMap
                                                 withComGoogleCommonCollectMaps_EntryTransformer:(id<ComGoogleCommonCollectMaps_EntryTransformer>)transformer;

/*!
 @brief Returns a view of a multimap whose values are derived from the original multimap's entries.In
  contrast to <code>transformValues</code>, this method's entry-transformation logic may depend on
  the key as well as the value.
 <p>All other properties of the transformed multimap, such as iteration order, are left intact.
  For example, the code: 
 @code
 SetMultimap<String, Integer> multimap =
      ImmutableSetMultimap.of("a", 1, "a", 4, "b", -6);
  EntryTransformer<String, Integer, String> transformer =
      new EntryTransformer<String, Integer, String>() {
        public String transformEntry(String key, Integer value) {
           return (value >= 0) ? key : "no" + key;
        }
      };
  Multimap<String, String> transformed =
      Multimaps.transformEntries(multimap, transformer);
  System.out.println(transformed); 
 
@endcode
  ... prints <code>{a=[a, a], b=[nob]}</code>.
  
 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
  supports removal operations, and these are reflected in the underlying multimap. 
 <p>It's acceptable for the underlying multimap to contain null keys and null values provided
  that the transformer is capable of accepting null inputs. The transformed multimap might
  contain null values if the transformer sometimes gives a null result. 
 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
  is. The <code>equals</code> and <code>hashCode</code> methods of the returned multimap are meaningless,
  since there is not a definition of <code>equals</code> or <code>hashCode</code> for general collections,
  and <code>get()</code> will return a general <code>Collection</code> as opposed to a <code>List</code> or a 
 <code>Set</code>.
  
 <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned
  multimap to be a view, but it means that the transformer will be applied many times for bulk
  operations like <code>Multimap.containsValue</code> and <code>Object.toString</code>. For this to perform
  well, <code>transformer</code> should be fast. To avoid lazy evaluation when the returned multimap
  doesn't need to be a view, copy the returned multimap into a new multimap of your choosing. 
 <p><b>Warning:</b> This method assumes that for any instance <code>k</code> of <code>EntryTransformer</code>
  key type <code>K</code>, <code>k.equals(k2)</code> implies that <code>k2</code> is also of
  type <code>K</code>. Using an <code>EntryTransformer</code> key type for which this may not hold, such as 
 <code>ArrayList</code>, may risk a <code>ClassCastException</code> when calling methods on the
  transformed multimap.
 @since 7.0
 */
+ (id<ComGoogleCommonCollectMultimap>)transformEntriesWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)fromMap
                                         withComGoogleCommonCollectMaps_EntryTransformer:(id<ComGoogleCommonCollectMaps_EntryTransformer>)transformer;

/*!
 @brief Returns a view of a <code>ListMultimap</code> where each value is transformed by a function.All
  other properties of the multimap, such as iteration order, are left intact.
 For example, the
  code: 
 @code
 ListMultimap<String, Integer> multimap
       = ImmutableListMultimap.of("a", 4, "a", 16, "b", 9);
  Function<Integer, Double> sqrt =
      new Function<Integer, Double>() {
        public Double apply(Integer in) {
          return Math.sqrt((int) in);
        }
      };
  ListMultimap<String, Double> transformed = Multimaps.transformValues(map,
      sqrt);
  System.out.println(transformed); 
 
@endcode
  ... prints <code>{a=[2.0, 4.0], b=[3.0]}</code>.
  
 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
  supports removal operations, and these are reflected in the underlying multimap. 
 <p>It's acceptable for the underlying multimap to contain null keys, and even null values
  provided that the function is capable of accepting null input. The transformed multimap might
  contain null values, if the function sometimes gives a null result. 
 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
  is. 
 <p>The function is applied lazily, invoked when needed. This is necessary for the returned
  multimap to be a view, but it means that the function will be applied many times for bulk
  operations like <code>Multimap.containsValue</code> and <code>Multimap.toString()</code>. For this to
  perform well, <code>function</code> should be fast. To avoid lazy evaluation when the returned
  multimap doesn't need to be a view, copy the returned multimap into a new multimap of your
  choosing.
 @since 7.0
 */
+ (id<ComGoogleCommonCollectListMultimap>)transformValuesWithComGoogleCommonCollectListMultimap:(id<ComGoogleCommonCollectListMultimap>)fromMultimap
                                                                withComGoogleCommonBaseFunction:(id<ComGoogleCommonBaseFunction>)function;

/*!
 @brief Returns a view of a multimap where each value is transformed by a function.All other
  properties of the multimap, such as iteration order, are left intact.
 For example, the code: 
 @code
 Multimap<String, Integer> multimap =
      ImmutableSetMultimap.of("a", 2, "b", -3, "b", -3, "a", 4, "c", 6);
  Function<Integer, String> square = new Function<Integer, String>() {
      public String apply(Integer in) {
        return Integer.toString(in * in);
      }
  };
  Multimap<String, String> transformed =
      Multimaps.transformValues(multimap, square);
    System.out.println(transformed); 
 
@endcode
  ... prints <code>{a=[4, 16], b=[9, 9], c=[36]}</code>.
  
 <p>Changes in the underlying multimap are reflected in this view. Conversely, this view
  supports removal operations, and these are reflected in the underlying multimap. 
 <p>It's acceptable for the underlying multimap to contain null keys, and even null values
  provided that the function is capable of accepting null input. The transformed multimap might
  contain null values, if the function sometimes gives a null result. 
 <p>The returned multimap is not thread-safe or serializable, even if the underlying multimap
  is. The <code>equals</code> and <code>hashCode</code> methods of the returned multimap are meaningless,
  since there is not a definition of <code>equals</code> or <code>hashCode</code> for general collections,
  and <code>get()</code> will return a general <code>Collection</code> as opposed to a <code>List</code> or a 
 <code>Set</code>.
  
 <p>The function is applied lazily, invoked when needed. This is necessary for the returned
  multimap to be a view, but it means that the function will be applied many times for bulk
  operations like <code>Multimap.containsValue</code> and <code>Multimap.toString()</code>. For this to
  perform well, <code>function</code> should be fast. To avoid lazy evaluation when the returned
  multimap doesn't need to be a view, copy the returned multimap into a new multimap of your
  choosing.
 @since 7.0
 */
+ (id<ComGoogleCommonCollectMultimap>)transformValuesWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)fromMultimap
                                                        withComGoogleCommonBaseFunction:(id<ComGoogleCommonBaseFunction>)function;

/*!
 @brief Simply returns its argument.
 @since 10.0
 */
+ (id<ComGoogleCommonCollectListMultimap>)unmodifiableListMultimapWithComGoogleCommonCollectImmutableListMultimap:(ComGoogleCommonCollectImmutableListMultimap *)delegate __attribute__((deprecated));

/*!
 @brief Returns an unmodifiable view of the specified <code>ListMultimap</code>.Query operations on the
  returned multimap "read through" to the specified multimap, and attempts to modify the returned
  multimap, either directly or through the multimap's views, result in an <code>UnsupportedOperationException</code>
 .
 <p>Note that the generated multimap's <code>Multimap.removeAll</code> and <code>Multimap.replaceValues</code>
  methods return collections that are modifiable. 
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap
 */
+ (id<ComGoogleCommonCollectListMultimap>)unmodifiableListMultimapWithComGoogleCommonCollectListMultimap:(id<ComGoogleCommonCollectListMultimap>)delegate;

/*!
 @brief Simply returns its argument.
 @since 10.0
 */
+ (id<ComGoogleCommonCollectMultimap>)unmodifiableMultimapWithComGoogleCommonCollectImmutableMultimap:(ComGoogleCommonCollectImmutableMultimap *)delegate __attribute__((deprecated));

/*!
 @brief Returns an unmodifiable view of the specified multimap.Query operations on the returned
  multimap "read through" to the specified multimap, and attempts to modify the returned
  multimap, either directly or through the multimap's views, result in an <code>UnsupportedOperationException</code>
 .
 <p>Note that the generated multimap's <code>Multimap.removeAll</code> and <code>Multimap.replaceValues</code>
  methods return collections that are modifiable. 
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap
 */
+ (id<ComGoogleCommonCollectMultimap>)unmodifiableMultimapWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)delegate;

/*!
 @brief Simply returns its argument.
 @since 10.0
 */
+ (id<ComGoogleCommonCollectSetMultimap>)unmodifiableSetMultimapWithComGoogleCommonCollectImmutableSetMultimap:(ComGoogleCommonCollectImmutableSetMultimap *)delegate __attribute__((deprecated));

/*!
 @brief Returns an unmodifiable view of the specified <code>SetMultimap</code>.Query operations on the
  returned multimap "read through" to the specified multimap, and attempts to modify the returned
  multimap, either directly or through the multimap's views, result in an <code>UnsupportedOperationException</code>
 .
 <p>Note that the generated multimap's <code>Multimap.removeAll</code> and <code>Multimap.replaceValues</code>
  methods return collections that are modifiable. 
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap
 */
+ (id<ComGoogleCommonCollectSetMultimap>)unmodifiableSetMultimapWithComGoogleCommonCollectSetMultimap:(id<ComGoogleCommonCollectSetMultimap>)delegate;

/*!
 @brief Returns an unmodifiable view of the specified <code>SortedSetMultimap</code>.Query operations on
  the returned multimap "read through" to the specified multimap, and attempts to modify the
  returned multimap, either directly or through the multimap's views, result in an <code>UnsupportedOperationException</code>
 .
 <p>Note that the generated multimap's <code>Multimap.removeAll</code> and <code>Multimap.replaceValues</code>
  methods return collections that are modifiable. 
 <p>The returned multimap will be serializable if the specified multimap is serializable.
 @param delegate the multimap for which an unmodifiable view is to be returned
 @return an unmodifiable view of the specified multimap
 */
+ (id<ComGoogleCommonCollectSortedSetMultimap>)unmodifiableSortedSetMultimapWithComGoogleCommonCollectSortedSetMultimap:(id<ComGoogleCommonCollectSortedSetMultimap>)delegate;

#pragma mark Package-Private

+ (jboolean)equalsImplWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)multimap
                                                  withId:(id __nullable)object;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectMultimaps)

FOUNDATION_EXPORT id<JavaUtilStreamCollector> ComGoogleCommonCollectMultimaps_toMultimapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_withJavaUtilFunctionSupplier_(id<JavaUtilFunctionFunction> keyFunction, id<JavaUtilFunctionFunction> valueFunction, id<JavaUtilFunctionSupplier> multimapSupplier);

FOUNDATION_EXPORT id<JavaUtilStreamCollector> ComGoogleCommonCollectMultimaps_flatteningToMultimapWithJavaUtilFunctionFunction_withJavaUtilFunctionFunction_withJavaUtilFunctionSupplier_(id<JavaUtilFunctionFunction> keyFunction, id<JavaUtilFunctionFunction> valueFunction, id<JavaUtilFunctionSupplier> multimapSupplier);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_newMultimapWithJavaUtilMap_withComGoogleCommonBaseSupplier_(id<JavaUtilMap> map, id<ComGoogleCommonBaseSupplier> factory);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_newListMultimapWithJavaUtilMap_withComGoogleCommonBaseSupplier_(id<JavaUtilMap> map, id<ComGoogleCommonBaseSupplier> factory);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_newSetMultimapWithJavaUtilMap_withComGoogleCommonBaseSupplier_(id<JavaUtilMap> map, id<ComGoogleCommonBaseSupplier> factory);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSortedSetMultimap> ComGoogleCommonCollectMultimaps_newSortedSetMultimapWithJavaUtilMap_withComGoogleCommonBaseSupplier_(id<JavaUtilMap> map, id<ComGoogleCommonBaseSupplier> factory);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_invertFromWithComGoogleCommonCollectMultimap_withComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> source, id<ComGoogleCommonCollectMultimap> dest);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_synchronizedMultimapWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> multimap);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_unmodifiableMultimapWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> delegate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_unmodifiableMultimapWithComGoogleCommonCollectImmutableMultimap_(ComGoogleCommonCollectImmutableMultimap *delegate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_synchronizedSetMultimapWithComGoogleCommonCollectSetMultimap_(id<ComGoogleCommonCollectSetMultimap> multimap);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_unmodifiableSetMultimapWithComGoogleCommonCollectSetMultimap_(id<ComGoogleCommonCollectSetMultimap> delegate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_unmodifiableSetMultimapWithComGoogleCommonCollectImmutableSetMultimap_(ComGoogleCommonCollectImmutableSetMultimap *delegate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSortedSetMultimap> ComGoogleCommonCollectMultimaps_synchronizedSortedSetMultimapWithComGoogleCommonCollectSortedSetMultimap_(id<ComGoogleCommonCollectSortedSetMultimap> multimap);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSortedSetMultimap> ComGoogleCommonCollectMultimaps_unmodifiableSortedSetMultimapWithComGoogleCommonCollectSortedSetMultimap_(id<ComGoogleCommonCollectSortedSetMultimap> delegate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_synchronizedListMultimapWithComGoogleCommonCollectListMultimap_(id<ComGoogleCommonCollectListMultimap> multimap);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_unmodifiableListMultimapWithComGoogleCommonCollectListMultimap_(id<ComGoogleCommonCollectListMultimap> delegate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_unmodifiableListMultimapWithComGoogleCommonCollectImmutableListMultimap_(ComGoogleCommonCollectImmutableListMultimap *delegate);

FOUNDATION_EXPORT id<JavaUtilMap> ComGoogleCommonCollectMultimaps_asMapWithComGoogleCommonCollectListMultimap_(id<ComGoogleCommonCollectListMultimap> multimap);

FOUNDATION_EXPORT id<JavaUtilMap> ComGoogleCommonCollectMultimaps_asMapWithComGoogleCommonCollectSetMultimap_(id<ComGoogleCommonCollectSetMultimap> multimap);

FOUNDATION_EXPORT id<JavaUtilMap> ComGoogleCommonCollectMultimaps_asMapWithComGoogleCommonCollectSortedSetMultimap_(id<ComGoogleCommonCollectSortedSetMultimap> multimap);

FOUNDATION_EXPORT id<JavaUtilMap> ComGoogleCommonCollectMultimaps_asMapWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> multimap);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_forMapWithJavaUtilMap_(id<JavaUtilMap> map);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_transformValuesWithComGoogleCommonCollectMultimap_withComGoogleCommonBaseFunction_(id<ComGoogleCommonCollectMultimap> fromMultimap, id<ComGoogleCommonBaseFunction> function);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_transformValuesWithComGoogleCommonCollectListMultimap_withComGoogleCommonBaseFunction_(id<ComGoogleCommonCollectListMultimap> fromMultimap, id<ComGoogleCommonBaseFunction> function);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_transformEntriesWithComGoogleCommonCollectMultimap_withComGoogleCommonCollectMaps_EntryTransformer_(id<ComGoogleCommonCollectMultimap> fromMap, id<ComGoogleCommonCollectMaps_EntryTransformer> transformer);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_transformEntriesWithComGoogleCommonCollectListMultimap_withComGoogleCommonCollectMaps_EntryTransformer_(id<ComGoogleCommonCollectListMultimap> fromMap, id<ComGoogleCommonCollectMaps_EntryTransformer> transformer);

FOUNDATION_EXPORT ComGoogleCommonCollectImmutableListMultimap *ComGoogleCommonCollectMultimaps_indexWithJavaLangIterable_withComGoogleCommonBaseFunction_(id<JavaLangIterable> values, id<ComGoogleCommonBaseFunction> keyFunction);

FOUNDATION_EXPORT ComGoogleCommonCollectImmutableListMultimap *ComGoogleCommonCollectMultimaps_indexWithJavaUtilIterator_withComGoogleCommonBaseFunction_(id<JavaUtilIterator> values, id<ComGoogleCommonBaseFunction> keyFunction);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_filterKeysWithComGoogleCommonCollectMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectMultimap> unfiltered, id<ComGoogleCommonBasePredicate> keyPredicate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_filterKeysWithComGoogleCommonCollectSetMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectSetMultimap> unfiltered, id<ComGoogleCommonBasePredicate> keyPredicate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectListMultimap> ComGoogleCommonCollectMultimaps_filterKeysWithComGoogleCommonCollectListMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectListMultimap> unfiltered, id<ComGoogleCommonBasePredicate> keyPredicate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_filterValuesWithComGoogleCommonCollectMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectMultimap> unfiltered, id<ComGoogleCommonBasePredicate> valuePredicate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_filterValuesWithComGoogleCommonCollectSetMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectSetMultimap> unfiltered, id<ComGoogleCommonBasePredicate> valuePredicate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectMultimap> ComGoogleCommonCollectMultimaps_filterEntriesWithComGoogleCommonCollectMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectMultimap> unfiltered, id<ComGoogleCommonBasePredicate> entryPredicate);

FOUNDATION_EXPORT id<ComGoogleCommonCollectSetMultimap> ComGoogleCommonCollectMultimaps_filterEntriesWithComGoogleCommonCollectSetMultimap_withComGoogleCommonBasePredicate_(id<ComGoogleCommonCollectSetMultimap> unfiltered, id<ComGoogleCommonBasePredicate> entryPredicate);

FOUNDATION_EXPORT jboolean ComGoogleCommonCollectMultimaps_equalsImplWithComGoogleCommonCollectMultimap_withId_(id<ComGoogleCommonCollectMultimap> multimap, id object);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectMultimaps)

#endif

#if !defined (ComGoogleCommonCollectMultimaps_Keys_) && (INCLUDE_ALL_ComGoogleCommonCollectMultimaps || defined(INCLUDE_ComGoogleCommonCollectMultimaps_Keys))
#define ComGoogleCommonCollectMultimaps_Keys_

#define RESTRICT_ComGoogleCommonCollectAbstractMultiset 1
#define INCLUDE_ComGoogleCommonCollectAbstractMultiset 1
#include "com/google/common/collect/AbstractMultiset.h"

@protocol ComGoogleCommonCollectMultimap;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSet;
@protocol JavaUtilSpliterator;

@interface ComGoogleCommonCollectMultimaps_Keys : ComGoogleCommonCollectAbstractMultiset {
 @public
  __unsafe_unretained id<ComGoogleCommonCollectMultimap> multimap_;
}

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id __nullable)element;

- (jint)countWithId:(id __nullable)element;

- (id<JavaUtilSet>)elementSet;

- (void)forEachWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)consumer;

- (id<JavaUtilIterator>)iterator;

- (jint)removeWithId:(id __nullable)element
             withInt:(jint)occurrences;

- (jint)size;

- (id<JavaUtilSpliterator>)spliterator;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)multimap;

- (jint)distinctElements;

- (id<JavaUtilIterator>)elementIterator;

- (id<JavaUtilIterator>)entryIterator;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initPackagePrivate NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectMultimaps_Keys)

FOUNDATION_EXPORT void ComGoogleCommonCollectMultimaps_Keys_initWithComGoogleCommonCollectMultimap_(ComGoogleCommonCollectMultimaps_Keys *self, id<ComGoogleCommonCollectMultimap> multimap);

FOUNDATION_EXPORT ComGoogleCommonCollectMultimaps_Keys *new_ComGoogleCommonCollectMultimaps_Keys_initWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> multimap) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonCollectMultimaps_Keys *create_ComGoogleCommonCollectMultimaps_Keys_initWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> multimap);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectMultimaps_Keys)

#endif

#if !defined (ComGoogleCommonCollectMultimaps_Entries_) && (INCLUDE_ALL_ComGoogleCommonCollectMultimaps || defined(INCLUDE_ComGoogleCommonCollectMultimaps_Entries))
#define ComGoogleCommonCollectMultimaps_Entries_

#define RESTRICT_JavaUtilAbstractCollection 1
#define INCLUDE_JavaUtilAbstractCollection 1
#include "java/util/AbstractCollection.h"

@protocol ComGoogleCommonCollectMultimap;

/*!
 @brief A skeleton implementation of <code>Multimap.entries()</code>.
 */
@interface ComGoogleCommonCollectMultimaps_Entries : JavaUtilAbstractCollection

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id __nullable)o;

- (jboolean)removeWithId:(id __nullable)o;

- (jint)size;

#pragma mark Package-Private

- (instancetype __nonnull)init;

- (id<ComGoogleCommonCollectMultimap>)multimap;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectMultimaps_Entries)

FOUNDATION_EXPORT void ComGoogleCommonCollectMultimaps_Entries_init(ComGoogleCommonCollectMultimaps_Entries *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectMultimaps_Entries)

#endif

#if !defined (ComGoogleCommonCollectMultimaps_AsMap_) && (INCLUDE_ALL_ComGoogleCommonCollectMultimaps || defined(INCLUDE_ComGoogleCommonCollectMultimaps_AsMap))
#define ComGoogleCommonCollectMultimaps_AsMap_

#define RESTRICT_ComGoogleCommonCollectMaps 1
#define INCLUDE_ComGoogleCommonCollectMaps_ViewCachingAbstractMap 1
#include "com/google/common/collect/Maps.h"

@protocol ComGoogleCommonCollectMultimap;
@protocol JavaUtilCollection;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilSet;

/*!
 @brief A skeleton implementation of <code>Multimap.asMap()</code>.
 */
@interface ComGoogleCommonCollectMultimaps_AsMap : ComGoogleCommonCollectMaps_ViewCachingAbstractMap

#pragma mark Public

- (void)clear;

- (id<JavaUtilCollection>)computeIfAbsentWithId:(id)arg0
                   withJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg1;

- (id<JavaUtilCollection>)computeIfPresentWithId:(id)arg0
                  withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg1;

- (id<JavaUtilCollection>)computeWithId:(id)arg0
         withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg1;

- (jboolean)containsKeyWithId:(id)key;

- (id<JavaUtilCollection>)getWithId:(id)key;

- (id<JavaUtilCollection>)getOrDefaultWithId:(id)arg0
                                      withId:(id<JavaUtilCollection>)arg1;

- (jboolean)isEmpty;

- (id<JavaUtilSet>)keySet;

- (id<JavaUtilCollection>)mergeWithId:(id)arg0
                               withId:(id<JavaUtilCollection>)arg1
       withJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)arg2;

- (id<JavaUtilCollection>)putIfAbsentWithId:(id)arg0
                                     withId:(id<JavaUtilCollection>)arg1;

- (id<JavaUtilCollection>)putWithId:(id)arg0
                             withId:(id<JavaUtilCollection>)arg1;

- (id<JavaUtilCollection>)removeWithId:(id)key;

- (id<JavaUtilCollection>)replaceWithId:(id)arg0
                                 withId:(id<JavaUtilCollection>)arg1;

- (jint)size;

#pragma mark Protected

- (id<JavaUtilSet>)createEntrySet;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonCollectMultimap:(id<ComGoogleCommonCollectMultimap>)multimap;

- (void)removeValuesForKeyWithId:(id)key;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectMultimaps_AsMap)

FOUNDATION_EXPORT void ComGoogleCommonCollectMultimaps_AsMap_initWithComGoogleCommonCollectMultimap_(ComGoogleCommonCollectMultimaps_AsMap *self, id<ComGoogleCommonCollectMultimap> multimap);

FOUNDATION_EXPORT ComGoogleCommonCollectMultimaps_AsMap *new_ComGoogleCommonCollectMultimaps_AsMap_initWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> multimap) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonCollectMultimaps_AsMap *create_ComGoogleCommonCollectMultimaps_AsMap_initWithComGoogleCommonCollectMultimap_(id<ComGoogleCommonCollectMultimap> multimap);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectMultimaps_AsMap)

#endif

#if !defined (ComGoogleCommonCollectMultimaps_AsMap_EntrySet_) && (INCLUDE_ALL_ComGoogleCommonCollectMultimaps || defined(INCLUDE_ComGoogleCommonCollectMultimaps_AsMap_EntrySet))
#define ComGoogleCommonCollectMultimaps_AsMap_EntrySet_

#define RESTRICT_ComGoogleCommonCollectMaps 1
#define INCLUDE_ComGoogleCommonCollectMaps_EntrySet 1
#include "com/google/common/collect/Maps.h"

@class ComGoogleCommonCollectMultimaps_AsMap;
@protocol JavaUtilIterator;
@protocol JavaUtilMap;

@interface ComGoogleCommonCollectMultimaps_AsMap_EntrySet : ComGoogleCommonCollectMaps_EntrySet

#pragma mark Public

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonCollectMultimaps_AsMap:(ComGoogleCommonCollectMultimaps_AsMap *)outer$;

- (id<JavaUtilMap>)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonCollectMultimaps_AsMap_EntrySet)

FOUNDATION_EXPORT void ComGoogleCommonCollectMultimaps_AsMap_EntrySet_initWithComGoogleCommonCollectMultimaps_AsMap_(ComGoogleCommonCollectMultimaps_AsMap_EntrySet *self, ComGoogleCommonCollectMultimaps_AsMap *outer$);

FOUNDATION_EXPORT ComGoogleCommonCollectMultimaps_AsMap_EntrySet *new_ComGoogleCommonCollectMultimaps_AsMap_EntrySet_initWithComGoogleCommonCollectMultimaps_AsMap_(ComGoogleCommonCollectMultimaps_AsMap *outer$) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonCollectMultimaps_AsMap_EntrySet *create_ComGoogleCommonCollectMultimaps_AsMap_EntrySet_initWithComGoogleCommonCollectMultimaps_AsMap_(ComGoogleCommonCollectMultimaps_AsMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonCollectMultimaps_AsMap_EntrySet)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonCollectMultimaps")
