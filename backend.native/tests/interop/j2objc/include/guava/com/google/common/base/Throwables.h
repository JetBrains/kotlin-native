//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/base/Throwables.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonBaseThrowables")
#ifdef RESTRICT_ComGoogleCommonBaseThrowables
#define INCLUDE_ALL_ComGoogleCommonBaseThrowables 0
#else
#define INCLUDE_ALL_ComGoogleCommonBaseThrowables 1
#endif
#undef RESTRICT_ComGoogleCommonBaseThrowables

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonBaseThrowables_) && (INCLUDE_ALL_ComGoogleCommonBaseThrowables || defined(INCLUDE_ComGoogleCommonBaseThrowables))
#define ComGoogleCommonBaseThrowables_

@class IOSClass;
@class JavaLangRuntimeException;
@class JavaLangThrowable;
@protocol JavaUtilList;

/*!
 @brief Static utility methods pertaining to instances of <code>Throwable</code>.
 <p>See the Guava User Guide entry on <a href="https://github.com/google/guava/wiki/ThrowablesExplained">
 Throwables</a>.
 @author Kevin Bourrillion
 @author Ben Yu
 @since 1.0
 */
@interface ComGoogleCommonBaseThrowables : NSObject
@property (readonly, copy, class) NSString *SHARED_SECRETS_CLASSNAME NS_SWIFT_NAME(SHARED_SECRETS_CLASSNAME);

+ (NSString *)SHARED_SECRETS_CLASSNAME;

#pragma mark Public

/*!
 @brief Gets a <code>Throwable</code> cause chain as a list.The first entry in the list will be <code>throwable</code>
  followed by its cause hierarchy.
 Note that this is a snapshot of the cause chain and
  will not reflect any subsequent changes to the cause chain. 
 <p>Here's an example of how it can be used to find specific types of exceptions in the cause
  chain: 
 @code

  Iterables.filter(Throwables.getCausalChain(e), IOException.class)); 
  
@endcode
 @param throwable the non-null <code>Throwable</code>  to extract causes from
 @return an unmodifiable list containing the cause chain starting with <code>throwable</code>
 @throw IllegalArgumentExceptionif there is a loop in the causal chain
 */
+ (id<JavaUtilList>)getCausalChainWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable;

/*!
 @brief Returns <code>throwable</code>'s cause, cast to <code>expectedCauseType</code>.
 <p>Prefer this method instead of manually casting an exception's cause. For example, <code>(IOException) e.getCause()</code>
  throws a <code>ClassCastException</code> that discards the original
  exception <code>e</code> if the cause is not an <code>IOException</code>, but <code>Throwables.getCauseAs(e, IOException.class)</code>
  keeps <code>e</code> as the <code>ClassCastException</code>
 's cause.
 @throw ClassCastExceptionif the cause cannot be cast to the expected type. The <code>ClassCastException</code>
 's cause is <code>throwable</code>.
 @since 22.0
 */
+ (JavaLangThrowable *)getCauseAsWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable
                                          withIOSClass:(IOSClass * __nonnull)expectedCauseType;

/*!
 @brief Returns the innermost cause of <code>throwable</code>.The first throwable in a chain provides
  context from when the error or exception was initially detected.
 Example usage: 
 @code

  assertEquals("Unable to assign a customer id", Throwables.getRootCause(e).getMessage()); 
  
@endcode
 @throw IllegalArgumentExceptionif there is a loop in the causal chain
 */
+ (JavaLangThrowable *)getRootCauseWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable;

/*!
 @brief Returns a string containing the result of <code>toString()</code>, followed by
  the full, recursive stack trace of <code>throwable</code>.Note that you probably should not be
  parsing the resulting string; if you need programmatic access to the stack frames, you can call 
 <code>Throwable.getStackTrace()</code>.
 */
+ (NSString *)getStackTraceAsStringWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable;

/*!
 @brief Returns the stack trace of <code>throwable</code>, possibly providing slower iteration over the full
  trace but faster iteration over parts of the trace.Here, "slower" and "faster" are defined in
  comparison to the normal way to access the stack trace, <code>throwable.getStackTrace()</code>
 .
 Note, however, that this method's special implementation is not
  available for all platforms and configurations. If that implementation is unavailable, this
  method falls back to <code>getStackTrace</code>. Callers that require the special implementation can
  check its availability with <code>lazyStackTraceIsLazy()</code>.
  
 <p>The expected (but not guaranteed) performance of the special implementation differs from 
 <code>getStackTrace</code> in one main way: The <code>lazyStackTrace</code> call itself returns quickly
  by delaying the per-stack-frame work until each element is accessed. Roughly speaking: 
 <ul>
    <li><code>getStackTrace</code> takes <code>stackSize</code> time to return but then negligible time to
        retrieve each element of the returned list.   
 <li><code>lazyStackTrace</code> takes negligible time to return but then <code>1/stackSize</code> time
        to retrieve each element of the returned list (probably slightly more than <code>1/stackSize</code>
 ).
  </ul>
  
 <p>Note: The special implementation does not respect calls to <code>throwable.setStackTrace</code>
 . Instead, it always reflects the original stack trace from the
  exception's creation.
 @since 19.0
 */
+ (id<JavaUtilList>)lazyStackTraceWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable;

/*!
 @brief Returns whether <code>lazyStackTrace</code> will use the special implementation described in its
  documentation.
 @since 19.0
 */
+ (jboolean)lazyStackTraceIsLazy;

/*!
 @brief Propagates <code>throwable</code> as-is if it is an instance of <code>RuntimeException</code> or <code>Error</code>
 , or else as a last resort, wraps it in a <code>RuntimeException</code> and then propagates.
 <p>This method always throws an exception. The <code>RuntimeException</code> return type allows
  client code to signal to the compiler that statements after the call are unreachable. Example
  usage: 
 @code

  T doSomething() {
    try {
      return someMethodThatCouldThrowAnything();
    } catch (IKnowWhatToDoWithThisException e) {
      return handle(e);
    } catch (Throwable t) {
      throw Throwables.propagate(t);
    }  }  
  
@endcode
 @param throwable the Throwable to propagate
 @return nothing will ever be returned; this return type is only for your convenience, as
      illustrated in the example above
 */
+ (JavaLangRuntimeException *)propagateWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable __attribute__((deprecated));

/*!
 @brief Propagates <code>throwable</code> exactly as-is, if and only if it is an instance of <code>declaredType</code>
 .Example usage: 
 @code

  try {
    someMethodThatCouldThrowAnything();
  } catch (IKnowWhatToDoWithThisException e) {
    handle(e);
  } catch (Throwable t) {
    Throwables.propagateIfInstanceOf(t, IOException.class);
    Throwables.propagateIfInstanceOf(t, SQLException.class);
    throw Throwables.propagate(t);
  } 
  
@endcode
 */
+ (void)propagateIfInstanceOfWithJavaLangThrowable:(JavaLangThrowable * __nullable)throwable
                                      withIOSClass:(IOSClass * __nonnull)declaredType __attribute__((deprecated));

/*!
 @brief Propagates <code>throwable</code> exactly as-is, if and only if it is an instance of <code>RuntimeException</code>
  or <code>Error</code>.Example usage: 
 @code

  try {
    someMethodThatCouldThrowAnything();
  } catch (IKnowWhatToDoWithThisException e) {
    handle(e);
  } catch (Throwable t) {
    Throwables.propagateIfPossible(t);
    throw new RuntimeException("unexpected", t);
  } 
  
@endcode
 */
+ (void)propagateIfPossibleWithJavaLangThrowable:(JavaLangThrowable * __nullable)throwable __attribute__((deprecated));

/*!
 @brief Propagates <code>throwable</code> exactly as-is, if and only if it is an instance of <code>RuntimeException</code>
 , <code>Error</code>, or <code>declaredType</code>.Example usage: 
 @code

  try {
    someMethodThatCouldThrowAnything();
  } catch (IKnowWhatToDoWithThisException e) {
    handle(e);
  } catch (Throwable t) {
    Throwables.propagateIfPossible(t, OtherException.class);
    throw new RuntimeException("unexpected", t);
  } 
  
@endcode
 @param throwable the Throwable to possibly propagate
 @param declaredType the single checked exception type declared by the calling method
 */
+ (void)propagateIfPossibleWithJavaLangThrowable:(JavaLangThrowable * __nullable)throwable
                                    withIOSClass:(IOSClass * __nonnull)declaredType;

/*!
 @brief Propagates <code>throwable</code> exactly as-is, if and only if it is an instance of <code>RuntimeException</code>
 , <code>Error</code>, <code>declaredType1</code>, or <code>declaredType2</code>.In the
  unlikely case that you have three or more declared checked exception types, you can handle them
  all by invoking these methods repeatedly.
 See usage example in <code>propagateIfPossible(Throwable, Class)</code>
 .
 @param throwable the Throwable to possibly propagate
 @param declaredType1 any checked exception type declared by the calling method
 @param declaredType2 any other checked exception type declared by the calling method
 */
+ (void)propagateIfPossibleWithJavaLangThrowable:(JavaLangThrowable * __nullable)throwable
                                    withIOSClass:(IOSClass * __nonnull)declaredType1
                                    withIOSClass:(IOSClass * __nonnull)declaredType2;

/*!
 @brief Throws <code>throwable</code> if it is an instance of <code>declaredType</code>.Example usage: 
 @code

  for (Foo foo : foos) {
    try {
      foo.bar();
    } catch (BarException | RuntimeException | Error t) {
      failure = t;
    }  }
  if (failure !
 = null) {
    throwIfInstanceOf(failure, BarException.class);
    throwIfUnchecked(failure);
    throw new AssertionError(failure);
  } 
  
@endcode
 @since 20.0
 */
+ (void)throwIfInstanceOfWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable
                                  withIOSClass:(IOSClass * __nonnull)declaredType;

/*!
 @brief Throws <code>throwable</code> if it is a <code>RuntimeException</code> or <code>Error</code>.Example usage: 
 @code

  for (Foo foo : foos) {
    try {
      foo.bar();
    } catch (RuntimeException | Error t) {
      failure = t;
    }  }
  if (failure !
 = null) {
    throwIfUnchecked(failure);
    throw new AssertionError(failure);
  } 
  
@endcode
 @since 20.0
 */
+ (void)throwIfUncheckedWithJavaLangThrowable:(JavaLangThrowable * __nonnull)throwable;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonBaseThrowables)

/*!
 @brief SharedSecrets class name to load using reflection
 */
inline NSString *ComGoogleCommonBaseThrowables_get_SHARED_SECRETS_CLASSNAME(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComGoogleCommonBaseThrowables_SHARED_SECRETS_CLASSNAME;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComGoogleCommonBaseThrowables, SHARED_SECRETS_CLASSNAME, NSString *)

FOUNDATION_EXPORT void ComGoogleCommonBaseThrowables_throwIfInstanceOfWithJavaLangThrowable_withIOSClass_(JavaLangThrowable *throwable, IOSClass *declaredType);

FOUNDATION_EXPORT void ComGoogleCommonBaseThrowables_propagateIfInstanceOfWithJavaLangThrowable_withIOSClass_(JavaLangThrowable *throwable, IOSClass *declaredType);

FOUNDATION_EXPORT void ComGoogleCommonBaseThrowables_throwIfUncheckedWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT void ComGoogleCommonBaseThrowables_propagateIfPossibleWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT void ComGoogleCommonBaseThrowables_propagateIfPossibleWithJavaLangThrowable_withIOSClass_(JavaLangThrowable *throwable, IOSClass *declaredType);

FOUNDATION_EXPORT void ComGoogleCommonBaseThrowables_propagateIfPossibleWithJavaLangThrowable_withIOSClass_withIOSClass_(JavaLangThrowable *throwable, IOSClass *declaredType1, IOSClass *declaredType2);

FOUNDATION_EXPORT JavaLangRuntimeException *ComGoogleCommonBaseThrowables_propagateWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT JavaLangThrowable *ComGoogleCommonBaseThrowables_getRootCauseWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT id<JavaUtilList> ComGoogleCommonBaseThrowables_getCausalChainWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT JavaLangThrowable *ComGoogleCommonBaseThrowables_getCauseAsWithJavaLangThrowable_withIOSClass_(JavaLangThrowable *throwable, IOSClass *expectedCauseType);

FOUNDATION_EXPORT NSString *ComGoogleCommonBaseThrowables_getStackTraceAsStringWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT id<JavaUtilList> ComGoogleCommonBaseThrowables_lazyStackTraceWithJavaLangThrowable_(JavaLangThrowable *throwable);

FOUNDATION_EXPORT jboolean ComGoogleCommonBaseThrowables_lazyStackTraceIsLazy(void);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonBaseThrowables)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonBaseThrowables")
