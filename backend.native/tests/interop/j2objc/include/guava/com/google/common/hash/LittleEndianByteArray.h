//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/hash/LittleEndianByteArray.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonHashLittleEndianByteArray")
#ifdef RESTRICT_ComGoogleCommonHashLittleEndianByteArray
#define INCLUDE_ALL_ComGoogleCommonHashLittleEndianByteArray 0
#else
#define INCLUDE_ALL_ComGoogleCommonHashLittleEndianByteArray 1
#endif
#undef RESTRICT_ComGoogleCommonHashLittleEndianByteArray

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonHashLittleEndianByteArray_) && (INCLUDE_ALL_ComGoogleCommonHashLittleEndianByteArray || defined(INCLUDE_ComGoogleCommonHashLittleEndianByteArray))
#define ComGoogleCommonHashLittleEndianByteArray_

@class IOSByteArray;

/*!
 @brief Utility functions for loading and storing values from a byte array.
 @author Kevin Damm
 @author Kyle Maddison
 */
@interface ComGoogleCommonHashLittleEndianByteArray : NSObject

#pragma mark Package-Private

/*!
 @brief Load 4 bytes from the provided array at the indicated offset.
 @param source the input bytes
 @param offset the offset into the array at which to start
 @return the value found in the array in the form of a long
 */
+ (jint)load32WithByteArray:(IOSByteArray * __nonnull)source
                    withInt:(jint)offset;

/*!
 @brief Load 8 bytes into long in a little endian manner, from the substring between position and
  position + 8.The array must have at least 8 bytes from offset (inclusive).
 @param input the input bytes
 @param offset the offset into the array at which to start
 @return a long of a concatenated 8 bytes
 */
+ (jlong)load64WithByteArray:(IOSByteArray * __nonnull)input
                     withInt:(jint)offset;

/*!
 @brief Similar to load64, but allows offset + 8 > input.length, padding the result with zeroes.This
  has to explicitly reverse the order of the bytes as it packs them into the result which makes
  it slower than the native version.
 @param input the input bytes
 @param offset the offset into the array at which to start reading
 @param length the number of bytes from the input to read
 @return a long of a concatenated 8 bytes
 */
+ (jlong)load64SafelyWithByteArray:(IOSByteArray * __nonnull)input
                           withInt:(jint)offset
                           withInt:(jint)length;

/*!
 @brief Store 8 bytes into the provided array at the indicated offset, using the value provided.
 @param sink the output byte array
 @param offset the offset into the array at which to start writing
 @param value the value to write
 */
+ (void)store64WithByteArray:(IOSByteArray * __nonnull)sink
                     withInt:(jint)offset
                    withLong:(jlong)value;

/*!
 @brief Indicates that the loading of Unsafe was successful and the load and store operations will be
  very efficient.May be useful for calling code to fall back on an alternative implementation
  that is slower than Unsafe.get/store but faster than the pure-Java mask-and-shift.
 */
+ (jboolean)usingUnsafe;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonHashLittleEndianByteArray)

FOUNDATION_EXPORT jlong ComGoogleCommonHashLittleEndianByteArray_load64WithByteArray_withInt_(IOSByteArray *input, jint offset);

FOUNDATION_EXPORT jlong ComGoogleCommonHashLittleEndianByteArray_load64SafelyWithByteArray_withInt_withInt_(IOSByteArray *input, jint offset, jint length);

FOUNDATION_EXPORT void ComGoogleCommonHashLittleEndianByteArray_store64WithByteArray_withInt_withLong_(IOSByteArray *sink, jint offset, jlong value);

FOUNDATION_EXPORT jint ComGoogleCommonHashLittleEndianByteArray_load32WithByteArray_withInt_(IOSByteArray *source, jint offset);

FOUNDATION_EXPORT jboolean ComGoogleCommonHashLittleEndianByteArray_usingUnsafe(void);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonHashLittleEndianByteArray)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonHashLittleEndianByteArray")
