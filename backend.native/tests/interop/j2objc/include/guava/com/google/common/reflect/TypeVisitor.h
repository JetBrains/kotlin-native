//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/reflect/TypeVisitor.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonReflectTypeVisitor")
#ifdef RESTRICT_ComGoogleCommonReflectTypeVisitor
#define INCLUDE_ALL_ComGoogleCommonReflectTypeVisitor 0
#else
#define INCLUDE_ALL_ComGoogleCommonReflectTypeVisitor 1
#endif
#undef RESTRICT_ComGoogleCommonReflectTypeVisitor

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonReflectTypeVisitor_) && (INCLUDE_ALL_ComGoogleCommonReflectTypeVisitor || defined(INCLUDE_ComGoogleCommonReflectTypeVisitor))
#define ComGoogleCommonReflectTypeVisitor_

@class IOSClass;
@class IOSObjectArray;
@protocol JavaLangReflectGenericArrayType;
@protocol JavaLangReflectParameterizedType;
@protocol JavaLangReflectTypeVariable;
@protocol JavaLangReflectWildcardType;

/*!
 @brief Based on what a <code>Type</code> is, dispatch it to the corresponding <code>visit*</code> method.By
  default, no recursion is done for type arguments or type bounds.
 But subclasses can opt to do
  recursion by calling <code>visit</code> for any <code>Type</code> while visitation is in progress. For
  example, this can be used to reject wildcards or type variables contained in a type as in: 
 @code
 new TypeVisitor() {
    protected void visitParameterizedType(ParameterizedType t) {
      visit(t.getOwnerType());
      visit(t.getActualTypeArguments());
    }
    protected void visitGenericArrayType(GenericArrayType t) {
      visit(t.getGenericComponentType());
    }
    protected void visitTypeVariable(TypeVariable<?> t) {
      throw new IllegalArgumentException("Cannot contain type variable.");
    }
    protected void visitWildcardType(WildcardType t) {
      throw new IllegalArgumentException("Cannot contain wildcard type.");
    }
  }.visit(type); 
 
@endcode
  
 <p>One <code>Type</code> is visited at most once. The second time the same type is visited, it's
  ignored by <code>visit</code>. This avoids infinite recursion caused by recursive type bounds. 
 <p>This class is <em>not</em> thread safe.
 @author Ben Yu
 */
@interface ComGoogleCommonReflectTypeVisitor : NSObject

#pragma mark Public

/*!
 @brief Visits the given types.Null types are ignored.
 This allows subclasses to call <code>visit(parameterizedType.getOwnerType())</code>
  safely without having to check nulls.
 */
- (void)visitWithJavaLangReflectTypeArray:(IOSObjectArray * __nonnull)types;

#pragma mark Package-Private

- (instancetype __nonnull)initPackagePrivate;

- (void)visitClassWithIOSClass:(IOSClass * __nonnull)t;

- (void)visitGenericArrayTypeWithJavaLangReflectGenericArrayType:(id<JavaLangReflectGenericArrayType> __nonnull)t;

- (void)visitParameterizedTypeWithJavaLangReflectParameterizedType:(id<JavaLangReflectParameterizedType> __nonnull)t;

- (void)visitTypeVariableWithJavaLangReflectTypeVariable:(id<JavaLangReflectTypeVariable> __nonnull)t;

- (void)visitWildcardTypeWithJavaLangReflectWildcardType:(id<JavaLangReflectWildcardType> __nonnull)t;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonReflectTypeVisitor)

FOUNDATION_EXPORT void ComGoogleCommonReflectTypeVisitor_initPackagePrivate(ComGoogleCommonReflectTypeVisitor *self);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonReflectTypeVisitor)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonReflectTypeVisitor")
