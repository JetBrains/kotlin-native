//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/util/concurrent/ListenableFuture.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenableFuture")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentListenableFuture
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenableFuture 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenableFuture 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentListenableFuture

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentListenableFuture_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenableFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentListenableFuture))
#define ComGoogleCommonUtilConcurrentListenableFuture_

#define RESTRICT_JavaUtilConcurrentFuture 1
#define INCLUDE_JavaUtilConcurrentFuture 1
#include "java/util/concurrent/Future.h"

@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A <code>Future</code> that accepts completion listeners.Each listener has an associated executor, and
  it is invoked using this executor once the future's computation is complete
 .
 If the computation has already completed when the listener is added, the listener will
  execute immediately. 
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/ListenableFutureExplained">
 <code>ListenableFuture</code>
 </a>.
  
 <h3>Purpose</h3>
  
 <p>The main purpose of <code>ListenableFuture</code> is to help you chain together a graph of
  asynchronous operations. You can chain them together manually with calls to methods like <code>Futures.transform</code>
 , but you will often find it easier to use a framework. Frameworks automate the
  process, often adding features like monitoring, debugging, and cancellation. Examples of
  frameworks include: 
 <ul>
    <li><a href="http://google.github.io/dagger/producers.html">Dagger Producers</a>
  </ul>
  
 <p>The main purpose of <code>addListener</code> is to support this chaining. You will
  rarely use it directly, in part because it does not provide direct access to the <code>Future</code>
  result. (If you want such access, you may prefer <code>Futures.addCallback</code>
 .) Still, direct <code>addListener</code> calls are occasionally useful: 
 @code
 final String name = ...;
  inFlight.add(name);
  ListenableFuture<Result> future = service.query(name);
  future.addListener(new Runnable() {
    public void run() {
      processedCount.incrementAndGet();
      inFlight.remove(name);
      lastProcessed.set(name);
      logger.info("Done with {0}", name);
    }
  }, executor); 
 
@endcode
  
 <h3>How to get an instance</h3>
  
 <p>We encourage you to return <code>ListenableFuture</code> from your methods so that your users can
  take advantage of the utilities built atop the class. The way that you will
  create <code>ListenableFuture</code> instances depends on how you currently create <code>Future</code>
  instances: 
 <ul>
    <li>If you receive them from an <code>java.util.concurrent.ExecutorService</code>, convert that
        service to a <code>ListeningExecutorService</code>, usually by calling <code>MoreExecutors.listeningDecorator</code>
 .
    <li>If you manually call <code>java.util.concurrent.FutureTask.set</code> or a similar method,
        create a <code>SettableFuture</code> instead. (If your needs are more complex, you may prefer
        <code>AbstractFuture</code>.)
  </ul>
  
 <p><b>Test doubles</b>: If you need a <code>ListenableFuture</code> for your test, try a <code>SettableFuture</code>
  or one of the methods in the <code>Futures.immediate*</code>
  family. <b>Avoid</b> creating a mock or stub <code>Future</code>. Mock and stub implementations are
  fragile because they assume that only certain methods will be called and because they often
  implement subtleties of the API improperly. 
 <p><b>Custom implementation</b>: Avoid implementing <code>ListenableFuture</code> from scratch. If you
  can't get by with the standard implementations, prefer to derive a new <code>Future</code> instance
  with the methods in <code>Futures</code> or, if necessary, to extend <code>AbstractFuture</code>.
  
 <p>Occasionally, an API will return a plain <code>Future</code> and it will be impossible to change
  the return type. For this case, we provide a more expensive workaround in <code>JdkFutureAdapters</code>
 . However, when possible, it is more efficient and reliable to create a <code>ListenableFuture</code>
  directly.
 @author Sven Mawson
 @author Nishant Thakkar
 @since 1.0
 */
@protocol ComGoogleCommonUtilConcurrentListenableFuture < JavaUtilConcurrentFuture, JavaObject >

/*!
 @brief Registers a listener to be run on the given executor.
 The listener will run when the <code>Future</code>'s computation is complete
  or, if the computation is already complete, immediately. 
 <p>There is no guaranteed ordering of execution of listeners, but any listener added through
  this method is guaranteed to be called once the computation is complete. 
 <p>Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown
  during <code>Executor.execute</code> (e.g., a <code>RejectedExecutionException</code> or an exception
  thrown by direct execution) will be caught and
  logged. 
 <p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider 
 <code>MoreExecutors.directExecutor</code>. Otherwise, avoid it. Heavyweight <code>directExecutor</code>
  listeners can cause problems, and these problems can be difficult to reproduce because they
  depend on timing. For example: 
 <ul>
    <li>The listener may be executed by the caller of <code>addListener</code>. That caller may be a
        UI thread or other latency-sensitive thread. This can harm UI responsiveness.   
 <li>The listener may be executed by the thread that completes this <code>Future</code>. That
        thread may be an internal system thread such as an RPC network thread. Blocking that
        thread may stall progress of the whole system. It may even cause a deadlock.   
 <li>The listener may delay other listeners, even listeners that are not themselves <code>directExecutor</code>
  listeners. 
 </ul>
  
 <p>This is the most general listener interface. For common operations performed using
  listeners, see <code>Futures</code>. For a simplified but general listener interface, see <code>addCallback()</code>
 .
  
 <p>Memory consistency effects: Actions in a thread prior to adding a listener <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5">
  <i>happen-before</i></a> its execution begins, perhaps in another thread.
 @param listener the listener to run when the computation is complete
 @param executor the executor to run the listener in
 @throw RejectedExecutionExceptionif we tried to execute the listener immediately but the
      executor rejected it.
 */
- (void)addListenerWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)listener
         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentListenableFuture)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentListenableFuture)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenableFuture")
