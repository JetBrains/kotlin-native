//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/build_result/java/com/google/common/util/concurrent/Monitor.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentMonitor")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentMonitor
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentMonitor 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentMonitor 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentMonitor

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentMonitor_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentMonitor || defined(INCLUDE_ComGoogleCommonUtilConcurrentMonitor))
#define ComGoogleCommonUtilConcurrentMonitor_

@class ComGoogleCommonUtilConcurrentMonitor_Guard;
@class JavaLangThread;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilFunctionBooleanSupplier;

/*!
 @brief A synchronization abstraction supporting waiting on arbitrary boolean conditions.
 <p>This class is intended as a replacement for <code>ReentrantLock</code>. Code using <code>Monitor</code>
  is less error-prone and more readable than code using <code>ReentrantLock</code>, without significant
  performance loss. <code>Monitor</code> even has the potential for performance gain by optimizing the
  evaluation and signaling of conditions. Signaling is entirely <a href="http://en.wikipedia.org/wiki/Monitor_(synchronization)#Implicit_signaling">
 implicit</a>. By
  eliminating explicit signaling, this class can guarantee that only one thread is awakened when a
  condition becomes true (no "signaling storms" due to use of <code>Condition.signalAll</code>
 ) and that no signals are lost
  (no "hangs" due to incorrect use of <code>Condition.signal</code>
 ).
  
 <p>A thread is said to <i>occupy</i> a monitor if it has <i>entered</i> the monitor but not yet 
 <i>left</i>. Only one thread may occupy a given monitor at any moment. A monitor is also
  reentrant, so a thread may enter a monitor any number of times, and then must leave the same
  number of times. The <i>enter</i> and <i>leave</i> operations have the same synchronization
  semantics as the built-in Java language synchronization primitives. 
 <p>A call to any of the <i>enter</i> methods with <b>void</b> return type should always be
  followed immediately by a <i>try/finally</i> block to ensure that the current thread leaves the
  monitor cleanly: 
 @code
 monitor.enter();
  try {
    // do things while occupying the monitor
  } finally {
    monitor.leave();
  } 
 
@endcode
  
 <p>A call to any of the <i>enter</i> methods with <b>boolean</b> return type should always appear
  as the condition of an <i>if</i> statement containing a <i>try/finally</i> block to ensure that
  the current thread leaves the monitor cleanly: 
 @code
 if (monitor.tryEnter()) {
    try {
      // do things while occupying the monitor
    } finally {
      monitor.leave();
    }
  } else {
    // do other things since the monitor was not available
  } 
 
@endcode
  
 <h2>Comparison with <code>synchronized</code> and <code>ReentrantLock</code></h2>
  
 <p>The following examples show a simple threadsafe holder expressed using <code>synchronized</code>,
  <code>ReentrantLock</code>, and <code>Monitor</code>.
  
 <h3><code>synchronized</code></h3>
  
 <p>This version is the fewest lines of code, largely because the synchronization mechanism used
  is built into the language and runtime. But the programmer has to remember to avoid a couple of
  common bugs: The <code>wait()</code> must be inside a <code>while</code> instead of an <code>if</code>, and 
 <code>notifyAll()</code> must be used instead of <code>notify()</code> because there are two different
  logical conditions being awaited. 
 @code
 public class SafeBox<V> {
    private V value;
    public synchronized V get() throws InterruptedException {
      while (value == null) {
        wait();
      }
      V result = value;
      value = null;
      notifyAll();
      return result;
    }
    public synchronized void set(V newValue) throws InterruptedException {
      while (value != null) {
        wait();
      }
      value = newValue;
      notifyAll();
    }  }  
 
@endcode
  
 <h3><code>ReentrantLock</code></h3>
  
 <p>This version is much more verbose than the <code>synchronized</code> version, and still suffers
  from the need for the programmer to remember to use <code>while</code> instead of <code>if</code>. However,
  one advantage is that we can introduce two separate <code>Condition</code> objects, which allows us to
  use <code>signal()</code> instead of <code>signalAll()</code>, which may be a performance benefit. 
 @code
 public class SafeBox<V> {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition valuePresent = lock.newCondition();
    private final Condition valueAbsent = lock.newCondition();
    private V value;
    public V get() throws InterruptedException {
      lock.lock();
      try {
        while (value == null) {
          valuePresent.await();
        }
        V result = value;
        value = null;
        valueAbsent.signal();
        return result;
      } finally {
        lock.unlock();
      }    }
    public void set(V newValue) throws InterruptedException {
      lock.lock();
      try {
        while (value != null) {
          valueAbsent.await();
        }
        value = newValue;
        valuePresent.signal();
      } finally {
        lock.unlock();
      }    }    }    
 
@endcode
  
 <h3><code>Monitor</code></h3>
  
 <p>This version adds some verbosity around the <code>Guard</code> objects, but removes that same
  verbosity, and more, from the <code>get</code> and <code>set</code> methods. <code>Monitor</code> implements the
  same efficient signaling as we had to hand-code in the <code>ReentrantLock</code> version above.
  Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to
  remember to use <code>while</code> instead of <code>if</code>.
  
 @code
 public class SafeBox<V> {
    private final Monitor monitor = new Monitor();
    private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {
      public boolean isSatisfied() {
        return value != null;
      }
    };
    private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {
      public boolean isSatisfied() {
        return value == null;
      }
    };
    private V value;
    public V get() throws InterruptedException {
      monitor.enterWhen(valuePresent);
      try {
        V result = value;
        value = null;
        return result;
      } finally {
        monitor.leave();
      }    }
    public void set(V newValue) throws InterruptedException {
      monitor.enterWhen(valueAbsent);
      try {
        value = newValue;
      } finally {
        monitor.leave();
      }    }    }    
 
@endcode
 @author Justin T. Sampson
 @author Martin Buchholz
 @since 10.0
 */
@interface ComGoogleCommonUtilConcurrentMonitor : NSObject

#pragma mark Public

/*!
 @brief Creates a monitor with a non-fair (but fast) ordering policy.Equivalent to <code>Monitor(false)</code>
 .
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a monitor with the given ordering policy.
 @param fair whether this monitor should use a fair ordering policy rather than a non-fair (but      fast) one
 */
- (instancetype __nonnull)initWithBoolean:(jboolean)fair;

/*!
 @brief Enters this monitor.Blocks indefinitely.
 */
- (void)enter;

/*!
 @brief Enters this monitor.Blocks at most the given time.
 @return whether the monitor was entered
 */
- (jboolean)enterWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Enters this monitor if the guard is satisfied.Blocks indefinitely acquiring the lock, but does
  not wait for the guard to be satisfied.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 */
- (jboolean)enterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Enters this monitor if the guard is satisfied.Blocks at most the given time acquiring the
  lock, but does not wait for the guard to be satisfied.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 */
- (jboolean)enterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard
                                                         withLong:(jlong)time
                                   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Enters this monitor if the guard is satisfied.Blocks indefinitely acquiring the lock, but does
  not wait for the guard to be satisfied, and may be interrupted.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @throw InterruptedExceptionif interrupted while waiting
 */
- (jboolean)enterIfInterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Enters this monitor if the guard is satisfied.Blocks at most the given time acquiring the
  lock, but does not wait for the guard to be satisfied, and may be interrupted.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 */
- (jboolean)enterIfInterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard
                                                                      withLong:(jlong)time
                                                withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Enters this monitor.Blocks indefinitely, but may be interrupted.
 @throw InterruptedExceptionif interrupted while waiting
 */
- (void)enterInterruptibly;

/*!
 @brief Enters this monitor.Blocks at most the given time, and may be interrupted.
 @return whether the monitor was entered
 @throw InterruptedExceptionif interrupted while waiting
 */
- (jboolean)enterInterruptiblyWithLong:(jlong)time
        withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Enters this monitor when the guard is satisfied.Blocks indefinitely, but may be interrupted.
 @throw InterruptedExceptionif interrupted while waiting
 */
- (void)enterWhenWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Enters this monitor when the guard is satisfied.Blocks at most the given time, including both
  the time to acquire the lock and the time to wait for the guard to be satisfied, and may be
  interrupted.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 @throw InterruptedExceptionif interrupted while waiting
 */
- (jboolean)enterWhenWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard
                                                           withLong:(jlong)time
                                     withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Enters this monitor when the guard is satisfied.Blocks indefinitely.
 */
- (void)enterWhenUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Enters this monitor when the guard is satisfied.Blocks at most the given time, including both
  the time to acquire the lock and the time to wait for the guard to be satisfied.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 */
- (jboolean)enterWhenUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard
                                                                          withLong:(jlong)time
                                                    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Returns the number of times the current thread has entered this monitor in excess of the number
  of times it has left.Returns 0 if the current thread is not occupying this monitor.
 */
- (jint)getOccupiedDepth;

/*!
 @brief Returns an estimate of the number of threads waiting to enter this monitor.The value is only
  an estimate because the number of threads may change dynamically while this method traverses
  internal data structures.
 This method is designed for use in monitoring of the system state,
  not for synchronization control.
 */
- (jint)getQueueLength;

/*!
 @brief Returns an estimate of the number of threads waiting for the given guard to become satisfied.
 Note that because timeouts and interrupts may occur at any time, the estimate serves only as an
  upper bound on the actual number of waiters. This method is designed for use in monitoring of
  the system state, not for synchronization control.
 */
- (jint)getWaitQueueLengthWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Queries whether the given thread is waiting to enter this monitor.Note that because
  cancellations may occur at any time, a <code>true</code> return does not guarantee that this thread
  will ever enter this monitor.
 This method is designed primarily for use in monitoring of the
  system state.
 */
- (jboolean)hasQueuedThreadWithJavaLangThread:(JavaLangThread * __nonnull)thread;

/*!
 @brief Returns whether any threads are waiting to enter this monitor.Note that because cancellations
  may occur at any time, a <code>true</code> return does not guarantee that any other thread will ever
  enter this monitor.
 This method is designed primarily for use in monitoring of the system
  state.
 */
- (jboolean)hasQueuedThreads;

/*!
 @brief Queries whether any threads are waiting for the given guard to become satisfied.Note that
  because timeouts and interrupts may occur at any time, a <code>true</code> return does not guarantee
  that the guard becoming satisfied in the future will awaken any threads.
 This method is
  designed primarily for use in monitoring of the system state.
 */
- (jboolean)hasWaitersWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Returns whether this monitor is using a fair ordering policy.
 */
- (jboolean)isFair;

/*!
 @brief Returns whether this monitor is occupied by any thread.This method is designed for use in
  monitoring of the system state, not for synchronization control.
 */
- (jboolean)isOccupied;

/*!
 @brief Returns whether the current thread is occupying this monitor (has entered more times than it
  has left).
 */
- (jboolean)isOccupiedByCurrentThread;

/*!
 @brief Leaves this monitor.May be called only by a thread currently occupying this monitor.
 */
- (void)leave;

/*!
 @brief Creates a new <code>Guard</code> for <code>this</code> monitor.
 @@Param isSatisfied The guards boolean
  condition. See <code>Guard.isSatisfied</code>.
 */
- (ComGoogleCommonUtilConcurrentMonitor_Guard *)newGuardWithJavaUtilFunctionBooleanSupplier:(id<JavaUtilFunctionBooleanSupplier> __nonnull)isSatisfied OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Enters this monitor if it is possible to do so immediately.Does not block.
 <p><b>Note:</b> This method disregards the fairness setting of this monitor.
 @return whether the monitor was entered
 */
- (jboolean)tryEnter;

/*!
 @brief Enters this monitor if it is possible to do so immediately and the guard is satisfied.Does not
  block acquiring the lock and does not wait for the guard to be satisfied.
 <p><b>Note:</b> This method disregards the fairness setting of this monitor.
 @return whether the monitor was entered, which guarantees that the guard is now satisfied
 */
- (jboolean)tryEnterIfWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Waits for the guard to be satisfied.Waits indefinitely, but may be interrupted.
 May be called
  only by a thread currently occupying this monitor.
 @throw InterruptedExceptionif interrupted while waiting
 */
- (void)waitForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Waits for the guard to be satisfied.Waits at most the given time, and may be interrupted.
 May
  be called only by a thread currently occupying this monitor.
 @return whether the guard is now satisfied
 @throw InterruptedExceptionif interrupted while waiting
 */
- (jboolean)waitForWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard
                                                         withLong:(jlong)time
                                   withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

/*!
 @brief Waits for the guard to be satisfied.Waits indefinitely.
 May be called only by a thread
  currently occupying this monitor.
 */
- (void)waitForUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard;

/*!
 @brief Waits for the guard to be satisfied.Waits at most the given time.
 May be called only by a
  thread currently occupying this monitor.
 @return whether the guard is now satisfied
 */
- (jboolean)waitForUninterruptiblyWithComGoogleCommonUtilConcurrentMonitor_Guard:(ComGoogleCommonUtilConcurrentMonitor_Guard * __nonnull)guard
                                                                        withLong:(jlong)time
                                                  withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)unit;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentMonitor)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentMonitor_init(ComGoogleCommonUtilConcurrentMonitor *self);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentMonitor *new_ComGoogleCommonUtilConcurrentMonitor_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentMonitor *create_ComGoogleCommonUtilConcurrentMonitor_init(void);

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(ComGoogleCommonUtilConcurrentMonitor *self, jboolean fair);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentMonitor *new_ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(jboolean fair) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentMonitor *create_ComGoogleCommonUtilConcurrentMonitor_initWithBoolean_(jboolean fair);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentMonitor)

#endif

#if !defined (ComGoogleCommonUtilConcurrentMonitor_Guard_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentMonitor || defined(INCLUDE_ComGoogleCommonUtilConcurrentMonitor_Guard))
#define ComGoogleCommonUtilConcurrentMonitor_Guard_

@class ComGoogleCommonUtilConcurrentMonitor;
@protocol JavaUtilConcurrentLocksCondition;

/*!
 @brief A boolean condition for which a thread may wait.A <code>Guard</code> is associated with a single 
 <code>Monitor</code>.
 The monitor may check the guard at arbitrary times from any thread occupying
  the monitor, so code should not be written to rely on how often a guard might or might not be
  checked. 
 <p>If a <code>Guard</code> is passed into any method of a <code>Monitor</code> other than the one it is
  associated with, an <code>IllegalMonitorStateException</code> is thrown.
 @since 10.0
 */
@interface ComGoogleCommonUtilConcurrentMonitor_Guard : NSObject {
 @public
  __unsafe_unretained ComGoogleCommonUtilConcurrentMonitor *monitor_;
  id<JavaUtilConcurrentLocksCondition> condition_;
  jint waiterCount_;
  /*!
   @brief The next active guard
   */
  ComGoogleCommonUtilConcurrentMonitor_Guard *next_;
}

#pragma mark Public

/*!
 @brief Evaluates this guard's boolean condition.This method is always called with the associated
  monitor already occupied.
 Implementations of this method must depend only on state protected
  by the associated monitor, and must not modify that state.
 */
- (jboolean)isSatisfied;

#pragma mark Protected

- (instancetype __nonnull)initWithComGoogleCommonUtilConcurrentMonitor:(ComGoogleCommonUtilConcurrentMonitor * __nonnull)monitor;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentMonitor_Guard)

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentMonitor_Guard, condition_, id<JavaUtilConcurrentLocksCondition>)
J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentMonitor_Guard, next_, ComGoogleCommonUtilConcurrentMonitor_Guard *)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentMonitor_Guard_initWithComGoogleCommonUtilConcurrentMonitor_(ComGoogleCommonUtilConcurrentMonitor_Guard *self, ComGoogleCommonUtilConcurrentMonitor *monitor);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentMonitor_Guard)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentMonitor")
