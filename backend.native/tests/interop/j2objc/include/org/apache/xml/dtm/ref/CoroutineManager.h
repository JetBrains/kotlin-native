//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/xalan/third_party/android/platform/external/apache-xml/src/main/java/org/apache/xml/dtm/ref/CoroutineManager.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheXmlDtmRefCoroutineManager")
#ifdef RESTRICT_OrgApacheXmlDtmRefCoroutineManager
#define INCLUDE_ALL_OrgApacheXmlDtmRefCoroutineManager 0
#else
#define INCLUDE_ALL_OrgApacheXmlDtmRefCoroutineManager 1
#endif
#undef RESTRICT_OrgApacheXmlDtmRefCoroutineManager

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheXmlDtmRefCoroutineManager_) && (INCLUDE_ALL_OrgApacheXmlDtmRefCoroutineManager || defined(INCLUDE_OrgApacheXmlDtmRefCoroutineManager))
#define OrgApacheXmlDtmRefCoroutineManager_

@class JavaUtilBitSet;

/*!
 @brief <p>Support the coroutine design pattern.
 </p>
   
 <p>A coroutine set is a very simple cooperative non-preemptive
  multitasking model, where the switch from one task to another is
  performed via an explicit request. Coroutines interact according to
  the following rules:</p>
  
 <ul>
  <li>One coroutine in the set has control, which it retains until it
  either exits or resumes another coroutine.</li>
  <li>A coroutine is activated when it is resumed by some other coroutine
  for the first time.</li>
  <li>An active coroutine that gives up control by resuming another in
  the set retains its context -- including call stack and local variables
  -- so that if/when it is resumed, it will proceed from the point at which
  it last gave up control.</li>
  </ul>
  
 <p>Coroutines can be thought of as falling somewhere between pipes and
  subroutines. Like call/return, there is an explicit flow of control
  from one coroutine to another. Like pipes, neither coroutine is
  actually "in charge", and neither must exit in order to transfer
  control to the other. </p>
   
 <p>One classic application of coroutines is in compilers, where both
  the parser and the lexer are maintaining complex state
  information. The parser resumes the lexer to process incoming
  characters into lexical tokens, and the lexer resumes the parser
  when it has reached a point at which it has a reliably interpreted
  set of tokens available for semantic processing. Structuring this
  as call-and-return would require saving and restoring a
  considerable amount of state each time. Structuring it as two tasks
  connected by a queue may involve higher overhead (in systems which
  can optimize the coroutine metaphor), isn't necessarily as clear in
  intent, may have trouble handling cases where data flows in both
  directions, and may not handle some of the more complex cases where
  more than two coroutines are involved.</p>
   
 <p>Most coroutine systems also provide a way to pass data between the
  source and target of a resume operation; this is sometimes referred
  to as "yielding" a value.  Others rely on the fact that, since only
  one member of a coroutine set is running at a time and does not
  lose control until it chooses to do so, data structures may be
  directly shared between them with only minimal precautions.</p>
   
 <p>"Note: This should not be taken to mean that producer/consumer
  problems should be always be done with coroutines." Queueing is
  often a better solution when only two threads of execution are
  involved and full two-way handshaking is not required. It's a bit
  difficult to find short pedagogical examples that require
  coroutines for a clear solution.</p>
   
 <p>The fact that only one of a group of coroutines is running at a
  time, and the control transfer between them is explicit, simplifies
  their possible interactions, and in some implementations permits
  them to be implemented more efficiently than general multitasking.
  In some situations, coroutines can be compiled out entirely;
  in others, they may only require a few instructions more than a
  simple function call.</p>
  
 <p>This version is built on top of standard Java threading, since
  that's all we have available right now. It's been encapsulated for
  code clarity and possible future optimization.</p>
   
 <p>(Two possible approaches: wait-notify based and queue-based. Some
  folks think that a one-item queue is a cleaner solution because it's
  more abstract -- but since coroutine _is_ an abstraction I'm not really
  worried about that; folks should be able to switch this code without
  concern.)</p>
   
 <p>%TBD% THIS SHOULD BE AN INTERFACE, to facilitate building other
  implementations... perhaps including a true coroutine system
  someday, rather than controlled threading. Arguably Coroutine
  itself should be an interface much like Runnable, but I think that
  can be built on top of this.</p>
 */
@interface OrgApacheXmlDtmRefCoroutineManager : NSObject {
 @public
  /*!
   @brief "Is this coroutine ID number already in use" lookup table.
   Currently implemented as a bitset as a compromise between
  compactness and speed of access, but obviously other solutions
  could be applied.
   */
  JavaUtilBitSet *m_activeIDs_;
  /*!
   @brief Internal field used to hold the data being explicitly passed
  from one coroutine to another during a co_resume() operation.
   (Of course implicit data sharing may also occur; one of the reasons
  for using coroutines is that you're guaranteed that none of the
  other coroutines in your set are using shared structures at the time
  you access them.)
  %REVIEW% It's been proposed that we be able to pass types of data
  other than Object -- more specific object types, or
  lighter-weight primitives.  This would seem to create a potential
  explosion of "pass x recieve y back" methods (or require
  fracturing resume into two calls, resume-other and
  wait-to-be-resumed), and the weight issue could be managed by
  reusing a mutable buffer object to contain the primitive
  (remember that only one coroutine runs at a time, so once the
  buffer's set it won't be walked on). Typechecking objects is
  interesting from a code-robustness point of view, but it's
  unclear whether it makes sense to encapsulate that in the
  coroutine code or let the callers do it, since it depends on RTTI
  either way. Restricting the parameters to objects implementing a
  specific CoroutineParameter interface does _not_ seem to be a net
  win; applications can do so if they want via front-end code, but
  there seem to be too many use cases involving passing an existing
  object type that you may not have the freedom to alter and may
  not want to spend time wrapping another object around.
   */
  id m_yield_;
  /*!
   @brief Internal field used to confirm that the coroutine now waking up is
  in fact the one we intended to resume.Some such selection mechanism
  is needed when more that two coroutines are operating within the same
  group.
   */
  jint m_nextCoroutine_;
}
@property (readonly, class) jint m_unreasonableId NS_SWIFT_NAME(m_unreasonableId);
@property (readonly, class) jint NOBODY NS_SWIFT_NAME(NOBODY);
@property (readonly, class) jint ANYBODY NS_SWIFT_NAME(ANYBODY);

+ (jint)m_unreasonableId;

+ (jint)NOBODY;

+ (jint)ANYBODY;

#pragma mark Public

- (instancetype __nonnull)init;

/*!
 @brief In the standard coroutine architecture, coroutines are
  identified by their method names and are launched and run up to
  their first yield by simply resuming them; its's presumed that
  this recognizes the not-already-running case and does the right
  thing.We seem to need a way to achieve that same threadsafe
  run-up...
 eg, start the coroutine with a wait.
  %TBD% whether this makes any sense...
 @param thisCoroutine the identifier of this coroutine, so we can  recognize when we are being resumed.
 @throw java.lang.NoSuchMethodExceptionif thisCoroutine isn't
  a registered member of this group. %REVIEW% whether this is the
  best choice.
 */
- (id)co_entry_pauseWithInt:(jint)thisCoroutine;

/*!
 @brief Terminate this entire set of coroutines.The others will be
  deregistered and have exceptions thrown at them.
 Note that this
  is intended as a panic-shutdown operation; under normal
  circumstances a coroutine should always end with co_exit_to() in
  order to politely inform at least one of its partners that it is
  going away.
  %TBD% This may need significantly more work. 
  %TBD% Should this just be co_exit_to(,,CoroutineManager.PANIC)?
 @param thisCoroutine Integer identifier for the coroutine requesting exit.
 */
- (void)co_exitWithInt:(jint)thisCoroutine;

/*!
 @brief Make the ID available for reuse and terminate this coroutine,
  transferring control to the specified coroutine.Note that this
  returns immediately rather than waiting for any further coroutine
  traffic, so the thread can proceed with other shutdown activities.
 @param arg_object A value to be passed to the other coroutine.
 @param thisCoroutine Integer identifier for the coroutine leaving the set.
 @param toCoroutine Integer identifier for the coroutine we wish to  invoke.
 @throw java.lang.NoSuchMethodExceptionif toCoroutine isn't a
  registered member of this group. %REVIEW% whether this is the best choice.
 */
- (void)co_exit_toWithId:(id)arg_object
                 withInt:(jint)thisCoroutine
                 withInt:(jint)toCoroutine;

/*!
 @brief <p>Each coroutine in the set managed by a single
  CoroutineManager is identified by a small positive integer.
 This
  brings up the question of how to manage those integers to avoid
  reuse... since if two coroutines use the same ID number, resuming
  that ID could resume either. I can see arguments for either
  allowing applications to select their own numbers (they may want
  to declare mnemonics via manefest constants) or generating
  numbers on demand.  This routine's intended to support both
  approaches.</p>
  
 <p>%REVIEW% We could use an object as the identifier. Not sure
  it's a net gain, though it would allow the thread to be its own
  ID. Ponder.</p>
 @param coroutineID If  > =0, requests that we reserve this number.
   If  < 0, requests that we find, reserve, and return an available ID  number.
 @return If >=0, the ID number to be used by this coroutine. If <0,
  an error occurred -- the ID requested was already in use, or we
  couldn't assign one without going over the "unreasonable value" mark
 */
- (jint)co_joinCoroutineSetWithInt:(jint)coroutineID;

/*!
 @brief Transfer control to another coroutine which has already been started and
  is waiting on this CoroutineManager.We won't return from this call
  until that routine has relinquished control.
 %TBD% What should we do if toCoroutine isn't registered? Exception?
 @param arg_object A value to be passed to the other coroutine.
 @param thisCoroutine Integer identifier for this coroutine. This is the  ID we watch for to see if we're the ones being resumed.
 @param toCoroutine Integer identifier for the coroutine we wish to  invoke.
 @throw java.lang.NoSuchMethodExceptionif toCoroutine isn't a
  registered member of this group. %REVIEW% whether this is the best choice.
 */
- (id)co_resumeWithId:(id)arg_object
              withInt:(jint)thisCoroutine
              withInt:(jint)toCoroutine;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheXmlDtmRefCoroutineManager)

J2OBJC_FIELD_SETTER(OrgApacheXmlDtmRefCoroutineManager, m_activeIDs_, JavaUtilBitSet *)
J2OBJC_FIELD_SETTER(OrgApacheXmlDtmRefCoroutineManager, m_yield_, id)

/*!
 @brief Limit on the coroutine ID numbers accepted.I didn't want the
  in-use table to grow without bound.
 If we switch to a more efficient
  sparse-array mechanism, it may be possible to raise or eliminate
  this boundary.
 */
inline jint OrgApacheXmlDtmRefCoroutineManager_get_m_unreasonableId(void);
#define OrgApacheXmlDtmRefCoroutineManager_m_unreasonableId 1024
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXmlDtmRefCoroutineManager, m_unreasonableId, jint)

inline jint OrgApacheXmlDtmRefCoroutineManager_get_NOBODY(void);
#define OrgApacheXmlDtmRefCoroutineManager_NOBODY -1
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXmlDtmRefCoroutineManager, NOBODY, jint)

inline jint OrgApacheXmlDtmRefCoroutineManager_get_ANYBODY(void);
#define OrgApacheXmlDtmRefCoroutineManager_ANYBODY -1
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXmlDtmRefCoroutineManager, ANYBODY, jint)

FOUNDATION_EXPORT void OrgApacheXmlDtmRefCoroutineManager_init(OrgApacheXmlDtmRefCoroutineManager *self);

FOUNDATION_EXPORT OrgApacheXmlDtmRefCoroutineManager *new_OrgApacheXmlDtmRefCoroutineManager_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheXmlDtmRefCoroutineManager *create_OrgApacheXmlDtmRefCoroutineManager_init(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheXmlDtmRefCoroutineManager)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_OrgApacheXmlDtmRefCoroutineManager")
