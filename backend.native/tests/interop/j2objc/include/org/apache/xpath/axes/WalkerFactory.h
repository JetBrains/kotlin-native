//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/xalan/third_party/android/platform/external/apache-xml/src/main/java/org/apache/xpath/axes/WalkerFactory.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgApacheXpathAxesWalkerFactory")
#ifdef RESTRICT_OrgApacheXpathAxesWalkerFactory
#define INCLUDE_ALL_OrgApacheXpathAxesWalkerFactory 0
#else
#define INCLUDE_ALL_OrgApacheXpathAxesWalkerFactory 1
#endif
#undef RESTRICT_OrgApacheXpathAxesWalkerFactory

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgApacheXpathAxesWalkerFactory_) && (INCLUDE_ALL_OrgApacheXpathAxesWalkerFactory || defined(INCLUDE_OrgApacheXpathAxesWalkerFactory))
#define OrgApacheXpathAxesWalkerFactory_

@class OrgApacheXpathAxesAxesWalker;
@class OrgApacheXpathAxesMatchPatternIterator;
@class OrgApacheXpathAxesWalkingIterator;
@class OrgApacheXpathCompilerCompiler;
@class OrgApacheXpathPatternsStepPattern;
@protocol OrgApacheXmlDtmDTMIterator;

/*!
 @brief This class is both a factory for XPath location path expressions,
  which are built from the opcode map output, and an analysis engine
  for the location path expressions in order to provide optimization hints.
 */
@interface OrgApacheXpathAxesWalkerFactory : NSObject
@property (readonly, class) jboolean DEBUG_PATTERN_CREATION NS_SWIFT_NAME(DEBUG_PATTERN_CREATION);
@property (readonly, class) jboolean DEBUG_WALKER_CREATION NS_SWIFT_NAME(DEBUG_WALKER_CREATION);
@property (readonly, class) jboolean DEBUG_ITERATOR_CREATION NS_SWIFT_NAME(DEBUG_ITERATOR_CREATION);
@property (readonly, class) jint BITS_COUNT NS_SWIFT_NAME(BITS_COUNT);
@property (readonly, class) jint BITS_RESERVED NS_SWIFT_NAME(BITS_RESERVED);
@property (readonly, class) jint BIT_PREDICATE NS_SWIFT_NAME(BIT_PREDICATE);
@property (readonly, class) jint BIT_ANCESTOR NS_SWIFT_NAME(BIT_ANCESTOR);
@property (readonly, class) jint BIT_ANCESTOR_OR_SELF NS_SWIFT_NAME(BIT_ANCESTOR_OR_SELF);
@property (readonly, class) jint BIT_ATTRIBUTE NS_SWIFT_NAME(BIT_ATTRIBUTE);
@property (readonly, class) jint BIT_CHILD NS_SWIFT_NAME(BIT_CHILD);
@property (readonly, class) jint BIT_DESCENDANT NS_SWIFT_NAME(BIT_DESCENDANT);
@property (readonly, class) jint BIT_DESCENDANT_OR_SELF NS_SWIFT_NAME(BIT_DESCENDANT_OR_SELF);
@property (readonly, class) jint BIT_FOLLOWING NS_SWIFT_NAME(BIT_FOLLOWING);
@property (readonly, class) jint BIT_FOLLOWING_SIBLING NS_SWIFT_NAME(BIT_FOLLOWING_SIBLING);
@property (readonly, class) jint BIT_NAMESPACE NS_SWIFT_NAME(BIT_NAMESPACE);
@property (readonly, class) jint BIT_PARENT NS_SWIFT_NAME(BIT_PARENT);
@property (readonly, class) jint BIT_PRECEDING NS_SWIFT_NAME(BIT_PRECEDING);
@property (readonly, class) jint BIT_PRECEDING_SIBLING NS_SWIFT_NAME(BIT_PRECEDING_SIBLING);
@property (readonly, class) jint BIT_SELF NS_SWIFT_NAME(BIT_SELF);
@property (readonly, class) jint BIT_FILTER NS_SWIFT_NAME(BIT_FILTER);
@property (readonly, class) jint BIT_ROOT NS_SWIFT_NAME(BIT_ROOT);
@property (readonly, class) jint BITMASK_TRAVERSES_OUTSIDE_SUBTREE NS_SWIFT_NAME(BITMASK_TRAVERSES_OUTSIDE_SUBTREE);
@property (readonly, class) jint BIT_BACKWARDS_SELF NS_SWIFT_NAME(BIT_BACKWARDS_SELF);
@property (readonly, class) jint BIT_ANY_DESCENDANT_FROM_ROOT NS_SWIFT_NAME(BIT_ANY_DESCENDANT_FROM_ROOT);
@property (readonly, class) jint BIT_NODETEST_ANY NS_SWIFT_NAME(BIT_NODETEST_ANY);
@property (readonly, class) jint BIT_MATCH_PATTERN NS_SWIFT_NAME(BIT_MATCH_PATTERN);

+ (jboolean)DEBUG_PATTERN_CREATION;

+ (jboolean)DEBUG_WALKER_CREATION;

+ (jboolean)DEBUG_ITERATOR_CREATION;

+ (jint)BITS_COUNT;

+ (jint)BITS_RESERVED;

+ (jint)BIT_PREDICATE;

+ (jint)BIT_ANCESTOR;

+ (jint)BIT_ANCESTOR_OR_SELF;

+ (jint)BIT_ATTRIBUTE;

+ (jint)BIT_CHILD;

+ (jint)BIT_DESCENDANT;

+ (jint)BIT_DESCENDANT_OR_SELF;

+ (jint)BIT_FOLLOWING;

+ (jint)BIT_FOLLOWING_SIBLING;

+ (jint)BIT_NAMESPACE;

+ (jint)BIT_PARENT;

+ (jint)BIT_PRECEDING;

+ (jint)BIT_PRECEDING_SIBLING;

+ (jint)BIT_SELF;

+ (jint)BIT_FILTER;

+ (jint)BIT_ROOT;

+ (jint)BITMASK_TRAVERSES_OUTSIDE_SUBTREE;

+ (jint)BIT_BACKWARDS_SELF;

+ (jint)BIT_ANY_DESCENDANT_FROM_ROOT;

+ (jint)BIT_NODETEST_ANY;

+ (jint)BIT_MATCH_PATTERN;

#pragma mark Public

- (instancetype __nonnull)init;

+ (jboolean)canCrissCrossWithInt:(jint)analysis;

+ (jboolean)canSkipSubtreesWithInt:(jint)analysis;

+ (void)diagnoseIteratorWithNSString:(NSString *)name
                             withInt:(jint)analysis
  withOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler;

/*!
 @brief Get a corresponding BIT_XXX from an axis.
 @param axis One of Axis.ANCESTOR, etc.
 @return One of BIT_ANCESTOR, etc.
 */
+ (jint)getAnalysisBitFromAxesWithInt:(jint)axis;

+ (NSString *)getAnalysisStringWithInt:(jint)analysis;

/*!
 @brief Special purpose function to see if we can optimize the pattern for 
  a DescendantIterator.
 @param compiler non-null reference to compiler object that has processed                  the XPath operations into an opcode map.
 @param stepOpCodePos The opcode position for the step.
 @return 32 bits as an integer that give information about the location
  path as a whole.
 @throw javax.xml.transform.TransformerException
 */
+ (jint)getAxisFromStepWithOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                  withInt:(jint)stepOpCodePos;

+ (jint)getStepCountWithInt:(jint)analysis;

+ (jboolean)hasPredicateWithInt:(jint)analysis;

+ (jboolean)isAbsoluteWithInt:(jint)analysis;

/*!
 @brief Tell if the given axis goes downword.Bogus name, if you can think of 
  a better one, please do tell.
 This really has to do with inverting 
  attribute axis.
 @param axis One of Axis.XXX.
 @return true if the axis is not a child axis and does not go up from 
  the axis root.
 */
+ (jboolean)isDownwardAxisOfManyWithInt:(jint)axis;

/*!
 @brief Tell if the pattern can be 'walked' with the iteration steps in natural 
  document order, without duplicates.
 @param analysis The general analysis of the pattern.
 @return true if the walk can be done in natural order.
 @throw javax.xml.transform.TransformerException
 */
+ (jboolean)isNaturalDocOrderWithInt:(jint)analysis;

+ (jboolean)isOneStepWithInt:(jint)analysis;

+ (jboolean)isSetWithInt:(jint)analysis
                 withInt:(jint)bits;

+ (jboolean)isWildWithInt:(jint)analysis;

/*!
 @brief Tell if the predicates need to have proximity knowledge.
 */
+ (jboolean)mightBeProximateWithOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                       withInt:(jint)opPos
                                                       withInt:(jint)stepType;

/*!
 @brief Create a new LocPathIterator iterator.The exact type of iterator
  returned is based on an analysis of the XPath operations.
 @param compiler non-null reference to compiler object that has processed                  the XPath operations into an opcode map.
 @param opPos The position of the operation code for this itterator.
 @return non-null reference to a LocPathIterator or derivative.
 @throw javax.xml.transform.TransformerException
 */
+ (id<OrgApacheXmlDtmDTMIterator>)newDTMIteratorWithOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                                           withInt:(jint)opPos
                                                                       withBoolean:(jboolean)isTopLevel OBJC_METHOD_FAMILY_NONE;

+ (jboolean)walksAncestorsWithInt:(jint)analysis;

+ (jboolean)walksAttributesWithInt:(jint)analysis;

+ (jboolean)walksChildrenWithInt:(jint)analysis;

+ (jboolean)walksChildrenAndExtraAndSelfOnlyWithInt:(jint)analysis;

+ (jboolean)walksChildrenOnlyWithInt:(jint)analysis;

+ (jboolean)walksDescendantsWithInt:(jint)analysis;

+ (jboolean)walksDescendantsAndExtraAndSelfOnlyWithInt:(jint)analysis;

+ (jboolean)walksDownExtraOnlyWithInt:(jint)analysis;

+ (jboolean)walksDownOnlyWithInt:(jint)analysis;

+ (jboolean)walksExtraNodesWithInt:(jint)analysis;

+ (jboolean)walksExtraNodesOnlyWithInt:(jint)analysis;

+ (jboolean)walksFilteredListWithInt:(jint)analysis;

+ (jboolean)walksFollowingOnlyMaybeAbsoluteWithInt:(jint)analysis;

+ (jboolean)walksInDocOrderWithInt:(jint)analysis;

+ (jboolean)walksNamespacesWithInt:(jint)analysis;

+ (jboolean)walksSelfOnlyWithInt:(jint)analysis;

+ (jboolean)walksSidewaysWithInt:(jint)analysis;

+ (jboolean)walksSubtreeWithInt:(jint)analysis;

+ (jboolean)walksSubtreeOnlyWithInt:(jint)analysis;

+ (jboolean)walksSubtreeOnlyFromRootOrContextWithInt:(jint)analysis;

+ (jboolean)walksSubtreeOnlyMaybeAbsoluteWithInt:(jint)analysis;

+ (jboolean)walksUpWithInt:(jint)analysis;

+ (jboolean)walksUpOnlyWithInt:(jint)analysis;

#pragma mark Package-Private

/*!
 @brief Analyze a step and give information about it's predicates.Right now this
  just returns true or false if the step has a predicate.
 @param compiler non-null reference to compiler object that has processed                  the XPath operations into an opcode map.
 @param opPos The opcode position for the step.
 @param stepType The type of step, one of OP_GROUP, etc.
 @return true if step has a predicate.
 @throw javax.xml.transform.TransformerException
 */
+ (jboolean)analyzePredicateWithOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                       withInt:(jint)opPos
                                                       withInt:(jint)stepType;

+ (jboolean)functionProximateOrContainsProximateWithOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                                           withInt:(jint)opPos;

+ (jboolean)isProximateInnerExprWithOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                           withInt:(jint)opPos;

/*!
 @brief This method is for building an array of possible levels
  where the target element(s) could be found for a match.
 @param lpi The owning location path iterator.
 @param compiler non-null reference to compiler object that has processed                  the XPath operations into an opcode map.
 @param stepOpCodePos The opcode position for the step.
 @return non-null AxesWalker derivative.
 @throw javax.xml.transform.TransformerException
 */
+ (OrgApacheXpathAxesAxesWalker *)loadOneWalkerWithOrgApacheXpathAxesWalkingIterator:(OrgApacheXpathAxesWalkingIterator *)lpi
                                                  withOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                                             withInt:(jint)stepOpCodePos;

/*!
 @brief Read a <a href="http://www.w3.org/TR/xpath#location-paths">LocationPath</a>
  as a generalized match pattern.What this means is that the LocationPath
  is read backwards, as a test on a given node, to see if it matches the
  criteria of the selection, and ends up at the context node.
 Essentially,
  this is a backwards query from a given node, to find the context node. 
 <p>So, the selection "foo/daz[2]" is, in non-abreviated expanded syntax,
  "self::node()/following-sibling::foo/child::daz[position()=2]".
  Taking this as a match pattern for a probable node, it works out to
  "self::daz/parent::foo[child::daz[position()=2 and isPrevStepNode()]
  precedingSibling::node()[isContextNodeOfLocationPath()]", adding magic
  isPrevStepNode and isContextNodeOfLocationPath operations.  Predicates in
  the location path have to be executed by the following step,
  because they have to know the context of their execution.
 @param mpi The MatchPatternIterator to which the steps will be attached.
 @param compiler The compiler that holds the syntax tree/op map to  construct from.
 @param stepOpCodePos The current op code position within the opmap.
 @param stepIndex The top-level step index withing the iterator.
 @return A StepPattern object, which may contain relative StepPatterns.
 @throw javax.xml.transform.TransformerException
 */
+ (OrgApacheXpathPatternsStepPattern *)loadStepsWithOrgApacheXpathAxesMatchPatternIterator:(OrgApacheXpathAxesMatchPatternIterator *)mpi
                                                        withOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                                                   withInt:(jint)stepOpCodePos
                                                                                   withInt:(jint)stepIndex;

/*!
 @brief This method is for building an array of possible levels
  where the target element(s) could be found for a match.
 @param lpi The owning location path iterator object.
 @param compiler non-null reference to compiler object that has processed                  the XPath operations into an opcode map.
 @param stepOpCodePos The opcode position for the step.
 @param stepIndex The top-level step index withing the iterator.
 @return non-null AxesWalker derivative.
 @throw javax.xml.transform.TransformerException
 */
+ (OrgApacheXpathAxesAxesWalker *)loadWalkersWithOrgApacheXpathAxesWalkingIterator:(OrgApacheXpathAxesWalkingIterator *)lpi
                                                withOrgApacheXpathCompilerCompiler:(OrgApacheXpathCompilerCompiler *)compiler
                                                                           withInt:(jint)stepOpCodePos
                                                                           withInt:(jint)stepIndex;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheXpathAxesWalkerFactory)

/*!
 @brief Set to true for diagnostics about walker creation
 */
inline jboolean OrgApacheXpathAxesWalkerFactory_get_DEBUG_PATTERN_CREATION(void);
#define OrgApacheXpathAxesWalkerFactory_DEBUG_PATTERN_CREATION false
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, DEBUG_PATTERN_CREATION, jboolean)

/*!
 @brief Set to true for diagnostics about walker creation
 */
inline jboolean OrgApacheXpathAxesWalkerFactory_get_DEBUG_WALKER_CREATION(void);
#define OrgApacheXpathAxesWalkerFactory_DEBUG_WALKER_CREATION false
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, DEBUG_WALKER_CREATION, jboolean)

/*!
 @brief Set to true for diagnostics about iterator creation
 */
inline jboolean OrgApacheXpathAxesWalkerFactory_get_DEBUG_ITERATOR_CREATION(void);
#define OrgApacheXpathAxesWalkerFactory_DEBUG_ITERATOR_CREATION false
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, DEBUG_ITERATOR_CREATION, jboolean)

/*!
 @brief First 8 bits are the number of top-level location steps.Hopefully
   there will never be more that 255 location steps!!!
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BITS_COUNT(void);
#define OrgApacheXpathAxesWalkerFactory_BITS_COUNT 255
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BITS_COUNT, jint)

/*!
 @brief 4 bits are reserved for future use.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BITS_RESERVED(void);
#define OrgApacheXpathAxesWalkerFactory_BITS_RESERVED 3840
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BITS_RESERVED, jint)

/*!
 @brief Bit is on if the expression contains a top-level predicate.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_PREDICATE(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_PREDICATE 4096
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_PREDICATE, jint)

/*!
 @brief Bit is on if any of the walkers contain an ancestor step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_ANCESTOR(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_ANCESTOR 8192
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_ANCESTOR, jint)

/*!
 @brief Bit is on if any of the walkers contain an ancestor-or-self step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_ANCESTOR_OR_SELF(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_ANCESTOR_OR_SELF 16384
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_ANCESTOR_OR_SELF, jint)

/*!
 @brief Bit is on if any of the walkers contain an attribute step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_ATTRIBUTE(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_ATTRIBUTE 32768
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_ATTRIBUTE, jint)

/*!
 @brief Bit is on if any of the walkers contain a child step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_CHILD(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_CHILD 65536
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_CHILD, jint)

/*!
 @brief Bit is on if any of the walkers contain a descendant step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_DESCENDANT(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_DESCENDANT 131072
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_DESCENDANT, jint)

/*!
 @brief Bit is on if any of the walkers contain a descendant-or-self step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_DESCENDANT_OR_SELF(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_DESCENDANT_OR_SELF 262144
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_DESCENDANT_OR_SELF, jint)

/*!
 @brief Bit is on if any of the walkers contain a following step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_FOLLOWING(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_FOLLOWING 524288
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_FOLLOWING, jint)

/*!
 @brief Bit is on if any of the walkers contain a following-sibiling step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_FOLLOWING_SIBLING(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_FOLLOWING_SIBLING 1048576
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_FOLLOWING_SIBLING, jint)

/*!
 @brief Bit is on if any of the walkers contain a namespace step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_NAMESPACE(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_NAMESPACE 2097152
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_NAMESPACE, jint)

/*!
 @brief Bit is on if any of the walkers contain a parent step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_PARENT(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_PARENT 4194304
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_PARENT, jint)

/*!
 @brief Bit is on if any of the walkers contain a preceding step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_PRECEDING(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_PRECEDING 8388608
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_PRECEDING, jint)

/*!
 @brief Bit is on if any of the walkers contain a preceding-sibling step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_PRECEDING_SIBLING(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_PRECEDING_SIBLING 16777216
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_PRECEDING_SIBLING, jint)

/*!
 @brief Bit is on if any of the walkers contain a self step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_SELF(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_SELF 33554432
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_SELF, jint)

/*!
 @brief Bit is on if any of the walkers contain a filter (i.e.id(), extension
   function, etc.) step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_FILTER(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_FILTER 67108864
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_FILTER, jint)

/*!
 @brief Bit is on if any of the walkers contain a root step.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_ROOT(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_ROOT 134217728
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_ROOT, jint)

/*!
 @brief If any of these bits are on, the expression may likely traverse outside
   the given subtree.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BITMASK_TRAVERSES_OUTSIDE_SUBTREE(void);
#define OrgApacheXpathAxesWalkerFactory_BITMASK_TRAVERSES_OUTSIDE_SUBTREE 234381312
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BITMASK_TRAVERSES_OUTSIDE_SUBTREE, jint)

/*!
 @brief Bit is on if any of the walkers can go backwards in document
   order from the context node.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_BACKWARDS_SELF(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_BACKWARDS_SELF 268435456
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_BACKWARDS_SELF, jint)

/*!
 @brief Found "//foo" pattern
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_ANY_DESCENDANT_FROM_ROOT(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_ANY_DESCENDANT_FROM_ROOT 536870912
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_ANY_DESCENDANT_FROM_ROOT, jint)

/*!
 @brief Bit is on if any of the walkers contain an node() test.This is
   really only useful if the count is 1.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_NODETEST_ANY(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_NODETEST_ANY 1073741824
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_NODETEST_ANY, jint)

/*!
 @brief Bit is on if the expression is a match pattern.
 */
inline jint OrgApacheXpathAxesWalkerFactory_get_BIT_MATCH_PATTERN(void);
#define OrgApacheXpathAxesWalkerFactory_BIT_MATCH_PATTERN ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(OrgApacheXpathAxesWalkerFactory, BIT_MATCH_PATTERN, jint)

FOUNDATION_EXPORT void OrgApacheXpathAxesWalkerFactory_init(OrgApacheXpathAxesWalkerFactory *self);

FOUNDATION_EXPORT OrgApacheXpathAxesWalkerFactory *new_OrgApacheXpathAxesWalkerFactory_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgApacheXpathAxesWalkerFactory *create_OrgApacheXpathAxesWalkerFactory_init(void);

FOUNDATION_EXPORT OrgApacheXpathAxesAxesWalker *OrgApacheXpathAxesWalkerFactory_loadOneWalkerWithOrgApacheXpathAxesWalkingIterator_withOrgApacheXpathCompilerCompiler_withInt_(OrgApacheXpathAxesWalkingIterator *lpi, OrgApacheXpathCompilerCompiler *compiler, jint stepOpCodePos);

FOUNDATION_EXPORT OrgApacheXpathAxesAxesWalker *OrgApacheXpathAxesWalkerFactory_loadWalkersWithOrgApacheXpathAxesWalkingIterator_withOrgApacheXpathCompilerCompiler_withInt_withInt_(OrgApacheXpathAxesWalkingIterator *lpi, OrgApacheXpathCompilerCompiler *compiler, jint stepOpCodePos, jint stepIndex);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isSetWithInt_withInt_(jint analysis, jint bits);

FOUNDATION_EXPORT void OrgApacheXpathAxesWalkerFactory_diagnoseIteratorWithNSString_withInt_withOrgApacheXpathCompilerCompiler_(NSString *name, jint analysis, OrgApacheXpathCompilerCompiler *compiler);

FOUNDATION_EXPORT id<OrgApacheXmlDtmDTMIterator> OrgApacheXpathAxesWalkerFactory_newDTMIteratorWithOrgApacheXpathCompilerCompiler_withInt_withBoolean_(OrgApacheXpathCompilerCompiler *compiler, jint opPos, jboolean isTopLevel);

FOUNDATION_EXPORT jint OrgApacheXpathAxesWalkerFactory_getAxisFromStepWithOrgApacheXpathCompilerCompiler_withInt_(OrgApacheXpathCompilerCompiler *compiler, jint stepOpCodePos);

FOUNDATION_EXPORT jint OrgApacheXpathAxesWalkerFactory_getAnalysisBitFromAxesWithInt_(jint axis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_functionProximateOrContainsProximateWithOrgApacheXpathCompilerCompiler_withInt_(OrgApacheXpathCompilerCompiler *compiler, jint opPos);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isProximateInnerExprWithOrgApacheXpathCompilerCompiler_withInt_(OrgApacheXpathCompilerCompiler *compiler, jint opPos);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_mightBeProximateWithOrgApacheXpathCompilerCompiler_withInt_withInt_(OrgApacheXpathCompilerCompiler *compiler, jint opPos, jint stepType);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isDownwardAxisOfManyWithInt_(jint axis);

FOUNDATION_EXPORT OrgApacheXpathPatternsStepPattern *OrgApacheXpathAxesWalkerFactory_loadStepsWithOrgApacheXpathAxesMatchPatternIterator_withOrgApacheXpathCompilerCompiler_withInt_withInt_(OrgApacheXpathAxesMatchPatternIterator *mpi, OrgApacheXpathCompilerCompiler *compiler, jint stepOpCodePos, jint stepIndex);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_analyzePredicateWithOrgApacheXpathCompilerCompiler_withInt_withInt_(OrgApacheXpathCompilerCompiler *compiler, jint opPos, jint stepType);

FOUNDATION_EXPORT NSString *OrgApacheXpathAxesWalkerFactory_getAnalysisStringWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_hasPredicateWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isWildWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksAncestorsWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksAttributesWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksNamespacesWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksChildrenWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksDescendantsWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksSubtreeWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksSubtreeOnlyMaybeAbsoluteWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksSubtreeOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksFilteredListWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksSubtreeOnlyFromRootOrContextWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksInDocOrderWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksFollowingOnlyMaybeAbsoluteWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksUpWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksSidewaysWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksExtraNodesWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksExtraNodesOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isAbsoluteWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksChildrenOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksChildrenAndExtraAndSelfOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksDescendantsAndExtraAndSelfOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksSelfOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksUpOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksDownOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_walksDownExtraOnlyWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_canSkipSubtreesWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_canCrissCrossWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isNaturalDocOrderWithInt_(jint analysis);

FOUNDATION_EXPORT jboolean OrgApacheXpathAxesWalkerFactory_isOneStepWithInt_(jint analysis);

FOUNDATION_EXPORT jint OrgApacheXpathAxesWalkerFactory_getStepCountWithInt_(jint analysis);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheXpathAxesWalkerFactory)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_OrgApacheXpathAxesWalkerFactory")
