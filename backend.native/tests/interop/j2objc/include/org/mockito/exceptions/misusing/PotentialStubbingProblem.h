//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/testing/mockito/build_result/java/org/mockito/exceptions/misusing/PotentialStubbingProblem.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgMockitoExceptionsMisusingPotentialStubbingProblem")
#ifdef RESTRICT_OrgMockitoExceptionsMisusingPotentialStubbingProblem
#define INCLUDE_ALL_OrgMockitoExceptionsMisusingPotentialStubbingProblem 0
#else
#define INCLUDE_ALL_OrgMockitoExceptionsMisusingPotentialStubbingProblem 1
#endif
#undef RESTRICT_OrgMockitoExceptionsMisusingPotentialStubbingProblem

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgMockitoExceptionsMisusingPotentialStubbingProblem_) && (INCLUDE_ALL_OrgMockitoExceptionsMisusingPotentialStubbingProblem || defined(INCLUDE_OrgMockitoExceptionsMisusingPotentialStubbingProblem))
#define OrgMockitoExceptionsMisusingPotentialStubbingProblem_

#define RESTRICT_OrgMockitoExceptionsBaseMockitoException 1
#define INCLUDE_OrgMockitoExceptionsBaseMockitoException 1
#include "org/mockito/exceptions/base/MockitoException.h"

@class JavaLangThrowable;

/*!
 @brief <code>PotentialStubbingProblem</code> improves productivity by failing the test early when the user
  misconfigures mock's stubbing.
 <p>
  <code>PotentialStubbingProblem</code> exception is a part of "strict stubbing" Mockito API
  intended to drive cleaner tests and better productivity with Mockito mocks.
  For more information see <code>Strictness</code>.
  <p>
  <code>PotentialStubbingProblem</code> is thrown when mocked method is stubbed with some argument in test
  but then invoked with <strong>different</strong> argument in the code.
  This scenario is called "stubbing argument mismatch". 
 <p>
  Example: 
 <pre class="code"><code class="java">
  //test method:
  given(mock.getSomething(100)).willReturn(something);
  //code under test:
  Something something = mock.getSomething(50); // <-- stubbing argument mismatch 
 </code>
@endcode
  The stubbing argument mismatch typically indicates: 
 <ol>
      <li>Mistake, typo or misunderstanding in the test code, the argument(s) used when declaring stubbing are different by mistake</li>
      <li>Mistake, typo or misunderstanding in the code under test, the argument(s) used when invoking stubbed method are different by mistake</li>
      <li>Intentional use of stubbed method with different argument, either in the test (more stubbing) or in code under test</li>
  </ol>
  User mistake (use case 1 and 2) make up 95% of the stubbing argument mismatch cases. 
 <code>PotentialStubbingProblem</code> improves productivity in those scenarios
  by failing early with clean message pointing out the incorrect stubbing or incorrect invocation of stubbed method.
  In remaining 5% of the cases (use case 3) <code>PotentialStubbingProblem</code> can give false negative signal
  indicating non-existing problem. The exception message contains information how to opt-out from the feature.
  Mockito optimizes for enhanced productivity of 95% of the cases while offering opt-out for remaining 5%.
  False negative signal for edge cases is a trade-off for general improvement of productivity. 
 <p>
  What to do if you fall into use case 3 (false negative signal)? You have 2 options: 
 <ol>
   <li>Do you see this exception because you're stubbing the same method multiple times in the same test?
   In that case, please use <code>org.mockito.BDDMockito.willReturn(Object)</code> or <code>Mockito.doReturn(Object)</code>
   family of methods for stubbing.
   Convenient stubbing via <code>Mockito.when(Object)</code> has its drawbacks: the framework cannot distinguish between
   actual invocation on mock (real code) and the stubbing declaration (test code).
   Hence the need to use <code>org.mockito.BDDMockito.willReturn(Object)</code> or <code>Mockito.doReturn(Object)</code> for certain edge cases.
   It is a well known limitation of Mockito API and another example how Mockito optimizes its clean API for 95% of the cases
   while still supporting edge cases.  
 </li>
   <li>Reduce the strictness level per stubbing, per mock or per test - see <code>Mockito.lenient()</code></li>
   <li>To opt-out in Mockito 2.x, simply remove the strict stubbing setting in the test class.</li>
  </ol>
  <p>
  Mockito team is very eager to hear feedback about "strict stubbing" feature, let us know by commenting on GitHub 
 <a href="https://github.com/mockito/mockito/issues/769">issue 769</a>.
  Strict stubbing is an attempt to improve testability and productivity with Mockito. Tell us what you think!
 @since 2.3.0
 */
@interface OrgMockitoExceptionsMisusingPotentialStubbingProblem : OrgMockitoExceptionsBaseMockitoException

#pragma mark Public

- (instancetype __nonnull)initWithNSString:(NSString *)message;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithNSString:(NSString *)arg0
                     withJavaLangThrowable:(JavaLangThrowable *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgMockitoExceptionsMisusingPotentialStubbingProblem)

FOUNDATION_EXPORT void OrgMockitoExceptionsMisusingPotentialStubbingProblem_initWithNSString_(OrgMockitoExceptionsMisusingPotentialStubbingProblem *self, NSString *message);

FOUNDATION_EXPORT OrgMockitoExceptionsMisusingPotentialStubbingProblem *new_OrgMockitoExceptionsMisusingPotentialStubbingProblem_initWithNSString_(NSString *message) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgMockitoExceptionsMisusingPotentialStubbingProblem *create_OrgMockitoExceptionsMisusingPotentialStubbingProblem_initWithNSString_(NSString *message);

J2OBJC_TYPE_LITERAL_HEADER(OrgMockitoExceptionsMisusingPotentialStubbingProblem)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_OrgMockitoExceptionsMisusingPotentialStubbingProblem")
