//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/testing/mockito/build_result/java/org/mockito/MockitoSession.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgMockitoMockitoSession")
#ifdef RESTRICT_OrgMockitoMockitoSession
#define INCLUDE_ALL_OrgMockitoMockitoSession 0
#else
#define INCLUDE_ALL_OrgMockitoMockitoSession 1
#endif
#undef RESTRICT_OrgMockitoMockitoSession

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgMockitoMockitoSession_) && (INCLUDE_ALL_OrgMockitoMockitoSession || defined(INCLUDE_OrgMockitoMockitoSession))
#define OrgMockitoMockitoSession_

@class JavaLangThrowable;
@class OrgMockitoQualityStrictness;

/*!
 @brief <code>MockitoSession</code> is an optional, highly recommended feature
  that helps driving cleaner tests by eliminating boilerplate code and adding extra validation.
 If you already use <code>MockitoJUnitRunner</code> or <code>MockitoRule</code>
  *you don't need* <code>MockitoSession</code> because it is used by the runner/rule. 
 <p>
  <code>MockitoSession</code> is a session of mocking, during which the user creates and uses Mockito mocks.
  Typically the session is an execution of a single test method. 
 <code>MockitoSession</code> initializes mocks, validates usage and detects incorrect stubbing.
  When the session is started it must be concluded with <code>finishMocking()</code>
  otherwise <code>UnfinishedMockingSessionException</code> is triggered when the next session is created. 
 <p>
  <code>MockitoSession</code> is useful when you cannot use <code>MockitoJUnitRunner</code> or <code>MockitoRule</code>.
  For example, you work with TestNG instead of JUnit.
  Another example is when different JUnit runner is in use (Jukito, Springockito)
  and it cannot be combined with Mockito's own runner. 
 <p>
  Framework integrators are welcome to use <code>MockitoSession</code> and give us feedback by commenting on 
 <a href="https://github.com/mockito/mockito/issues/857">issue 857</a>.
  <p>
  Example: 
 <pre class="code"><code class="java">
  public class ExampleTest {
      &#064;Mock Foo foo;
      //Keeping session object in a field so that we can complete session in 'tear down' method.
      //It is recommended to hide the session object, along with 'setup' and 'tear down' methods in a base class / runner.
      //Keep in mind that you can use Mockito's JUnit runner or rule instead of MockitoSession and get the same behavior.
      MockitoSession mockito;     
 &#064;Before public void setup() {
          //initialize session to start mocking
          mockito = Mockito.mockitoSession()
             .initMocks(this)
             .strictness(Strictness.STRICT_STUBS)
             .startMocking();
      }     
 &#064;After public void tearDown() {
          //It is necessary to finish the session so that Mockito
          // can detect incorrect stubbing and validate Mockito usage
          //'finishMocking()' is intended to be used in your test framework's 'tear down' method.
          mockito.finishMocking();
      }
      // test methods ...
  } 
 </code>
@endcode
  
 <p>
  Why to use <code>MockitoSession</code>?
  What's the difference between <code>MockitoSession</code>, <code>MockitoJUnitRunner</code>, <code>MockitoRule</code>
  and traditional <code>MockitoAnnotations.initMocks(Object)</code>?
  <p>
  Great questions!
  There is no need to use <code>MockitoSession</code> if you already use <code>MockitoJUnitRunner</code> or <code>MockitoRule</code>.
  If you are JUnit user who does not leverage Mockito rule or runner we strongly recommend to do so.
  Both the runner and the rule support strict stubbing which can really help driving cleaner tests.
  See <code>MockitoJUnitRunner.StrictStubs</code> and <code>MockitoRule.strictness(Strictness)</code>.
  If you cannot use Mockito's JUnit support (for example, you are on TestNG) <code>MockitoSession</code> exactly is for you!
  You can automatically take advantage of strict stubbing (<code>Strictness</code>),
  automatic initialization of annotated mocks (<code>MockitoAnnotations</code>),
  and extra validation (<code>Mockito.validateMockitoUsage()</code>).
  If you use Mockito annotations with <code>MockitoAnnotations.initMocks(Object)</code>
  but not Mockito runner/rule please try out Mockito's JUnit support (runner or rule) or
  start using <code>MockitoSession</code>. You'll get cleaner tests and better productivity. 
 <p>
  Mockito team would really appreciate feedback about <code>MockitoSession</code> API.
  Help us out by commenting at <a href="https://github.com/mockito/mockito/issues/857">issue 857</a>.
 @since 2.7.0
 */
@protocol OrgMockitoMockitoSession < JavaObject >

/*!
 @brief Changes the strictness of this <code>MockitoSession</code>.
 The new strictness will be applied to operations on mocks and checks performed by <code>finishMocking()</code>.
  This method is used behind the hood by <code>MockitoRule.strictness(Strictness)</code> method.
  In most healthy tests, this method is not needed.
  We keep it for edge cases and when you really need to change strictness in given test method.
  For use cases see Javadoc for <code>PotentialStubbingProblem</code> class.
 @param strictness new strictness for this session.
 @since 2.15.0
 */
- (void)setStrictnessWithOrgMockitoQualityStrictness:(OrgMockitoQualityStrictness *)strictness;

/*!
 @brief Must be invoked when the user is done with mocking for given session (test method).
 It detects unused stubbings and may throw <code>UnnecessaryStubbingException</code>
  or emit warnings (<code>MockitoHint</code>) depending on the <code>Strictness</code> level.
  The method also detects incorrect Mockito usage via <code>Mockito.validateMockitoUsage()</code>.
  <p>
  In order to implement <code>Strictness</code> Mockito session keeps track of mocking using <code>MockitoListener</code>.
  This method cleans up the listeners and ensures there is no leftover state after the session finishes.
  It is necessary to invoke this method to conclude mocking session.
  For more information about session lifecycle see <code>MockitoSessionBuilder.startMocking()</code>.
  <p>
  This method is intended to be used in your test framework's 'tear down' method.
  In the case of JUnit it is the "&#064;After" method. 
 <p>
  For example, see javadoc for <code>MockitoSession</code>.
 - seealso: #finishMocking(Throwable)
 @since 2.7.0
 */
- (void)finishMocking;

/*!
 @brief Must be invoked when the user is done with mocking for given session (test method).
 When a failure is specified, certain checks are disabled to avoid
  confusion that may arise because there are multiple competing failures. Other than that,
  this method behaves exactly like <code>finishMocking()</code>.
  <p>
  This method is intended to be used by framework integrations. When using MockitoSession
  directly, most users should rather use <code>finishMocking()</code>.
  <code>MockitoRule</code> uses this method behind the hood.
 @param failure the exception that caused the test to fail; passing <code>null</code>  is permitted
 - seealso: #finishMocking()
 @since 2.15.0
 */
- (void)finishMockingWithJavaLangThrowable:(JavaLangThrowable *)failure;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgMockitoMockitoSession)

J2OBJC_TYPE_LITERAL_HEADER(OrgMockitoMockitoSession)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_OrgMockitoMockitoSession")
