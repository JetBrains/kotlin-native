//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/android/build_result/java/com/google/common/io/Files.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonIoFiles")
#ifdef RESTRICT_ComGoogleCommonIoFiles
#define INCLUDE_ALL_ComGoogleCommonIoFiles 0
#else
#define INCLUDE_ALL_ComGoogleCommonIoFiles 1
#endif
#undef RESTRICT_ComGoogleCommonIoFiles

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonIoFiles_) && (INCLUDE_ALL_ComGoogleCommonIoFiles || defined(INCLUDE_ComGoogleCommonIoFiles))
#define ComGoogleCommonIoFiles_

@class ComGoogleCommonCollectTreeTraverser;
@class ComGoogleCommonGraphTraverser;
@class ComGoogleCommonHashHashCode;
@class ComGoogleCommonIoByteSink;
@class ComGoogleCommonIoByteSource;
@class ComGoogleCommonIoCharSink;
@class ComGoogleCommonIoCharSource;
@class IOSByteArray;
@class IOSObjectArray;
@class JavaIoBufferedReader;
@class JavaIoBufferedWriter;
@class JavaIoFile;
@class JavaIoOutputStream;
@class JavaNioChannelsFileChannel_MapMode;
@class JavaNioCharsetCharset;
@class JavaNioMappedByteBuffer;
@protocol ComGoogleCommonBasePredicate;
@protocol ComGoogleCommonHashHashFunction;
@protocol ComGoogleCommonIoByteProcessor;
@protocol ComGoogleCommonIoLineProcessor;
@protocol JavaLangAppendable;
@protocol JavaLangCharSequence;
@protocol JavaUtilList;

/*!
 @brief Provides utility methods for working with files.
 <p><code>java.nio.file.Path</code> users will find similar utilities in <code>MoreFiles</code> and the
  JDK's <code>java.nio.file.Files</code> class.
 @author Chris Nokleberg
 @author Colin Decker
 @since 1.0
 */
@interface ComGoogleCommonIoFiles : NSObject

#pragma mark Public

/*!
 @brief Appends a character sequence (such as a string) to a file using the given character set.
 @param from the character sequence to append
 @param to the destination file
 @param charset the charset used to encode the output stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @throw IOExceptionif an I/O error occurs
 */
+ (void)appendWithJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)from
                        withJavaIoFile:(JavaIoFile * __nonnull)to
             withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset __attribute__((deprecated));

/*!
 @brief Returns a new <code>ByteSink</code> for writing bytes to the given file.The given <code>modes</code>
  control how the file is opened for writing.
 When no mode is provided, the file will be
  truncated before writing. When the <code>APPEND</code> mode is provided, writes
  will append to the end of the file without truncating it.
 @since 14.0
 */
+ (ComGoogleCommonIoByteSink *)asByteSinkWithJavaIoFile:(JavaIoFile * __nonnull)file
                withComGoogleCommonIoFileWriteModeArray:(IOSObjectArray * __nonnull)modes;

/*!
 @brief Returns a new <code>ByteSource</code> for reading bytes from the given file.
 @since 14.0
 */
+ (ComGoogleCommonIoByteSource *)asByteSourceWithJavaIoFile:(JavaIoFile * __nonnull)file;

/*!
 @brief Returns a new <code>CharSink</code> for writing character data to the given file using the given
  character set.The given <code>modes</code> control how the file is opened for writing.
 When no mode
  is provided, the file will be truncated before writing. When the <code>APPEND</code>
  mode is provided, writes will append to the end of the file without truncating it.
 @since 14.0
 */
+ (ComGoogleCommonIoCharSink *)asCharSinkWithJavaIoFile:(JavaIoFile * __nonnull)file
                              withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset
                withComGoogleCommonIoFileWriteModeArray:(IOSObjectArray * __nonnull)modes;

/*!
 @brief Returns a new <code>CharSource</code> for reading character data from the given file using the given
  character set.
 @since 14.0
 */
+ (ComGoogleCommonIoCharSource *)asCharSourceWithJavaIoFile:(JavaIoFile * __nonnull)file
                                  withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset;

/*!
 @brief Copies all characters from a file to an appendable object, using the given character set.
 @param from the source file
 @param charset the charset used to decode the input stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @param to the appendable object
 @throw IOExceptionif an I/O error occurs
 */
+ (void)copy__WithJavaIoFile:(JavaIoFile * __nonnull)from
   withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset
      withJavaLangAppendable:(id<JavaLangAppendable> __nonnull)to OBJC_METHOD_FAMILY_NONE __attribute__((deprecated));

/*!
 @brief Copies all the bytes from one file to another.
 <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process
  termination, or other problems, <code>to</code> may not be a complete copy of <code>from</code>. If you
  need to guard against those conditions, you should employ other file-level synchronization. 
 <p><b>Warning:</b> If <code>to</code> represents an existing file, that file will be overwritten
  with the contents of <code>from</code>. If <code>to</code> and <code>from</code> refer to the <i>same</i>
  file, the contents of that file will be deleted. 
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)</code>
 .
 @param from the source file
 @param to the destination file
 @throw IOExceptionif an I/O error occurs
 @throw IllegalArgumentExceptionif <code>from.equals(to)</code>
 */
+ (void)copy__WithJavaIoFile:(JavaIoFile * __nonnull)from
              withJavaIoFile:(JavaIoFile * __nonnull)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies all bytes from a file to an output stream.
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.copy(java.nio.file.Path, OutputStream)</code>
 .
 @param from the source file
 @param to the output stream
 @throw IOExceptionif an I/O error occurs
 */
+ (void)copy__WithJavaIoFile:(JavaIoFile * __nonnull)from
      withJavaIoOutputStream:(JavaIoOutputStream * __nonnull)to OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates any necessary but nonexistent parent directories of the specified file.Note that if
  this operation fails it may have succeeded in creating some (but not all) of the necessary
  parent directories.
 @throw IOExceptionif an I/O error occurs, or if any necessary but nonexistent parent
      directories of the specified file could not be created.
 @since 4.0
 */
+ (void)createParentDirsWithJavaIoFile:(JavaIoFile * __nonnull)file;

/*!
 @brief Atomically creates a new directory somewhere beneath the system's temporary directory (as
  defined by the <code>java.io.tmpdir</code> system property), and returns its name.
 <p>Use this method instead of <code>File.createTempFile(String, String)</code> when you wish to
  create a directory, not a regular file. A common pitfall is to call <code>createTempFile</code>,
  delete the file and create a directory in its place, but this leads a race condition which can
  be exploited to create security vulnerabilities, especially when executable files are to be
  written into the directory. 
 <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,
  and that it will not be called thousands of times per second. 
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.createTempDirectory</code>
 .
 @return the newly-created directory
 @throw IllegalStateExceptionif the directory could not be created
 */
+ (JavaIoFile *)createTempDir;

/*!
 @brief Returns true if the given files exist, are not directories, and contain the same bytes.
 @throw IOExceptionif an I/O error occurs
 */
+ (jboolean)equalWithJavaIoFile:(JavaIoFile * __nonnull)file1
                 withJavaIoFile:(JavaIoFile * __nonnull)file2;

/*!
 @brief Returns a <code>Traverser</code> instance for the file and directory tree.The returned traverser
  starts from a <code>File</code> and will return all files and directories it encounters.
 <p><b>Warning:</b> <code>File</code> provides no support for symbolic links, and as such there is no
  way to ensure that a symbolic link to a directory is not followed when traversing the tree. In
  this case, iterables created by this traverser could contain files that are outside of the
  given directory or even be infinite if there is a symbolic link loop. 
 <p>If available, consider using <code>MoreFiles.fileTraverser()</code> instead. It behaves the same
  except that it doesn't follow symbolic links and returns <code>Path</code> instances. 
 <p>If the <code>File</code> passed to one of the <code>Traverser</code> methods does not exist or is not
  a directory, no exception will be thrown and the returned <code>Iterable</code> will contain a
  single element: that file. 
 <p>Example: <code>Files.fileTraverser().breadthFirst("/")</code> may return files with the following
  paths: <code>["/", "/etc", "/home", "/usr", "/etc/config.txt", "/etc/fonts", ...]</code>
 @since 23.5
 */
+ (ComGoogleCommonGraphTraverser *)fileTraverser;

/*!
 @brief Returns the <a href="http://en.wikipedia.org/wiki/Filename_extension">file extension</a> for
  the given file name, or the empty string if the file has no extension.The result does not
  include the '<code>.
 </code>'.
  
 <p><b>Note:</b> This method simply returns everything after the last '<code>.</code>' in the file's
  name as determined by <code>File.getName</code>. It does not account for any filesystem-specific
  behavior that the <code>File</code> API does not already account for. For example, on NTFS it will
  report <code>"txt"</code> as the extension for the filename <code>"foo.exe:.txt"</code> even though NTFS
  will drop the <code>":.txt"</code> part of the name when the file is actually created on the
  filesystem due to NTFS's <a href="https://goo.gl/vTpJi4">Alternate Data Streams</a>.
 @since 11.0
 */
+ (NSString *)getFileExtensionWithNSString:(NSString * __nonnull)fullName;

/*!
 @brief Returns the file name without its <a href="http://en.wikipedia.org/wiki/Filename_extension">
 file extension</a> or path.This is
  similar to the <code>basename</code> unix command.
 The result does not include the '<code>.</code>'.
 @param file The name of the file to trim the extension from. This can be either a fully      qualified file name (including a path) or just a file name.
 @return The file name without its path or extension.
 @since 14.0
 */
+ (NSString *)getNameWithoutExtensionWithNSString:(NSString * __nonnull)file;

/*!
 @brief Computes the hash code of the <code>file</code> using <code>hashFunction</code>.
 @param file the file to read
 @param hashFunction the hash function to use to hash the data
 @return the <code>HashCode</code> of all of the bytes in the file
 @throw IOExceptionif an I/O error occurs
 @since 12.0
 */
+ (ComGoogleCommonHashHashCode *)hash__WithJavaIoFile:(JavaIoFile * __nonnull)file
                  withComGoogleCommonHashHashFunction:(id<ComGoogleCommonHashHashFunction> __nonnull)hashFunction __attribute__((deprecated));

/*!
 @brief Returns a predicate that returns the result of <code>File.isDirectory</code> on input files.
 @since 15.0
 */
+ (id<ComGoogleCommonBasePredicate>)isDirectory;

/*!
 @brief Returns a predicate that returns the result of <code>File.isFile</code> on input files.
 @since 15.0
 */
+ (id<ComGoogleCommonBasePredicate>)isFile;

/*!
 @brief Fully maps a file read-only in to memory as per <code>FileChannel.map(java.nio.channels.FileChannel.MapMode, long, long)</code>
 .
 <p>Files are mapped from offset 0 to its length. 
 <p>This only works for files ≤ <code>Integer.MAX_VALUE</code> bytes.
 @param file the file to map
 @return a read-only buffer reflecting <code>file</code>
 @throw FileNotFoundExceptionif the <code>file</code> does not exist
 @throw IOExceptionif an I/O error occurs
 - seealso: FileChannel#map(MapMode, long, long)
 @since 2.0
 */
+ (JavaNioMappedByteBuffer *)mapWithJavaIoFile:(JavaIoFile * __nonnull)file;

/*!
 @brief Fully maps a file in to memory as per <code>FileChannel.map(java.nio.channels.FileChannel.MapMode, long, long)</code>
  using the requested <code>MapMode</code>
 .
 <p>Files are mapped from offset 0 to its length. 
 <p>This only works for files ≤ <code>Integer.MAX_VALUE</code> bytes.
 @param file the file to map
 @param mode the mode to use when mapping <code>file</code>
 @return a buffer reflecting <code>file</code>
 @throw FileNotFoundExceptionif the <code>file</code> does not exist
 @throw IOExceptionif an I/O error occurs
 - seealso: FileChannel#map(MapMode, long, long)
 @since 2.0
 */
+ (JavaNioMappedByteBuffer *)mapWithJavaIoFile:(JavaIoFile * __nonnull)file
        withJavaNioChannelsFileChannel_MapMode:(JavaNioChannelsFileChannel_MapMode * __nonnull)mode;

/*!
 @brief Maps a file in to memory as per <code>FileChannel.map(java.nio.channels.FileChannel.MapMode,
 long, long)</code>
  using the requested <code>MapMode</code>.
 <p>Files are mapped from offset 0 to <code>size</code>.
  
 <p>If the mode is <code>MapMode.READ_WRITE</code> and the file does not exist, it will be created
  with the requested <code>size</code>. Thus this method is useful for creating memory mapped files
  which do not yet exist. 
 <p>This only works for files ≤ <code>Integer.MAX_VALUE</code> bytes.
 @param file the file to map
 @param mode the mode to use when mapping <code>file</code>
 @return a buffer reflecting <code>file</code>
 @throw IOExceptionif an I/O error occurs
 - seealso: FileChannel#map(MapMode, long, long)
 @since 2.0
 */
+ (JavaNioMappedByteBuffer *)mapWithJavaIoFile:(JavaIoFile * __nonnull)file
        withJavaNioChannelsFileChannel_MapMode:(JavaNioChannelsFileChannel_MapMode * __nonnull)mode
                                      withLong:(jlong)size;

/*!
 @brief Moves a file from one path to another.This method can rename a file and/or move it to a
  different directory.
 In either case <code>to</code> must be the target path for the file itself; not
  just the new name for the file or the path to the new parent directory. 
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.move</code>.
 @param from the source file
 @param to the destination file
 @throw IOExceptionif an I/O error occurs
 @throw IllegalArgumentExceptionif <code>from.equals(to)</code>
 */
+ (void)moveWithJavaIoFile:(JavaIoFile * __nonnull)from
            withJavaIoFile:(JavaIoFile * __nonnull)to;

/*!
 @brief Returns a buffered reader that reads from a file using the given character set.
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.newBufferedReader(java.nio.file.Path, Charset)</code>
 .
 @param file the file to read from
 @param charset the charset used to decode the input stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @return the buffered reader
 */
+ (JavaIoBufferedReader *)newReaderWithJavaIoFile:(JavaIoFile * __nonnull)file
                        withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a buffered writer that writes to a file using the given character set.
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.newBufferedWriter(java.nio.file.Path, Charset,
 java.nio.file.OpenOption...)</code>
 .
 @param file the file to write to
 @param charset the charset used to encode the output stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @return the buffered writer
 */
+ (JavaIoBufferedWriter *)newWriterWithJavaIoFile:(JavaIoFile * __nonnull)file
                        withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Process the bytes of a file.
 <p>(If this seems too complicated, maybe you're looking for <code>toByteArray</code>.)
 @param file the file to read
 @param processor the object to which the bytes of the file are passed.
 @return the result of the byte processor
 @throw IOExceptionif an I/O error occurs
 */
+ (id)readBytesWithJavaIoFile:(JavaIoFile * __nonnull)file
withComGoogleCommonIoByteProcessor:(id<ComGoogleCommonIoByteProcessor> __nonnull)processor __attribute__((deprecated));

/*!
 @brief Reads the first line from a file.The line does not include line-termination characters, but
  does include other leading and trailing whitespace.
 @param file the file to read from
 @param charset the charset used to decode the input stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @return the first line, or null if the file is empty
 @throw IOExceptionif an I/O error occurs
 */
+ (NSString *)readFirstLineWithJavaIoFile:(JavaIoFile * __nonnull)file
                withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset __attribute__((deprecated));

/*!
 @brief Reads all of the lines from a file.The lines do not include line-termination characters, but
  do include other leading and trailing whitespace.
 <p>This method returns a mutable <code>List</code>. For an <code>ImmutableList</code>, use <code>Files.asCharSource(file, charset).readLines()</code>
 .
  
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.readAllLines(java.nio.file.Path, Charset)</code>
 .
 @param file the file to read from
 @param charset the charset used to decode the input stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @return a mutable <code>List</code> containing all the lines
 @throw IOExceptionif an I/O error occurs
 */
+ (id<JavaUtilList>)readLinesWithJavaIoFile:(JavaIoFile * __nonnull)file
                  withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset;

/*!
 @brief Streams lines from a <code>File</code>, stopping when our callback returns false, or we have read
  all of the lines.
 @param file the file to read from
 @param charset the charset used to decode the input stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @param callback the <code>LineProcessor</code>  to use to handle the lines
 @return the output of processing the lines
 @throw IOExceptionif an I/O error occurs
 */
+ (id)readLinesWithJavaIoFile:(JavaIoFile * __nonnull)file
    withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset
withComGoogleCommonIoLineProcessor:(id<ComGoogleCommonIoLineProcessor> __nonnull)callback __attribute__((deprecated));

/*!
 @brief Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent
  to the original.The following heuristics are used: 
 <ul>
    <li>empty string becomes .
 <li>. stays as .
    <li>fold out ./
    <li>fold out ../ when possible
    <li>collapse multiple slashes
    <li>delete trailing slashes (unless the path is just "/") 
 </ul>
  
 <p>These heuristics do not always match the behavior of the filesystem. In particular, consider
  the path <code>a/../b</code>, which <code>simplifyPath</code> will change to <code>b</code>. If <code>a</code> is a
  symlink to <code>x</code>, <code>a/../b</code> may refer to a sibling of <code>x</code>, rather than the
  sibling of <code>a</code> referred to by <code>b</code>.
 @since 11.0
 */
+ (NSString *)simplifyPathWithNSString:(NSString * __nonnull)pathname;

/*!
 @brief Reads all bytes from a file into a byte array.
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.readAllBytes</code>.
 @param file the file to read from
 @return a byte array containing all the bytes from file
 @throw IllegalArgumentExceptionif the file is bigger than the largest possible byte array
      (2^31 - 1)
 @throw IOExceptionif an I/O error occurs
 */
+ (IOSByteArray *)toByteArrayWithJavaIoFile:(JavaIoFile * __nonnull)file;

/*!
 @brief Reads all characters from a file into a <code>String</code>, using the given character set.
 @param file the file to read from
 @param charset the charset used to decode the input stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @return a string containing all the characters from the file
 @throw IOExceptionif an I/O error occurs
 */
+ (NSString *)toStringWithJavaIoFile:(JavaIoFile * __nonnull)file
           withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset __attribute__((deprecated));

/*!
 @brief Creates an empty file or updates the last updated timestamp on the same as the unix command of
  the same name.
 @param file the file to create or update
 @throw IOExceptionif an I/O error occurs
 */
+ (void)touchWithJavaIoFile:(JavaIoFile * __nonnull)file;

/*!
 @brief Overwrites a file with the contents of a byte array.
 <p><b><code>java.nio.file.Path</code> equivalent:</b> <code>java.nio.file.Files.write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)</code>
 .
 @param from the bytes to write
 @param to the destination file
 @throw IOExceptionif an I/O error occurs
 */
+ (void)writeWithByteArray:(IOSByteArray * __nonnull)from
            withJavaIoFile:(JavaIoFile * __nonnull)to;

/*!
 @brief Writes a character sequence (such as a string) to a file using the given character set.
 @param from the character sequence to write
 @param to the destination file
 @param charset the charset used to encode the output stream; see <code>StandardCharsets</code>  for
       helpful predefined constants
 @throw IOExceptionif an I/O error occurs
 */
+ (void)writeWithJavaLangCharSequence:(id<JavaLangCharSequence> __nonnull)from
                       withJavaIoFile:(JavaIoFile * __nonnull)to
            withJavaNioCharsetCharset:(JavaNioCharsetCharset * __nonnull)charset __attribute__((deprecated));

#pragma mark Package-Private

/*!
 @brief Returns a <code>TreeTraverser</code> instance for <code>File</code> trees.
 <p><b>Warning:</b> <code>File</code> provides no support for symbolic links, and as such there is no
  way to ensure that a symbolic link to a directory is not followed when traversing the tree. In
  this case, iterables created by this traverser could contain files that are outside of the
  given directory or even be infinite if there is a symbolic link loop.
 @since 15.0
 */
+ (ComGoogleCommonCollectTreeTraverser *)fileTreeTraverser __attribute__((deprecated));

@end

J2OBJC_STATIC_INIT(ComGoogleCommonIoFiles)

FOUNDATION_EXPORT JavaIoBufferedReader *ComGoogleCommonIoFiles_newReaderWithJavaIoFile_withJavaNioCharsetCharset_(JavaIoFile *file, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT JavaIoBufferedWriter *ComGoogleCommonIoFiles_newWriterWithJavaIoFile_withJavaNioCharsetCharset_(JavaIoFile *file, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT ComGoogleCommonIoByteSource *ComGoogleCommonIoFiles_asByteSourceWithJavaIoFile_(JavaIoFile *file);

FOUNDATION_EXPORT ComGoogleCommonIoByteSink *ComGoogleCommonIoFiles_asByteSinkWithJavaIoFile_withComGoogleCommonIoFileWriteModeArray_(JavaIoFile *file, IOSObjectArray *modes);

FOUNDATION_EXPORT ComGoogleCommonIoCharSource *ComGoogleCommonIoFiles_asCharSourceWithJavaIoFile_withJavaNioCharsetCharset_(JavaIoFile *file, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT ComGoogleCommonIoCharSink *ComGoogleCommonIoFiles_asCharSinkWithJavaIoFile_withJavaNioCharsetCharset_withComGoogleCommonIoFileWriteModeArray_(JavaIoFile *file, JavaNioCharsetCharset *charset, IOSObjectArray *modes);

FOUNDATION_EXPORT IOSByteArray *ComGoogleCommonIoFiles_toByteArrayWithJavaIoFile_(JavaIoFile *file);

FOUNDATION_EXPORT NSString *ComGoogleCommonIoFiles_toStringWithJavaIoFile_withJavaNioCharsetCharset_(JavaIoFile *file, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_writeWithByteArray_withJavaIoFile_(IOSByteArray *from, JavaIoFile *to);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_writeWithJavaLangCharSequence_withJavaIoFile_withJavaNioCharsetCharset_(id<JavaLangCharSequence> from, JavaIoFile *to, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_copy__WithJavaIoFile_withJavaIoOutputStream_(JavaIoFile *from, JavaIoOutputStream *to);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_copy__WithJavaIoFile_withJavaIoFile_(JavaIoFile *from, JavaIoFile *to);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_copy__WithJavaIoFile_withJavaNioCharsetCharset_withJavaLangAppendable_(JavaIoFile *from, JavaNioCharsetCharset *charset, id<JavaLangAppendable> to);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_appendWithJavaLangCharSequence_withJavaIoFile_withJavaNioCharsetCharset_(id<JavaLangCharSequence> from, JavaIoFile *to, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT jboolean ComGoogleCommonIoFiles_equalWithJavaIoFile_withJavaIoFile_(JavaIoFile *file1, JavaIoFile *file2);

FOUNDATION_EXPORT JavaIoFile *ComGoogleCommonIoFiles_createTempDir(void);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_touchWithJavaIoFile_(JavaIoFile *file);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_createParentDirsWithJavaIoFile_(JavaIoFile *file);

FOUNDATION_EXPORT void ComGoogleCommonIoFiles_moveWithJavaIoFile_withJavaIoFile_(JavaIoFile *from, JavaIoFile *to);

FOUNDATION_EXPORT NSString *ComGoogleCommonIoFiles_readFirstLineWithJavaIoFile_withJavaNioCharsetCharset_(JavaIoFile *file, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT id<JavaUtilList> ComGoogleCommonIoFiles_readLinesWithJavaIoFile_withJavaNioCharsetCharset_(JavaIoFile *file, JavaNioCharsetCharset *charset);

FOUNDATION_EXPORT id ComGoogleCommonIoFiles_readLinesWithJavaIoFile_withJavaNioCharsetCharset_withComGoogleCommonIoLineProcessor_(JavaIoFile *file, JavaNioCharsetCharset *charset, id<ComGoogleCommonIoLineProcessor> callback);

FOUNDATION_EXPORT id ComGoogleCommonIoFiles_readBytesWithJavaIoFile_withComGoogleCommonIoByteProcessor_(JavaIoFile *file, id<ComGoogleCommonIoByteProcessor> processor);

FOUNDATION_EXPORT ComGoogleCommonHashHashCode *ComGoogleCommonIoFiles_hash__WithJavaIoFile_withComGoogleCommonHashHashFunction_(JavaIoFile *file, id<ComGoogleCommonHashHashFunction> hashFunction);

FOUNDATION_EXPORT JavaNioMappedByteBuffer *ComGoogleCommonIoFiles_mapWithJavaIoFile_(JavaIoFile *file);

FOUNDATION_EXPORT JavaNioMappedByteBuffer *ComGoogleCommonIoFiles_mapWithJavaIoFile_withJavaNioChannelsFileChannel_MapMode_(JavaIoFile *file, JavaNioChannelsFileChannel_MapMode *mode);

FOUNDATION_EXPORT JavaNioMappedByteBuffer *ComGoogleCommonIoFiles_mapWithJavaIoFile_withJavaNioChannelsFileChannel_MapMode_withLong_(JavaIoFile *file, JavaNioChannelsFileChannel_MapMode *mode, jlong size);

FOUNDATION_EXPORT NSString *ComGoogleCommonIoFiles_simplifyPathWithNSString_(NSString *pathname);

FOUNDATION_EXPORT NSString *ComGoogleCommonIoFiles_getFileExtensionWithNSString_(NSString *fullName);

FOUNDATION_EXPORT NSString *ComGoogleCommonIoFiles_getNameWithoutExtensionWithNSString_(NSString *file);

FOUNDATION_EXPORT ComGoogleCommonCollectTreeTraverser *ComGoogleCommonIoFiles_fileTreeTraverser(void);

FOUNDATION_EXPORT ComGoogleCommonGraphTraverser *ComGoogleCommonIoFiles_fileTraverser(void);

FOUNDATION_EXPORT id<ComGoogleCommonBasePredicate> ComGoogleCommonIoFiles_isDirectory(void);

FOUNDATION_EXPORT id<ComGoogleCommonBasePredicate> ComGoogleCommonIoFiles_isFile(void);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonIoFiles)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonIoFiles")
