//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/android/build_result/java/com/google/common/primitives/UnsignedInts.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonPrimitivesUnsignedInts")
#ifdef RESTRICT_ComGoogleCommonPrimitivesUnsignedInts
#define INCLUDE_ALL_ComGoogleCommonPrimitivesUnsignedInts 0
#else
#define INCLUDE_ALL_ComGoogleCommonPrimitivesUnsignedInts 1
#endif
#undef RESTRICT_ComGoogleCommonPrimitivesUnsignedInts

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonPrimitivesUnsignedInts_) && (INCLUDE_ALL_ComGoogleCommonPrimitivesUnsignedInts || defined(INCLUDE_ComGoogleCommonPrimitivesUnsignedInts))
#define ComGoogleCommonPrimitivesUnsignedInts_

@class IOSIntArray;
@protocol JavaUtilComparator;

/*!
 @brief Static utility methods pertaining to <code>int</code> primitives that interpret values as 
 <i>unsigned</i> (that is, any negative value <code>x</code> is treated as the positive value <code>2^32 + x</code>
 ).The methods for which signedness is not an issue are in <code>Ints</code>, as well as
  signed versions of methods for which signedness is an issue.
 <p>In addition, this class provides several static methods for converting an <code>int</code> to a 
 <code>String</code> and a <code>String</code> to an <code>int</code> that treat the <code>int</code> as an unsigned
  number. 
 <p>Users of these utilities must be <i>extremely careful</i> not to mix up signed and unsigned 
 <code>int</code> values. When possible, it is recommended that the <code>UnsignedInteger</code> wrapper
  class be used, at a small efficiency penalty, to enforce the distinction in the type system. 
 <p>See the Guava User Guide article on <a href="https://github.com/google/guava/wiki/PrimitivesExplained#unsigned-support">
 unsigned
  primitive utilities</a>.
 @author Louis Wasserman
 @since 11.0
 */
@interface ComGoogleCommonPrimitivesUnsignedInts : NSObject
@property (readonly, class) jlong INT_MASK NS_SWIFT_NAME(INT_MASK);

+ (jlong)INT_MASK;

#pragma mark Public

/*!
 @brief Returns the <code>int</code> value that, when treated as unsigned, is equal to <code>value</code>, if
  possible.
 @param value a value between 0 and 2 <sup> 32 </sup> -1 inclusive
 @return the <code>int</code> value that, when treated as unsigned, equals <code>value</code>
 @throw IllegalArgumentExceptionif <code>value</code> is negative or greater than or equal to
      2<sup>32</sup>
 @since 21.0
 */
+ (jint)checkedCastWithLong:(jlong)value;

/*!
 @brief Compares the two specified <code>int</code> values, treating them as unsigned values between <code>0</code>
  and <code>2^32 - 1</code> inclusive.
 <p><b>Java 8 users:</b> use <code>Integer.compareUnsigned(int, int)</code> instead.
 @param a the first unsigned <code>int</code>  to compare
 @param b the second unsigned <code>int</code>  to compare
 @return a negative value if <code>a</code> is less than <code>b</code>; a positive value if <code>a</code> is
      greater than <code>b</code>; or zero if they are equal
 */
+ (jint)compareWithInt:(jint)a
               withInt:(jint)b;

/*!
 @brief Returns the unsigned <code>int</code> value represented by the given string.
 <p>Accepts a decimal, hexadecimal, or octal number given by specifying the following prefix: 
 <ul>
    <li><code>0x</code><i>HexDigits</i>
    <li><code>0X</code><i>HexDigits</i>
    <li><code>#</code><i>HexDigits</i>
    <li><code>0</code><i>OctalDigits</i>
  </ul>
 @throw NumberFormatExceptionif the string does not contain a valid unsigned <code>int</code> value
 @since 13.0
 */
+ (jint)decodeWithNSString:(NSString * __nonnull)stringValue;

/*!
 @brief Returns dividend / divisor, where the dividend and divisor are treated as unsigned 32-bit
  quantities.
 <p><b>Java 8 users:</b> use <code>Integer.divideUnsigned(int, int)</code> instead.
 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throw ArithmeticExceptionif divisor is 0
 */
+ (jint)divideWithInt:(jint)dividend
              withInt:(jint)divisor;

/*!
 @brief Returns a string containing the supplied unsigned <code>int</code> values separated by <code>separator</code>
 .For example, <code>join("-", 1, 2, 3)</code> returns the string <code>"1-2-3"</code>.
 @param separator the text that should appear between consecutive values in the resulting string      (but not at the start or end)
 @param array an array of unsigned <code>int</code>  values, possibly empty
 */
+ (NSString *)joinWithNSString:(NSString * __nonnull)separator
                  withIntArray:(IOSIntArray * __nonnull)array;

/*!
 @brief Returns a comparator that compares two arrays of unsigned <code>int</code> values <a href="http://en.wikipedia.org/wiki/Lexicographical_order">
 lexicographically</a>.That is, it
  compares, using <code>compare(int, int)</code>), the first pair of values that follow any common
  prefix, or when one array is a prefix of the other, treats the shorter array as the lesser.
 For
  example, <code>[] < [1] < [1, 2] < [2] < [1 << 31]</code>.
  
 <p>The returned comparator is inconsistent with <code>Object.equals(Object)</code> (since arrays
  support only identity equality), but it is consistent with <code>Arrays.equals(int[], int[])</code>.
 */
+ (id<JavaUtilComparator>)lexicographicalComparator;

/*!
 @brief Returns the greatest value present in <code>array</code>, treating values as unsigned.
 @param array a  <i> nonempty </i>  array of unsigned <code>int</code>  values
 @return the value present in <code>array</code> that is greater than or equal to every other value
      in the array according to <code>compare</code>
 @throw IllegalArgumentExceptionif <code>array</code> is empty
 */
+ (jint)maxWithIntArray:(IOSIntArray * __nonnull)array;

/*!
 @brief Returns the least value present in <code>array</code>, treating values as unsigned.
 @param array a  <i> nonempty </i>  array of unsigned <code>int</code>  values
 @return the value present in <code>array</code> that is less than or equal to every other value in
      the array according to <code>compare</code>
 @throw IllegalArgumentExceptionif <code>array</code> is empty
 */
+ (jint)minWithIntArray:(IOSIntArray * __nonnull)array;

/*!
 @brief Returns the unsigned <code>int</code> value represented by the given decimal string.
 <p><b>Java 8 users:</b> use <code>Integer.parseUnsignedInt(String)</code> instead.
 @throw NumberFormatExceptionif the string does not contain a valid unsigned <code>int</code> value
 @throw NullPointerExceptionif <code>s</code> is null (in contrast to <code>Integer.parseInt(String)</code>
 )
 */
+ (jint)parseUnsignedIntWithNSString:(NSString * __nonnull)s;

/*!
 @brief Returns the unsigned <code>int</code> value represented by a string with the given radix.
 <p><b>Java 8 users:</b> use <code>Integer.parseUnsignedInt(String, int)</code> instead.
 @param string the string containing the unsigned integer representation to be parsed.
 @param radix the radix to use while parsing <code>s</code> ; must be between <code>Character.MIN_RADIX</code>
   and <code>Character.MAX_RADIX</code>
  .
 @throw NumberFormatExceptionif the string does not contain a valid unsigned <code>int</code>, or
      if supplied radix is invalid.
 @throw NullPointerExceptionif <code>s</code> is null (in contrast to <code>Integer.parseInt(String)</code>
 )
 */
+ (jint)parseUnsignedIntWithNSString:(NSString * __nonnull)string
                             withInt:(jint)radix;

/*!
 @brief Returns dividend % divisor, where the dividend and divisor are treated as unsigned 32-bit
  quantities.
 <p><b>Java 8 users:</b> use <code>Integer.remainderUnsigned(int, int)</code> instead.
 @param dividend the dividend (numerator)
 @param divisor the divisor (denominator)
 @throw ArithmeticExceptionif divisor is 0
 */
+ (jint)remainderWithInt:(jint)dividend
                 withInt:(jint)divisor;

/*!
 @brief Returns the <code>int</code> value that, when treated as unsigned, is nearest in value to <code>value</code>
 .
 @param value any <code>long</code>  value
 @return <code>2^32 - 1</code> if <code>value >= 2^32</code>, <code>0</code> if <code>value <= 0</code>, and <code>value</code>
  cast to <code>int</code> otherwise
 @since 21.0
 */
+ (jint)saturatedCastWithLong:(jlong)value;

/*!
 @brief Sorts the array, treating its elements as unsigned 32-bit integers.
 @since 23.1
 */
+ (void)sortWithIntArray:(IOSIntArray * __nonnull)array;

/*!
 @brief Sorts the array between <code>fromIndex</code> inclusive and <code>toIndex</code> exclusive, treating its
  elements as unsigned 32-bit integers.
 @since 23.1
 */
+ (void)sortWithIntArray:(IOSIntArray * __nonnull)array
                 withInt:(jint)fromIndex
                 withInt:(jint)toIndex;

/*!
 @brief Sorts the elements of <code>array</code> in descending order, interpreting them as unsigned 32-bit
  integers.
 @since 23.1
 */
+ (void)sortDescendingWithIntArray:(IOSIntArray * __nonnull)array;

/*!
 @brief Sorts the elements of <code>array</code> between <code>fromIndex</code> inclusive and <code>toIndex</code>
  exclusive in descending order, interpreting them as unsigned 32-bit integers.
 @since 23.1
 */
+ (void)sortDescendingWithIntArray:(IOSIntArray * __nonnull)array
                           withInt:(jint)fromIndex
                           withInt:(jint)toIndex;

/*!
 @brief Returns the value of the given <code>int</code> as a <code>long</code>, when treated as unsigned.
 <p><b>Java 8 users:</b> use <code>Integer.toUnsignedLong(int)</code> instead.
 */
+ (jlong)toLongWithInt:(jint)value;

/*!
 @brief Returns a string representation of x, where x is treated as unsigned.
 <p><b>Java 8 users:</b> use <code>Integer.toUnsignedString(int)</code> instead.
 */
+ (NSString *)toStringWithInt:(jint)x;

/*!
 @brief Returns a string representation of <code>x</code> for the given radix, where <code>x</code> is treated as
  unsigned.
 <p><b>Java 8 users:</b> use <code>Integer.toUnsignedString(int, int)</code> instead.
 @param x the value to convert to a string.
 @param radix the radix to use while working with <code>x</code>
 @throw IllegalArgumentExceptionif <code>radix</code> is not between <code>Character.MIN_RADIX</code>
      and <code>Character.MAX_RADIX</code>.
 */
+ (NSString *)toStringWithInt:(jint)x
                      withInt:(jint)radix;

#pragma mark Package-Private

+ (jint)flipWithInt:(jint)value;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonPrimitivesUnsignedInts)

inline jlong ComGoogleCommonPrimitivesUnsignedInts_get_INT_MASK(void);
#define ComGoogleCommonPrimitivesUnsignedInts_INT_MASK 4294967295LL
J2OBJC_STATIC_FIELD_CONSTANT(ComGoogleCommonPrimitivesUnsignedInts, INT_MASK, jlong)

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_flipWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_compareWithInt_withInt_(jint a, jint b);

FOUNDATION_EXPORT jlong ComGoogleCommonPrimitivesUnsignedInts_toLongWithInt_(jint value);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_checkedCastWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_saturatedCastWithLong_(jlong value);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_minWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_maxWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT NSString *ComGoogleCommonPrimitivesUnsignedInts_joinWithNSString_withIntArray_(NSString *separator, IOSIntArray *array);

FOUNDATION_EXPORT id<JavaUtilComparator> ComGoogleCommonPrimitivesUnsignedInts_lexicographicalComparator(void);

FOUNDATION_EXPORT void ComGoogleCommonPrimitivesUnsignedInts_sortWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT void ComGoogleCommonPrimitivesUnsignedInts_sortWithIntArray_withInt_withInt_(IOSIntArray *array, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT void ComGoogleCommonPrimitivesUnsignedInts_sortDescendingWithIntArray_(IOSIntArray *array);

FOUNDATION_EXPORT void ComGoogleCommonPrimitivesUnsignedInts_sortDescendingWithIntArray_withInt_withInt_(IOSIntArray *array, jint fromIndex, jint toIndex);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_divideWithInt_withInt_(jint dividend, jint divisor);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_remainderWithInt_withInt_(jint dividend, jint divisor);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_decodeWithNSString_(NSString *stringValue);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_parseUnsignedIntWithNSString_(NSString *s);

FOUNDATION_EXPORT jint ComGoogleCommonPrimitivesUnsignedInts_parseUnsignedIntWithNSString_withInt_(NSString *string, jint radix);

FOUNDATION_EXPORT NSString *ComGoogleCommonPrimitivesUnsignedInts_toStringWithInt_(jint x);

FOUNDATION_EXPORT NSString *ComGoogleCommonPrimitivesUnsignedInts_toStringWithInt_withInt_(jint x, jint radix);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonPrimitivesUnsignedInts)

#endif

#if !defined (ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_) && (INCLUDE_ALL_ComGoogleCommonPrimitivesUnsignedInts || defined(INCLUDE_ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator))
#define ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

#define RESTRICT_JavaUtilComparator 1
#define INCLUDE_JavaUtilComparator 1
#include "java/util/Comparator.h"

@class IOSIntArray;
@class IOSObjectArray;
@protocol JavaUtilFunctionFunction;
@protocol JavaUtilFunctionToDoubleFunction;
@protocol JavaUtilFunctionToIntFunction;
@protocol JavaUtilFunctionToLongFunction;

typedef NS_ENUM(NSUInteger, ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_Enum) {
  ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_Enum_INSTANCE = 0,
};

@interface ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator : JavaLangEnum < JavaUtilComparator >

@property (readonly, class, nonnull) ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator *INSTANCE NS_SWIFT_NAME(INSTANCE);
+ (ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator * __nonnull)INSTANCE;

#pragma mark Public

- (jint)compareWithId:(IOSIntArray * __nonnull)left
               withId:(IOSIntArray * __nonnull)right;

- (NSString *)description;

+ (ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator *)valueOfWithNSString:(NSString * __nonnull)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator *ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_values_[];

inline ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator *ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_get_INSTANCE(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator, INSTANCE)

FOUNDATION_EXPORT IOSObjectArray *ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_values(void);

FOUNDATION_EXPORT ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator *ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator *ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonPrimitivesUnsignedInts_LexicographicalComparator)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonPrimitivesUnsignedInts")
