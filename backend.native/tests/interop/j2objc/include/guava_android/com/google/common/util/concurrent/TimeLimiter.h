//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/android/build_result/java/com/google/common/util/concurrent/TimeLimiter.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentTimeLimiter")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentTimeLimiter
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentTimeLimiter 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentTimeLimiter 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentTimeLimiter

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentTimeLimiter_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentTimeLimiter || defined(INCLUDE_ComGoogleCommonUtilConcurrentTimeLimiter))
#define ComGoogleCommonUtilConcurrentTimeLimiter_

@class IOSClass;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaUtilConcurrentCallable;

/*!
 @brief Imposes a time limit on method calls.
 @author Kevin Bourrillion
 @author Jens Nyman
 @since 1.0
 */
@protocol ComGoogleCommonUtilConcurrentTimeLimiter < JavaObject >

/*!
 @brief Returns an instance of <code>interfaceType</code> that delegates all method calls to the <code>target</code>
  object, enforcing the specified time limit on each call.This time-limited delegation
  is also performed for calls to <code>Object.equals</code>, <code>Object.hashCode</code>, and <code>Object.toString</code>
 .
 <p>If the target method call finishes before the limit is reached, the return value or
  exception is propagated to the caller exactly as-is. If, on the other hand, the time limit is
  reached, the proxy will attempt to abort the call to the target, and will throw an <code>UncheckedTimeoutException</code>
  to the caller. 
 <p>It is important to note that the primary purpose of the proxy object is to return control to
  the caller when the timeout elapses; aborting the target method call is of secondary concern.
  The particular nature and strength of the guarantees made by the proxy is
  implementation-dependent. However, it is important that each of the methods on the target
  object behaves appropriately when its thread is interrupted. 
 <p>For example, to return the value of <code>target.someMethod()</code>, but substitute <code>DEFAULT_VALUE</code>
  if this method call takes over 50 ms, you can use this code: 
 @code

    TimeLimiter limiter = . . .;
    TargetType proxy = limiter.newProxy(
        target, TargetType.class, 50, TimeUnit.MILLISECONDS);
    try {
      return proxy.someMethod();
    } catch (UncheckedTimeoutException e) {
      return DEFAULT_VALUE;
    } 
  
@endcode
 @param target the object to proxy
 @param interfaceType the interface you wish the returned proxy to implement
 @param timeoutDuration with timeoutUnit, the maximum length of time that callers are willing to      wait on each method call to the proxy
 @param timeoutUnit with timeoutDuration, the maximum length of time that callers are willing to      wait on each method call to the proxy
 @return a time-limiting proxy
 @throw IllegalArgumentExceptionif <code>interfaceType</code> is a regular class, enum, or
      annotation type, rather than an interface
 */
- (id)newProxyWithId:(id __nonnull)target
        withIOSClass:(IOSClass * __nonnull)interfaceType
            withLong:(jlong)timeoutDuration
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)timeoutUnit OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Invokes a specified Callable, timing out after the specified time limit.If the target method
  call finishes before the limit is reached, the return value or a wrapped exception is
  propagated.
 If, on the other hand, the time limit is reached, we attempt to abort the call to
  the target, and throw a <code>TimeoutException</code> to the caller.
 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @return the result returned by the Callable
 @throw TimeoutExceptionif the time limit is reached
 @throw InterruptedExceptionif the current thread was interrupted during execution
 @throw ExecutionExceptionif <code>callable</code> throws a checked exception
 @throw UncheckedExecutionExceptionif <code>callable</code> throws a <code>RuntimeException</code>
 @throw ExecutionErrorif <code>callable</code> throws an <code>Error</code>
 @since 22.0
 */
- (id)callWithTimeoutWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable> __nonnull)callable
                                           withLong:(jlong)timeoutDuration
                     withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)timeoutUnit;

/*!
 @brief Invokes a specified Callable, timing out after the specified time limit.If the target method
  call finishes before the limit is reached, the return value or a wrapped exception is
  propagated.
 If, on the other hand, the time limit is reached, we attempt to abort the call to
  the target, and throw a <code>TimeoutException</code> to the caller. 
 <p>The difference with <code>callWithTimeout(Callable, long, TimeUnit)</code> is that this method
  will ignore interrupts on the current thread.
 @param callable the Callable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @return the result returned by the Callable
 @throw TimeoutExceptionif the time limit is reached
 @throw ExecutionExceptionif <code>callable</code> throws a checked exception
 @throw UncheckedExecutionExceptionif <code>callable</code> throws a <code>RuntimeException</code>
 @throw ExecutionErrorif <code>callable</code> throws an <code>Error</code>
 @since 22.0
 */
- (id)callUninterruptiblyWithTimeoutWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable> __nonnull)callable
                                                          withLong:(jlong)timeoutDuration
                                    withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)timeoutUnit;

/*!
 @brief Invokes a specified Runnable, timing out after the specified time limit.If the target method
  run finishes before the limit is reached, this method returns or a wrapped exception is
  propagated.
 If, on the other hand, the time limit is reached, we attempt to abort the run, and
  throw a <code>TimeoutException</code> to the caller.
 @param runnable the Runnable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @throw TimeoutExceptionif the time limit is reached
 @throw InterruptedExceptionif the current thread was interrupted during execution
 @throw UncheckedExecutionExceptionif <code>runnable</code> throws a <code>RuntimeException</code>
 @throw ExecutionErrorif <code>runnable</code> throws an <code>Error</code>
 @since 22.0
 */
- (void)runWithTimeoutWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)runnable
                                  withLong:(jlong)timeoutDuration
            withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)timeoutUnit;

/*!
 @brief Invokes a specified Runnable, timing out after the specified time limit.If the target method
  run finishes before the limit is reached, this method returns or a wrapped exception is
  propagated.
 If, on the other hand, the time limit is reached, we attempt to abort the run, and
  throw a <code>TimeoutException</code> to the caller. 
 <p>The difference with <code>runWithTimeout(Runnable, long, TimeUnit)</code> is that this method
  will ignore interrupts on the current thread.
 @param runnable the Runnable to execute
 @param timeoutDuration with timeoutUnit, the maximum length of time to wait
 @param timeoutUnit with timeoutDuration, the maximum length of time to wait
 @throw TimeoutExceptionif the time limit is reached
 @throw UncheckedExecutionExceptionif <code>runnable</code> throws a <code>RuntimeException</code>
 @throw ExecutionErrorif <code>runnable</code> throws an <code>Error</code>
 @since 22.0
 */
- (void)runUninterruptiblyWithTimeoutWithJavaLangRunnable:(id<JavaLangRunnable> __nonnull)runnable
                                                 withLong:(jlong)timeoutDuration
                           withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit * __nonnull)timeoutUnit;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentTimeLimiter)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentTimeLimiter)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentTimeLimiter")
