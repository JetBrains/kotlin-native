//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/android/build_result/java/com/google/common/util/concurrent/ListenerCallQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenerCallQueue")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentListenerCallQueue
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenerCallQueue 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenerCallQueue 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentListenerCallQueue

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentListenerCallQueue_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenerCallQueue || defined(INCLUDE_ComGoogleCommonUtilConcurrentListenerCallQueue))
#define ComGoogleCommonUtilConcurrentListenerCallQueue_

@protocol ComGoogleCommonUtilConcurrentListenerCallQueue_Event;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A list of listeners for implementing a concurrency friendly observable object.
 <p>Listeners are registered once via <code>addListener</code> and then may be invoked by enqueueing
  and then dispatching events. 
 <p>The API of this class is designed to make it easy to achieve the following properties 
 <ul>
    <li>Multiple events for the same listener are never dispatched concurrently.
    <li>Events for the different listeners are dispatched concurrently.
    <li>All events for a given listener dispatch on the provided <code>executor</code>.
    <li>It is easy for the user to ensure that listeners are never invoked while holding locks. 
 </ul>
  The last point is subtle. Often the observable object will be managing its own internal state
  using a lock, however it is dangerous to dispatch listeners while holding a lock because they
  might run on the <code>directExecutor()</code> or be otherwise re-entrant (call back into your
  object). So it is important to not call <code>dispatch</code> while holding any locks. This is why 
 <code>enqueue</code> and <code>dispatch</code> are 2 different methods. It is expected that the decision
  to run a particular event is made during the state change, but the decision to actually invoke
  the listeners can be delayed slightly so that locks can be dropped. Also, because <code>dispatch</code>
  is expected to be called concurrently, it is idempotent.
 */
@interface ComGoogleCommonUtilConcurrentListenerCallQueue : NSObject

#pragma mark Public

/*!
 @brief Adds a listener that will be called using the given executor when events are later <code>enqueued</code>
  and <code>dispatched</code>.
 */
- (void)addListenerWithId:(id __nonnull)listener
withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Dispatches all events enqueued prior to this call, serially and in order, for every listener.
 <p>Note: this method is idempotent and safe to call from any thread
 */
- (void)dispatch;

/*!
 @brief Enqueues an event to be run on currently known listeners.
 <p>The <code>toString</code> method of the Event itself will be used to describe the event in the
  case of an error.
 @param event the callback to execute on <code>dispatch</code>
 */
- (void)enqueueWithComGoogleCommonUtilConcurrentListenerCallQueue_Event:(id<ComGoogleCommonUtilConcurrentListenerCallQueue_Event> __nonnull)event;

/*!
 @brief Enqueues an event to be run on currently known listeners, with a label.
 @param event the callback to execute on <code>dispatch</code>
 @param label a description of the event to use in the case of an error
 */
- (void)enqueueWithComGoogleCommonUtilConcurrentListenerCallQueue_Event:(id<ComGoogleCommonUtilConcurrentListenerCallQueue_Event> __nonnull)event
                                                           withNSString:(NSString * __nonnull)label;

#pragma mark Package-Private

- (instancetype __nonnull)initPackagePrivate;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentListenerCallQueue)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentListenerCallQueue_initPackagePrivate(ComGoogleCommonUtilConcurrentListenerCallQueue *self);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentListenerCallQueue *new_ComGoogleCommonUtilConcurrentListenerCallQueue_initPackagePrivate(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentListenerCallQueue *create_ComGoogleCommonUtilConcurrentListenerCallQueue_initPackagePrivate(void);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentListenerCallQueue)

#endif

#if !defined (ComGoogleCommonUtilConcurrentListenerCallQueue_Event_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenerCallQueue || defined(INCLUDE_ComGoogleCommonUtilConcurrentListenerCallQueue_Event))
#define ComGoogleCommonUtilConcurrentListenerCallQueue_Event_

/*!
 @brief Method reference-compatible listener event.
 */
@protocol ComGoogleCommonUtilConcurrentListenerCallQueue_Event < JavaObject >

/*!
 @brief Call a method on the listener.
 */
- (void)callWithId:(id __nonnull)listener;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentListenerCallQueue_Event)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentListenerCallQueue_Event)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentListenerCallQueue")
