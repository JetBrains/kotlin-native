/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import groovy.transform.stc.ClosureParams
import org.jetbrains.kotlin.konan.target.*
import static org.jetbrains.kotlin.konan.target.KonanTarget.*
import org.jetbrains.kotlin.konan.properties.KonanProperties
import org.jetbrains.kotlin.konan.properties.*

buildscript {
    apply from: "$rootDir/gradle/kotlinGradlePlugin.gradle"

    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
    }
}

apply plugin: 'com.jfrog.bintray'

configurations {
    kotlin_compiler_jar
    kotlin_compiler_pom
    kotlin_compiler_src
    kotlin_compiler_doc
}

// TODO: Check if we really need the our bintray mirror and delete the uploading code below if we don't.
repositories {
    maven { url kotlinCompilerRepo }
}

dependencies {
    kotlin_compiler_jar "$kotlinCompilerModule@jar"
    kotlin_compiler_pom "$kotlinCompilerModule@pom"
    kotlin_compiler_src "$kotlinCompilerModule:sources@jar"
    kotlin_compiler_doc "$kotlinCompilerModule:javadoc@jar"
}

// Hack kotlin-compiler pom-file to resolve the dependency correctly.
task generatePom(type: DefaultTask) {
    def originalPom = configurations.kotlin_compiler_pom.singleFile
    inputs.file(originalPom)

    def (_, artifactIdString, versionString) = kotlinCompilerModule.tokenize(':')
    def newPom = file("${temporaryDir.canonicalPath}/$artifactIdString-${versionString}.pom")
    outputs.file(newPom)

    doLast {
        def xml = new XmlParser().parse(originalPom)
        def parent = xml.children().find() { it.name().localPart == 'parent' } // <parent> </parent> section, not the parent node.
        if (parent != null) {
            def groupId = parent.groupId
            def version = parent.version
            xml.append(groupId)
            xml.append(version)
            xml.remove(parent)
        }
        new XmlNodePrinter(new PrintWriter(new FileWriter(newPom))).print(xml)
    }
}

bintray {
    user = project.hasProperty('bintrayUser') ? project.property('bintrayUser') : System.getenv('BINTRAY_USER')
    key  = project.hasProperty('bintrayKey') ? project.property('bintrayKey') : System.getenv('BINTRAY_KEY')
    pkg {
        repo = 'kotlin-native-dependencies'
        name = 'kotlin-compiler-builds'
        userOrg = 'jetbrains'
        publish = true
        override = project.hasProperty("override")
    }
    filesSpec {
        // kotlinCompilerModule@jar and @pom -> groupId/with/dots/replaced/by/slashes/artifactId/<major-version>-SNAPSHOT
        // e.g. org.jetbrains.kotlin:kotlin-compiler:1.1-20170426.212805-507 -> org/jetbrains/kotlin/kotlin-compiler/1.1-SNAPSHOT
        def (groupId, artifactId, version) = kotlinCompilerModule.tokenize(':')
        def groupPath = groupId.replace('.', '/')
        def artifactPath = artifactId
        def versionPath =  "${version.tokenize('-')[0]}-SNAPSHOT"
        from project.configurations.kotlin_compiler_jar.files
        from project.configurations.kotlin_compiler_src.files
        from project.configurations.kotlin_compiler_doc.files
        from generatePom.outputs.files
        into "$groupPath/$artifactPath/$versionPath"
    }
}

task update_kotlin_compiler(type: DefaultTask) {
    dependsOn(bintrayUpload)
}

abstract class NativeDep extends DefaultTask {
    protected final String hostSystem = TargetManager.longerSystemName();
    String baseUrl = "https://jetbrains.bintray.com/kotlin-native-dependencies"

    @Input
    abstract String getFileName()

    protected String getUrl() {
        return "$baseUrl/$fileName"
    }

    protected File getBaseOutDir() {
        final File res = project.rootProject.ext.dependenciesDir
        res.mkdirs()
        return res
    }

    protected File download() {
        File result = new File(baseOutDir, fileName)
        if (!result.exists())
            ant.get(src: url, dest: result, usetimestamp: true)
        return result
    }
}

class TgzNativeDep extends NativeDep {
    String baseName

    @Override
    String getFileName() {
        return "${baseName}.tar.gz"
    }

    @OutputDirectory
    File getOutputDir() {
        return new File(baseOutDir, baseName)
    }

    @TaskAction
    public void downloadAndExtract() {
        File archived = this.download()

        try {
            // Builtin Gradle unpacking tools seem to unable to handle symlinks;
            // Use external "tar" executable as workaround:
            project.exec {
                executable "tar"
                workingDir baseOutDir
                args "xf", archived
            }
        } catch (Throwable e) {
            e.printStackTrace()
            project.delete(outputDir)
            throw e
        }
    }
}

class HelperNativeDep extends TgzNativeDep {

    int maxAttempts = Integer.parseInt(
            project.rootProject.ext.konanProperties['downloadingAttempts'].toString())
    long attemptPauseMs = Long.parseLong(
            project.rootProject.ext.konanProperties['downloadingAttemptPauseMs'].toString())

    public HelperNativeDep() {
        dependsOn(':tools:helpers:jar')
    }

    @TaskAction
    public void downloadAndExtract() {
        project.javaexec {
            main = "org.jetbrains.kotlin.konan.MainKt"
            classpath += project.findProject(':tools:helpers').getConfigurations().getByName("runtime")
            classpath += project.findProject(':tools:helpers').getConfigurations().getByName("runtime").artifacts.files
            args baseOutDir.canonicalPath, baseUrl, maxAttempts, attemptPauseMs, baseName
        }
    }
}

enum DependencyKind {
    LLVM(            "llvm",            { it.llvmHome },       { "llvmDir" }        ),
    GCC_TOOLCHAIN(   "gccToolchain",    { it.gccToolchain },   { "gccToolchainDir" }),
    SYSROOT(         "sysroot",         { it.targetSysRoot }                        ),
    LIBFFI(          "libffi",          { it.libffiDir }                            ),
    TARGET_TOOLCHAIN("targetToolchain", { it.targetToolchain }                      )


    DependencyKind(String name,
            @ClosureParams(KonanProperties.class) Closure<String> dirGetter,
            @ClosureParams(KonanTarget.class) Closure<String> propertyNameGetter =
                           {target -> "${target.userName}${name.capitalize()}Dir"}) {
        this.name = name
        this.dirGetter = dirGetter
        this.propertyNameGetter = propertyNameGetter
    }

    private String name
    private Closure<String> dirGetter           // KonanProperties -> String
    private Closure<String> propertyNameGetter  // KonanTarget -> String

    String getDirectory(KonanProperties properties) {
        return dirGetter(properties)
    }

    String getPropertyName(KonanTarget target) {
        return propertyNameGetter(target)
    }

    String toString() { return name }
}

TargetManager.enabled.each { target ->
    def konanProperties = new KonanProperties(target,
            rootProject.ext.konanProperties,
            rootProject.ext.dependenciesDir.canonicalPath
    )

    konanProperties.dependencies.each { dependency ->
        task "${target.userName}-${dependency}"(type: HelperNativeDep) {
            baseName = dependency
        }
    }

    DependencyKind.values().each { kind ->
        def dir = kind.getDirectory(konanProperties)
        if (dir != null) {
            def path = rootProject.ext.dependenciesDir.toPath()
                    .resolve(dir).toFile()
                    .canonicalPath
            rootProject.ext.set(kind.getPropertyName(target), path)
        }
    }
}

task update(type: Copy) {
    dependsOn tasks.withType(NativeDep)
}
