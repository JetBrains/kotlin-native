/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import groovy.transform.stc.ClosureParams
import groovy.transform.stc.FromString
import org.jetbrains.kotlin.konan.target.*
import org.jetbrains.kotlin.konan.util.DependencyProcessor
import static org.jetbrains.kotlin.konan.target.KonanTarget.*
import org.jetbrains.kotlin.konan.util.Named
import org.jetbrains.kotlin.konan.properties.KonanPropertiesLoader
import org.jetbrains.kotlin.konan.target.ConfigurablesImplKt
import org.jetbrains.kotlin.konan.target.KonanTarget
import org.jetbrains.kotlin.konan.target.TargetManager
import org.jetbrains.kotlin.konan.util.DependencyProcessor

import static org.jetbrains.kotlin.konan.util.VisibleNamedKt.getVisibleName

buildscript {
    apply from: "$rootDir/gradle/kotlinGradlePlugin.gradle"

    repositories {
        jcenter()
    }
}

def kotlinGradleModule = "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinGradlePluginVersion"
def kotlinStdLibJdk8Module = "org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlinStdLibJdk8Version"

def modules = ['compiler'      : kotlinCompilerModule,
               'gradle_plugin' : kotlinGradleModule,
               'stdlib_jdk8'   : kotlinStdLibJdk8Module,
               'stdlib'        : kotlinStdLibModule,
               'reflect'       : kotlinReflectModule,
               'script_runtime': kotlinScriptRuntimeModule
]

Map.metaClass.moduleEntry = { key, version ->
    delegate[key] = "org.jetbrains.kotlin:kotlin-${key.replace('_', '-')}:$version"
}

modules.moduleEntry('gradle_plugin_api', kotlinGradlePluginApiVersion)
modules.moduleEntry('compiler_embeddable', kotlinCompilerEmbeddableVersion)
modules.moduleEntry('annotation_processing_gradle', kotlinAnnotationProcessingGradleVersion)
modules.moduleEntry('android_extensions', kotlinAndroidExtensionsVersion)
modules.moduleEntry('compiler_runner', kotlinCompilerRunnerVersion)
modules.moduleEntry('stdlib_jre7', kotlinStdLibJdk7Version)

private static String configurationJar(x) {
    "kotlin_${x}_jar".toString()
}

private static String configurationPom(x) {
    "kotlin_${x}_pom".toString()
}

private static String configurationSrc(x) {
    "kotlin_${x}_src".toString()
}

private static String configurationDoc(x) {
    "kotlin_${x}_doc".toString()
}

modules.forEach{ x, _ ->
    configurations.create(configurationJar(x))
    configurations.create(configurationPom(x))
    configurations.create(configurationSrc(x))
    configurations.create(configurationDoc(x))
}

modules.forEach { k, v ->
    dependencies.add(configurationJar(k), "${v}@jar")
    dependencies.add(configurationPom(k), "${v}@pom")
    dependencies.add(configurationSrc(k), "${v}:sources@jar")
    dependencies.add(configurationDoc(k), "${v}:javadoc@jar")
}

// TODO: Check if we really need the our bintray mirror and delete the uploading code below if we don't.
repositories {
    maven { url kotlinCompilerRepo }
}

def uploads = modules.keySet()
uploads.each { target ->
    task("${target}Upload", type:GradleBuild) {
        tasks = ['bintrayUpload']
        buildFile project.file("upload.gradle")
        dir project.projectDir
        startParameter.projectProperties = [
                'user'    :  "${project.hasProperty('bintrayUser') ? project['bintrayUser'] : System.getenv('BINTRAY_USER')}",
                'key'     : "${ project.hasProperty('bintrayKey') ? project.property('bintrayKey') : System.getenv('BINTRAY_KEY')}",
                'module'  : modules["${target}"],
                'jar'     : project.configurations.getByName(configurationJar(target)).files.collect {it.path},
                'src'     : project.configurations.getByName(configurationSrc(target)).files.collect {it.path},
                'doc'     : project.configurations.getByName(configurationDoc(target)).files.collect {it.path},
                'pom'     : project.configurations.getByName(configurationPom(target)).files.collect {it.path},
                'override': project.hasProperty("override") && project["override"]
        ]
        startParameter.useEmptySettings()
    }
}

task update_kotlin_compiler(type: DefaultTask) {
    dependsOn uploads.collect{"${it}Upload"}
}

abstract class NativeDep extends DefaultTask {
    static final String baseUrl = "https://download.jetbrains.com/kotlin/native"

    @Input
    abstract String getFileName()

    protected String getUrl() {
        return "$baseUrl/$fileName"
    }

    protected File getBaseOutDir() {
        final File res = project.rootProject.ext.dependenciesDir
        res.mkdirs()
        return res
    }

    protected File download() {
        File result = new File(baseOutDir, fileName)
        if (!result.exists())
            ant.get(src: url, dest: result, usetimestamp: true)
        return result
    }
}

class TgzNativeDep extends NativeDep {
    String baseName

    @Override
    String getFileName() {
        return "${baseName}.tar.gz"
    }

    @OutputDirectory
    File getOutputDir() {
        return new File(baseOutDir, baseName)
    }

    @TaskAction
    public void downloadAndExtract() {
        File archived = this.download()

        try {
            // Builtin Gradle unpacking tools seem to unable to handle symlinks;
            // Use external "tar" executable as workaround:
            project.exec {
                executable "tar"
                workingDir baseOutDir
                args "xf", archived
            }
        } catch (Throwable e) {
            e.printStackTrace()
            project.delete(outputDir)
            throw e
        }
    }
}

class HelperNativeDep extends TgzNativeDep {

    KonanPropertiesLoader konanPropertiesLoader = null

    @TaskAction
    public void downloadAndExtract() {
        def downloader = new DependencyProcessor(baseOutDir, konanPropertiesLoader, baseUrl, false)
        downloader.showInfo = false
        downloader.run()
    }
}

enum DependencyKind {
    LLVM(            "llvm",            { it.llvmHome },       { "llvmDir" }        ),
    LIBFFI(          "libffi",          { it.libffiDir }                            )


    DependencyKind(String name,
            @ClosureParams(value = FromString.class, options = "KonanPropertiesLoader") Closure<String> dirGetter,
            @ClosureParams(value = FromString.class, options = "KonanTarget") Closure<String> propertyNameGetter =
                           {target -> "${target.visibleName}${name.capitalize()}Dir"}) {
        this.name = name
        this.dirGetter = dirGetter
        this.propertyNameGetter = propertyNameGetter
    }

    private String name
    private Closure<String> dirGetter           // KonanProperties -> String
    private Closure<String> propertyNameGetter  // KonanTarget -> String

    String getDirectory(KonanPropertiesLoader properties) {
        return dirGetter(properties)
    }

    String getPropertyName(KonanTarget target) {
        return propertyNameGetter(target)
    }

    String toString() { return name }
}

def platformManager = rootProject.ext.platformManager

platformManager.enabled.each { target ->
    def loader = platformManager.loader(target)
    loader.dependencies.each { dependency ->
        if (tasks.findByName(dependency) == null) {
            task "${dependency}"(type: HelperNativeDep) {
                baseName = dependency
                it.konanPropertiesLoader = loader
            }
        }
    }

    // Also resolves all dependencies:
    final DependencyProcessor dependencyProcessor = new DependencyProcessor(
            project.rootProject.ext.dependenciesDir,
            loader.properties,
            loader.dependencies,
            HelperNativeDep.baseUrl,
            false
    )

    DependencyKind.values().each { kind ->
        def dir = kind.getDirectory(loader)
        if (dir != null) {
            String path = dependencyProcessor.resolveRelative(dir).canonicalPath
            rootProject.ext.set(kind.getPropertyName(target), path)
        }
    }
}

task update(type: Copy) {
    dependsOn tasks.withType(NativeDep)
}

task rmDotKonan(type: Delete) {
    delete "${System.getProperty("user.home")}/.konan"
}
